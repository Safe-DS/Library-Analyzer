{
  "schemaVersion": 1,
  "distribution": "",
  "package": "packager-parser",
  "version": "",
  "modules": [
    {
      "id": "packager-parser/package_parser",
      "name": "package_parser",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.__main__",
      "name": "package_parser.__main__",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.main",
          "declaration": "main",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.cli",
      "name": "package_parser.cli",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.cli._cli",
          "declaration": "cli",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.cli._cli",
      "name": "package_parser.cli._cli",
      "imports": [
        {
          "module": "argparse",
          "alias": null
        },
        {
          "module": "logging",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "argparse",
          "declaration": "_SubParsersAction",
          "alias": null
        },
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "package_parser.cli._run_all",
          "declaration": "_run_all_command",
          "alias": null
        },
        {
          "module": "package_parser.cli._run_annotations",
          "declaration": "_run_annotations",
          "alias": null
        },
        {
          "module": "package_parser.cli._run_api",
          "declaration": "_run_api_command",
          "alias": null
        },
        {
          "module": "package_parser.cli._run_migrate",
          "declaration": "_run_migrate_command",
          "alias": null
        },
        {
          "module": "package_parser.cli._run_usages",
          "declaration": "_run_usages_command",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.cli._cli/cli",
        "packager-parser/package_parser.cli._cli/_get_args",
        "packager-parser/package_parser.cli._cli/_add_api_subparser",
        "packager-parser/package_parser.cli._cli/_add_usages_subparser",
        "packager-parser/package_parser.cli._cli/_add_annotations_subparser",
        "packager-parser/package_parser.cli._cli/_add_all_subparser",
        "packager-parser/package_parser.cli._cli/_add_migrate_subparser"
      ]
    },
    {
      "id": "packager-parser/package_parser.cli._json_encoder",
      "name": "package_parser.cli._json_encoder",
      "imports": [],
      "from_imports": [
        {
          "module": "json",
          "declaration": "JSONEncoder",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.cli._json_encoder/CustomEncoder"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.cli._read_and_write_file",
      "name": "package_parser.cli._read_and_write_file",
      "imports": [
        {
          "module": "json",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "package_parser.cli._json_encoder",
          "declaration": "CustomEncoder",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AnnotationStore",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages.model",
          "declaration": "UsageCountStore",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "ensure_file_exists",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.cli._read_and_write_file/_read_annotations_file",
        "packager-parser/package_parser.cli._read_and_write_file/_write_annotations_file",
        "packager-parser/package_parser.cli._read_and_write_file/_read_api_file",
        "packager-parser/package_parser.cli._read_and_write_file/_read_usages_file",
        "packager-parser/package_parser.cli._read_and_write_file/_write_api_file",
        "packager-parser/package_parser.cli._read_and_write_file/_write_api_dependency_file"
      ]
    },
    {
      "id": "packager-parser/package_parser.cli._run_all",
      "name": "package_parser.cli._run_all",
      "imports": [
        {
          "module": "multiprocessing",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "functools",
          "declaration": "partial",
          "alias": null
        },
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "package_parser.cli._run_annotations",
          "declaration": "_run_annotations",
          "alias": null
        },
        {
          "module": "package_parser.cli._run_api",
          "declaration": "_run_api_command",
          "alias": null
        },
        {
          "module": "package_parser.cli._run_usages",
          "declaration": "_run_usages_command",
          "alias": null
        },
        {
          "module": "package_parser.cli._shared_constants",
          "declaration": "_API_KEY",
          "alias": null
        },
        {
          "module": "package_parser.cli._shared_constants",
          "declaration": "_USAGES_KEY",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.cli._run_all/_run_all_command",
        "packager-parser/package_parser.cli._run_all/_run_in_parallel"
      ]
    },
    {
      "id": "packager-parser/package_parser.cli._run_annotations",
      "name": "package_parser.cli._run_annotations",
      "imports": [],
      "from_imports": [
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations",
          "declaration": "generate_annotations",
          "alias": null
        },
        {
          "module": "package_parser.cli._read_and_write_file",
          "declaration": "_read_api_file",
          "alias": null
        },
        {
          "module": "package_parser.cli._read_and_write_file",
          "declaration": "_read_usages_file",
          "alias": null
        },
        {
          "module": "package_parser.cli._read_and_write_file",
          "declaration": "_write_annotations_file",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.cli._run_annotations/_run_annotations"
      ]
    },
    {
      "id": "packager-parser/package_parser.cli._run_api",
      "name": "package_parser.cli._run_api",
      "imports": [],
      "from_imports": [
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.processing.api",
          "declaration": "get_api",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies",
          "declaration": "get_dependencies",
          "alias": null
        },
        {
          "module": "package_parser.cli._read_and_write_file",
          "declaration": "_write_api_dependency_file",
          "alias": null
        },
        {
          "module": "package_parser.cli._read_and_write_file",
          "declaration": "_write_api_file",
          "alias": null
        },
        {
          "module": "package_parser.cli._shared_constants",
          "declaration": "_API_KEY",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.cli._run_api/_run_api_command"
      ]
    },
    {
      "id": "packager-parser/package_parser.cli._run_migrate",
      "name": "package_parser.cli._run_migrate",
      "imports": [
        {
          "module": "os",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration",
          "declaration": "APIMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration",
          "declaration": "Migration",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "AbstractDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "InheritanceDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "SimpleDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "StrictDiffer",
          "alias": null
        },
        {
          "module": "package_parser.cli._read_and_write_file",
          "declaration": "_read_annotations_file",
          "alias": null
        },
        {
          "module": "package_parser.cli._read_and_write_file",
          "declaration": "_read_api_file",
          "alias": null
        },
        {
          "module": "package_parser.cli._read_and_write_file",
          "declaration": "_write_annotations_file",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.cli._run_migrate/_run_migrate_command"
      ]
    },
    {
      "id": "packager-parser/package_parser.cli._run_usages",
      "name": "package_parser.cli._run_usages",
      "imports": [
        {
          "module": "json",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.cli._shared_constants",
          "declaration": "_USAGES_KEY",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages",
          "declaration": "find_usages",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "ensure_file_exists",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.cli._run_usages/_run_usages_command"
      ]
    },
    {
      "id": "packager-parser/package_parser.cli._shared_constants",
      "name": "package_parser.cli._shared_constants",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.main",
      "name": "package_parser.main",
      "imports": [
        {
          "module": "time",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "package_parser.cli",
          "declaration": "cli",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.main/main"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing",
      "name": "package_parser.processing",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations",
      "name": "package_parser.processing.annotations",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.annotations._generate_annotations",
          "declaration": "generate_annotations",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._constants",
      "name": "package_parser.processing.annotations._constants",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_annotations",
      "name": "package_parser.processing.annotations._generate_annotations",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.annotations._generate_boundary_annotations",
          "declaration": "_generate_boundary_annotations",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations._generate_enum_annotations",
          "declaration": "_generate_enum_annotations",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations._generate_remove_annotations",
          "declaration": "_generate_remove_annotations",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations._generate_value_annotations",
          "declaration": "_generate_value_annotations",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations._usages_preprocessor",
          "declaration": "_preprocess_usages",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AnnotationStore",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages.model",
          "declaration": "UsageCountStore",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.annotations._generate_annotations/generate_annotations"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_boundary_annotations",
      "name": "package_parser.processing.annotations._generate_boundary_annotations",
      "imports": [],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AnnotationStore",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "BoundaryAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "Interval",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ValueAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "BoundaryType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "UnionType",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations._constants",
          "declaration": "autogen_author",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.annotations._generate_boundary_annotations/_generate_boundary_annotations"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations",
      "name": "package_parser.processing.annotations._generate_enum_annotations",
      "imports": [
        {
          "module": "re",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AnnotationStore",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumPair",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ValueAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "EnumType",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations._constants",
          "declaration": "autogen_author",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_generate_enum_annotations",
        "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_enum_name",
        "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_enum_pairs",
        "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_enum_instance_name"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_remove_annotations",
      "name": "package_parser.processing.annotations._generate_remove_annotations",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AnnotationStore",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "RemoveAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages.model",
          "declaration": "UsageCountStore",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations._constants",
          "declaration": "autogen_author",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.annotations._generate_remove_annotations/_generate_remove_annotations",
        "packager-parser/package_parser.processing.annotations._generate_remove_annotations/_create_explanation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations",
      "name": "package_parser.processing.annotations._generate_value_annotations",
      "imports": [],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AnnotationStore",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ConstantAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "OmittedAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "OptionalAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "RequiredAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ValueAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterAssignment",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages.model",
          "declaration": "UsageCountStore",
          "alias": null
        },
        {
          "module": "scipy.stats",
          "declaration": "binom",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "pluralize",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations._constants",
          "declaration": "autogen_author",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_value_annotations",
        "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_constant_annotation",
        "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_required_or_optional_annotation",
        "packager-parser/package_parser.processing.annotations._generate_value_annotations/_should_be_required",
        "packager-parser/package_parser.processing.annotations._generate_value_annotations/_is_stringified_literal",
        "packager-parser/package_parser.processing.annotations._generate_value_annotations/_get_type_and_value_for_stringified_value",
        "packager-parser/package_parser.processing.annotations._generate_value_annotations/_is_float"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor",
      "name": "package_parser.processing.annotations._usages_preprocessor",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages.model",
          "declaration": "UsageCountStore",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "parent_id",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.annotations._usages_preprocessor/_preprocess_usages",
        "packager-parser/package_parser.processing.annotations._usages_preprocessor/_add_unused_api_elements",
        "packager-parser/package_parser.processing.annotations._usages_preprocessor/_add_implicit_usages_of_default_value"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model",
      "name": "package_parser.processing.annotations.model",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "ANNOTATION_SCHEMA_VERSION",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "BoundaryAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "CalledAfterAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "CompleteAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "ConstantAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "DescriptionAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "EnumAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "EnumPair",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "ExpertAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "GroupAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "Interval",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "MoveAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "OmittedAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "OptionalAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "ParameterInfo",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "ParameterType",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "PureAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "RemoveAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "RenameAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "RequiredAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "ValueAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._AnnotationStore",
          "declaration": "AnnotationStore",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._AnnotationStore",
      "name": "package_parser.processing.annotations.model._AnnotationStore",
      "imports": [],
      "from_imports": [
        {
          "module": "__future__",
          "declaration": "annotations",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "dataclass",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "field",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "ANNOTATION_SCHEMA_VERSION",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "BoundaryAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "CalledAfterAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "CompleteAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "DescriptionAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "EnumAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "ExpertAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "GroupAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "MoveAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "PureAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "RemoveAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "RenameAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model._annotations",
          "declaration": "ValueAnnotation",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations",
      "name": "package_parser.processing.annotations.model._annotations",
      "imports": [],
      "from_imports": [
        {
          "module": "__future__",
          "declaration": "annotations",
          "alias": null
        },
        {
          "module": "abc",
          "declaration": "ABC",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "asdict",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "dataclass",
          "alias": null
        },
        {
          "module": "enum",
          "declaration": "Enum",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.annotations.model._annotations/EnumReviewResult",
        "packager-parser/package_parser.processing.annotations.model._annotations/AbstractAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/RemoveAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/Interval",
        "packager-parser/package_parser.processing.annotations.model._annotations/BoundaryAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair",
        "packager-parser/package_parser.processing.annotations.model._annotations/EnumAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/ValueAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/ConstantAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/OmittedAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/OptionalAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/RequiredAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/ParameterType",
        "packager-parser/package_parser.processing.annotations.model._annotations/ParameterInfo",
        "packager-parser/package_parser.processing.annotations.model._annotations/CalledAfterAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/CompleteAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/DescriptionAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/ExpertAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/GroupAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/MoveAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/PureAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/RenameAnnotation",
        "packager-parser/package_parser.processing.annotations.model._annotations/TodoAnnotation"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.api",
      "name": "package_parser.processing.api",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.api._get_api",
          "declaration": "get_api",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._get_instance_attributes",
          "declaration": "get_instance_attributes",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._get_parameter_list",
          "declaration": "get_parameter_list",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._package_metadata",
          "declaration": "distribution",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._package_metadata",
          "declaration": "distribution_version",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._package_metadata",
          "declaration": "package_files",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._package_metadata",
          "declaration": "package_root",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor",
      "name": "package_parser.processing.api._ast_visitor",
      "imports": [
        {
          "module": "logging",
          "alias": null
        },
        {
          "module": "re",
          "alias": null
        },
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "astroid",
          "declaration": "NodeNG",
          "alias": null
        },
        {
          "module": "astroid.context",
          "declaration": "InferenceContext",
          "alias": null
        },
        {
          "module": "astroid.helpers",
          "declaration": "safe_infer",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "FromImport",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Import",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Module",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "parent_qualified_name",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._file_filters",
          "declaration": "_is_init_file",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._get_instance_attributes",
          "declaration": "get_instance_attributes",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._get_parameter_list",
          "declaration": "get_parameter_list",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing",
          "declaration": "AbstractDocumentationParser",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor"
      ],
      "functions": [
        "packager-parser/package_parser.processing.api._ast_visitor/trim_code",
        "packager-parser/package_parser.processing.api._ast_visitor/is_public_module"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api._file_filters",
      "name": "package_parser.processing.api._file_filters",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.api._file_filters/_is_init_file",
        "packager-parser/package_parser.processing.api._file_filters/_is_test_file"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_api",
      "name": "package_parser.processing.api._get_api",
      "imports": [
        {
          "module": "logging",
          "alias": null
        },
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "ASTWalker",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._ast_visitor",
          "declaration": "_AstVisitor",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._file_filters",
          "declaration": "_is_test_file",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._package_metadata",
          "declaration": "distribution",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._package_metadata",
          "declaration": "distribution_version",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._package_metadata",
          "declaration": "package_files",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._package_metadata",
          "declaration": "package_root",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing",
          "declaration": "NumpyDocParser",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.api._get_api/get_api",
        "packager-parser/package_parser.processing.api._get_api/__module_name"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_instance_attributes",
      "name": "package_parser.processing.api._get_instance_attributes",
      "imports": [
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "astroid.context",
          "declaration": "InferenceContext",
          "alias": null
        },
        {
          "module": "astroid.nodes",
          "declaration": "Name",
          "alias": null
        },
        {
          "module": "astroid.nodes",
          "declaration": "Subscript",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "NamedType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "UnionType",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.api._get_instance_attributes/get_instance_attributes",
        "packager-parser/package_parser.processing.api._get_instance_attributes/_get_type_of_attribute"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_parameter_list",
      "name": "package_parser.processing.api._get_parameter_list",
      "imports": [
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing",
          "declaration": "AbstractDocumentationParser",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterAssignment",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.api._get_parameter_list/get_parameter_list",
        "packager-parser/package_parser.processing.api._get_parameter_list/_get_parameters_assigned_by",
        "packager-parser/package_parser.processing.api._get_parameter_list/_get_stringified_default_value"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api._package_metadata",
      "name": "package_parser.processing.api._package_metadata",
      "imports": [
        {
          "module": "importlib",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "importlib.metadata",
          "declaration": "packages_distributions",
          "alias": null
        },
        {
          "module": "importlib.metadata",
          "declaration": "version",
          "alias": null
        },
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "list_files",
          "alias": null
        },
        {
          "module": "package_parser.processing.api._file_filters",
          "declaration": "_is_init_file",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.api._package_metadata/package_files",
        "packager-parser/package_parser.processing.api._package_metadata/package_root",
        "packager-parser/package_parser.processing.api._package_metadata/__move_init_files_to_front",
        "packager-parser/package_parser.processing.api._package_metadata/distribution",
        "packager-parser/package_parser.processing.api._package_metadata/distribution_version"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing",
      "name": "package_parser.processing.api.documentation_parsing",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser",
          "declaration": "AbstractDocumentationParser",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser",
          "declaration": "DefaultDocumentationParser",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing._get_full_docstring",
          "declaration": "get_full_docstring",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing._NumpyDocParser",
          "declaration": "NumpyDocParser",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser",
      "name": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser",
      "imports": [
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "__future__",
          "declaration": "annotations",
          "alias": null
        },
        {
          "module": "abc",
          "declaration": "ABC",
          "alias": null
        },
        {
          "module": "abc",
          "declaration": "abstractmethod",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ClassDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "FunctionDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterAssignment",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterDocumentation",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser",
      "name": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser",
      "imports": [
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ClassDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "FunctionDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterAssignment",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser",
          "declaration": "AbstractDocumentationParser",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing._get_full_docstring",
          "declaration": "get_full_docstring",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser",
      "name": "package_parser.processing.api.documentation_parsing._NumpyDocParser",
      "imports": [
        {
          "module": "re",
          "alias": null
        },
        {
          "module": "astroid",
          "alias": null
        },
        {
          "module": "numpydoc.docscrape",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Tuple",
          "alias": null
        },
        {
          "module": "numpydoc.docscrape",
          "declaration": "NumpyDocString",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ClassDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "FunctionDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterAssignment",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser",
          "declaration": "AbstractDocumentationParser",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.documentation_parsing._get_full_docstring",
          "declaration": "get_full_docstring",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser"
      ],
      "functions": [
        "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_get_description",
        "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_is_matching_parameter_numpydoc",
        "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_get_type_and_default_value"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._get_full_docstring",
      "name": "package_parser.processing.api.documentation_parsing._get_full_docstring",
      "imports": [
        {
          "module": "inspect",
          "alias": null
        },
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.api.documentation_parsing._get_full_docstring/get_full_docstring"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model",
      "name": "package_parser.processing.api.model",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "API_SCHEMA_VERSION",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "FromImport",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "Import",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "Module",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._api",
          "declaration": "ResultDocstring",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._documentation",
          "declaration": "ClassDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._documentation",
          "declaration": "FunctionDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._documentation",
          "declaration": "ParameterDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._parameters",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._parameters",
          "declaration": "ParameterAssignment",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._types",
          "declaration": "AbstractType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._types",
          "declaration": "BoundaryType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._types",
          "declaration": "EnumType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._types",
          "declaration": "NamedType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._types",
          "declaration": "UnionType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._types",
          "declaration": "create_type",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api",
      "name": "package_parser.processing.api.model._api",
      "imports": [],
      "from_imports": [
        {
          "module": "__future__",
          "declaration": "annotations",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "dataclass",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "field",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "black",
          "declaration": "FileMode",
          "alias": null
        },
        {
          "module": "black",
          "declaration": "InvalidInput",
          "alias": null
        },
        {
          "module": "black",
          "declaration": "format_str",
          "alias": null
        },
        {
          "module": "black.brackets",
          "declaration": "BracketMatchError",
          "alias": null
        },
        {
          "module": "black.linegen",
          "declaration": "CannotSplit",
          "alias": null
        },
        {
          "module": "black.trans",
          "declaration": "CannotTransform",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "parent_id",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._documentation",
          "declaration": "ClassDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._documentation",
          "declaration": "FunctionDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._parameters",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._types",
          "declaration": "AbstractType",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.api.model._api/API",
        "packager-parser/package_parser.processing.api.model._api/Module",
        "packager-parser/package_parser.processing.api.model._api/Import",
        "packager-parser/package_parser.processing.api.model._api/FromImport",
        "packager-parser/package_parser.processing.api.model._api/Class",
        "packager-parser/package_parser.processing.api.model._api/Attribute",
        "packager-parser/package_parser.processing.api.model._api/Function",
        "packager-parser/package_parser.processing.api.model._api/Result",
        "packager-parser/package_parser.processing.api.model._api/ResultDocstring"
      ],
      "functions": [
        "packager-parser/package_parser.processing.api.model._api/_generate_formatted_code"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation",
      "name": "package_parser.processing.api.model._documentation",
      "imports": [
        {
          "module": "dataclasses",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "__future__",
          "declaration": "annotations",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "dataclass",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.api.model._documentation/ClassDocumentation",
        "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation",
        "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters",
      "name": "package_parser.processing.api.model._parameters",
      "imports": [],
      "from_imports": [
        {
          "module": "__future__",
          "declaration": "annotations",
          "alias": null
        },
        {
          "module": "enum",
          "declaration": "Enum",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._documentation",
          "declaration": "ParameterDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._types",
          "declaration": "AbstractType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._types",
          "declaration": "create_type",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.api.model._parameters/Parameter",
        "packager-parser/package_parser.processing.api.model._parameters/ParameterAssignment"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types",
      "name": "package_parser.processing.api.model._types",
      "imports": [
        {
          "module": "re",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "__future__",
          "declaration": "annotations",
          "alias": null
        },
        {
          "module": "abc",
          "declaration": "ABCMeta",
          "alias": null
        },
        {
          "module": "abc",
          "declaration": "abstractmethod",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "dataclass",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "field",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "ClassVar",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model._documentation",
          "declaration": "ParameterDocumentation",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.api.model._types/AbstractType",
        "packager-parser/package_parser.processing.api.model._types/NamedType",
        "packager-parser/package_parser.processing.api.model._types/EnumType",
        "packager-parser/package_parser.processing.api.model._types/BoundaryType",
        "packager-parser/package_parser.processing.api.model._types/UnionType"
      ],
      "functions": [
        "packager-parser/package_parser.processing.api.model._types/create_type"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies",
      "name": "package_parser.processing.dependencies",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.dependencies._get_dependency",
          "declaration": "DependencyExtractor",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._get_dependency",
          "declaration": "extract_action",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._get_dependency",
          "declaration": "extract_condition",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._get_dependency",
          "declaration": "extract_lefts_and_rights",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._get_dependency",
          "declaration": "get_dependencies",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "Action",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "Condition",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "Dependency",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "ParameterHasValue",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "ParameterIsIgnored",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "ParameterIsIllegal",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "ParameterIsNone",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "RuntimeAction",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "RuntimeCondition",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "StaticAction",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "StaticCondition",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._dependency_patterns",
      "name": "package_parser.processing.dependencies._dependency_patterns",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._get_dependency",
      "name": "package_parser.processing.dependencies._get_dependency",
      "imports": [
        {
          "module": "spacy",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Dict",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "List",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Tuple",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "spacy.matcher",
          "declaration": "DependencyMatcher",
          "alias": null
        },
        {
          "module": "spacy.tokens",
          "declaration": "Token",
          "alias": null
        },
        {
          "module": "spacy.tokens.doc",
          "declaration": "Doc",
          "alias": null
        },
        {
          "module": "spacy.tokens.span",
          "declaration": "Span",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._dependency_patterns",
          "declaration": "dependency_matcher_patterns",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "Action",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "APIDependencies",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "Condition",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "Dependency",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "ParameterHasValue",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "ParameterIsIgnored",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "ParameterIsIllegal",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._parameter_dependencies",
          "declaration": "ParameterIsNone",
          "alias": null
        },
        {
          "module": "package_parser.processing.dependencies._preprocess_docstring",
          "declaration": "preprocess_docstring",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor"
      ],
      "functions": [
        "packager-parser/package_parser.processing.dependencies._get_dependency/extract_lefts_and_rights",
        "packager-parser/package_parser.processing.dependencies._get_dependency/extract_action",
        "packager-parser/package_parser.processing.dependencies._get_dependency/extract_condition",
        "packager-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring",
        "packager-parser/package_parser.processing.dependencies._get_dependency/get_dependencies"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._ground_truth",
      "name": "package_parser.processing.dependencies._ground_truth",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies",
      "name": "package_parser.processing.dependencies._parameter_dependencies",
      "imports": [],
      "from_imports": [
        {
          "module": "dataclasses",
          "declaration": "dataclass",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Dict",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Action",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeAction",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticAction",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIgnored",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIllegal",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Condition",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeCondition",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticCondition",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterHasValue",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsNone",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Dependency",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/APIDependencies"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._preprocess_docstring",
      "name": "package_parser.processing.dependencies._preprocess_docstring",
      "imports": [
        {
          "module": "re",
          "alias": null
        }
      ],
      "from_imports": [],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.dependencies._preprocess_docstring/preprocess_docstring"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration",
      "name": "package_parser.processing.migration",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.migration._api_mapping",
          "declaration": "APIMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration._migrate",
          "declaration": "Migration",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.migration._api_mapping",
      "name": "package_parser.processing.migration._api_mapping",
      "imports": [],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Callable",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "List",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "TypeVar",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "AbstractDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "merge_mappings",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.migration._api_mapping/APIMapping"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate",
      "name": "package_parser.processing.migration._migrate",
      "imports": [],
      "from_imports": [
        {
          "module": "dataclasses",
          "declaration": "dataclass",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "field",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AnnotationStore",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_boundary_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_called_after_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_description_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_enum_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_expert_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_group_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_move_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_remove_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_rename_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_todo_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations",
          "declaration": "migrate_value_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.migration._migrate/Migration"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations",
      "name": "package_parser.processing.migration.annotations",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_boundary_annotation",
          "declaration": "migrate_boundary_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_called_after_annotation",
          "declaration": "migrate_called_after_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_description_annotation",
          "declaration": "migrate_description_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_enum_annotation",
          "declaration": "migrate_enum_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_expert_annotation",
          "declaration": "migrate_expert_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_group_annotation",
          "declaration": "migrate_group_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_move_annotation",
          "declaration": "migrate_move_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_remove_annotation",
          "declaration": "migrate_remove_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_rename_annotation",
          "declaration": "migrate_rename_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_todo_annotation",
          "declaration": "migrate_todo_annotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._migrate_value_annotation",
          "declaration": "migrate_value_annotation",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._constants",
      "name": "package_parser.processing.migration.annotations._constants",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element",
      "name": "package_parser.processing.migration.annotations._get_annotated_api_element",
      "imports": [],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "List",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "TypeVar",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element",
        "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element_by_type"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text",
      "name": "package_parser.processing.migration.annotations._get_migration_text",
      "imports": [],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Sequence",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "BoundaryAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "CalledAfterAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "CompleteAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ConstantAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "DescriptionAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ExpertAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "GroupAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "MoveAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "OptionalAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "PureAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "RemoveAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "RenameAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ValueAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._get_migration_text/_get_further_information",
        "packager-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text",
        "packager-parser/package_parser.processing.migration.annotations._get_migration_text/_list_api_elements"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_boundary_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Tuple",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "BoundaryAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "Interval",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "AbstractType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "NamedType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "UnionType",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToManyMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToManyMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_annotated_api_element",
          "declaration": "get_annotated_api_element",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_interval_to_fit_parameter_type",
        "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/_contains_number_and_is_discrete",
        "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_boundary_annotation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_called_after_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "CalledAfterAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/migrate_called_after_annotation",
        "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/_get_function_called_before_replacements"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_description_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_description_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "DescriptionAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_annotated_api_element",
          "declaration": "get_annotated_api_element",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_description_annotation/migrate_description_annotation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_enum_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "List",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumPair",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "AbstractType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "NamedType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "UnionType",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToManyMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToManyMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_annotated_api_element",
          "declaration": "get_annotated_api_element",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_contains_string",
        "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_default_value_is_in_instance_values_or_is_empty",
        "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/migrate_enum_annotation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_expert_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_expert_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ExpertAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_annotated_api_element",
          "declaration": "get_annotated_api_element",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_expert_annotation/migrate_expert_annotation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_group_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "GroupAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/migrate_group_annotation",
        "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/_get_mappings_for_grouped_parameters"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_move_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_move_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "MoveAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_annotated_api_element",
          "declaration": "get_annotated_api_element",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_move_annotation/is_moveable",
        "packager-parser/package_parser.processing.migration.annotations._migrate_move_annotation/migrate_move_annotation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_remove_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_remove_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "RemoveAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_annotated_api_element",
          "declaration": "get_annotated_api_element",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/is_removeable",
        "packager-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/migrate_remove_annotation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_rename_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_rename_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "RenameAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_annotated_api_element",
          "declaration": "get_annotated_api_element",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_rename_annotation/migrate_rename_annotation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_todo_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_todo_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_annotated_api_element",
          "declaration": "get_annotated_api_element",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_todo_annotation/migrate_todo_annotation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation",
      "name": "package_parser.processing.migration.annotations._migrate_value_annotation",
      "imports": [],
      "from_imports": [
        {
          "module": "copy",
          "declaration": "deepcopy",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "AbstractAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ConstantAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "EnumReviewResult",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "OmittedAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "OptionalAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "RequiredAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "TodoAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.annotations.model",
          "declaration": "ValueAnnotation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "AbstractType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "NamedType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "UnionType",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToManyMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToManyMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._constants",
          "declaration": "migration_author",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_annotated_api_element",
          "declaration": "get_annotated_api_element_by_type",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.annotations._get_migration_text",
          "declaration": "get_migration_text",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_value_annotation",
        "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_type",
        "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_value",
        "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_constant_annotation",
        "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_omitted_annotation",
        "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_optional_annotation",
        "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_required_annotation"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model",
      "name": "package_parser.processing.migration.model",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.migration.model._api_mapping",
          "declaration": "APIMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._differ",
          "declaration": "AbstractDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._differ",
          "declaration": "SimpleDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._inheritance_differ",
          "declaration": "InheritanceDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "ManyToManyMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "ManyToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "OneToManyMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "merge_mappings",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._strict_differ",
          "declaration": "StrictDiffer",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._api_mapping",
      "name": "package_parser.processing.migration.model._api_mapping",
      "imports": [],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Callable",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "List",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "TypeVar",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._differ",
          "declaration": "AbstractDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "Mapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "OneToOneMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "merge_mappings",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ",
      "name": "package_parser.processing.migration.model._differ",
      "imports": [
        {
          "module": "re",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "__future__",
          "declaration": "annotations",
          "alias": null
        },
        {
          "module": "abc",
          "declaration": "ABC",
          "alias": null
        },
        {
          "module": "abc",
          "declaration": "abstractmethod",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "dataclass",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Callable",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Sequence",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Tuple",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "TypeVar",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "Levenshtein",
          "declaration": "distance",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "AbstractType",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ClassDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "FunctionDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterAssignment",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "ParameterDocumentation",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "UnionType",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "Mapping",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer"
      ],
      "functions": [
        "packager-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ",
      "name": "package_parser.processing.migration.model._inheritance_differ",
      "imports": [],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Callable",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._differ",
          "declaration": "AbstractDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "ManyToManyMapping",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "Mapping",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping",
      "name": "package_parser.processing.migration.model._mapping",
      "imports": [],
      "from_imports": [
        {
          "module": "abc",
          "declaration": "ABC",
          "alias": null
        },
        {
          "module": "abc",
          "declaration": "abstractmethod",
          "alias": null
        },
        {
          "module": "dataclasses",
          "declaration": "dataclass",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "TypeVar",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.migration.model._mapping/Mapping",
        "packager-parser/package_parser.processing.migration.model._mapping/OneToOneMapping",
        "packager-parser/package_parser.processing.migration.model._mapping/OneToManyMapping",
        "packager-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping",
        "packager-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping"
      ],
      "functions": [
        "packager-parser/package_parser.processing.migration.model._mapping/merge_mappings",
        "packager-parser/package_parser.processing.migration.model._mapping/merge_api_elements_and_remove_duplicates"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ",
      "name": "package_parser.processing.migration.model._strict_differ",
      "imports": [],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "TypeVar",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "API",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Attribute",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Class",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Function",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Parameter",
          "alias": null
        },
        {
          "module": "package_parser.processing.api.model",
          "declaration": "Result",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._differ",
          "declaration": "AbstractDiffer",
          "alias": null
        },
        {
          "module": "package_parser.processing.migration.model._mapping",
          "declaration": "Mapping",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.usages",
      "name": "package_parser.processing.usages",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.usages._find_usages",
          "declaration": "find_usages",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor",
      "name": "package_parser.processing.usages._ast_visitor",
      "imports": [
        {
          "module": "re",
          "alias": null
        },
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Union",
          "alias": null
        },
        {
          "module": "astroid.arguments",
          "declaration": "CallSite",
          "alias": null
        },
        {
          "module": "astroid.helpers",
          "declaration": "safe_infer",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages.model",
          "declaration": "UsageCountStore",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "parent_id",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder"
      ],
      "functions": [
        "packager-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by",
        "packager-parser/package_parser.processing.usages._ast_visitor/_id",
        "packager-parser/package_parser.processing.usages._ast_visitor/_path",
        "packager-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name",
        "packager-parser/package_parser.processing.usages._ast_visitor/__n_implicit_parameters",
        "packager-parser/package_parser.processing.usages._ast_visitor/__called_constructor",
        "packager-parser/package_parser.processing.usages._ast_visitor/_stringify_value",
        "packager-parser/package_parser.processing.usages._ast_visitor/_bound_parameters"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.usages._find_usages",
      "name": "package_parser.processing.usages._find_usages",
      "imports": [
        {
          "module": "logging",
          "alias": null
        },
        {
          "module": "signal",
          "alias": null
        },
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "multiprocessing",
          "declaration": "Pool",
          "alias": null
        },
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "TypeVar",
          "alias": null
        },
        {
          "module": "astroid.builder",
          "declaration": "AstroidBuilder",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages.model",
          "declaration": "UsageCountStore",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "ASTWalker",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "list_files",
          "alias": null
        },
        {
          "module": "package_parser.utils",
          "declaration": "parse_python_code",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages._ast_visitor",
          "declaration": "_UsageFinder",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.processing.usages._find_usages/find_usages",
        "packager-parser/package_parser.processing.usages._find_usages/_split_into_batches",
        "packager-parser/package_parser.processing.usages._find_usages/_initializer",
        "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch",
        "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file",
        "packager-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file"
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model",
      "name": "package_parser.processing.usages.model",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.processing.usages.model._usages",
          "declaration": "USAGES_SCHEMA_VERSION",
          "alias": null
        },
        {
          "module": "package_parser.processing.usages.model._usages",
          "declaration": "UsageCountStore",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages",
      "name": "package_parser.processing.usages.model._usages",
      "imports": [],
      "from_imports": [
        {
          "module": "__future__",
          "declaration": "annotations",
          "alias": null
        },
        {
          "module": "collections",
          "declaration": "Counter",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.utils",
      "name": "package_parser.utils",
      "imports": [],
      "from_imports": [
        {
          "module": "package_parser.utils._ASTWalker",
          "declaration": "ASTWalker",
          "alias": null
        },
        {
          "module": "package_parser.utils._files",
          "declaration": "ensure_file_exists",
          "alias": null
        },
        {
          "module": "package_parser.utils._files",
          "declaration": "initialize_and_read_exclude_file",
          "alias": null
        },
        {
          "module": "package_parser.utils._files",
          "declaration": "list_files",
          "alias": null
        },
        {
          "module": "package_parser.utils._names",
          "declaration": "declaration_qname_to_name",
          "alias": null
        },
        {
          "module": "package_parser.utils._names",
          "declaration": "parent_id",
          "alias": null
        },
        {
          "module": "package_parser.utils._names",
          "declaration": "parent_qualified_name",
          "alias": null
        },
        {
          "module": "package_parser.utils._parsing",
          "declaration": "parse_python_code",
          "alias": null
        },
        {
          "module": "package_parser.utils._strings",
          "declaration": "pluralize",
          "alias": null
        }
      ],
      "classes": [],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.utils._ASTWalker",
      "name": "package_parser.utils._ASTWalker",
      "imports": [
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "typing",
          "declaration": "Any",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Callable",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Optional",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "Type",
          "alias": null
        }
      ],
      "classes": [
        "packager-parser/package_parser.utils._ASTWalker/ASTWalker"
      ],
      "functions": []
    },
    {
      "id": "packager-parser/package_parser.utils._files",
      "name": "package_parser.utils._files",
      "imports": [
        {
          "module": "os",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "pathlib",
          "declaration": "Path",
          "alias": null
        },
        {
          "module": "typing",
          "declaration": "TextIO",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.utils._files/list_files",
        "packager-parser/package_parser.utils._files/ensure_file_exists",
        "packager-parser/package_parser.utils._files/initialize_and_read_exclude_file",
        "packager-parser/package_parser.utils._files/__read_lines",
        "packager-parser/package_parser.utils._files/__write_lines"
      ]
    },
    {
      "id": "packager-parser/package_parser.utils._names",
      "name": "package_parser.utils._names",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.utils._names/declaration_qname_to_name",
        "packager-parser/package_parser.utils._names/parent_id",
        "packager-parser/package_parser.utils._names/parent_qualified_name"
      ]
    },
    {
      "id": "packager-parser/package_parser.utils._parsing",
      "name": "package_parser.utils._parsing",
      "imports": [
        {
          "module": "textwrap",
          "alias": null
        },
        {
          "module": "astroid",
          "alias": null
        }
      ],
      "from_imports": [
        {
          "module": "astroid.builder",
          "declaration": "AstroidBuilder",
          "alias": null
        }
      ],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.utils._parsing/parse_python_code"
      ]
    },
    {
      "id": "packager-parser/package_parser.utils._strings",
      "name": "package_parser.utils._strings",
      "imports": [],
      "from_imports": [],
      "classes": [],
      "functions": [
        "packager-parser/package_parser.utils._strings/pluralize"
      ]
    }
  ],
  "classes": [
    {
      "id": "packager-parser/package_parser.cli._json_encoder/CustomEncoder",
      "name": "CustomEncoder",
      "qname": "package_parser.cli._json_encoder.CustomEncoder",
      "decorators": [],
      "superclasses": [
        "JSONEncoder"
      ],
      "methods": [
        "packager-parser/package_parser.cli._json_encoder/CustomEncoder/default"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class CustomEncoder(JSONEncoder):\n    def default(self, o: Any) -> Any:\n        if isinstance(o, set):\n            return list(o)\n        return super().default(o)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore",
      "name": "AnnotationStore",
      "qname": "package_parser.processing.annotations.model._AnnotationStore.AnnotationStore",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/from_json",
        "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/add_annotation",
        "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AnnotationStore:\n    boundaryAnnotations: list[BoundaryAnnotation] = field(default_factory=list)\n    calledAfterAnnotations: list[CalledAfterAnnotation] = field(default_factory=list)\n    completeAnnotations: list[CompleteAnnotation] = field(default_factory=list)\n    descriptionAnnotations: list[DescriptionAnnotation] = field(default_factory=list)\n    enumAnnotations: list[EnumAnnotation] = field(default_factory=list)\n    expertAnnotations: list[ExpertAnnotation] = field(default_factory=list)\n    groupAnnotations: list[GroupAnnotation] = field(default_factory=list)\n    moveAnnotations: list[MoveAnnotation] = field(default_factory=list)\n    pureAnnotations: list[PureAnnotation] = field(default_factory=list)\n    removeAnnotations: list[RemoveAnnotation] = field(default_factory=list)\n    renameAnnotations: list[RenameAnnotation] = field(default_factory=list)\n    todoAnnotations: list[TodoAnnotation] = field(default_factory=list)\n    valueAnnotations: list[ValueAnnotation] = field(default_factory=list)\n\n    @staticmethod\n    def from_json(json: Any) -> AnnotationStore:\n        if json[\"schemaVersion\"] == 1:\n            raise Exception(\n                \"Incompatible Annotation File: This file is not compatible with the current version.\"\n            )\n\n        boundaryAnnotations = []\n        for annotation in json[\"boundaryAnnotations\"].values():\n            boundaryAnnotations.append(BoundaryAnnotation.from_json(annotation))\n\n        calledAfterAnnotations = []\n        for annotation in json[\"calledAfterAnnotations\"].values():\n            calledAfterAnnotations.append(CalledAfterAnnotation.from_json(annotation))\n\n        completeAnnotations = []\n        for annotation in json[\"completeAnnotations\"].values():\n            completeAnnotations.append(CompleteAnnotation.from_json(annotation))\n\n        descriptionAnnotations = []\n        for annotation in json[\"descriptionAnnotations\"].values():\n            descriptionAnnotations.append(DescriptionAnnotation.from_json(annotation))\n\n        enumAnnotations = []\n        for annotation in json[\"enumAnnotations\"].values():\n            enumAnnotations.append(EnumAnnotation.from_json(annotation))\n\n        expertAnnotations = []\n        for annotation in json[\"expertAnnotations\"].values():\n            expertAnnotations.append(ExpertAnnotation.from_json(annotation))\n\n        groupAnnotations = []\n        for annotation in json[\"groupAnnotations\"].values():\n            groupAnnotations.append(GroupAnnotation.from_json(annotation))\n\n        moveAnnotations = []\n        for annotation in json[\"moveAnnotations\"].values():\n            moveAnnotations.append(MoveAnnotation.from_json(annotation))\n\n        pureAnnotations = []\n        for annotation in json[\"pureAnnotations\"].values():\n            pureAnnotations.append(PureAnnotation.from_json(annotation))\n\n        removeAnnotations = []\n        for annotation in json[\"removeAnnotations\"].values():\n            removeAnnotations.append(RemoveAnnotation.from_json(annotation))\n\n        renameAnnotations = []\n        for annotation in json[\"renameAnnotations\"].values():\n            renameAnnotations.append(RenameAnnotation.from_json(annotation))\n\n        todoAnnotations = []\n        for annotation in json[\"todoAnnotations\"].values():\n            todoAnnotations.append(TodoAnnotation.from_json(annotation))\n\n        valueAnnotations = []\n        for annotation in json[\"valueAnnotations\"].values():\n            valueAnnotations.append(ValueAnnotation.from_json(annotation))\n\n        return AnnotationStore(\n            boundaryAnnotations,\n            calledAfterAnnotations,\n            completeAnnotations,\n            descriptionAnnotations,\n            enumAnnotations,\n            expertAnnotations,\n            groupAnnotations,\n            moveAnnotations,\n            pureAnnotations,\n            removeAnnotations,\n            renameAnnotations,\n            todoAnnotations,\n            valueAnnotations,\n        )\n\n    def add_annotation(self, annotation: AbstractAnnotation) -> None:\n        if isinstance(annotation, BoundaryAnnotation):\n            self.boundaryAnnotations.append(annotation)\n        elif isinstance(annotation, CalledAfterAnnotation):\n            self.calledAfterAnnotations.append(annotation)\n        elif isinstance(annotation, CompleteAnnotation):\n            self.completeAnnotations.append(annotation)\n        elif isinstance(annotation, DescriptionAnnotation):\n            self.descriptionAnnotations.append(annotation)\n        elif isinstance(annotation, EnumAnnotation):\n            self.enumAnnotations.append(annotation)\n        elif isinstance(annotation, ExpertAnnotation):\n            self.expertAnnotations.append(annotation)\n        elif isinstance(annotation, GroupAnnotation):\n            self.groupAnnotations.append(annotation)\n        elif isinstance(annotation, MoveAnnotation):\n            self.moveAnnotations.append(annotation)\n        elif isinstance(annotation, PureAnnotation):\n            self.pureAnnotations.append(annotation)\n        elif isinstance(annotation, RemoveAnnotation):\n            self.removeAnnotations.append(annotation)\n        elif isinstance(annotation, RenameAnnotation):\n            self.renameAnnotations.append(annotation)\n        elif isinstance(annotation, TodoAnnotation):\n            self.todoAnnotations.append(annotation)\n        elif isinstance(annotation, ValueAnnotation):\n            self.valueAnnotations.append(annotation)\n\n    def to_json(self) -> dict:\n        return {\n            \"schemaVersion\": ANNOTATION_SCHEMA_VERSION,\n            \"boundaryAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.boundaryAnnotations\n            },\n            \"calledAfterAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.calledAfterAnnotations\n            },\n            \"completeAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.completeAnnotations\n            },\n            \"descriptionAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.descriptionAnnotations\n            },\n            \"enumAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.enumAnnotations\n            },\n            \"expertAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.expertAnnotations\n            },\n            \"groupAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.groupAnnotations\n            },\n            \"moveAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.moveAnnotations\n            },\n            \"pureAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.pureAnnotations\n            },\n            \"renameAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.renameAnnotations\n            },\n            \"removeAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.removeAnnotations\n            },\n            \"todoAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.todoAnnotations\n            },\n            \"valueAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.valueAnnotations\n            },\n        }",
      "instance_attributes": [
        {
          "name": "boundaryAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "calledAfterAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "completeAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "descriptionAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "enumAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "expertAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "groupAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "moveAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "pureAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "removeAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "renameAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "todoAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "valueAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/AbstractAnnotation",
      "name": "AbstractAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.AbstractAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/AbstractAnnotation/to_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/AbstractAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AbstractAnnotation(ABC):\n    target: str\n    authors: list[str]\n    reviewers: list[str]\n    comment: str\n    reviewResult: EnumReviewResult\n\n    def to_json(self) -> dict:\n        return asdict(self, dict_factory=EnumReviewResult.to_json)\n\n    @staticmethod\n    def from_json(json: Any) -> AbstractAnnotation:\n        review_result = EnumReviewResult(json.get(\"reviewResult\", \"\"))\n\n        return AbstractAnnotation(\n            json[\"target\"],\n            json[\"authors\"],\n            json[\"reviewers\"],\n            json.get(\"comment\", \"\"),\n            review_result,\n        )",
      "instance_attributes": [
        {
          "name": "target",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "authors",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "reviewers",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "comment",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "reviewResult",
          "types": {
            "kind": "NamedType",
            "name": "EnumReviewResult"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/BoundaryAnnotation",
      "name": "BoundaryAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.BoundaryAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/BoundaryAnnotation/to_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/BoundaryAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class BoundaryAnnotation(AbstractAnnotation):\n    interval: Interval\n\n    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"interval\": self.interval.to_json(),\n        }\n\n    @staticmethod\n    def from_json(json: Any) -> BoundaryAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return BoundaryAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            Interval.from_json(json[\"interval\"]),\n        )",
      "instance_attributes": [
        {
          "name": "interval",
          "types": {
            "kind": "NamedType",
            "name": "Interval"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/CalledAfterAnnotation",
      "name": "CalledAfterAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.CalledAfterAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/CalledAfterAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class CalledAfterAnnotation(AbstractAnnotation):\n    calledAfterName: str\n\n    @staticmethod\n    def from_json(json: Any) -> CalledAfterAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return CalledAfterAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"calledAfterName\"],\n        )",
      "instance_attributes": [
        {
          "name": "calledAfterName",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/CompleteAnnotation",
      "name": "CompleteAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.CompleteAnnotation",
      "decorators": [],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/CompleteAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class CompleteAnnotation(AbstractAnnotation):\n    @staticmethod\n    def from_json(json: Any) -> CompleteAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return CompleteAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ConstantAnnotation",
      "name": "ConstantAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.ConstantAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ValueAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/ConstantAnnotation/to_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/ConstantAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConstantAnnotation(ValueAnnotation):\n    variant = ValueAnnotation.Variant.CONSTANT\n    defaultValueType: ValueAnnotation.DefaultValueType\n    defaultValue: Any\n\n    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"variant\": self.variant.value,\n            \"defaultValueType\": self.defaultValueType.value,\n            \"defaultValue\": self.defaultValue,\n        }\n\n    @staticmethod\n    def from_json(json: Any) -> ConstantAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return ConstantAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            ValueAnnotation.DefaultValueType(json[\"defaultValueType\"]),\n            json[\"defaultValue\"],\n        )",
      "instance_attributes": [
        {
          "name": "defaultValueType",
          "types": {
            "kind": "NamedType",
            "name": "DefaultValueType"
          }
        },
        {
          "name": "defaultValue",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/DescriptionAnnotation",
      "name": "DescriptionAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.DescriptionAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/DescriptionAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class DescriptionAnnotation(AbstractAnnotation):\n    newDescription: str\n\n    @staticmethod\n    def from_json(json: Any) -> DescriptionAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return DescriptionAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"newDescription\"],\n        )",
      "instance_attributes": [
        {
          "name": "newDescription",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumAnnotation",
      "name": "EnumAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.EnumAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/EnumAnnotation/to_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/EnumAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class EnumAnnotation(AbstractAnnotation):\n    enumName: str\n    pairs: list[EnumPair]\n\n    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"enumName\": self.enumName,\n            \"pairs\": [pair.to_json() for pair in self.pairs],\n        }\n\n    @staticmethod\n    def from_json(json: Any) -> EnumAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        pairs = [EnumPair.from_json(enum_pair) for enum_pair in json[\"pairs\"]]\n        return EnumAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"enumName\"],\n            pairs,\n        )",
      "instance_attributes": [
        {
          "name": "enumName",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "pairs",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair",
      "name": "EnumPair",
      "qname": "package_parser.processing.annotations.model._annotations.EnumPair",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/to_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/from_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/__eq__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class EnumPair:\n    stringValue: str\n    instanceName: str\n\n    def to_json(self) -> dict:\n        return asdict(self)\n\n    @staticmethod\n    def from_json(json: Any) -> EnumPair:\n        return EnumPair(json[\"stringValue\"], json[\"instanceName\"])\n\n    def __eq__(self, other: Any) -> bool:\n        return (\n            isinstance(other, EnumPair)\n            and self.stringValue == other.stringValue\n            and self.instanceName == other.instanceName\n        )",
      "instance_attributes": [
        {
          "name": "stringValue",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "instanceName",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumReviewResult",
      "name": "EnumReviewResult",
      "qname": "package_parser.processing.annotations.model._annotations.EnumReviewResult",
      "decorators": [],
      "superclasses": [
        "Enum"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/EnumReviewResult/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class EnumReviewResult(Enum):\n    CORRECT = \"correct\"\n    UNSURE = \"unsure\"\n    WRONG = \"wrong\"\n    NONE = \"\"\n\n    @staticmethod\n    def to_json(result: list[tuple[str, Any]]) -> dict[str, Any]:\n        for item in result:\n            if isinstance(item[1], EnumReviewResult):\n                result.append((item[0], item[1].value))\n                result.remove(item)\n        return dict(result)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ExpertAnnotation",
      "name": "ExpertAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.ExpertAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/ExpertAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ExpertAnnotation(AbstractAnnotation):\n    @staticmethod\n    def from_json(json: Any) -> ExpertAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return ExpertAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/GroupAnnotation",
      "name": "GroupAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.GroupAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/GroupAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class GroupAnnotation(AbstractAnnotation):\n    groupName: str\n    parameters: list[str]\n\n    @staticmethod\n    def from_json(json: Any) -> GroupAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return GroupAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"groupName\"],\n            json[\"parameters\"],\n        )",
      "instance_attributes": [
        {
          "name": "groupName",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "parameters",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/Interval",
      "name": "Interval",
      "qname": "package_parser.processing.annotations.model._annotations.Interval",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/Interval/to_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/Interval/from_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/Interval/__eq__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Interval:\n    isDiscrete: bool\n    lowerIntervalLimit: Union[int, float, str]\n    lowerLimitType: int\n    upperIntervalLimit: Union[int, float, str]\n    upperLimitType: int\n\n    def to_json(self) -> dict:\n        return asdict(self)\n\n    @staticmethod\n    def from_json(json: Any) -> Interval:\n        return Interval(\n            json[\"isDiscrete\"],\n            json[\"lowerIntervalLimit\"],\n            json[\"lowerLimitType\"],\n            json[\"upperIntervalLimit\"],\n            json[\"upperLimitType\"],\n        )\n\n    def __eq__(self, other: Any) -> bool:\n        return (\n            isinstance(other, Interval)\n            and self.isDiscrete == other.isDiscrete\n            and self.lowerIntervalLimit == other.lowerIntervalLimit\n            and isinstance(self.lowerIntervalLimit, type(self.lowerIntervalLimit))\n            and self.lowerLimitType == other.lowerLimitType\n            and self.upperIntervalLimit == other.upperIntervalLimit\n            and isinstance(self.upperIntervalLimit, type(self.upperIntervalLimit))\n            and self.upperLimitType == self.upperLimitType\n        )",
      "instance_attributes": [
        {
          "name": "isDiscrete",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "lowerIntervalLimit",
          "types": null
        },
        {
          "name": "lowerLimitType",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "upperIntervalLimit",
          "types": null
        },
        {
          "name": "upperLimitType",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/MoveAnnotation",
      "name": "MoveAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.MoveAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/MoveAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class MoveAnnotation(AbstractAnnotation):\n    destination: str\n\n    @staticmethod\n    def from_json(json: Any) -> MoveAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return MoveAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"destination\"],\n        )",
      "instance_attributes": [
        {
          "name": "destination",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/OmittedAnnotation",
      "name": "OmittedAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.OmittedAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ValueAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/OmittedAnnotation/to_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/OmittedAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class OmittedAnnotation(ValueAnnotation):\n    variant = ValueAnnotation.Variant.OMITTED\n\n    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"variant\": self.variant.value,\n        }\n\n    @staticmethod\n    def from_json(json: Any) -> OmittedAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return OmittedAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/OptionalAnnotation",
      "name": "OptionalAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.OptionalAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ValueAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/OptionalAnnotation/to_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/OptionalAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class OptionalAnnotation(ValueAnnotation):\n    variant = ValueAnnotation.Variant.OPTIONAL\n    defaultValueType: ValueAnnotation.DefaultValueType\n    defaultValue: Any\n\n    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"variant\": self.variant.value,\n            \"defaultValueType\": self.defaultValueType.value,\n            \"defaultValue\": self.defaultValue,\n        }\n\n    @staticmethod\n    def from_json(json: Any) -> OptionalAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return OptionalAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            ValueAnnotation.DefaultValueType(json[\"defaultValueType\"]),\n            json[\"defaultValue\"],\n        )",
      "instance_attributes": [
        {
          "name": "defaultValueType",
          "types": {
            "kind": "NamedType",
            "name": "DefaultValueType"
          }
        },
        {
          "name": "defaultValue",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ParameterInfo",
      "name": "ParameterInfo",
      "qname": "package_parser.processing.annotations.model._annotations.ParameterInfo",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/ParameterInfo/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterInfo:\n    type: ParameterType\n    value: str\n    value_type: str\n\n    def __init__(\n        self, parameter_type: ParameterType, value: str = \"\", value_type: str = \"\"\n    ) -> None:\n        self.type = parameter_type\n        self.value = value\n        self.value_type = value_type",
      "instance_attributes": [
        {
          "name": "type",
          "types": {
            "kind": "NamedType",
            "name": "ParameterType"
          }
        },
        {
          "name": "value",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "value_type",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ParameterType",
      "name": "ParameterType",
      "qname": "package_parser.processing.annotations.model._annotations.ParameterType",
      "decorators": [],
      "superclasses": [
        "Enum"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterType(Enum):\n    Constant = 0\n    Optional = 1\n    Required = 2\n    Unused = 3",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/PureAnnotation",
      "name": "PureAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.PureAnnotation",
      "decorators": [],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/PureAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class PureAnnotation(AbstractAnnotation):\n    @staticmethod\n    def from_json(json: Any) -> PureAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return PureAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/RemoveAnnotation",
      "name": "RemoveAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.RemoveAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/RemoveAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RemoveAnnotation(AbstractAnnotation):\n    @staticmethod\n    def from_json(json: Any) -> RemoveAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return RemoveAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/RenameAnnotation",
      "name": "RenameAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.RenameAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/RenameAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RenameAnnotation(AbstractAnnotation):\n    newName: str\n\n    @staticmethod\n    def from_json(json: Any) -> RenameAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return RenameAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"newName\"],\n        )",
      "instance_attributes": [
        {
          "name": "newName",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/RequiredAnnotation",
      "name": "RequiredAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.RequiredAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ValueAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/RequiredAnnotation/to_json",
        "packager-parser/package_parser.processing.annotations.model._annotations/RequiredAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RequiredAnnotation(ValueAnnotation):\n    variant = ValueAnnotation.Variant.REQUIRED\n\n    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"variant\": self.variant.value,\n        }\n\n    @staticmethod\n    def from_json(json: Any) -> RequiredAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return RequiredAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/TodoAnnotation",
      "name": "TodoAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.TodoAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/TodoAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class TodoAnnotation(AbstractAnnotation):\n    newTodo: str\n\n    @staticmethod\n    def from_json(json: Any) -> TodoAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return TodoAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"newTodo\"],\n        )",
      "instance_attributes": [
        {
          "name": "newTodo",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ValueAnnotation",
      "name": "ValueAnnotation",
      "qname": "package_parser.processing.annotations.model._annotations.ValueAnnotation",
      "decorators": [],
      "superclasses": [
        "AbstractAnnotation",
        "ABC"
      ],
      "methods": [
        "packager-parser/package_parser.processing.annotations.model._annotations/ValueAnnotation/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ValueAnnotation(AbstractAnnotation, ABC):\n    class Variant(Enum):\n        CONSTANT = \"constant\"\n        OMITTED = \"omitted\"\n        OPTIONAL = \"optional\"\n        REQUIRED = \"required\"\n\n    class DefaultValueType(Enum):\n        BOOLEAN = \"boolean\"\n        NONE = \"none\"\n        NUMBER = \"number\"\n        STRING = \"string\"\n\n    variant: Variant\n\n    @staticmethod\n    def from_json(json: Any) -> ValueAnnotation:\n        variant = json[\"variant\"]\n        if ValueAnnotation.Variant.CONSTANT.value == variant:\n            return ConstantAnnotation.from_json(json)\n        if ValueAnnotation.Variant.OMITTED.value == variant:\n            return OmittedAnnotation.from_json(json)\n        if ValueAnnotation.Variant.OPTIONAL.value == variant:\n            return OptionalAnnotation.from_json(json)\n        if ValueAnnotation.Variant.REQUIRED.value == variant:\n            return RequiredAnnotation.from_json(json)\n        raise Exception(\"unkonwn variant found\")",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor",
      "name": "_AstVisitor",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__init__",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_id",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_module",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_module",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_classdef",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_classdef",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_functiondef",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/get_code",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_functiondef",
        "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class _AstVisitor:\n    def __init__(\n        self, documentation_parser: AbstractDocumentationParser, api: API\n    ) -> None:\n        self.documentation_parser: AbstractDocumentationParser = documentation_parser\n        self.reexported: dict[str, list[str]] = {}\n        self.api: API = api\n        self.__declaration_stack: list[Union[Module, Class, Function]] = []\n\n    def __get_id(self, name: str) -> str:\n        segments = [self.api.package]\n        segments += [it.name for it in self.__declaration_stack]\n        segments += [name]\n\n        return \"/\".join(segments)\n\n    def __get_function_id(self, name: str, decorators: list[str]) -> str:\n        def is_getter() -> bool:\n            return \"property\" in decorators\n\n        def is_setter() -> bool:\n            for decorator in decorators:\n                if re.search(r\"^[^.]*.setter$\", decorator):\n                    return True\n\n            return False\n\n        def is_deleter() -> bool:\n            for decorator in decorators:\n                if re.search(r\"^[^.]*.deleter$\", decorator):\n                    return True\n\n            return False\n\n        result = self.__get_id(name)\n\n        if is_getter():\n            result += \"@getter\"\n        elif is_setter():\n            result += \"@setter\"\n        elif is_deleter():\n            result += \"@deleter\"\n\n        return result\n\n    def enter_module(self, module_node: astroid.Module) -> None:\n        imports: list[Import] = []\n        from_imports: list[FromImport] = []\n        visited_global_nodes: set[astroid.NodeNG] = set()\n        id_ = f\"{self.api.package}/{module_node.qname()}\"\n\n        for _, global_node_list in module_node.globals.items():\n            global_node = global_node_list[0]\n\n            # For some reason from-imports get visited as often as there are imported names, leading to duplicates\n            if global_node in visited_global_nodes:\n                continue\n            visited_global_nodes.add(global_node)\n\n            # import X as Y\n            if isinstance(global_node, astroid.Import):\n                for name, alias in global_node.names:\n                    imports.append(Import(name, alias))\n\n            # from X import a as b\n            if isinstance(global_node, astroid.ImportFrom):\n                base_import_path = module_node.relative_to_absolute_name(\n                    global_node.modname, global_node.level\n                )\n\n                for name, alias in global_node.names:\n                    from_imports.append(FromImport(base_import_path, name, alias))\n\n                # Find re-exported declarations in __init__.py files\n                if _is_init_file(module_node.file) and is_public_module(\n                    module_node.qname()\n                ):\n                    for declaration, _ in global_node.names:\n                        context = InferenceContext()\n                        context.lookupname = declaration\n                        node = safe_infer(global_node, context)\n\n                        if node is None:\n                            logging.warning(\n                                f\"Could not resolve 'from {global_node.modname} import {declaration}\"\n                            )\n                            continue\n\n                        reexported_name = node.qname()\n\n                        if reexported_name.startswith(module_node.name):\n                            if reexported_name not in self.reexported:\n                                self.reexported[reexported_name] = []\n                            self.reexported[reexported_name].append(id_)\n\n        # Remember module, so we can later add classes and global functions\n        module = Module(\n            id_,\n            module_node.qname(),\n            imports,\n            from_imports,\n        )\n        self.__declaration_stack.append(module)\n\n    def leave_module(self, _: astroid.Module) -> None:\n        module = self.__declaration_stack.pop()\n        if not isinstance(module, Module):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        self.api.add_module(module)\n\n    def enter_classdef(self, class_node: astroid.ClassDef) -> None:\n        qname = class_node.qname()\n        instance_attributes = get_instance_attributes(class_node)\n\n        decorators: Optional[astroid.Decorators] = class_node.decorators\n        if decorators is not None:\n            decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n        else:\n            decorator_names = []\n\n        code = self.get_code(class_node)\n\n        # Remember class, so we can later add methods\n        class_ = Class(\n            id_=self.__get_id(class_node.name),\n            qname=qname,\n            decorators=decorator_names,\n            superclasses=class_node.basenames,\n            is_public=self.is_public(class_node.name, qname),\n            reexported_by=self.reexported.get(qname, []),\n            documentation=self.documentation_parser.get_class_documentation(class_node),\n            code=code,\n            instance_attributes=instance_attributes,\n        )\n        self.__declaration_stack.append(class_)\n\n    def leave_classdef(self, _: astroid.ClassDef) -> None:\n        class_ = self.__declaration_stack.pop()\n        if not isinstance(class_, Class):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        if len(self.__declaration_stack) > 0:\n            parent = self.__declaration_stack[-1]\n\n            # Ignore nested classes for now\n            if isinstance(parent, Module):\n                self.api.add_class(class_)\n                parent.add_class(class_.id)\n\n    def enter_functiondef(self, function_node: astroid.FunctionDef) -> None:\n        qname = function_node.qname()\n\n        decorators: Optional[astroid.Decorators] = function_node.decorators\n        if decorators is not None:\n            decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n        else:\n            decorator_names = []\n\n        is_public = self.is_public(function_node.name, qname)\n\n        code = self.get_code(function_node)\n\n        function_id = self.__get_function_id(function_node.name, decorator_names)\n        function = Function(\n            id=function_id,\n            qname=qname,\n            decorators=decorator_names,\n            parameters=get_parameter_list(\n                self.documentation_parser,\n                function_node,\n                function_id,\n                qname,\n                is_public,\n            ),\n            results=[],  # TODO: results\n            is_public=is_public,\n            reexported_by=self.reexported.get(qname, []),\n            documentation=self.documentation_parser.get_function_documentation(\n                function_node\n            ),\n            code=code,\n        )\n        self.__declaration_stack.append(function)\n\n    def get_code(\n        self, function_node: Union[astroid.FunctionDef, astroid.ClassDef]\n    ) -> str:\n        code = \"\"\n        node: NodeNG = function_node\n        while node.parent is not None:\n            node = node.parent\n            if isinstance(node, astroid.Module):\n                code = trim_code(\n                    node.file_bytes,\n                    function_node.lineno,\n                    function_node.tolineno,\n                    node.file_encoding,\n                )\n                break\n        return code\n\n    def leave_functiondef(self, _: astroid.FunctionDef) -> None:\n        function = self.__declaration_stack.pop()\n        if not isinstance(function, Function):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        if len(self.__declaration_stack) > 0:\n            parent = self.__declaration_stack[-1]\n\n            # Ignore nested functions for now\n            if isinstance(parent, Module):\n                self.api.add_function(function)\n                parent.add_function(function.id)\n            elif isinstance(parent, Class):\n                self.api.add_function(function)\n                parent.add_method(function.id)\n\n    def is_public(self, name: str, qualified_name: str) -> bool:\n        if name.startswith(\"_\") and not name.endswith(\"__\"):\n            return False\n\n        if qualified_name in self.reexported:\n            return True\n\n        # Containing class is re-exported (always false if the current API element is not a method)\n        if (\n            isinstance(self.__declaration_stack[-1], Class)\n            and parent_qualified_name(qualified_name) in self.reexported\n        ):\n            return True\n\n        # The slicing is necessary so __init__ functions are not excluded (already handled in the first condition).\n        return all(not it.startswith(\"_\") for it in qualified_name.split(\".\")[:-1])",
      "instance_attributes": [
        {
          "name": "documentation_parser",
          "types": null
        },
        {
          "name": "reexported",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "api",
          "types": null
        },
        {
          "name": "__declaration_stack",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser",
      "name": "AbstractDocumentationParser",
      "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser",
      "decorators": [],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_class_documentation",
        "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_function_documentation",
        "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_parameter_documentation"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AbstractDocumentationParser(ABC):\n    @abstractmethod\n    def get_class_documentation(\n        self, class_node: astroid.ClassDef\n    ) -> ClassDocumentation:\n        pass\n\n    @abstractmethod\n    def get_function_documentation(\n        self, function_node: astroid.FunctionDef\n    ) -> FunctionDocumentation:\n        pass\n\n    @abstractmethod\n    def get_parameter_documentation(\n        self,\n        function_node: astroid.FunctionDef,\n        parameter_name: str,\n        parameter_assigned_by: ParameterAssignment,\n    ) -> ParameterDocumentation:\n        pass",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser",
      "name": "DefaultDocumentationParser",
      "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser",
      "decorators": [],
      "superclasses": [
        "AbstractDocumentationParser"
      ],
      "methods": [
        "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_class_documentation",
        "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_function_documentation",
        "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_parameter_documentation"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Parses documentation in any format. Should not be used if there is another parser for the specific format.",
      "docstring": "Parses documentation in any format. Should not be used if there is another parser for the specific format.",
      "code": "class DefaultDocumentationParser(AbstractDocumentationParser):\n    \"\"\"\n    Parses documentation in any format. Should not be used if there is another parser for the specific format.\n    \"\"\"\n\n    def get_class_documentation(\n        self, class_node: astroid.ClassDef\n    ) -> ClassDocumentation:\n        return ClassDocumentation(\n            full_docstring=get_full_docstring(class_node),\n        )\n\n    def get_function_documentation(\n        self, function_node: astroid.FunctionDef\n    ) -> FunctionDocumentation:\n        return FunctionDocumentation(\n            full_docstring=get_full_docstring(function_node),\n        )\n\n    def get_parameter_documentation(\n        self,\n        function_node: astroid.FunctionDef,\n        parameter_name: str,\n        parameter_assigned_by: ParameterAssignment,\n    ) -> ParameterDocumentation:\n        return ParameterDocumentation()",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser",
      "name": "NumpyDocParser",
      "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser",
      "decorators": [],
      "superclasses": [
        "AbstractDocumentationParser"
      ],
      "methods": [
        "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/__init__",
        "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_class_documentation",
        "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_function_documentation",
        "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_parameter_documentation",
        "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/__get_cached_function_numpydoc_string"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Parses documentation in the NumpyDoc format. See https://numpydoc.readthedocs.io/en/latest/format.html for more\ninformation.\n\nThis class is not thread-safe. Each thread should create its own instance.",
      "docstring": "Parses documentation in the NumpyDoc format. See https://numpydoc.readthedocs.io/en/latest/format.html for more\ninformation.\n\nThis class is not thread-safe. Each thread should create its own instance.",
      "code": "class NumpyDocParser(AbstractDocumentationParser):\n    \"\"\"\n    Parses documentation in the NumpyDoc format. See https://numpydoc.readthedocs.io/en/latest/format.html for more\n    information.\n\n    This class is not thread-safe. Each thread should create its own instance.\n    \"\"\"\n\n    def __init__(self):\n        self.__cached_function_node: Optional[astroid.FunctionDef] = None\n        self.__cached_numpydoc_string: Optional[NumpyDocString] = None\n\n    def get_class_documentation(\n        self, class_node: astroid.ClassDef\n    ) -> ClassDocumentation:\n        docstring = get_full_docstring(class_node)\n\n        return ClassDocumentation(\n            description=_get_description(NumpyDocString(docstring)),\n            full_docstring=docstring,\n        )\n\n    def get_function_documentation(\n        self, function_node: astroid.FunctionDef\n    ) -> FunctionDocumentation:\n        docstring = get_full_docstring(function_node)\n\n        return FunctionDocumentation(\n            description=_get_description(\n                self.__get_cached_function_numpydoc_string(function_node, docstring)\n            ),\n            full_docstring=docstring,\n        )\n\n    def get_parameter_documentation(\n        self,\n        function_node: astroid.FunctionDef,\n        parameter_name: str,\n        parameter_assigned_by: ParameterAssignment,\n    ) -> ParameterDocumentation:\n\n        # For constructors (__init__ functions) the parameters are described on the class\n        if function_node.name == \"__init__\" and isinstance(\n            function_node.parent, astroid.ClassDef\n        ):\n            docstring = get_full_docstring(function_node.parent)\n        else:\n            docstring = get_full_docstring(function_node)\n\n        # Find matching parameter docstrings\n        function_numpydoc = self.__get_cached_function_numpydoc_string(\n            function_node, docstring\n        )\n        all_parameters_numpydoc: list[\n            numpydoc.docscrape.Parameter\n        ] = function_numpydoc.get(\"Parameters\", [])\n        matching_parameters_numpydoc = [\n            it\n            for it in all_parameters_numpydoc\n            if _is_matching_parameter_numpydoc(\n                it, parameter_name, parameter_assigned_by\n            )\n        ]\n\n        if len(matching_parameters_numpydoc) == 0:\n            return ParameterDocumentation(type=\"\", default_value=\"\", description=\"\")\n\n        last_parameter_numpydoc = matching_parameters_numpydoc[-1]\n        type_, default_value = _get_type_and_default_value(last_parameter_numpydoc)\n        return ParameterDocumentation(\n            type=type_,\n            default_value=default_value,\n            description=\"\\n\".join(\n                [line.rstrip() for line in last_parameter_numpydoc.desc]\n            ),\n        )\n\n    def __get_cached_function_numpydoc_string(\n        self, function_node: astroid.FunctionDef, docstring: str\n    ) -> NumpyDocString:\n        \"\"\"\n        Returns the NumpyDocString for the given function node. It is only recomputed when the function node differs\n        from the previous one that was passed to this function. This avoids reparsing the docstring for the function\n        itself and all of its parameters.\n\n        On Lars's system this caused a significant performance improvement: Previously, 8.382s were spent inside the\n        function get_parameter_documentation when parsing sklearn. Afterwards, it was only 2.113s.\n        \"\"\"\n\n        if self.__cached_function_node is not function_node:\n            self.__cached_function_node = function_node\n            self.__cached_numpydoc_string = NumpyDocString(docstring)\n\n        return self.__cached_numpydoc_string",
      "instance_attributes": [
        {
          "name": "__cached_function_node",
          "types": null
        },
        {
          "name": "__cached_numpydoc_string",
          "types": {
            "kind": "NamedType",
            "name": "NumpyDocString"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API",
      "name": "API",
      "qname": "package_parser.processing.api.model._api.API",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._api/API/from_json",
        "packager-parser/package_parser.processing.api.model._api/API/__init__",
        "packager-parser/package_parser.processing.api.model._api/API/add_module",
        "packager-parser/package_parser.processing.api.model._api/API/add_class",
        "packager-parser/package_parser.processing.api.model._api/API/add_function",
        "packager-parser/package_parser.processing.api.model._api/API/is_public_class",
        "packager-parser/package_parser.processing.api.model._api/API/is_public_function",
        "packager-parser/package_parser.processing.api.model._api/API/class_count",
        "packager-parser/package_parser.processing.api.model._api/API/public_class_count",
        "packager-parser/package_parser.processing.api.model._api/API/function_count",
        "packager-parser/package_parser.processing.api.model._api/API/public_function_count",
        "packager-parser/package_parser.processing.api.model._api/API/parameter_count",
        "packager-parser/package_parser.processing.api.model._api/API/public_parameter_count",
        "packager-parser/package_parser.processing.api.model._api/API/parameters",
        "packager-parser/package_parser.processing.api.model._api/API/attributes",
        "packager-parser/package_parser.processing.api.model._api/API/results",
        "packager-parser/package_parser.processing.api.model._api/API/get_default_value",
        "packager-parser/package_parser.processing.api.model._api/API/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class API:\n    @staticmethod\n    def from_json(json: Any) -> API:\n        result = API(json[\"distribution\"], json[\"package\"], json[\"version\"])\n\n        for module_json in json.get(\"modules\", []):\n            result.add_module(Module.from_json(module_json))\n\n        for class_json in json.get(\"classes\", []):\n            result.add_class(Class.from_json(class_json))\n\n        for function_json in json.get(\"functions\", []):\n            result.add_function(Function.from_json(function_json))\n\n        return result\n\n    def __init__(self, distribution: str, package: str, version: str) -> None:\n        self.distribution: str = distribution\n        self.package: str = package\n        self.version: str = version\n        self.modules: dict[str, Module] = {}\n        self.classes: dict[str, Class] = {}\n        self.functions: dict[str, Function] = {}\n\n    def add_module(self, module: Module) -> None:\n        self.modules[module.id] = module\n\n    def add_class(self, class_: Class) -> None:\n        self.classes[class_.id] = class_\n\n    def add_function(self, function: Function) -> None:\n        self.functions[function.id] = function\n\n    def is_public_class(self, class_id: str) -> bool:\n        return class_id in self.classes and self.classes[class_id].is_public\n\n    def is_public_function(self, function_id: str) -> bool:\n        return function_id in self.functions and self.functions[function_id].is_public\n\n    def class_count(self) -> int:\n        return len(self.classes)\n\n    def public_class_count(self) -> int:\n        return len([it for it in self.classes.values() if it.is_public])\n\n    def function_count(self) -> int:\n        return len(self.functions)\n\n    def public_function_count(self) -> int:\n        return len([it for it in self.functions.values() if it.is_public])\n\n    def parameter_count(self) -> int:\n        return len(self.parameters())\n\n    def public_parameter_count(self) -> int:\n        return len([it for it in self.parameters().values() if it.is_public])\n\n    def parameters(self) -> dict[str, Parameter]:\n        result: dict[str, Parameter] = {}\n\n        for function in self.functions.values():\n            for parameter in function.parameters:\n                parameter_id = f\"{function.id}/{parameter.name}\"\n                result[parameter_id] = parameter\n\n        return result\n\n    def attributes(self) -> dict[str, Attribute]:\n        result: dict[str, Attribute] = {}\n\n        for class_ in self.classes.values():\n            for attribute in class_.instance_attributes:\n                attribute_id = f\"{class_.id}/{attribute.name}\"\n                result[attribute_id] = attribute\n\n        return result\n\n    def results(self) -> dict[str, Result]:\n        result_dict: dict[str, Result] = {}\n\n        for function in self.functions.values():\n            for result in function.results:\n                result_id = f\"{function.id}/{result.name}\"\n                result_dict[result_id] = result\n\n        return result_dict\n\n    def get_default_value(self, parameter_id: str) -> Optional[str]:\n        function_id = parent_id(parameter_id)\n\n        if function_id not in self.functions:\n            return None\n\n        for parameter in self.functions[function_id].parameters:\n            if parameter.id == parameter_id:\n                return parameter.default_value\n\n        return None\n\n    def to_json(self) -> Any:\n        return {\n            \"schemaVersion\": API_SCHEMA_VERSION,\n            \"distribution\": self.distribution,\n            \"package\": self.package,\n            \"version\": self.version,\n            \"modules\": [\n                module.to_json()\n                for module in sorted(self.modules.values(), key=lambda it: it.id)\n            ],\n            \"classes\": [\n                class_.to_json()\n                for class_ in sorted(self.classes.values(), key=lambda it: it.id)\n            ],\n            \"functions\": [\n                function.to_json()\n                for function in sorted(self.functions.values(), key=lambda it: it.id)\n            ],\n        }",
      "instance_attributes": [
        {
          "name": "distribution",
          "types": null
        },
        {
          "name": "package",
          "types": null
        },
        {
          "name": "version",
          "types": null
        },
        {
          "name": "modules",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "classes",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "functions",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Attribute",
      "name": "Attribute",
      "qname": "package_parser.processing.api.model._api.Attribute",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._api/Attribute/__hash__",
        "packager-parser/package_parser.processing.api.model._api/Attribute/to_json",
        "packager-parser/package_parser.processing.api.model._api/Attribute/from_json",
        "packager-parser/package_parser.processing.api.model._api/Attribute/__repr__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Attribute:\n    name: str\n    types: Optional[AbstractType]\n    class_id: Optional[str] = None\n\n    def __hash__(self) -> int:\n        return hash((self.name, self.class_id, self.types))\n\n    def to_json(self) -> dict[str, Any]:\n        types_json = self.types.to_json() if self.types is not None else None\n        return {\"name\": self.name, \"types\": types_json}\n\n    @staticmethod\n    def from_json(json: Any, class_id: Optional[str] = None) -> Attribute:\n        return Attribute(\n            json[\"name\"], AbstractType.from_json(json.get(\"types\", {})), class_id\n        )\n\n    def __repr__(self) -> str:\n        type_str = (\n            \" , type=\" + str(self.types.to_json()) if self.types is not None else \"None\"\n        )\n        return (\n            \"Attribute(class_id=\"\n            + str(self.class_id)\n            + \"/\"\n            + self.name\n            + type_str\n            + \")\"\n        )",
      "instance_attributes": [
        {
          "name": "name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "types",
          "types": null
        },
        {
          "name": "class_id",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Class",
      "name": "Class",
      "qname": "package_parser.processing.api.model._api.Class",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._api/Class/from_json",
        "packager-parser/package_parser.processing.api.model._api/Class/__init__",
        "packager-parser/package_parser.processing.api.model._api/Class/name@getter",
        "packager-parser/package_parser.processing.api.model._api/Class/add_method",
        "packager-parser/package_parser.processing.api.model._api/Class/to_json",
        "packager-parser/package_parser.processing.api.model._api/Class/get_formatted_code",
        "packager-parser/package_parser.processing.api.model._api/Class/__repr__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Class:\n    @staticmethod\n    def from_json(json: Any) -> Class:\n        result = Class(\n            json[\"id\"],\n            json[\"qname\"],\n            json.get(\"decorators\", []),\n            json.get(\"superclasses\", []),\n            json.get(\"is_public\", True),\n            json.get(\"reexported_by\", []),\n            ClassDocumentation(\n                description=json.get(\"description\", \"\"),\n                full_docstring=json.get(\"docstring\", \"\"),\n            ),\n            json.get(\"code\", \"\"),\n            [\n                Attribute.from_json(instance_attribute, json[\"id\"])\n                for instance_attribute in json.get(\"instance_attributes\", [])\n            ],\n        )\n\n        for method_id in json[\"methods\"]:\n            result.add_method(method_id)\n\n        return result\n\n    def __init__(\n        self,\n        id_: str,\n        qname: str,\n        decorators: list[str],\n        superclasses: list[str],\n        is_public: bool,\n        reexported_by: list[str],\n        documentation: ClassDocumentation,\n        code: str,\n        instance_attributes: list[Attribute],\n    ) -> None:\n        self.id: str = id_\n        self.qname: str = qname\n        self.decorators: list[str] = decorators\n        self.superclasses: list[str] = superclasses\n        self.methods: list[str] = []\n        self.is_public: bool = is_public\n        self.reexported_by: list[str] = reexported_by\n        self.documentation: ClassDocumentation = documentation\n        self.code: str = code\n        self.instance_attributes = instance_attributes\n        self.formatted_code: Optional[str] = None\n\n    @property\n    def name(self) -> str:\n        return self.qname.split(\".\")[-1]\n\n    def add_method(self, method_id: str) -> None:\n        self.methods.append(method_id)\n\n    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"decorators\": self.decorators,\n            \"superclasses\": self.superclasses,\n            \"methods\": self.methods,\n            \"is_public\": self.is_public,\n            \"reexported_by\": self.reexported_by,\n            \"description\": self.documentation.description,\n            \"docstring\": self.documentation.full_docstring,\n            \"code\": self.code,\n            \"instance_attributes\": [\n                attribute.to_json() for attribute in self.instance_attributes\n            ],\n        }\n\n    def get_formatted_code(self) -> str:\n        if self.formatted_code is None:\n            self.formatted_code = _generate_formatted_code(self)\n        return self.formatted_code\n\n    def __repr__(self) -> str:\n        return \"Class(id=\" + self.id + \")\"",
      "instance_attributes": [
        {
          "name": "id",
          "types": null
        },
        {
          "name": "qname",
          "types": null
        },
        {
          "name": "decorators",
          "types": null
        },
        {
          "name": "superclasses",
          "types": null
        },
        {
          "name": "methods",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "is_public",
          "types": null
        },
        {
          "name": "reexported_by",
          "types": null
        },
        {
          "name": "documentation",
          "types": null
        },
        {
          "name": "code",
          "types": null
        },
        {
          "name": "instance_attributes",
          "types": {
            "kind": "NamedType",
            "name": "list[Attribute]"
          }
        },
        {
          "name": "formatted_code",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/FromImport",
      "name": "FromImport",
      "qname": "package_parser.processing.api.model._api.FromImport",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._api/FromImport/from_json",
        "packager-parser/package_parser.processing.api.model._api/FromImport/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FromImport:\n    module_name: str\n    declaration_name: str\n    alias: Optional[str]\n\n    @staticmethod\n    def from_json(json: Any) -> FromImport:\n        return FromImport(json[\"module\"], json[\"declaration\"], json[\"alias\"])\n\n    def to_json(self) -> Any:\n        return {\n            \"module\": self.module_name,\n            \"declaration\": self.declaration_name,\n            \"alias\": self.alias,\n        }",
      "instance_attributes": [
        {
          "name": "module_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "declaration_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "alias",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Function",
      "name": "Function",
      "qname": "package_parser.processing.api.model._api.Function",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._api/Function/__post_init__",
        "packager-parser/package_parser.processing.api.model._api/Function/from_json",
        "packager-parser/package_parser.processing.api.model._api/Function/name@getter",
        "packager-parser/package_parser.processing.api.model._api/Function/to_json",
        "packager-parser/package_parser.processing.api.model._api/Function/get_formatted_code",
        "packager-parser/package_parser.processing.api.model._api/Function/__repr__",
        "packager-parser/package_parser.processing.api.model._api/Function/__hash__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Function:\n    id: str\n    qname: str\n    decorators: list[str]\n    parameters: list[Parameter]\n    results: list[Result]\n    is_public: bool\n    reexported_by: list[str]\n    documentation: FunctionDocumentation\n    code: str\n    formatted_code: Optional[str] = field(init=False)\n\n    def __post_init__(self) -> None:\n        self.formatted_code = None\n\n    @staticmethod\n    def from_json(json: Any) -> Function:\n        return Function(\n            json[\"id\"],\n            json[\"qname\"],\n            json.get(\"decorators\", []),\n            [\n                Parameter.from_json(parameter_json)\n                for parameter_json in json.get(\"parameters\", [])\n            ],\n            [Result.from_json(result_json) for result_json in json.get(\"results\", [])],\n            json.get(\"is_public\", True),\n            json.get(\"reexported_by\", []),\n            FunctionDocumentation(\n                description=json.get(\"description\", \"\"),\n                full_docstring=json.get(\"docstring\", \"\"),\n            ),\n            json.get(\"code\", \"\"),\n        )\n\n    @property\n    def name(self) -> str:\n        return self.qname.rsplit(\".\", maxsplit=1)[-1]\n\n    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"decorators\": self.decorators,\n            \"parameters\": [parameter.to_json() for parameter in self.parameters],\n            \"results\": [result.to_json() for result in self.results],\n            \"is_public\": self.is_public,\n            \"reexported_by\": self.reexported_by,\n            \"description\": self.documentation.description,\n            \"docstring\": self.documentation.full_docstring,\n            \"code\": self.code,\n        }\n\n    def get_formatted_code(self) -> str:\n        if self.formatted_code is None:\n            self.formatted_code = _generate_formatted_code(self)\n        return self.formatted_code\n\n    def __repr__(self) -> str:\n        return \"Function(id=\" + self.id + \")\"\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.id,\n                self.name,\n                self.qname,\n                frozenset(self.decorators),\n                frozenset(self.parameters),\n                frozenset(self.results),\n                self.is_public,\n                frozenset(self.reexported_by),\n                self.documentation,\n                self.code,\n            )\n        )",
      "instance_attributes": [
        {
          "name": "formatted_code",
          "types": null
        },
        {
          "name": "id",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "qname",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "decorators",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "parameters",
          "types": null
        },
        {
          "name": "results",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "is_public",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "reexported_by",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "documentation",
          "types": null
        },
        {
          "name": "code",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Import",
      "name": "Import",
      "qname": "package_parser.processing.api.model._api.Import",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._api/Import/from_json",
        "packager-parser/package_parser.processing.api.model._api/Import/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Import:\n    module_name: str\n    alias: Optional[str]\n\n    @staticmethod\n    def from_json(json: Any) -> Import:\n        return Import(json[\"module\"], json[\"alias\"])\n\n    def to_json(self) -> Any:\n        return {\"module\": self.module_name, \"alias\": self.alias}",
      "instance_attributes": [
        {
          "name": "module_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "alias",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Module",
      "name": "Module",
      "qname": "package_parser.processing.api.model._api.Module",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._api/Module/from_json",
        "packager-parser/package_parser.processing.api.model._api/Module/__init__",
        "packager-parser/package_parser.processing.api.model._api/Module/add_class",
        "packager-parser/package_parser.processing.api.model._api/Module/add_function",
        "packager-parser/package_parser.processing.api.model._api/Module/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Module:\n    @staticmethod\n    def from_json(json: Any) -> Module:\n        result = Module(\n            json[\"id\"],\n            json[\"name\"],\n            [Import.from_json(import_json) for import_json in json.get(\"imports\", [])],\n            [\n                FromImport.from_json(from_import_json)\n                for from_import_json in json.get(\"from_imports\", [])\n            ],\n        )\n\n        for class_id in json.get(\"classes\", []):\n            result.add_class(class_id)\n\n        for function_id in json.get(\"functions\", []):\n            result.add_function(function_id)\n\n        return result\n\n    def __init__(\n        self, id_: str, name: str, imports: list[Import], from_imports: list[FromImport]\n    ):\n        self.id: str = id_\n        self.name: str = name\n        self.imports: list[Import] = imports\n        self.from_imports: list[FromImport] = from_imports\n        self.classes: list[str] = []\n        self.functions: list[str] = []\n\n    def add_class(self, class_id: str) -> None:\n        self.classes.append(class_id)\n\n    def add_function(self, function_id: str) -> None:\n        self.functions.append(function_id)\n\n    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"imports\": [import_.to_json() for import_ in self.imports],\n            \"from_imports\": [\n                from_import.to_json() for from_import in self.from_imports\n            ],\n            \"classes\": self.classes,\n            \"functions\": self.functions,\n        }",
      "instance_attributes": [
        {
          "name": "id",
          "types": null
        },
        {
          "name": "name",
          "types": null
        },
        {
          "name": "imports",
          "types": null
        },
        {
          "name": "from_imports",
          "types": null
        },
        {
          "name": "classes",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "functions",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Result",
      "name": "Result",
      "qname": "package_parser.processing.api.model._api.Result",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._api/Result/from_json",
        "packager-parser/package_parser.processing.api.model._api/Result/to_json",
        "packager-parser/package_parser.processing.api.model._api/Result/__repr__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Result:\n    name: str\n    docstring: ResultDocstring\n    function_id: Optional[str] = None\n\n    @staticmethod\n    def from_json(json: Any, function_id: Optional[str] = None) -> Result:\n        return Result(\n            json[\"name\"],\n            ResultDocstring.from_json(json.get(\"docstring\", {})),\n            function_id,\n        )\n\n    def to_json(self) -> Any:\n        return {\"name\": self.name, \"docstring\": self.docstring.to_json()}\n\n    def __repr__(self) -> str:\n        return (\n            \"Result(function_id=\" + str(self.function_id) + \", name=\" + self.name + \")\"\n        )",
      "instance_attributes": [
        {
          "name": "name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "docstring",
          "types": {
            "kind": "NamedType",
            "name": "ResultDocstring"
          }
        },
        {
          "name": "function_id",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/ResultDocstring",
      "name": "ResultDocstring",
      "qname": "package_parser.processing.api.model._api.ResultDocstring",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._api/ResultDocstring/from_json",
        "packager-parser/package_parser.processing.api.model._api/ResultDocstring/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ResultDocstring:\n    type: str\n    description: str\n\n    @staticmethod\n    def from_json(json: Any) -> ResultDocstring:\n        return ResultDocstring(\n            json.get(\"type\", \"\"),\n            json.get(\"description\", \"\"),\n        )\n\n    def to_json(self) -> Any:\n        return {\"type\": self.type, \"description\": self.description}",
      "instance_attributes": [
        {
          "name": "type",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "description",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/ClassDocumentation",
      "name": "ClassDocumentation",
      "qname": "package_parser.processing.api.model._documentation.ClassDocumentation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._documentation/ClassDocumentation/from_dict",
        "packager-parser/package_parser.processing.api.model._documentation/ClassDocumentation/to_dict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ClassDocumentation:\n    description: str = \"\"\n    full_docstring: str = \"\"\n\n    @staticmethod\n    def from_dict(d: dict) -> ClassDocumentation:\n        return ClassDocumentation(**d)\n\n    def to_dict(self) -> dict:\n        return dataclasses.asdict(self)",
      "instance_attributes": [
        {
          "name": "description",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "full_docstring",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation",
      "name": "FunctionDocumentation",
      "qname": "package_parser.processing.api.model._documentation.FunctionDocumentation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation/from_dict",
        "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation/to_dict",
        "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation/__hash__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FunctionDocumentation:\n    description: str = \"\"\n    full_docstring: str = \"\"\n\n    @staticmethod\n    def from_dict(d: dict) -> FunctionDocumentation:\n        return FunctionDocumentation(**d)\n\n    def to_dict(self) -> dict:\n        return dataclasses.asdict(self)\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.description,\n                self.full_docstring,\n            )\n        )",
      "instance_attributes": [
        {
          "name": "description",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "full_docstring",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation",
      "name": "ParameterDocumentation",
      "qname": "package_parser.processing.api.model._documentation.ParameterDocumentation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation/from_dict",
        "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation/to_dict",
        "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation/__hash__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterDocumentation:\n    type: str = \"\"\n    default_value: str = \"\"\n    description: str = \"\"\n\n    @staticmethod\n    def from_dict(d: dict) -> ParameterDocumentation:\n        return ParameterDocumentation(**d)\n\n    def to_dict(self) -> dict:\n        return dataclasses.asdict(self)\n\n    def __hash__(self) -> int:\n        return hash((self.type, self.default_value, self.description))",
      "instance_attributes": [
        {
          "name": "type",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "default_value",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "description",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter",
      "name": "Parameter",
      "qname": "package_parser.processing.api.model._parameters.Parameter",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._parameters/Parameter/from_json",
        "packager-parser/package_parser.processing.api.model._parameters/Parameter/__hash__",
        "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__",
        "packager-parser/package_parser.processing.api.model._parameters/Parameter/is_optional",
        "packager-parser/package_parser.processing.api.model._parameters/Parameter/is_required",
        "packager-parser/package_parser.processing.api.model._parameters/Parameter/to_json",
        "packager-parser/package_parser.processing.api.model._parameters/Parameter/__repr__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Parameter:\n    @staticmethod\n    def from_json(json: Any) -> Parameter:\n        return Parameter(\n            json[\"id\"],\n            json[\"name\"],\n            json[\"qname\"],\n            json.get(\"default_value\", None),\n            ParameterAssignment[json.get(\"assigned_by\", \"POSITION_OR_NAME\")],\n            json.get(\"is_public\", True),\n            ParameterDocumentation.from_dict(json.get(\"docstring\", {})),\n        )\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.id,\n                self.name,\n                self.qname,\n                self.default_value,\n                self.assigned_by,\n                self.is_public,\n                self.documentation,\n            )\n        )\n\n    def __init__(\n        self,\n        id_: str,\n        name: str,\n        qname: str,\n        default_value: Optional[str],\n        assigned_by: ParameterAssignment,\n        is_public: bool,\n        documentation: ParameterDocumentation,\n    ) -> None:\n        self.id: str = id_\n        self.name: str = name\n        self.qname: str = qname\n        self.default_value: Optional[str] = default_value\n        self.assigned_by: ParameterAssignment = assigned_by\n        self.is_public: bool = is_public\n        self.documentation = documentation\n        self.type: Optional[AbstractType] = create_type(documentation)\n\n    def is_optional(self) -> bool:\n        return self.default_value is not None\n\n    def is_required(self) -> bool:\n        return self.default_value is None\n\n    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"default_value\": self.default_value,\n            \"assigned_by\": self.assigned_by.name,\n            \"is_public\": self.is_public,\n            \"docstring\": self.documentation.to_dict(),\n            \"type\": self.type.to_json() if self.type is not None else {},\n        }\n\n    def __repr__(self) -> str:\n        return \"Parameter(id=\" + self.id + \")\"",
      "instance_attributes": [
        {
          "name": "id",
          "types": null
        },
        {
          "name": "name",
          "types": null
        },
        {
          "name": "qname",
          "types": null
        },
        {
          "name": "default_value",
          "types": null
        },
        {
          "name": "assigned_by",
          "types": null
        },
        {
          "name": "is_public",
          "types": null
        },
        {
          "name": "documentation",
          "types": {
            "kind": "NamedType",
            "name": "ParameterDocumentation"
          }
        },
        {
          "name": "type",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters/ParameterAssignment",
      "name": "ParameterAssignment",
      "qname": "package_parser.processing.api.model._parameters.ParameterAssignment",
      "decorators": [],
      "superclasses": [
        "Enum"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "How arguments are assigned to parameters. The parameters must appear exactly in this order in a parameter list.\n\nIMPLICIT parameters appear on instance methods (usually called \"self\") and on class methods (usually called \"cls\").\nPOSITION_ONLY parameters precede the \"/\" in a parameter list. NAME_ONLY parameters follow the \"*\" or the\nPOSITIONAL_VARARGS parameter (\"*args\"). Between the \"/\" and the \"*\" the POSITION_OR_NAME parameters reside. Finally,\nthe parameter list might optionally include a NAMED_VARARG parameter (\"**kwargs\").",
      "docstring": "How arguments are assigned to parameters. The parameters must appear exactly in this order in a parameter list.\n\nIMPLICIT parameters appear on instance methods (usually called \"self\") and on class methods (usually called \"cls\").\nPOSITION_ONLY parameters precede the \"/\" in a parameter list. NAME_ONLY parameters follow the \"*\" or the\nPOSITIONAL_VARARGS parameter (\"*args\"). Between the \"/\" and the \"*\" the POSITION_OR_NAME parameters reside. Finally,\nthe parameter list might optionally include a NAMED_VARARG parameter (\"**kwargs\").",
      "code": "class ParameterAssignment(Enum):\n    \"\"\"\n    How arguments are assigned to parameters. The parameters must appear exactly in this order in a parameter list.\n\n    IMPLICIT parameters appear on instance methods (usually called \"self\") and on class methods (usually called \"cls\").\n    POSITION_ONLY parameters precede the \"/\" in a parameter list. NAME_ONLY parameters follow the \"*\" or the\n    POSITIONAL_VARARGS parameter (\"*args\"). Between the \"/\" and the \"*\" the POSITION_OR_NAME parameters reside. Finally,\n    the parameter list might optionally include a NAMED_VARARG parameter (\"**kwargs\").\n    \"\"\"\n\n    IMPLICIT = \"IMPLICIT\"\n    POSITION_ONLY = \"POSITION_ONLY\"\n    POSITION_OR_NAME = \"POSITION_OR_NAME\"\n    POSITIONAL_VARARG = (\"POSITIONAL_VARARG\",)\n    NAME_ONLY = \"NAME_ONLY\"\n    NAMED_VARARG = \"NAMED_VARARG\"",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/AbstractType",
      "name": "AbstractType",
      "qname": "package_parser.processing.api.model._types.AbstractType",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.api.model._types/AbstractType/to_json",
        "packager-parser/package_parser.processing.api.model._types/AbstractType/from_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AbstractType(metaclass=ABCMeta):\n    @abstractmethod\n    def to_json(self) -> dict[str, Any]:\n        pass\n\n    @classmethod\n    def from_json(cls, json: Any) -> Optional[AbstractType]:\n        if json is None:\n            return None\n        value: Optional[AbstractType] = NamedType.from_json(json)\n        if value is not None:\n            return value\n        value = EnumType.from_json(json)\n        if value is not None:\n            return value\n        value = BoundaryType.from_json(json)\n        if value is not None:\n            return value\n        return UnionType.from_json(json)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType",
      "name": "BoundaryType",
      "qname": "package_parser.processing.api.model._types.BoundaryType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractType"
      ],
      "methods": [
        "packager-parser/package_parser.processing.api.model._types/BoundaryType/_is_inclusive",
        "packager-parser/package_parser.processing.api.model._types/BoundaryType/from_json",
        "packager-parser/package_parser.processing.api.model._types/BoundaryType/from_string",
        "packager-parser/package_parser.processing.api.model._types/BoundaryType/__eq__",
        "packager-parser/package_parser.processing.api.model._types/BoundaryType/__hash__",
        "packager-parser/package_parser.processing.api.model._types/BoundaryType/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class BoundaryType(AbstractType):\n    NEGATIVE_INFINITY: ClassVar = \"NegativeInfinity\"\n    INFINITY: ClassVar = \"Infinity\"\n\n    base_type: str\n    min: Union[float, int, str]\n    max: Union[float, int, str]\n    min_inclusive: bool\n    max_inclusive: bool\n\n    full_match: str = \"\"\n\n    @classmethod\n    def _is_inclusive(cls, bracket: str) -> bool:\n        if bracket in (\"(\", \")\"):\n            return False\n        if bracket in (\"[\", \"]\"):\n            return True\n        raise Exception(f\"{bracket} is not one of []()\")\n\n    @classmethod\n    def from_json(cls, json: Any) -> Optional[BoundaryType]:\n        if json[\"kind\"] == cls.__name__:\n            return BoundaryType(\n                json[\"base_type\"],\n                json[\"min\"],\n                json[\"max\"],\n                json[\"min_inclusive\"],\n                json[\"max_inclusive\"],\n            )\n        return None\n\n    @classmethod\n    def from_string(cls, string: str) -> Optional[BoundaryType]:\n        # language=PythonRegExp\n        pattern = r\"\"\"(?P<base_type>float|int)?[ ]  # optional base type of either float or int\n                    (in|of)[ ](the[ ])?(range|interval)[ ](of[ ])?  # 'in' or 'of', optional 'the', 'range' or 'interval', optional 'of'\n                    `?(?P<min_bracket>[\\[(])(?P<min>[-+]?\\d+(.\\d*)?|negative_infinity),[ ]  # left side of the range\n                    (?P<max>[-+]?\\d+(.\\d*)?|infinity)(?P<max_bracket>[\\])])`?\"\"\"  # right side of the range\n        match = re.search(pattern, string, re.VERBOSE)\n\n        if match is not None:\n            base_type = match.group(\"base_type\")\n            if base_type is None:\n                base_type = \"float\"\n\n            min_value: Union[str, int, float] = match.group(\"min\")\n            if min_value != \"negative_infinity\":\n                if base_type == \"int\":\n                    min_value = int(min_value)\n                else:\n                    min_value = float(min_value)\n            else:\n                min_value = BoundaryType.NEGATIVE_INFINITY\n\n            max_value: Union[str, int, float] = match.group(\"max\")\n            if max_value != \"infinity\":\n                if base_type == \"int\":\n                    max_value = int(max_value)\n                else:\n                    max_value = float(max_value)\n            else:\n                max_value = BoundaryType.INFINITY\n\n            min_bracket = match.group(\"min_bracket\")\n            max_bracket = match.group(\"max_bracket\")\n            min_inclusive = BoundaryType._is_inclusive(min_bracket)\n            max_inclusive = BoundaryType._is_inclusive(max_bracket)\n\n            return BoundaryType(\n                base_type=base_type,\n                min=min_value,\n                max=max_value,\n                min_inclusive=min_inclusive,\n                max_inclusive=max_inclusive,\n                full_match=match.group(0),\n            )\n\n        return None\n\n    def __eq__(self, __o: object) -> bool:\n        if isinstance(__o, BoundaryType):\n            eq = (\n                self.base_type == __o.base_type\n                and self.min == __o.min\n                and self.min_inclusive == __o.min_inclusive\n                and self.max == __o.max\n            )\n            if eq:\n                if self.max == BoundaryType.INFINITY:\n                    return True\n                return self.max_inclusive == __o.max_inclusive\n        return False\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.base_type,\n                self.min,\n                self.min_inclusive,\n                self.max,\n                self.max_inclusive,\n                self.full_match,\n            )\n        )\n\n    def to_json(self) -> dict[str, Any]:\n        return {\n            \"kind\": self.__class__.__name__,\n            \"base_type\": self.base_type,\n            \"min\": self.min,\n            \"max\": self.max,\n            \"min_inclusive\": self.min_inclusive,\n            \"max_inclusive\": self.max_inclusive,\n        }",
      "instance_attributes": [
        {
          "name": "base_type",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "min",
          "types": null
        },
        {
          "name": "max",
          "types": null
        },
        {
          "name": "min_inclusive",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "max_inclusive",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "full_match",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/EnumType",
      "name": "EnumType",
      "qname": "package_parser.processing.api.model._types.EnumType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractType"
      ],
      "methods": [
        "packager-parser/package_parser.processing.api.model._types/EnumType/from_json",
        "packager-parser/package_parser.processing.api.model._types/EnumType/from_string",
        "packager-parser/package_parser.processing.api.model._types/EnumType/update",
        "packager-parser/package_parser.processing.api.model._types/EnumType/to_json",
        "packager-parser/package_parser.processing.api.model._types/EnumType/__hash__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class EnumType(AbstractType):\n    values: set[str] = field(default_factory=set)\n    full_match: str = \"\"\n\n    @classmethod\n    def from_json(cls, json: Any) -> Optional[EnumType]:\n        if json[\"kind\"] == cls.__name__:\n            return EnumType(json[\"values\"])\n        return None\n\n    @classmethod\n    def from_string(cls, string: str) -> Optional[EnumType]:\n        def remove_backslash(e: str) -> str:\n            e = e.replace(r\"\\\"\", '\"')\n            e = e.replace(r\"\\'\", \"'\")\n            return e\n\n        enum_match = re.search(r\"{(.*?)}\", string)\n        if enum_match:\n            quotes = \"'\\\"\"\n            values = set()\n            enum_str = enum_match.group(1)\n            value = \"\"\n            inside_value = False\n            curr_quote = None\n            for i, char in enumerate(enum_str):\n                if char in quotes and (i == 0 or (i > 0 and enum_str[i - 1] != \"\\\\\")):\n                    if not inside_value:\n                        inside_value = True\n                        curr_quote = char\n                    elif inside_value:\n                        if curr_quote == char:\n                            inside_value = False\n                            curr_quote = None\n                            values.add(remove_backslash(value))\n                            value = \"\"\n                        else:\n                            value += char\n                elif inside_value:\n                    value += char\n\n            return EnumType(values, enum_match.group(0))\n\n        return None\n\n    def update(self, enum: EnumType) -> None:\n        self.values.update(enum.values)\n\n    def to_json(self) -> dict[str, Any]:\n        return {\"kind\": self.__class__.__name__, \"values\": self.values}\n\n    def __hash__(self) -> int:\n        return hash((frozenset(self.values), self.full_match))",
      "instance_attributes": [
        {
          "name": "values",
          "types": {
            "kind": "NamedType",
            "name": "set"
          }
        },
        {
          "name": "full_match",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/NamedType",
      "name": "NamedType",
      "qname": "package_parser.processing.api.model._types.NamedType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractType"
      ],
      "methods": [
        "packager-parser/package_parser.processing.api.model._types/NamedType/from_json",
        "packager-parser/package_parser.processing.api.model._types/NamedType/from_string",
        "packager-parser/package_parser.processing.api.model._types/NamedType/to_json",
        "packager-parser/package_parser.processing.api.model._types/NamedType/__eq__",
        "packager-parser/package_parser.processing.api.model._types/NamedType/__hash__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NamedType(AbstractType):\n    name: str\n\n    @classmethod\n    def from_json(cls, json: Any) -> Optional[NamedType]:\n        if json.get(\"kind\", \"\") == cls.__name__:\n            return NamedType(json[\"name\"])\n        return None\n\n    @classmethod\n    def from_string(cls, string: str) -> NamedType:\n        return NamedType(string)\n\n    def to_json(self) -> dict[str, str]:\n        return {\"kind\": self.__class__.__name__, \"name\": self.name}\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, self.__class__):\n            return self.name == other.name\n        return False\n\n    def __hash__(self) -> int:\n        return hash(self.name)",
      "instance_attributes": [
        {
          "name": "name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/UnionType",
      "name": "UnionType",
      "qname": "package_parser.processing.api.model._types.UnionType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractType"
      ],
      "methods": [
        "packager-parser/package_parser.processing.api.model._types/UnionType/from_json",
        "packager-parser/package_parser.processing.api.model._types/UnionType/to_json",
        "packager-parser/package_parser.processing.api.model._types/UnionType/__hash__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class UnionType(AbstractType):\n    types: list[AbstractType]\n\n    @classmethod\n    def from_json(cls, json: Any) -> Optional[UnionType]:\n        if json[\"kind\"] == cls.__name__:\n            types = []\n            for element in json[\"types\"]:\n                type_ = AbstractType.from_json(element)\n                if type_ is not None:\n                    types.append(type_)\n            return UnionType(types)\n        return None\n\n    def to_json(self) -> dict[str, Any]:\n        type_list = []\n        for t in self.types:\n            type_list.append(t.to_json())\n\n        return {\"kind\": self.__class__.__name__, \"types\": type_list}\n\n    def __hash__(self) -> int:\n        return hash((frozenset(self.types)))",
      "instance_attributes": [
        {
          "name": "types",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor",
      "name": "DependencyExtractor",
      "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Functions to extract each type of pattern in _dependency_patterns",
      "docstring": "Functions to extract each type of pattern in _dependency_patterns",
      "code": "class DependencyExtractor:\n    \"\"\"\n    Functions to extract each type of pattern in _dependency_patterns\n    \"\"\"\n\n    @staticmethod\n    def extract_pattern_parameter_adverbial_clause(\n        dependent_param: Parameter,\n        func_parameters: List[Parameter],\n        match: Tuple,\n        param_docstring: Doc,\n    ) -> Union[Dependency, None]:\n        is_depending_on_param_index = match[1][2]\n        is_depending_on_param_name = param_docstring[is_depending_on_param_index].text\n        is_depending_on_param = next(\n            filter(\n                lambda param: param.name == is_depending_on_param_name, func_parameters\n            ),\n            None,\n        )\n        if is_depending_on_param is None:\n            # Likely not a correct dependency match\n            return None\n\n        condition_token = param_docstring[match[1][1]]\n        condition = extract_condition(condition_token)\n\n        action_token = param_docstring[match[1][0]]\n        action = extract_action(action_token, condition_token)\n\n        return Dependency(\n            hasDependentParameter=dependent_param,\n            isDependingOn=is_depending_on_param,\n            hasCondition=condition,\n            hasAction=action,\n        )",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/APIDependencies",
      "name": "APIDependencies",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.APIDependencies",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/APIDependencies/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class APIDependencies:\n    dependencies: Dict\n\n    def to_json(self) -> Dict:\n        return {\n            function_name: {\n                parameter_name: [dependency.to_json() for dependency in dependencies]\n                for parameter_name, dependencies in parameter_name.items()\n            }\n            for function_name, parameter_name in self.dependencies.items()\n        }",
      "instance_attributes": [
        {
          "name": "dependencies",
          "types": {
            "kind": "NamedType",
            "name": "Dict"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Action",
      "name": "Action",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.Action",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Action/from_json",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Action/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Action:\n    action: str\n\n    @classmethod\n    def from_json(cls, json: Any):\n        return cls(json[\"action\"])\n\n    def to_json(self) -> Dict:\n        return {\"action\": self.action}",
      "instance_attributes": [
        {
          "name": "action",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Condition",
      "name": "Condition",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.Condition",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Condition/from_json",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Condition/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Condition:\n    condition: str\n\n    @classmethod\n    def from_json(cls, json: Any):\n        return cls(json[\"condition\"])\n\n    def to_json(self) -> Dict:\n        return {\"condition\": self.condition}",
      "instance_attributes": [
        {
          "name": "condition",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Dependency",
      "name": "Dependency",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.Dependency",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Dependency/from_json",
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Dependency/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Dependency:\n    hasDependentParameter: Parameter\n    isDependingOn: Parameter\n    hasCondition: Condition\n    hasAction: Action\n\n    @classmethod\n    def from_json(cls, json: Any):\n        return cls(\n            Parameter.from_json(json[\"hasDependentParameter\"]),\n            Parameter.from_json(json[\"isDependingOn\"]),\n            Condition.from_json(json[\"hasCondition\"]),\n            Action.from_json(json[\"hasAction\"]),\n        )\n\n    def to_json(self) -> dict:\n        return {\n            \"hasDependentParameter\": self.hasDependentParameter.to_json(),\n            \"isDependingOn\": self.isDependingOn.to_json(),\n            \"hasCondition\": self.hasCondition.to_json(),\n            \"hasAction\": self.hasAction.to_json(),\n        }",
      "instance_attributes": [
        {
          "name": "hasDependentParameter",
          "types": {
            "kind": "NamedType",
            "name": "Parameter"
          }
        },
        {
          "name": "isDependingOn",
          "types": {
            "kind": "NamedType",
            "name": "Parameter"
          }
        },
        {
          "name": "hasCondition",
          "types": {
            "kind": "NamedType",
            "name": "Condition"
          }
        },
        {
          "name": "hasAction",
          "types": {
            "kind": "NamedType",
            "name": "Action"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterHasValue",
      "name": "ParameterHasValue",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterHasValue",
      "decorators": [],
      "superclasses": [
        "StaticCondition"
      ],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterHasValue/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterHasValue(StaticCondition):\n    def __init__(self, condition: str) -> None:\n        super().__init__(condition)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIgnored",
      "name": "ParameterIsIgnored",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsIgnored",
      "decorators": [],
      "superclasses": [
        "StaticAction"
      ],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIgnored/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterIsIgnored(StaticAction):\n    def __init__(self, action: str) -> None:\n        super().__init__(action)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIllegal",
      "name": "ParameterIsIllegal",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsIllegal",
      "decorators": [],
      "superclasses": [
        "StaticAction"
      ],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIllegal/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterIsIllegal(StaticAction):\n    def __init__(self, action: str) -> None:\n        super().__init__(action)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsNone",
      "name": "ParameterIsNone",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsNone",
      "decorators": [],
      "superclasses": [
        "StaticCondition"
      ],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsNone/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterIsNone(StaticCondition):\n    def __init__(self, condition: str) -> None:\n        super().__init__(condition)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeAction",
      "name": "RuntimeAction",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.RuntimeAction",
      "decorators": [],
      "superclasses": [
        "Action"
      ],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeAction/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RuntimeAction(Action):\n    def __init__(self, action: str) -> None:\n        super().__init__(action)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeCondition",
      "name": "RuntimeCondition",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.RuntimeCondition",
      "decorators": [],
      "superclasses": [
        "Condition"
      ],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeCondition/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RuntimeCondition(Condition):\n    def __init__(self, condition: str) -> None:\n        super().__init__(condition)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticAction",
      "name": "StaticAction",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.StaticAction",
      "decorators": [],
      "superclasses": [
        "Action"
      ],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticAction/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class StaticAction(Action):\n    def __init__(self, action: str) -> None:\n        super().__init__(action)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticCondition",
      "name": "StaticCondition",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.StaticCondition",
      "decorators": [],
      "superclasses": [
        "Condition"
      ],
      "methods": [
        "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticCondition/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class StaticCondition(Condition):\n    def __init__(self, condition: str) -> None:\n        super().__init__(condition)",
      "instance_attributes": []
    },
    {
      "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping",
      "name": "APIMapping",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__",
        "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements",
        "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/map_api",
        "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_similar_mappings",
        "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class APIMapping:\n    threshold_of_similarity_between_mappings: float\n    threshold_of_similarity_for_creation_of_mappings: float\n    threshold_of_merging_mappings: float\n    apiv1: API\n    apiv2: API\n    differ: AbstractDiffer\n\n    def __init__(\n        self,\n        apiv1: API,\n        apiv2: API,\n        differ: AbstractDiffer,\n        threshold_of_similarity_for_creation_of_mappings: float = 0.5,\n        threshold_of_similarity_between_mappings: float = 0.05,\n        threshold_of_merging_mappings: float = 0.3,\n    ) -> None:\n        self.apiv1 = apiv1\n        self.apiv2 = apiv2\n        self.differ = differ\n        self.threshold_of_similarity_for_creation_of_mappings = (\n            threshold_of_similarity_for_creation_of_mappings\n        )\n        self.threshold_of_similarity_between_mappings = (\n            threshold_of_similarity_between_mappings\n        )\n        self.threshold_of_merging_mappings = threshold_of_merging_mappings\n\n    def _get_mappings_for_api_elements(\n        self,\n        api_elementv1_list: List[API_ELEMENTS],\n        api_elementv2_list: List[API_ELEMENTS],\n        compute_similarity: Callable[[API_ELEMENTS, API_ELEMENTS], float],\n    ) -> list[Mapping]:\n        element_mappings: list[Mapping] = []\n        for api_elementv1 in api_elementv1_list:\n            mapping_for_api_elementv1: list[Mapping] = []\n            for api_elementv2 in api_elementv2_list:\n                similarity = compute_similarity(api_elementv1, api_elementv2)\n                if similarity >= self.threshold_of_similarity_for_creation_of_mappings:\n                    mapping_for_api_elementv1.append(\n                        OneToOneMapping(similarity, api_elementv1, api_elementv2)\n                    )\n            mapping_for_api_elementv1.sort(key=Mapping.get_similarity, reverse=True)\n            new_mapping = self._merge_similar_mappings(mapping_for_api_elementv1)\n            if new_mapping is not None:\n                self._merge_mappings_with_same_elements(new_mapping, element_mappings)\n        return element_mappings\n\n    def map_api(self) -> List[Mapping]:\n        mappings: List[Mapping] = []\n        related_mappings = self.differ.get_related_mappings()\n        if related_mappings is not None:\n            for mapping in related_mappings:\n                new_mapping = None\n                if isinstance(\n                    mapping.get_apiv1_elements()[0], Attribute\n                ) and isinstance(mapping.get_apiv2_elements()[0], Attribute):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        self.differ.compute_attribute_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Class) and isinstance(\n                    mapping.get_apiv2_elements()[0], Class\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Class)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Class)\n                        ],\n                        self.differ.compute_class_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Function\n                ) and isinstance(mapping.get_apiv2_elements()[0], Function):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Function)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Function)\n                        ],\n                        self.differ.compute_function_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Parameter\n                ) and isinstance(mapping.get_apiv2_elements()[0], Parameter):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        self.differ.compute_parameter_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Result) and isinstance(\n                    mapping.get_apiv2_elements()[0], Result\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Result)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Result)\n                        ],\n                        self.differ.compute_result_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                if new_mapping is not None and len(new_mapping) > 0:\n                    self.differ.notify_new_mapping(new_mapping)\n        else:\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.classes.values()),\n                    list(self.apiv2.classes.values()),\n                    self.differ.compute_class_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.functions.values()),\n                    list(self.apiv2.functions.values()),\n                    self.differ.compute_function_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.parameters().values()),\n                    list(self.apiv2.parameters().values()),\n                    self.differ.compute_parameter_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        attribute\n                        for class_ in self.apiv1.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    [\n                        attribute\n                        for class_ in self.apiv2.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    self.differ.compute_attribute_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        result\n                        for function in self.apiv1.functions.values()\n                        for result in function.results\n                    ],\n                    [\n                        result\n                        for function in self.apiv2.functions.values()\n                        for result in function.results\n                    ],\n                    self.differ.compute_result_similarity,\n                )\n            )\n        mappings.extend(self.differ.get_additional_mappings())\n        mappings.sort(key=Mapping.get_similarity, reverse=True)\n        return mappings\n\n    def _merge_similar_mappings(self, mappings: List[Mapping]) -> Optional[Mapping]:\n        \"\"\"\n        Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\n        from this apiv1 element to apiv2 elements by merging the first and second elements recursively,\n        if the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n        :param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n        :return: the first element of the sorted list that could be a result of merged similar mappings\n        \"\"\"\n        if len(mappings) == 0:\n            return None\n        if len(mappings) == 1:\n            return mappings[0]\n        while (len(mappings) > 1) and (\n            (mappings[0].similarity - mappings[1].similarity)\n            < self.threshold_of_similarity_between_mappings\n        ):\n            mappings[0] = merge_mappings(mappings[0], mappings[1])\n            mappings.pop(1)\n        return mappings[0]\n\n    def _merge_mappings_with_same_elements(\n        self, mapping_to_be_appended: Mapping, mappings: list[Mapping]\n    ) -> None:\n        \"\"\"\n        This method prevents that an element in a mapping appears multiple times in a list of mappings\n        by merging the affected mappings and include the result in the list. If there is no such element,\n        the mapping will be included without any merge.\n\n        :param mapping_to_be_appended: the mapping that should be included in mappings\n        :param mappings: the list, in which mapping_to_be_appended should be appended\n        \"\"\"\n        duplicated: list[Mapping] = []\n        for mapping in mappings:\n            duplicated_element = False\n            for element in mapping.get_apiv2_elements():\n                for element_2 in mapping_to_be_appended.get_apiv2_elements():\n                    if element == element_2:\n                        duplicated_element = True\n                        break\n            if duplicated_element:\n                duplicated.append(mapping)\n\n        if len(duplicated) == 0:\n            mappings.append(mapping_to_be_appended)\n            return\n\n        for conflicted_mapping in duplicated:\n            mapping_to_be_appended = merge_mappings(\n                mapping_to_be_appended, conflicted_mapping\n            )\n            mappings.remove(conflicted_mapping)\n\n        mappings.append(mapping_to_be_appended)",
      "instance_attributes": [
        {
          "name": "apiv1",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "apiv2",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "differ",
          "types": {
            "kind": "NamedType",
            "name": "AbstractDiffer"
          }
        },
        {
          "name": "threshold_of_similarity_for_creation_of_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "threshold_of_similarity_between_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "threshold_of_merging_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration",
      "name": "Migration",
      "qname": "package_parser.processing.migration._migrate.Migration",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.migration._migrate/Migration/__post_init__",
        "packager-parser/package_parser.processing.migration._migrate/Migration/_get_mapping_from_annotation",
        "packager-parser/package_parser.processing.migration._migrate/Migration/migrate_annotations",
        "packager-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity",
        "packager-parser/package_parser.processing.migration._migrate/Migration/_get_mappings_for_table",
        "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table",
        "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string",
        "packager-parser/package_parser.processing.migration._migrate/Migration/print",
        "packager-parser/package_parser.processing.migration._migrate/Migration/_handle_duplicates"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Migration:\n    annotationsv1: AnnotationStore\n    mappings: list[Mapping]\n    reliable_similarity: float = 0.9\n    unsure_similarity: float = 0.8\n    migrated_annotation_store: AnnotationStore = field(init=False)\n    unsure_migrated_annotation_store: AnnotationStore = field(init=False)\n\n    def __post_init__(self) -> None:\n        self.migrated_annotation_store = AnnotationStore()\n        self.unsure_migrated_annotation_store = AnnotationStore()\n\n    def _get_mapping_from_annotation(\n        self, annotation: AbstractAnnotation\n    ) -> Optional[Mapping]:\n        for mapping in self.mappings:\n            for element in mapping.get_apiv1_elements():\n                if (\n                    not isinstance(element, (Attribute, Result))\n                    and element.id == annotation.target\n                ):\n                    return mapping\n        return None\n\n    def migrate_annotations(self) -> None:\n        for boundary_annotation in self.annotationsv1.boundaryAnnotations:\n            mapping = self._get_mapping_from_annotation(boundary_annotation)\n            if mapping is not None:\n                for annotation in migrate_boundary_annotation(\n                    boundary_annotation, mapping\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for called_after_annotation in self.annotationsv1.calledAfterAnnotations:\n            mapping = self._get_mapping_from_annotation(called_after_annotation)\n            if mapping is not None:\n                for annotation in migrate_called_after_annotation(\n                    called_after_annotation, mapping, self.mappings\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for description_annotation in self.annotationsv1.descriptionAnnotations:\n            mapping = self._get_mapping_from_annotation(description_annotation)\n            if mapping is not None:\n                for annotation in migrate_description_annotation(\n                    description_annotation, mapping\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for enum_annotation in self.annotationsv1.enumAnnotations:\n            mapping = self._get_mapping_from_annotation(enum_annotation)\n            if mapping is not None:\n                for annotation in migrate_enum_annotation(enum_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for expert_annotation in self.annotationsv1.expertAnnotations:\n            mapping = self._get_mapping_from_annotation(expert_annotation)\n            if mapping is not None:\n                for annotation in migrate_expert_annotation(expert_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for group_annotation in self.annotationsv1.groupAnnotations:\n            mapping = self._get_mapping_from_annotation(group_annotation)\n            if mapping is not None:\n                for annotation in migrate_group_annotation(\n                    group_annotation, mapping, self.mappings\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for move_annotation in self.annotationsv1.moveAnnotations:\n            mapping = self._get_mapping_from_annotation(move_annotation)\n            if mapping is not None:\n                for annotation in migrate_move_annotation(move_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for rename_annotation in self.annotationsv1.renameAnnotations:\n            mapping = self._get_mapping_from_annotation(rename_annotation)\n            if mapping is not None:\n                for annotation in migrate_rename_annotation(rename_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for remove_annotation in self.annotationsv1.removeAnnotations:\n            mapping = self._get_mapping_from_annotation(remove_annotation)\n            if mapping is not None:\n                for annotation in migrate_remove_annotation(remove_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for todo_annotation in self.annotationsv1.todoAnnotations:\n            mapping = self._get_mapping_from_annotation(todo_annotation)\n            if mapping is not None:\n                for annotation in migrate_todo_annotation(todo_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for value_annotation in self.annotationsv1.valueAnnotations:\n            mapping = self._get_mapping_from_annotation(value_annotation)\n            if mapping is not None:\n                for annotation in migrate_value_annotation(value_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n        self._handle_duplicates()\n\n    def add_annotations_based_on_similarity(\n        self, annotation: AbstractAnnotation, similarity: float\n    ) -> None:\n        if similarity >= self.reliable_similarity:\n            self.migrated_annotation_store.add_annotation(annotation)\n        elif similarity >= self.unsure_similarity:\n            annotation.reviewResult = EnumReviewResult.UNSURE\n            self.migrated_annotation_store.add_annotation(annotation)\n        else:\n            self.unsure_migrated_annotation_store.add_annotation(annotation)\n\n    def _get_mappings_for_table(self) -> list[str]:\n        table_rows: list[str] = []\n        for mapping in self.mappings:\n\n            def print_api_element(\n                api_element: Union[Attribute, Class, Function, Parameter, Result]\n            ) -> str:\n                if isinstance(api_element, Result):\n                    return api_element.name\n                if isinstance(api_element, Attribute):\n                    return str(api_element.class_id) + \"/\" + api_element.name\n                return api_element.id\n\n            apiv1_elements = \", \".join(\n                [\n                    print_api_element(api_element)\n                    for api_element in mapping.get_apiv1_elements()\n                ]\n            )\n            apiv2_elements = \", \".join(\n                [\n                    print_api_element(api_element)\n                    for api_element in mapping.get_apiv2_elements()\n                ]\n            )\n            apiv1_elements = \"`\" + apiv1_elements + \"`\"\n            apiv2_elements = \"`\" + apiv2_elements + \"`\"\n            table_rows.append(\n                f\"{mapping.similarity:.4}|{apiv1_elements}|{apiv2_elements}|\"\n            )\n        return table_rows\n\n    def _get_not_mapped_api_elements_for_table(\n        self, apiv1: API, apiv2: API\n    ) -> list[str]:\n        not_mapped_api_elements: list[str] = []\n        not_mapped_apiv1_elements = self._get_not_mapped_api_elements_as_string(apiv1)\n        for element_id in not_mapped_apiv1_elements:\n            not_mapped_api_elements.append(f\"-|`{element_id}`||\")\n        not_mapped_apiv2_elements = self._get_not_mapped_api_elements_as_string(\n            apiv2, print_for_apiv2=True\n        )\n        for element_id in not_mapped_apiv2_elements:\n            not_mapped_api_elements.append(f\"-||`{element_id}`|\")\n        return not_mapped_api_elements\n\n    def _get_not_mapped_api_elements_as_string(\n        self, api: API, print_for_apiv2: bool = False\n    ) -> list[str]:\n        not_mapped_api_elements: list[str] = []\n\n        def is_included(\n            api_element: Union[Attribute, Class, Function, Parameter, Result]\n        ) -> bool:\n            if not print_for_apiv2:\n                for mapping in self.mappings:\n                    for element in mapping.get_apiv1_elements():\n                        if isinstance(api_element, Attribute) and isinstance(\n                            element, Attribute\n                        ):\n                            if element.name == api_element.name and isinstance(\n                                element.types, type(api_element.types)\n                            ):\n                                return True\n                        if isinstance(api_element, Result) and isinstance(\n                            element, Result\n                        ):\n                            if (\n                                element.name == api_element.name\n                                and element.docstring == api_element.docstring\n                            ):\n                                return True\n                        if not isinstance(\n                            api_element, (Attribute, Result)\n                        ) and not isinstance(element, (Attribute, Result)):\n                            if element.id == api_element.id:\n                                return True\n                return False\n            for mapping in self.mappings:\n                for element in mapping.get_apiv2_elements():\n                    if isinstance(api_element, Attribute) and isinstance(\n                        element, Attribute\n                    ):\n                        if element.name == api_element.name and isinstance(\n                            element.types, type(api_element.types)\n                        ):\n                            return True\n                    if isinstance(api_element, Result) and isinstance(element, Result):\n                        if (\n                            element.name == api_element.name\n                            and element.docstring == api_element.docstring\n                        ):\n                            return True\n                    if not isinstance(\n                        api_element, (Attribute, Result)\n                    ) and not isinstance(element, (Attribute, Result)):\n                        if element.id == api_element.id:\n                            return True\n            return False\n\n        for class_ in api.classes.values():\n            if not is_included(class_):\n                not_mapped_api_elements.append(class_.id)\n        for function in api.functions.values():\n            if not is_included(function):\n                not_mapped_api_elements.append(function.id)\n        for parameter in api.parameters().values():\n            if not is_included(parameter):\n                not_mapped_api_elements.append(parameter.id)\n        for attribute, class_ in [\n            (attribute, class_)\n            for class_ in api.classes.values()\n            for attribute in class_.instance_attributes\n        ]:\n            if not is_included(attribute):\n                not_mapped_api_elements.append(class_.id + \"/\" + attribute.name)\n        for result, function in [\n            (result, function)\n            for function in api.functions.values()\n            for result in function.results\n        ]:\n            if not is_included(result):\n                not_mapped_api_elements.append(function.id + \"/\" + result.name)\n        return not_mapped_api_elements\n\n    def print(self, apiv1: API, apiv2: API) -> None:\n        print(\n            \"**Similarity**|**APIV1**|**APIV2**|**comment**\\n:-----:|:-----:|:-----:|:----:|\"\n        )\n        table_body = self._get_mappings_for_table()\n        table_body.extend(self._get_not_mapped_api_elements_for_table(apiv1, apiv2))\n        table_body.sort(\n            key=lambda row: max(len(cell.split(\"/\")) for cell in row.split(\"|\")[:-1])\n        )\n        print(\"\\n\".join(table_body))\n\n    def _handle_duplicates(self) -> None:\n        for annotation_type in [\n            \"boundaryAnnotations\",\n            \"calledAfterAnnotations\",\n            \"descriptionAnnotations\",\n            \"enumAnnotations\",\n            \"expertAnnotations\",\n            \"groupAnnotations\",\n            \"moveAnnotations\",\n            \"pureAnnotations\",\n            \"removeAnnotations\",\n            \"renameAnnotations\",\n            \"todoAnnotations\",\n            \"valueAnnotations\",\n        ]:\n            migrated_annotations = [\n                annotation\n                for annotation_store in [\n                    self.migrated_annotation_store,\n                    self.unsure_migrated_annotation_store,\n                ]\n                for annotation in getattr(annotation_store, annotation_type)\n            ]\n            duplicates_dict: dict[str, list[AbstractAnnotation]] = {}\n            for duplicated_annotations in migrated_annotations:\n                if duplicated_annotations.target in duplicates_dict:\n                    duplicates_dict[duplicated_annotations.target].append(\n                        duplicated_annotations\n                    )\n                    continue\n                for annotation in migrated_annotations:\n                    if (\n                        duplicated_annotations is annotation\n                        or annotation.target in duplicates_dict\n                    ):\n                        continue\n                    if (\n                        isinstance(annotation, type(duplicated_annotations))\n                        and annotation.target == duplicated_annotations.target\n                    ):\n                        duplicates = duplicates_dict.get(annotation.target, [])\n                        duplicates.append(annotation)\n                        duplicates.append(duplicated_annotations)\n                        duplicates_dict[duplicated_annotations.target] = duplicates\n                        break\n\n            for duplicates in duplicates_dict.values():\n                if len(duplicates) > 1:\n                    duplicates = sorted(\n                        duplicates, key=lambda annotation: annotation.reviewResult.name\n                    )\n                    different_values = set()\n                    first_annotation_and_value: Optional[\n                        tuple[AbstractAnnotation, str]\n                    ] = None\n                    for annotation in duplicates:\n                        annotation_dict = annotation.to_json()\n                        for key in [\n                            \"target\",\n                            \"authors\",\n                            \"reviewers\",\n                            \"comment\",\n                            \"reviewResult\",\n                        ]:\n                            del annotation_dict[key]\n                        annotation_value = str(annotation_dict)\n                        if first_annotation_and_value is None:\n                            first_annotation_and_value = annotation, annotation_value\n                        different_values.add(annotation_value)\n\n                    if first_annotation_and_value is not None:\n                        first_annotation, first_value = first_annotation_and_value\n                        if len(different_values) > 1:\n                            different_values.remove(first_value)\n                            comment = (\n                                \"Conflicting Attribute during migration: \"\n                                + \", \".join(sorted(different_values))\n                            )\n                            first_annotation.comment = (\n                                \"\\n\".join([comment, first_annotation.comment])\n                                if len(first_annotation.comment) > 0\n                                else comment\n                            )\n                            first_annotation.reviewResult = EnumReviewResult.UNSURE\n                        for annotation_store in [\n                            self.migrated_annotation_store,\n                            self.unsure_migrated_annotation_store,\n                        ]:\n                            for annotation in duplicates:\n                                if annotation is first_annotation:\n                                    continue\n                                annotations: list[AbstractAnnotation] = getattr(\n                                    annotation_store, annotation_type\n                                )\n                                if annotation in annotations:\n                                    annotations.remove(annotation)",
      "instance_attributes": [
        {
          "name": "migrated_annotation_store",
          "types": {
            "kind": "NamedType",
            "name": "AnnotationStore"
          }
        },
        {
          "name": "unsure_migrated_annotation_store",
          "types": {
            "kind": "NamedType",
            "name": "AnnotationStore"
          }
        },
        {
          "name": "annotationsv1",
          "types": {
            "kind": "NamedType",
            "name": "AnnotationStore"
          }
        },
        {
          "name": "mappings",
          "types": null
        },
        {
          "name": "reliable_similarity",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "unsure_similarity",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping",
      "name": "APIMapping",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__",
        "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements",
        "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/map_api",
        "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_similar_mappings",
        "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class APIMapping:\n    threshold_of_similarity_between_mappings: float\n    threshold_of_similarity_for_creation_of_mappings: float\n    apiv1: API\n    apiv2: API\n    differ: AbstractDiffer\n\n    def __init__(\n        self,\n        apiv1: API,\n        apiv2: API,\n        differ: AbstractDiffer,\n        threshold_of_similarity_for_creation_of_mappings: float = 0.5,\n        threshold_of_similarity_between_mappings: float = 0.05,\n    ) -> None:\n        self.apiv1 = apiv1\n        self.apiv2 = apiv2\n        self.differ = differ\n        self.threshold_of_similarity_for_creation_of_mappings = (\n            threshold_of_similarity_for_creation_of_mappings\n        )\n        self.threshold_of_similarity_between_mappings = (\n            threshold_of_similarity_between_mappings\n        )\n\n    def _get_mappings_for_api_elements(\n        self,\n        api_elementv1_list: List[API_ELEMENTS],\n        api_elementv2_list: List[API_ELEMENTS],\n        compute_similarity: Callable[[API_ELEMENTS, API_ELEMENTS], float],\n    ) -> list[Mapping]:\n        element_mappings: list[Mapping] = []\n        for api_elementv1 in api_elementv1_list:\n            mapping_for_class_1: list[Mapping] = []\n            for api_elementv2 in api_elementv2_list:\n                similarity = compute_similarity(api_elementv1, api_elementv2)\n                if similarity >= self.threshold_of_similarity_for_creation_of_mappings:\n                    mapping_for_class_1.append(\n                        OneToOneMapping(similarity, api_elementv1, api_elementv2)\n                    )\n            mapping_for_class_1.sort(key=Mapping.get_similarity, reverse=True)\n            new_mapping = self._merge_similar_mappings(mapping_for_class_1)\n            if new_mapping is not None:\n                self._merge_mappings_with_same_elements(new_mapping, element_mappings)\n        return element_mappings\n\n    def map_api(self) -> List[Mapping]:\n        mappings: List[Mapping] = []\n        previous_mappings = self.differ.get_related_mappings()\n        if previous_mappings is not None:\n            for mapping in previous_mappings:\n                new_mapping = None\n                if isinstance(\n                    mapping.get_apiv1_elements()[0], Attribute\n                ) and isinstance(mapping.get_apiv2_elements()[0], Attribute):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        self.differ.compute_attribute_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Class) and isinstance(\n                    mapping.get_apiv2_elements()[0], Class\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Class)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Class)\n                        ],\n                        self.differ.compute_class_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Function\n                ) and isinstance(mapping.get_apiv2_elements()[0], Function):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Function)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Function)\n                        ],\n                        self.differ.compute_function_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Parameter\n                ) and isinstance(mapping.get_apiv2_elements()[0], Parameter):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        self.differ.compute_parameter_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Result) and isinstance(\n                    mapping.get_apiv2_elements()[0], Result\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Result)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Result)\n                        ],\n                        self.differ.compute_result_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                if new_mapping is not None:\n                    self.differ.notify_new_mapping(new_mapping)\n        else:\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.classes.values()),\n                    list(self.apiv2.classes.values()),\n                    self.differ.compute_class_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.functions.values()),\n                    list(self.apiv2.functions.values()),\n                    self.differ.compute_function_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.parameters().values()),\n                    list(self.apiv2.parameters().values()),\n                    self.differ.compute_parameter_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        attribute\n                        for class_ in self.apiv1.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    [\n                        attribute\n                        for class_ in self.apiv2.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    self.differ.compute_attribute_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        result\n                        for function in self.apiv1.functions.values()\n                        for result in function.results\n                    ],\n                    [\n                        result\n                        for function in self.apiv2.functions.values()\n                        for result in function.results\n                    ],\n                    self.differ.compute_result_similarity,\n                )\n            )\n\n        mappings.sort(key=Mapping.get_similarity, reverse=True)\n        return mappings\n\n    def _merge_similar_mappings(self, mappings: List[Mapping]) -> Optional[Mapping]:\n        \"\"\"\n        Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\n        from this apiv1 element to apiv2 elements by merging the first and second elements recursively,\n        if the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n        :param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n        :return: the first element of the sorted list that could be a result of merged similar mappings\n        \"\"\"\n        if len(mappings) == 0:\n            return None\n        if len(mappings) == 1:\n            return mappings[0]\n        if (\n            mappings[0].similarity - mappings[1].similarity\n            < self.threshold_of_similarity_between_mappings\n        ):\n            mappings[0] = merge_mappings(mappings[0], mappings[1])\n            mappings.pop(1)\n            return self._merge_similar_mappings(mappings)\n        return mappings[0]\n\n    def _merge_mappings_with_same_elements(\n        self, mapping_to_be_appended: Mapping, mappings: list[Mapping]\n    ) -> None:\n        \"\"\"\n        This method prevents that an element in a mapping appears multiple times in a list of mappings\n        by merging the affected mappings and include the result in the list. If there is no such element,\n        the mapping will be included without any merge.\n\n        :param mapping_to_be_appended: the mapping that should be included in mappings\n        :param mappings: the list, in which mapping_to_be_appended should be appended\n        \"\"\"\n        duplicated: list[Mapping] = []\n        for mapping in mappings:\n            duplicated_element = False\n            for element in mapping.get_apiv2_elements():\n                for element_2 in mapping_to_be_appended.get_apiv2_elements():\n                    if element == element_2:\n                        duplicated_element = True\n                        break\n            if duplicated_element:\n                duplicated.append(mapping)\n\n        if len(duplicated) == 0:\n            mappings.append(mapping_to_be_appended)\n            return\n\n        for conflicted_mapping in duplicated:\n            mapping_to_be_appended = merge_mappings(\n                mapping_to_be_appended, conflicted_mapping\n            )\n            mappings.remove(conflicted_mapping)\n\n        mappings.append(mapping_to_be_appended)",
      "instance_attributes": [
        {
          "name": "apiv1",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "apiv2",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "differ",
          "types": {
            "kind": "NamedType",
            "name": "AbstractDiffer"
          }
        },
        {
          "name": "threshold_of_similarity_for_creation_of_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "threshold_of_similarity_between_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer",
      "name": "AbstractDiffer",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_related_mappings",
        "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/notify_new_mapping",
        "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_additional_mappings"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AbstractDiffer(ABC):\n    previous_base_differ: Optional[AbstractDiffer]\n    previous_mappings: list[Mapping]\n    apiv1: API\n    apiv2: API\n\n    @abstractmethod\n    def compute_attribute_similarity(\n        self,\n        attributev1: Attribute,\n        attributev2: Attribute,\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2.\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2.\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        \"\"\"\n        Indicates whether all api elements should be compared with each other\n        or just the ones that are mapped to each other.\n        :return: a list of Mappings if only previously mapped api elements should be mapped to each other or else None.\n        \"\"\"\n\n    @abstractmethod\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        \"\"\"\n        If previous mappings returns None, the differ will be notified about a new mapping.\n        Thereby the differ can calculate the similarity with more information.\n        :param mappings: a list of mappings new appended mappings.\n        \"\"\"\n\n    @abstractmethod\n    def get_additional_mappings(self) -> list[Mapping]:\n        \"\"\"\n        This method allows the differ to add further mappings from previous differs\n        :return: additional mappings that should be included in the result of the differentiation\n        \"\"\"",
      "instance_attributes": [
        {
          "name": "previous_base_differ",
          "types": null
        },
        {
          "name": "previous_mappings",
          "types": null
        },
        {
          "name": "apiv1",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "apiv2",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer",
      "name": "SimpleDiffer",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer",
      "decorators": [],
      "superclasses": [
        "AbstractDiffer"
      ],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_related_mappings",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/notify_new_mapping",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_additional_mappings",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_create_list_from_type",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity",
        "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SimpleDiffer(AbstractDiffer):\n    assigned_by_look_up_similarity: dict[\n        ParameterAssignment, dict[ParameterAssignment, float]\n    ]\n    previous_parameter_similarity: dict[str, dict[str, float]] = {}\n    previous_function_similarity: dict[str, dict[str, float]] = {}\n\n    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        return None\n\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        return\n\n    def get_additional_mappings(self) -> list[Mapping]:\n        return []\n\n    def __init__(\n        self,\n        previous_base_differ: Optional[AbstractDiffer],\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        distance_between_implicit_and_explicit = 0.3\n        distance_between_vararg_and_normal = 0.3\n        distance_between_position_and_named = 0.3\n        distance_between_both_to_one = 0.15\n        distance_between_one_to_both = 0.15\n        self.assigned_by_look_up_similarity = {\n            ParameterAssignment.IMPLICIT: {\n                ParameterAssignment.IMPLICIT: 1.0,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_implicit_and_explicit,\n            },\n            ParameterAssignment.NAMED_VARARG: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.NAMED_VARARG: 1.0,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0 - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n            },\n            ParameterAssignment.POSITIONAL_VARARG: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_vararg_and_normal,\n            },\n            ParameterAssignment.POSITION_OR_NAME: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_both_to_one,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_both_to_one,\n                ParameterAssignment.POSITION_OR_NAME: 1.0,\n                ParameterAssignment.NAME_ONLY: 1.0 - distance_between_both_to_one,\n                ParameterAssignment.POSITION_ONLY: 1.0 - distance_between_both_to_one,\n            },\n            ParameterAssignment.NAME_ONLY: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_position_and_named,\n            },\n            ParameterAssignment.POSITION_ONLY: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_ONLY: 1.0,\n            },\n        }\n\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2 with the respect to their name, id, code, and attributes.\n        :param classv1: attribute from apiv1\n        :param classv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        normalize_similarity = 6\n\n        code_similarity = self._compute_code_similarity(\n            classv1.get_formatted_code(), classv2.get_formatted_code()\n        )\n        name_similarity = self._compute_name_similarity(classv1.name, classv2.name)\n\n        attributes_similarity = distance(\n            classv1.instance_attributes, classv2.instance_attributes\n        )\n        attributes_similarity = attributes_similarity / (\n            max(len(classv1.instance_attributes), len(classv2.instance_attributes), 1)\n        )\n        attributes_similarity = 1 - attributes_similarity\n\n        function_similarity = distance(\n            classv1.methods,\n            classv2.methods,\n        ) / max(len(classv1.methods), len(classv2.methods), 1)\n        function_similarity = 1 - function_similarity\n\n        id_similarity = self._compute_id_similarity(classv1.id, classv2.id)\n\n        documentation_similarity = self._compute_documentation_similarity(\n            classv1.documentation, classv2.documentation\n        )\n        if documentation_similarity < 0:\n            documentation_similarity = 0\n            normalize_similarity -= 1\n\n        return (\n            name_similarity\n            + attributes_similarity\n            + function_similarity\n            + code_similarity\n            + id_similarity\n            + documentation_similarity\n        ) / normalize_similarity\n\n    def _compute_name_similarity(self, namev1: str, namev2: str) -> float:\n        name_similarity = distance(namev1, namev2) / max(len(namev1), len(namev2), 1)\n        return 1 - name_similarity\n\n    def compute_attribute_similarity(\n        self,\n        attributev1: Attribute,\n        attributev2: Attribute,\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2 with the respect to their name and type.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        name_similarity = self._compute_name_similarity(\n            attributev1.name, attributev2.name\n        )\n        type_listv1 = self._create_list_from_type(attributev1.types)\n        type_listv2 = self._create_list_from_type(attributev2.types)\n        type_similarity = distance(type_listv1, type_listv2) / max(\n            len(type_listv1), len(type_listv2), 1\n        )\n        type_similarity = 1 - type_similarity\n        return (name_similarity + type_similarity) / 2\n\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2 with the respect to their code, name, id, and parameters.\n        :param functionv1: attribute from apiv1\n        :param functionv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        if (\n            functionv1.id in self.previous_function_similarity\n            and functionv2.id in self.previous_function_similarity[functionv1.id]\n        ):\n            return self.previous_function_similarity[functionv1.id][functionv2.id]\n\n        normalize_similarity = 5\n\n        code_similarity = self._compute_code_similarity(\n            functionv1.get_formatted_code(), functionv2.get_formatted_code()\n        )\n        name_similarity = self._compute_name_similarity(\n            functionv1.name, functionv2.name\n        )\n\n        parameter_similarity = distance(\n            functionv1.parameters,\n            functionv2.parameters,\n        ) / max(len(functionv1.parameters), len(functionv2.parameters), 1)\n        parameter_similarity = 1 - parameter_similarity\n\n        id_similarity = self._compute_id_similarity(functionv1.id, functionv2.id)\n\n        documentation_similarity = self._compute_documentation_similarity(\n            functionv1.documentation, functionv2.documentation\n        )\n        if documentation_similarity < 0:\n            documentation_similarity = 0\n            normalize_similarity -= 1\n\n        result = (\n            code_similarity\n            + name_similarity\n            + parameter_similarity\n            + id_similarity\n            + documentation_similarity\n        ) / normalize_similarity\n        if functionv1.id not in self.previous_function_similarity:\n            self.previous_function_similarity[functionv1.id] = {}\n        self.previous_function_similarity[functionv1.id][functionv2.id] = result\n        return result\n\n    def _compute_code_similarity(self, codev1: str, codev2: str) -> float:\n        splitv1 = codev1.split(\"\\n\")\n        splitv2 = codev2.split(\"\\n\")\n        diff_code = distance(splitv1, splitv2) / max(len(splitv1), len(splitv2), 1)\n        return 1 - diff_code\n\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2 with the respect to their name, type, assignment, default value, documentation, and id.\n        :param parameterv1: attribute from apiv1\n        :param parameterv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        if (\n            parameterv1.id in self.previous_parameter_similarity\n            and parameterv2.id in self.previous_parameter_similarity[parameterv1.id]\n        ):\n            return self.previous_parameter_similarity[parameterv1.id][parameterv2.id]\n\n        normalize_similarity = 6\n        parameter_name_similarity = self._compute_name_similarity(\n            parameterv1.name, parameterv2.name\n        )\n        parameter_type_similarity = self._compute_type_similarity(\n            parameterv1.type, parameterv2.type\n        )\n        parameter_assignment_similarity = self._compute_assignment_similarity(\n            parameterv1.assigned_by, parameterv2.assigned_by\n        )\n        if parameter_assignment_similarity < 0:\n            parameter_assignment_similarity = 0\n            normalize_similarity -= 1\n        parameter_default_value_similarity = self._compute_default_value_similarity(\n            parameterv1.default_value, parameterv2.default_value\n        )\n        if parameter_default_value_similarity < 0:\n            parameter_default_value_similarity = 0\n            normalize_similarity -= 1\n        parameter_documentation_similarity = self._compute_documentation_similarity(\n            parameterv1.documentation, parameterv2.documentation\n        )\n        if parameter_documentation_similarity < 0:\n            parameter_documentation_similarity = 0\n            normalize_similarity -= 1\n\n        id_similarity = self._compute_id_similarity(parameterv1.id, parameterv2.id)\n\n        result = (\n            parameter_name_similarity\n            + parameter_type_similarity\n            + parameter_assignment_similarity\n            + parameter_default_value_similarity\n            + parameter_documentation_similarity\n            + id_similarity\n        ) / normalize_similarity\n        if parameterv1.id not in self.previous_parameter_similarity:\n            self.previous_parameter_similarity[parameterv1.id] = {}\n        self.previous_parameter_similarity[parameterv1.id][parameterv2.id] = result\n        return result\n\n    def _compute_type_similarity(\n        self, typev1: Optional[AbstractType], typev2: Optional[AbstractType]\n    ) -> float:\n        if typev1 is None:\n            if typev2 is None:\n                return 1\n            return 0\n        if typev2 is None:\n            return 0\n\n        type_listv1 = self._create_list_from_type(typev1)\n        type_listv2 = self._create_list_from_type(typev2)\n        diff_elements = distance(type_listv1, type_listv2) / max(\n            len(type_listv1), len(type_listv2), 1\n        )\n        return 1 - diff_elements\n\n    def _create_list_from_type(\n        self, abstract_type: Optional[AbstractType]\n    ) -> Sequence[Optional[AbstractType]]:\n        if abstract_type is not None and isinstance(abstract_type, UnionType):\n            return abstract_type.types\n        return [abstract_type]\n\n    def _compute_assignment_similarity(\n        self, assigned_byv1: ParameterAssignment, assigned_byv2: ParameterAssignment\n    ) -> float:\n        return self.assigned_by_look_up_similarity[assigned_byv1][assigned_byv2]\n\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2 with the respect to their name.\n        :param resultv1: attribute from apiv1\n        :param resultv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        return self._compute_name_similarity(resultv1.name, resultv2.name)\n\n    def _compute_default_value_similarity(\n        self, default_valuev1: Optional[str], default_valuev2: Optional[str]\n    ) -> float:\n        if default_valuev1 is None and default_valuev2 is None:\n            return -1.0\n        if default_valuev1 is None or default_valuev2 is None:\n            return 0.0\n        if default_valuev1 == \"None\" and default_valuev2 == \"None\":\n            return 1.0\n        try:\n            intv1_value = int(default_valuev1)\n            intv2_value = int(default_valuev2)\n            if intv1_value == intv2_value:\n                return 1.0\n            return 0.5\n        except ValueError:\n            try:\n                floatv1_value = float(default_valuev1)\n                floatv2_value = float(default_valuev2)\n                if floatv1_value == floatv2_value:\n                    return 1.0\n            except ValueError:\n                try:\n                    if float(int(default_valuev1)) == float(default_valuev2):\n                        return 0.75\n                except ValueError:\n                    try:\n                        if float(int(default_valuev2)) == float(default_valuev1):\n                            return 0.75\n                    except ValueError:\n                        pass\n        if default_valuev1 in (\n            \"True\",\n            \"False\",\n        ) and default_valuev2 in (\"True\", \"False\"):\n            if bool(default_valuev1) == bool(default_valuev2):\n                return 1.0\n            return 0.5\n        valuev1_is_in_quotation_marks = (\n            default_valuev1.startswith(\"'\") and default_valuev1.endswith(\"'\")\n        ) or (default_valuev1.startswith('\"') and default_valuev1.endswith('\"'))\n        valuev2_is_in_quotation_marks = (\n            default_valuev2.startswith(\"'\") and default_valuev2.endswith(\"'\")\n        ) or (default_valuev2.startswith('\"') and default_valuev2.endswith('\"'))\n        if valuev1_is_in_quotation_marks and valuev2_is_in_quotation_marks:\n            if default_valuev1[1:-1] == default_valuev2[1:-1]:\n                return 1.0\n            return 0.5\n        return 0.0\n\n    def _compute_documentation_similarity(\n        self,\n        documentationv1: Union[\n            ClassDocumentation, FunctionDocumentation, ParameterDocumentation\n        ],\n        documentationv2: Union[\n            ClassDocumentation, FunctionDocumentation, ParameterDocumentation\n        ],\n    ) -> float:\n        if len(documentationv1.description) == len(documentationv2.description) == 0:\n            return -1.0\n        descriptionv1 = re.split(\"[\\n ]\", documentationv1.description)\n        descriptionv2 = re.split(\"[\\n ]\", documentationv2.description)\n\n        documentation_similarity = distance(descriptionv1, descriptionv2) / max(\n            len(descriptionv1), len(descriptionv2), 1\n        )\n        return 1 - documentation_similarity\n\n    def _compute_id_similarity(self, idv1: str, idv2: str) -> float:\n        module_pathv1 = idv1.split(\"/\")[1].split(\".\")\n        additional_module_pathv1 = idv1.split(\"/\")[2:-1]\n        if len(additional_module_pathv1) > 0:\n            module_pathv1.extend(additional_module_pathv1)\n        module_pathv2 = idv2.split(\"/\")[1].split(\".\")\n        additional_module_pathv2 = idv2.split(\"/\")[2:-1]\n        if len(additional_module_pathv2) > 0:\n            module_pathv2.extend(additional_module_pathv2)\n\n        def cost_function(iteration: int, max_iteration: int) -> float:\n            return (max_iteration - iteration + 1) / max_iteration\n\n        total_costs, max_iterations = distance_elements_with_cost_function(\n            module_pathv1, module_pathv2, cost_function\n        )\n        return 1 - (total_costs / (sum(range(1, max_iterations + 1)) / max_iterations))",
      "instance_attributes": [
        {
          "name": "assigned_by_look_up_similarity",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer",
      "name": "InheritanceDiffer",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer",
      "decorators": [],
      "superclasses": [
        "AbstractDiffer"
      ],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__",
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity",
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity",
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity",
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity",
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity",
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_related_mappings",
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements",
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/notify_new_mapping",
        "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_additional_mappings"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class InheritanceDiffer(AbstractDiffer):\n    boost_value: float\n    differ: AbstractDiffer\n    inheritance: dict[str, list[str]]\n    new_mappings: list[Mapping]\n\n    def __init__(\n        self,\n        previous_base_differ: AbstractDiffer,\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n        boost_value: float = 0.15,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        self.differ = previous_base_differ\n        self.boost_value = boost_value\n        self.inheritance = {}\n        self.new_mappings = []\n        for class_v2 in self.apiv2.classes.values():\n            additional_v1_elements = []\n            for mapping in previous_mappings:\n                if isinstance(mapping.get_apiv2_elements()[0], Class):\n                    is_inheritance_mapping = class_v2.id in map(\n                        lambda class_: class_.id if isinstance(class_, Class) else \"\",\n                        mapping.get_apiv2_elements(),\n                    )\n                    if not is_inheritance_mapping:\n                        for inheritance_class_v2 in mapping.get_apiv2_elements():\n                            if isinstance(inheritance_class_v2, Class):\n                                if (\n                                    inheritance_class_v2.name in class_v2.superclasses\n                                    or class_v2.name\n                                    in inheritance_class_v2.superclasses\n                                ):\n                                    is_inheritance_mapping = True\n                                    break\n                    if is_inheritance_mapping:\n                        for class_v1 in mapping.get_apiv1_elements():\n                            if isinstance(class_v1, Class):\n                                additional_v1_elements.append(class_v1.id)\n            if len(additional_v1_elements) > 0:\n                self.inheritance[class_v2.id] = additional_v1_elements\n\n    def compute_attribute_similarity(\n        self, attributev1: Attribute, attributev2: Attribute\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: if the parent of the attributes are mapped onto each other\n         or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if (\n            attributev2.class_id in self.inheritance\n            and attributev1.class_id in self.inheritance[attributev2.class_id]\n        ):\n            return (\n                self.differ.compute_attribute_similarity(attributev1, attributev2)\n                * (1 - self.boost_value)\n            ) + self.boost_value\n        return 0.0\n\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: if the classes are mapped onto each other or onto a super- or subclass,\n        the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if classv2.id in self.inheritance:\n            for mapping in self.previous_mappings:\n                for elementv2 in mapping.get_apiv2_elements():\n                    if isinstance(elementv2, Class):\n                        if elementv2.id in self.inheritance[classv2.id]:\n                            return (\n                                self.differ.compute_class_similarity(classv1, classv2)\n                                * (1 - self.boost_value)\n                            ) + self.boost_value\n        return 0.0\n\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: if functions are not global functions and its parent are mapped onto each other\n         or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        functionv1_is_global = len(functionv1.id.split(\"/\")) == 3\n        functionv2_is_global = len(functionv2.id.split(\"/\")) == 3\n        if functionv1_is_global or functionv2_is_global:\n            return 0.0\n        class_id_functionv1 = \"/\".join(functionv1.id.split(\"/\")[:-1])\n        class_id_functionv2 = \"/\".join(functionv2.id.split(\"/\")[:-1])\n        if (\n            class_id_functionv2 in self.inheritance\n            and class_id_functionv1 in self.inheritance[class_id_functionv2]\n        ):\n            base_similarity = self.differ.compute_function_similarity(\n                functionv1, functionv2\n            )\n            return (base_similarity * (1 - self.boost_value)) + self.boost_value\n        return 0.0\n\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: if their parents are mapped together, the normalized similarity of the previous differ plus boost_value,\n        or else 0.\n        \"\"\"\n        parameterv2_id_splitted = parameterv2.id.split(\"/\")\n        if \"/\".join(parameterv2_id_splitted[:-2]) in self.inheritance:\n            functionv1_id = \"/\".join(parameterv1.id.split(\"/\")[:-1])\n            for mapping in self.new_mappings:\n                for functionv1 in mapping.get_apiv1_elements():\n                    if (\n                        isinstance(functionv1, Function)\n                        and functionv1_id == functionv1.id\n                    ):\n                        for functionv2 in mapping.get_apiv2_elements():\n                            if (\n                                isinstance(functionv2, Function)\n                                and \"/\".join(parameterv2_id_splitted[:-1])\n                                == functionv2.id\n                            ):\n                                return (\n                                    self.differ.compute_parameter_similarity(\n                                        parameterv1, parameterv2\n                                    )\n                                    * (1 - self.boost_value)\n                                ) + self.boost_value\n        return 0.0\n\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: if their parents are mapped together,\n        the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if (\n            resultv2.function_id is not None\n            and \"/\".join(resultv2.function_id.split(\"/\")[:-1]) in self.inheritance\n        ):\n            for mapping in self.new_mappings:\n                for functionv1 in mapping.get_apiv1_elements():\n                    if (\n                        isinstance(functionv1, Function)\n                        and resultv1.function_id == functionv1.id\n                    ):\n                        for functionv2 in mapping.get_apiv2_elements():\n                            if (\n                                isinstance(functionv2, Function)\n                                and resultv2.function_id == functionv2.id\n                            ):\n                                return (\n                                    self.differ.compute_result_similarity(\n                                        resultv1, resultv2\n                                    )\n                                    * (1 - self.boost_value)\n                                ) + self.boost_value\n        return 0.0\n\n    def get_related_mappings(self) -> Optional[list[Mapping]]:\n        \"\"\"\n        Indicates whether all api elements should be compared with each other\n        or just the ones that are mapped to each other.\n        :return: a list of Mappings by type whose elements are not already mapped\n        \"\"\"\n        related_mappings = []\n        mapped_apiv1_elements = [\n            element\n            for mapping in self.previous_mappings\n            for element in mapping.get_apiv1_elements()\n        ]\n        mapped_apiv2_elements = [\n            element\n            for mapping in self.previous_mappings\n            for element in mapping.get_apiv2_elements()\n        ]\n        for get_api_element in [\n            lambda api: api.classes.values(),\n            lambda api: api.functions.values(),\n            lambda api: api.attributes().values(),\n            lambda api: api.parameters().values(),\n            lambda api: api.results().values(),\n        ]:\n            not_mapped_elements_mapping = self._get_not_mapped_api_elements(\n                mapped_apiv1_elements, mapped_apiv2_elements, get_api_element\n            )\n            if not_mapped_elements_mapping is not None:\n                related_mappings.append(not_mapped_elements_mapping)\n        return related_mappings\n\n    def _get_not_mapped_api_elements(\n        self,\n        mapped_apiv1_elements: list[api_element],\n        mapped_apiv2_elements: list[api_element],\n        get_api_element: Callable[[API], list[api_element]],\n    ) -> Optional[Mapping]:\n        not_mapped_v1_elements = []\n        for api_elementv1 in get_api_element(self.apiv1):\n            if api_elementv1 not in mapped_apiv1_elements:\n                not_mapped_v1_elements.append(api_elementv1)\n        not_mapped_v2_elements = []\n        for api_elementv2 in get_api_element(self.apiv2):\n            if api_elementv2 not in mapped_apiv2_elements:\n                not_mapped_v2_elements.append(api_elementv2)\n        if len(not_mapped_v1_elements) > 0 and len(not_mapped_v2_elements) > 0:\n            return ManyToManyMapping(\n                -1.0, not_mapped_v1_elements, not_mapped_v2_elements\n            )\n        return None\n\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        self.new_mappings.extend(mappings)\n\n    def get_additional_mappings(self) -> list[Mapping]:\n        return self.previous_mappings",
      "instance_attributes": [
        {
          "name": "differ",
          "types": {
            "kind": "NamedType",
            "name": "AbstractDiffer"
          }
        },
        {
          "name": "boost_value",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "inheritance",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "new_mappings",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping",
      "name": "ManyToManyMapping",
      "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "Mapping"
      ],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv1_elements",
        "packager-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv2_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ManyToManyMapping(Mapping):\n    apiv1_elements: list[api_element]\n    apiv2_elements: list[api_element]\n\n    def get_apiv1_elements(self) -> list[api_element]:\n        return self.apiv1_elements\n\n    def get_apiv2_elements(self) -> list[api_element]:\n        return self.apiv2_elements",
      "instance_attributes": [
        {
          "name": "apiv1_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "apiv2_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping",
      "name": "ManyToOneMapping",
      "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "Mapping"
      ],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv1_elements",
        "packager-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv2_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ManyToOneMapping(Mapping):\n    apiv1_elements: list[api_element]\n    apiv2_element: api_element\n\n    def get_apiv1_elements(self) -> list[api_element]:\n        return self.apiv1_elements\n\n    def get_apiv2_elements(self) -> list[api_element]:\n        return [self.apiv2_element]",
      "instance_attributes": [
        {
          "name": "apiv1_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "apiv2_element",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/Mapping",
      "name": "Mapping",
      "qname": "package_parser.processing.migration.model._mapping.Mapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv1_elements",
        "packager-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv2_elements",
        "packager-parser/package_parser.processing.migration.model._mapping/Mapping/get_similarity"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Mapping(ABC):\n    similarity: float\n\n    @abstractmethod\n    def get_apiv1_elements(self) -> list[api_element]:\n        pass\n\n    @abstractmethod\n    def get_apiv2_elements(self) -> list[api_element]:\n        pass\n\n    def get_similarity(self) -> float:\n        return self.similarity",
      "instance_attributes": [
        {
          "name": "similarity",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToManyMapping",
      "name": "OneToManyMapping",
      "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "Mapping"
      ],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv1_elements",
        "packager-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv2_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class OneToManyMapping(Mapping):\n    apiv1_element: api_element\n    apiv2_elements: list[api_element]\n\n    def get_apiv1_elements(self) -> list[api_element]:\n        return [self.apiv1_element]\n\n    def get_apiv2_elements(self) -> list[api_element]:\n        return self.apiv2_elements",
      "instance_attributes": [
        {
          "name": "apiv1_element",
          "types": null
        },
        {
          "name": "apiv2_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToOneMapping",
      "name": "OneToOneMapping",
      "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "Mapping"
      ],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv1_elements",
        "packager-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv2_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class OneToOneMapping(Mapping):\n    apiv1_element: api_element\n    apiv2_element: api_element\n\n    def get_apiv1_elements(self) -> list[api_element]:\n        return [self.apiv1_element]\n\n    def get_apiv2_elements(self) -> list[api_element]:\n        return [self.apiv2_element]",
      "instance_attributes": [
        {
          "name": "apiv1_element",
          "types": null
        },
        {
          "name": "apiv2_element",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer",
      "name": "StrictDiffer",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer",
      "decorators": [],
      "superclasses": [
        "AbstractDiffer"
      ],
      "methods": [
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_related_mappings",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/notify_new_mapping",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_additional_mappings",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity",
        "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class StrictDiffer(AbstractDiffer):\n    new_mappings: list[Mapping]\n    differ: AbstractDiffer\n\n    def __init__(\n        self,\n        previous_base_differ: AbstractDiffer,\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        self.differ = previous_base_differ\n        self.new_mappings = []\n\n    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        sort_order = {\n            Class: 0,\n            Attribute: 1,\n            Function: 2,\n            Parameter: 3,\n            Result: 4,\n        }\n        return sorted(\n            self.previous_mappings,\n            key=lambda mapping: sort_order[type(mapping.get_apiv1_elements()[0])],\n        )\n\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        self.new_mappings.extend(mappings)\n\n    def get_additional_mappings(self) -> list[Mapping]:\n        return []\n\n    def _is_parent(\n        self,\n        possible_parent: Union[Class, Function, Attribute, Parameter, Result],\n        child: DEPENDENT_API_ELEMENTS,\n    ) -> bool:\n        if isinstance(child, Attribute) and isinstance(possible_parent, Class):\n            return child.class_id == possible_parent.id\n        if isinstance(child, Result) and isinstance(possible_parent, Function):\n            return child.function_id == possible_parent.id\n        if isinstance(child, Parameter) and isinstance(possible_parent, Function):\n            return \"/\".join(child.id.split(\"/\")[:-1]) == possible_parent.id\n        if isinstance(child, Function) and isinstance(possible_parent, Class):\n            return \"/\".join(child.id.split(\"/\")[:-1]) == possible_parent.id\n        return False\n\n    def _api_elements_are_mapped_to_each_other(\n        self,\n        api_elementv1: DEPENDENT_API_ELEMENTS,\n        api_elementv2: DEPENDENT_API_ELEMENTS,\n    ) -> bool:\n        (\n            relevant_apiv1_mappings,\n            relevant_apiv2_mappings,\n        ) = self._get_mapping_for_elements(api_elementv1, api_elementv2)\n        relevant_apiv2_mappings_include_functionv1 = (\n            len(\n                [\n                    parent\n                    for mapping in relevant_apiv2_mappings\n                    for parent in mapping.get_apiv1_elements()\n                    if self._is_parent(parent, api_elementv1)\n                ]\n            )\n            == 1\n        )\n        relevant_apiv2_mappings_include_functionv2 = (\n            len(\n                [\n                    parent\n                    for mapping in relevant_apiv1_mappings\n                    for parent in mapping.get_apiv2_elements()\n                    if self._is_parent(parent, api_elementv2)\n                ]\n            )\n            == 1\n        )\n        return (\n            relevant_apiv2_mappings_include_functionv1\n            and relevant_apiv2_mappings_include_functionv2\n        )\n\n    def _get_mapping_for_elements(\n        self,\n        apiv1_element: DEPENDENT_API_ELEMENTS,\n        apiv2_element: DEPENDENT_API_ELEMENTS,\n    ) -> tuple[list[Mapping], list[Mapping]]:\n        mapping_for_apiv1_elements = []\n        mapping_for_apiv2_elements = []\n        for mapping in self.new_mappings:\n            if isinstance(mapping.get_apiv1_elements()[0], (Class, Function)):\n                for element in mapping.get_apiv1_elements():\n                    if self._is_parent(element, apiv1_element):\n                        mapping_for_apiv1_elements.append(mapping)\n                for element in mapping.get_apiv2_elements():\n                    if self._is_parent(element, apiv2_element):\n                        mapping_for_apiv2_elements.append(mapping)\n        return mapping_for_apiv1_elements, mapping_for_apiv2_elements\n\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: if the classes are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        for mapping in self.previous_mappings:\n            if (\n                classv1 in mapping.get_apiv1_elements()\n                and classv2 in mapping.get_apiv2_elements()\n            ):\n                return self.differ.compute_class_similarity(classv1, classv2)\n        return 0\n\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        is_global_functionv1 = len(functionv1.id.split(\"/\")) == 3\n        is_global_functionv2 = len(functionv2.id.split(\"/\")) == 3\n        if is_global_functionv1 and is_global_functionv2:\n            for mapping in self.previous_mappings:\n                if (\n                    functionv1 in mapping.get_apiv1_elements()\n                    and functionv2 in mapping.get_apiv2_elements()\n                ):\n                    return self.differ.compute_function_similarity(\n                        functionv1, functionv2\n                    )\n        elif (\n            not is_global_functionv1 and not is_global_functionv2\n        ) and self._api_elements_are_mapped_to_each_other(functionv1, functionv2):\n            return self.differ.compute_function_similarity(functionv1, functionv2)\n        return 0.0\n\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(parameterv1, parameterv2):\n            return self.differ.compute_parameter_similarity(parameterv1, parameterv2)\n        return 0.0\n\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2.\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(resultv1, resultv2):\n            return self.differ.compute_result_similarity(resultv1, resultv2)\n        return 0.0\n\n    def compute_attribute_similarity(\n        self, attributev1: Attribute, attributev2: Attribute\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(attributev1, attributev2):\n            return self.differ.compute_attribute_similarity(attributev1, attributev2)\n        return 0.0",
      "instance_attributes": [
        {
          "name": "differ",
          "types": {
            "kind": "NamedType",
            "name": "AbstractDiffer"
          }
        },
        {
          "name": "new_mappings",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder",
      "name": "_UsageFinder",
      "qname": "package_parser.processing.usages._ast_visitor._UsageFinder",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__",
        "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class _UsageFinder:\n    def __init__(self, package_name: str) -> None:\n        self.package_name: str = package_name\n        self.usages: UsageCountStore = UsageCountStore()\n\n    def enter_call(self, node: astroid.Call):\n        called_tuple = _analyze_declaration_called_by(node, self.package_name)\n        if called_tuple is None:\n            return\n        called, function_id, parameters, n_implicit_parameters = called_tuple\n\n        bound_parameters = _bound_parameters(\n            parameters, CallSite.from_call(node), n_implicit_parameters\n        )\n        if bound_parameters is None:\n            return\n\n        # Add class usage\n        if (\n            isinstance(called, (astroid.BoundMethod, astroid.UnboundMethod))\n            or isinstance(called, astroid.FunctionDef)\n            and called.is_method()\n        ):\n            self.usages.add_class_usages(parent_id(function_id))\n\n        # Add function usage\n        self.usages.add_function_usages(function_id)\n\n        # Add parameter & value usage\n        for parameter_name, value in bound_parameters.items():\n            parameter_id = f\"{function_id}/{parameter_name}\"\n            self.usages.add_parameter_usages(parameter_id)\n\n            value = _stringify_value(value)\n            self.usages.add_value_usages(parameter_id, value)",
      "instance_attributes": [
        {
          "name": "package_name",
          "types": null
        },
        {
          "name": "usages",
          "types": null
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore",
      "name": "UsageCountStore",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/from_json",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__init__",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__eq__",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__hash__",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_class_usages",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_class",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_function_usages",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_function",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_parameter_usages",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_parameter",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_value_usages",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/init_value",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_class_usages",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_function_usages",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_parameter_usages",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_value_usages",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/most_common_parameter_values",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/merge_other_into_self",
        "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Counts how often classes, functions, parameters, and parameter values are used.",
      "docstring": "Counts how often classes, functions, parameters, and parameter values are used.",
      "code": "class UsageCountStore:\n    \"\"\"Counts how often classes, functions, parameters, and parameter values are used.\"\"\"\n\n    @staticmethod\n    def from_json(json: Any) -> UsageCountStore:\n        \"\"\"Creates an instance of this class from a dictionary.\"\"\"\n\n        result = UsageCountStore()\n\n        # Revive class counts\n        class_counts = json[\"class_counts\"]\n        for class_id, count in class_counts.items():\n            result.add_class_usages(class_id, count)\n\n        # Revive function counts\n        function_counts = json[\"function_counts\"]\n        for function_id, count in function_counts.items():\n            result.add_function_usages(function_id, count)\n\n        # Revive parameter counts\n        parameter_counts = json[\"parameter_counts\"]\n        for parameter_id, count in parameter_counts.items():\n            result.add_parameter_usages(parameter_id, count)\n\n        # Revive value counts\n        value_counts = json[\"value_counts\"]\n        for parameter_id, values in value_counts.items():\n            for value, count in values.items():\n                result.add_value_usages(parameter_id, value, count)\n\n        return result\n\n    def __init__(self) -> None:\n        self.class_usages: Counter[ClassId] = Counter()\n        self.function_usages: Counter[FunctionId] = Counter()\n        self.parameter_usages: Counter[ParameterId] = Counter()\n        self.value_usages: dict[ParameterId, Counter[StringifiedValue]] = {}\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, UsageCountStore):\n            return (\n                self.class_usages == other.class_usages\n                and self.function_usages == other.function_usages\n                and self.parameter_usages == other.parameter_usages\n                and self.value_usages == other.value_usages\n            )\n\n        return False\n\n    def __hash__(self) -> int:\n        return hash(tuple(sorted(self.__dict__.items())))\n\n    def add_class_usages(self, class_id: ClassId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the class with the given name by the given count.\"\"\"\n\n        self.class_usages[class_id] += count\n\n    def remove_class(self, class_id: ClassId) -> None:\n        \"\"\"Removes all usages of classes with the given name and usages of their methods.\"\"\"\n\n        if class_id in self.class_usages:\n            del self.class_usages[class_id]\n\n        for function_id in list(self.function_usages.keys()):\n            if function_id.startswith(class_id):\n                self.remove_function(function_id)\n\n    def add_function_usages(self, function_id: FunctionId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the function with the given name by the given count.\"\"\"\n\n        self.function_usages[function_id] += count\n\n    def remove_function(self, function_id: FunctionId) -> None:\n        \"\"\"Removes all usages of functions with the given name and usages of their parameters.\"\"\"\n\n        if function_id in self.function_usages:\n            del self.function_usages[function_id]\n\n        for parameter_id in list(self.parameter_usages.keys()):\n            if parameter_id.startswith(function_id):\n                self.remove_parameter(parameter_id)\n\n    def add_parameter_usages(self, parameter_id: ParameterId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the parameter with the given name by the given count.\"\"\"\n\n        self.parameter_usages[parameter_id] += count\n\n    def remove_parameter(self, parameter_id: ParameterId) -> None:\n        \"\"\"Removes all parameter and value usages of parameters with the given name.\"\"\"\n\n        if parameter_id in self.parameter_usages:\n            del self.parameter_usages[parameter_id]\n\n        if parameter_id in self.value_usages:\n            del self.value_usages[parameter_id]\n\n    def add_value_usages(\n        self, parameter_id: ParameterId, value: StringifiedValue, count: int = 1\n    ) -> None:\n        \"\"\"Increases the usage count of the given value for the parameter with the given name by the given count.\"\"\"\n\n        self.init_value(parameter_id)\n        self.value_usages[parameter_id][value] += count\n\n    def init_value(self, parameter_id: ParameterId) -> None:\n        \"\"\"Ensures the dictionary for the value counts has the given parameter name as a key.\"\"\"\n\n        if parameter_id not in self.value_usages:\n            self.value_usages[parameter_id] = Counter()\n\n    def n_class_usages(self, class_id: ClassId) -> int:\n        \"\"\"Returns how often the class is used, i.e. how often any of its methods are called.\"\"\"\n\n        return self.class_usages[class_id]\n\n    def n_function_usages(self, function_id: FunctionId) -> int:\n        \"\"\"Returns how often the function is called.\"\"\"\n\n        return self.function_usages[function_id]\n\n    def n_parameter_usages(self, parameter_id: ParameterId) -> int:\n        \"\"\"Returns how often the parameter is set.\"\"\"\n\n        return self.parameter_usages[parameter_id]\n\n    def n_value_usages(self, parameter_id: ParameterId, value: str) -> int:\n        \"\"\"Returns how often the parameter with the given name is set to the given value.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return self.value_usages[parameter_id][value]\n\n        return 0\n\n    def most_common_parameter_values(self, parameter_id: ParameterId) -> list[str]:\n        \"\"\"Returns all values that have been set for the parameter with the given name sorted by their count in descending order.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return [\n                value\n                for value, count in self.value_usages[parameter_id].most_common()\n                if count > 0\n            ]\n\n        return []\n\n    def merge_other_into_self(\n        self, other_usage_store: UsageCountStore\n    ) -> UsageCountStore:\n        \"\"\"\n        Merges the other usage store into this one **in-place** and returns this store.\n\n        :param other_usage_store: The usage store to merge into this one.\n        :return: This usage store.\n        \"\"\"\n\n        # Merge class usages\n        self.class_usages += other_usage_store.class_usages\n\n        # Merge function usages\n        self.function_usages += other_usage_store.function_usages\n\n        # Merge parameter usages\n        self.parameter_usages += other_usage_store.parameter_usages\n\n        # Merge value usages\n        for parameter_id, value_usages in other_usage_store.value_usages.items():\n            self.init_value(parameter_id)\n            self.value_usages[parameter_id] += value_usages\n\n        return self\n\n    def to_json(self) -> Any:\n        \"\"\"Converts this class to a dictionary, which can later be serialized as JSON.\"\"\"\n\n        return {\n            \"schemaVersion\": USAGES_SCHEMA_VERSION,\n            \"class_counts\": {\n                class_id: usage_count\n                for class_id, usage_count in self.class_usages.most_common()\n            },\n            \"function_counts\": {\n                function_id: usage_count\n                for function_id, usage_count in self.function_usages.most_common()\n            },\n            \"parameter_counts\": {\n                parameter_id: usage_count\n                for parameter_id, usage_count in self.parameter_usages.most_common()\n            },\n            \"value_counts\": {\n                parameter_id: {\n                    value: usage_count for value, usage_count in values.most_common()\n                }\n                for parameter_id, values in self.value_usages.items()\n            },\n        }",
      "instance_attributes": [
        {
          "name": "class_usages",
          "types": {
            "kind": "NamedType",
            "name": "Counter"
          }
        },
        {
          "name": "function_usages",
          "types": {
            "kind": "NamedType",
            "name": "Counter"
          }
        },
        {
          "name": "parameter_usages",
          "types": {
            "kind": "NamedType",
            "name": "Counter"
          }
        },
        {
          "name": "value_usages",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker",
      "name": "ASTWalker",
      "qname": "package_parser.utils._ASTWalker.ASTWalker",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__init__",
        "packager-parser/package_parser.utils._ASTWalker/ASTWalker/walk",
        "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__walk",
        "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__enter",
        "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__leave",
        "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "docstring": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "code": "class ASTWalker:\n    \"\"\"A walker visiting a tree in preorder, calling on the handler:\n\n    * enter_<class_name> on entering a node, where class name is the class of\n    the node in lower case.\n\n    * leave_<class_name> on leaving a node, where class name is the class of\n    the node in lower case.\n    \"\"\"\n\n    def __init__(self, handler: Any) -> None:\n        self._handler = handler\n        self._cache: dict[Type, _EnterAndLeaveFunctions] = {}\n\n    def walk(self, node: astroid.NodeNG) -> None:\n        self.__walk(node, set())\n\n    def __walk(self, node: astroid.NodeNG, visited_nodes: set[astroid.NodeNG]) -> None:\n        if node in visited_nodes:\n            raise AssertionError(\"Node visited twice\")\n        visited_nodes.add(node)\n\n        self.__enter(node)\n        for child_node in node.get_children():\n            self.__walk(child_node, visited_nodes)\n        self.__leave(node)\n\n    def __enter(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[0]\n        if method is not None:\n            method(node)\n\n    def __leave(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[1]\n        if method is not None:\n            method(node)\n\n    def __get_callbacks(self, node: astroid.NodeNG) -> _EnterAndLeaveFunctions:\n        klass = node.__class__\n        methods = self._cache.get(klass)\n\n        if methods is None:\n            handler = self._handler\n            class_name = klass.__name__.lower()\n            enter_method = getattr(\n                handler, f\"enter_{class_name}\", getattr(handler, \"enter_default\", None)\n            )\n            leave_method = getattr(\n                handler, f\"leave_{class_name}\", getattr(handler, \"leave_default\", None)\n            )\n            self._cache[klass] = (enter_method, leave_method)\n        else:\n            enter_method, leave_method = methods\n\n        return enter_method, leave_method",
      "instance_attributes": [
        {
          "name": "_handler",
          "types": {
            "kind": "NamedType",
            "name": "Any"
          }
        },
        {
          "name": "_cache",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    }
  ],
  "functions": [
    {
      "id": "packager-parser/package_parser.cli._cli/_add_all_subparser",
      "name": "_add_all_subparser",
      "qname": "package_parser.cli._cli._add_all_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._cli/_add_all_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_all_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_all_subparser(subparsers: _SubParsersAction) -> None:\n    all_parser = subparsers.add_parser(\n        _ALL_COMMAND,\n        help=\"Run api and usages command in parallel and then run annotations command.\",\n    )\n    all_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package.\",\n        type=str,\n        required=True,\n    )\n    all_parser.add_argument(\n        \"-s\",\n        \"--src\",\n        help=\"Directory containing the Python code of the package. If this is omitted, we try to locate the package \"\n        \"with the given name in the current Python interpreter.\",\n        type=Path,\n        required=False,\n        default=None,\n    )\n    all_parser.add_argument(\n        \"-c\",\n        \"--client\",\n        help=\"Directory containing Python code that uses the package.\",\n        type=Path,\n        required=True,\n    )\n    all_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )\n    all_parser.add_argument(\n        \"--processes\",\n        help=\"How many processes should be spawned during processing.\",\n        type=int,\n        required=False,\n        default=4,\n    )\n    all_parser.add_argument(\n        \"--batchsize\",\n        help=\"How many files to process in one go. Higher values lead to higher memory usage but better performance.\",\n        type=int,\n        required=False,\n        default=100,\n    )"
    },
    {
      "id": "packager-parser/package_parser.cli._cli/_add_annotations_subparser",
      "name": "_add_annotations_subparser",
      "qname": "package_parser.cli._cli._add_annotations_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._cli/_add_annotations_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_annotations_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_annotations_subparser(subparsers) -> None:\n    generate_parser = subparsers.add_parser(\n        _ANNOTATIONS_COMMAND, help=\"Generate Annotations automatically.\"\n    )\n    generate_parser.add_argument(\n        \"-a\",\n        \"--api\",\n        help=\"File created by the 'api' command.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-u\",\n        \"--usages\",\n        help=\"File created by the 'usages' command that contains usage counts.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "packager-parser/package_parser.cli._cli/_add_api_subparser",
      "name": "_add_api_subparser",
      "qname": "package_parser.cli._cli._add_api_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._cli/_add_api_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_api_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_api_subparser(subparsers: _SubParsersAction) -> None:\n    api_parser = subparsers.add_parser(_API_COMMAND, help=\"List the API of a package.\")\n    api_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package.\",\n        type=str,\n        required=True,\n    )\n    api_parser.add_argument(\n        \"-s\",\n        \"--src\",\n        help=\"Directory containing the Python code of the package. If this is omitted, we try to locate the package \"\n        \"with the given name in the current Python interpreter.\",\n        type=Path,\n        required=False,\n        default=None,\n    )\n    api_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "packager-parser/package_parser.cli._cli/_add_migrate_subparser",
      "name": "_add_migrate_subparser",
      "qname": "package_parser.cli._cli._add_migrate_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._cli/_add_migrate_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_migrate_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_migrate_subparser(subparsers) -> None:\n    generate_parser = subparsers.add_parser(\n        _MIGRATE_COMMAND,\n        help=\"Migrate Annotations for the new version based on the previous version.\",\n    )\n    generate_parser.add_argument(\n        \"-a1\",\n        \"--apiv1\",\n        help=\"File created with the 'api' command from the previous version.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-a2\",\n        \"--apiv2\",\n        help=\"File created by the 'api' command from the new version.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-a\",\n        \"--annotations\",\n        help=\"File that includes all annotations of the previous version.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "packager-parser/package_parser.cli._cli/_add_usages_subparser",
      "name": "_add_usages_subparser",
      "qname": "package_parser.cli._cli._add_usages_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._cli/_add_usages_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_usages_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_usages_subparser(subparsers: _SubParsersAction) -> None:\n    usages_parser = subparsers.add_parser(\n        _USAGES_COMMAND, help=\"Find usages of API elements.\"\n    )\n    usages_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package. It must be installed in the current interpreter.\",\n        type=str,\n        required=True,\n    )\n    usages_parser.add_argument(\n        \"-c\",\n        \"--client\",\n        help=\"Directory containing Python code that uses the package.\",\n        type=Path,\n        required=True,\n    )\n    usages_parser.add_argument(\n        \"--processes\",\n        help=\"How many processes should be spawned during processing.\",\n        type=int,\n        required=False,\n        default=4,\n    ),\n    usages_parser.add_argument(\n        \"--batchsize\",\n        help=\"How many files to process in one go. Higher values lead to higher memory usage but better performance.\",\n        type=int,\n        required=False,\n        default=100,\n    )\n    usages_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "packager-parser/package_parser.cli._cli/_get_args",
      "name": "_get_args",
      "qname": "package_parser.cli._cli._get_args",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(description=\"Analyze Python code.\")\n    parser.add_argument(\n        \"-v\", \"--verbose\", help=\"show info messages\", action=\"store_true\"\n    )\n\n    # Commands\n    subparsers = parser.add_subparsers(dest=\"command\")\n    _add_api_subparser(subparsers)\n    _add_usages_subparser(subparsers)\n    _add_annotations_subparser(subparsers)\n    _add_all_subparser(subparsers)\n    _add_migrate_subparser(subparsers)\n\n    return parser.parse_args()"
    },
    {
      "id": "packager-parser/package_parser.cli._cli/cli",
      "name": "cli",
      "qname": "package_parser.cli._cli.cli",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def cli() -> None:\n    args = _get_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.INFO)\n\n    if args.command == _API_COMMAND:\n        _run_api_command(args.package, args.src, args.out)\n    elif args.command == _USAGES_COMMAND:\n        _run_usages_command(\n            args.package, args.client, args.out, args.processes, args.batchsize\n        )\n    elif args.command == _ANNOTATIONS_COMMAND:\n        _run_annotations(args.api, args.usages, args.out)\n    elif args.command == _ALL_COMMAND:\n        _run_all_command(\n            args.package,\n            args.src,\n            args.client,\n            args.out,\n            args.processes,\n            args.batchsize,\n        )\n    elif args.command == _MIGRATE_COMMAND:\n        _run_migrate_command(args.apiv1, args.annotations, args.apiv2, args.out)"
    },
    {
      "id": "packager-parser/package_parser.cli._json_encoder/CustomEncoder/default",
      "name": "default",
      "qname": "package_parser.cli._json_encoder.CustomEncoder.default",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._json_encoder/CustomEncoder/default/self",
          "name": "self",
          "qname": "package_parser.cli._json_encoder.CustomEncoder.default.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._json_encoder/CustomEncoder/default/o",
          "name": "o",
          "qname": "package_parser.cli._json_encoder.CustomEncoder.default.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def default(self, o: Any) -> Any:\n        if isinstance(o, set):\n            return list(o)\n        return super().default(o)"
    },
    {
      "id": "packager-parser/package_parser.cli._read_and_write_file/_read_annotations_file",
      "name": "_read_annotations_file",
      "qname": "package_parser.cli._read_and_write_file._read_annotations_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_read_annotations_file/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._read_and_write_file._read_annotations_file.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_annotations_file(annotations_file_path: Path) -> AnnotationStore:\n    with open(annotations_file_path, encoding=\"utf-8\") as annotations_file:\n        annotations_json = json.load(annotations_file)\n\n    return AnnotationStore.from_json(annotations_json)"
    },
    {
      "id": "packager-parser/package_parser.cli._read_and_write_file/_read_api_file",
      "name": "_read_api_file",
      "qname": "package_parser.cli._read_and_write_file._read_api_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_read_api_file/api_file_path",
          "name": "api_file_path",
          "qname": "package_parser.cli._read_and_write_file._read_api_file.api_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_api_file(api_file_path: Path) -> API:\n    with open(api_file_path, encoding=\"utf-8\") as api_file:\n        api_json = json.load(api_file)\n\n    return API.from_json(api_json)"
    },
    {
      "id": "packager-parser/package_parser.cli._read_and_write_file/_read_usages_file",
      "name": "_read_usages_file",
      "qname": "package_parser.cli._read_and_write_file._read_usages_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_read_usages_file/usages_file_path",
          "name": "usages_file_path",
          "qname": "package_parser.cli._read_and_write_file._read_usages_file.usages_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_usages_file(usages_file_path: Path) -> UsageCountStore:\n    with open(usages_file_path, encoding=\"utf-8\") as usages_file:\n        usages_json = json.load(usages_file)\n\n    return UsageCountStore.from_json(usages_json)"
    },
    {
      "id": "packager-parser/package_parser.cli._read_and_write_file/_write_annotations_file",
      "name": "_write_annotations_file",
      "qname": "package_parser.cli._read_and_write_file._write_annotations_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_write_annotations_file/annotations",
          "name": "annotations",
          "qname": "package_parser.cli._read_and_write_file._write_annotations_file.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_write_annotations_file/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._read_and_write_file._write_annotations_file.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_annotations_file(\n    annotations: AnnotationStore, annotations_file_path: Path\n) -> None:\n    ensure_file_exists(annotations_file_path)\n    with annotations_file_path.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(annotations.to_json(), f, indent=2)"
    },
    {
      "id": "packager-parser/package_parser.cli._read_and_write_file/_write_api_dependency_file",
      "name": "_write_api_dependency_file",
      "qname": "package_parser.cli._read_and_write_file._write_api_dependency_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_write_api_dependency_file/api",
          "name": "api",
          "qname": "package_parser.cli._read_and_write_file._write_api_dependency_file.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_write_api_dependency_file/api_dependencies",
          "name": "api_dependencies",
          "qname": "package_parser.cli._read_and_write_file._write_api_dependency_file.api_dependencies",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_write_api_dependency_file/out",
          "name": "out",
          "qname": "package_parser.cli._read_and_write_file._write_api_dependency_file.out",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_api_dependency_file(api: API, api_dependencies, out):\n    out_file_api_dependencies = out.joinpath(f\"{api.package}__api_dependencies.json\")\n    ensure_file_exists(out_file_api_dependencies)\n    with out_file_api_dependencies.open(\"w\") as f:\n        json.dump(api_dependencies.to_json(), f, indent=2, cls=CustomEncoder)"
    },
    {
      "id": "packager-parser/package_parser.cli._read_and_write_file/_write_api_file",
      "name": "_write_api_file",
      "qname": "package_parser.cli._read_and_write_file._write_api_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_write_api_file/api",
          "name": "api",
          "qname": "package_parser.cli._read_and_write_file._write_api_file.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._read_and_write_file/_write_api_file/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._read_and_write_file._write_api_file.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_api_file(api: API, out_dir_path: Path) -> Path:\n    out_file_api = out_dir_path.joinpath(f\"{api.package}__api.json\")\n    ensure_file_exists(out_file_api)\n    with out_file_api.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(api.to_json(), f, indent=2, cls=CustomEncoder)\n    return out_file_api"
    },
    {
      "id": "packager-parser/package_parser.cli._run_all/_run_all_command",
      "name": "_run_all_command",
      "qname": "package_parser.cli._run_all._run_all_command",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._run_all/_run_all_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_all._run_all_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_all/_run_all_command/src_dir_path",
          "name": "src_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.src_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_all/_run_all_command/client_dir_path",
          "name": "client_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.client_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_all/_run_all_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_all/_run_all_command/n_processes",
          "name": "n_processes",
          "qname": "package_parser.cli._run_all._run_all_command.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_all/_run_all_command/batch_size",
          "name": "batch_size",
          "qname": "package_parser.cli._run_all._run_all_command.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_all_command(\n    package: str,\n    src_dir_path: Path,\n    client_dir_path: Path,\n    out_dir_path: Path,\n    n_processes: int,\n    batch_size: int,\n) -> None:\n    out_file_annotations = out_dir_path.joinpath(\"annotations.json\")\n    results = _run_in_parallel(\n        partial(_run_api_command, package, src_dir_path, out_dir_path),\n        partial(\n            _run_usages_command,\n            package,\n            client_dir_path,\n            out_dir_path,\n            n_processes,\n            batch_size,\n        ),\n    )\n    _run_annotations(results[_API_KEY], results[_USAGES_KEY], out_file_annotations)"
    },
    {
      "id": "packager-parser/package_parser.cli._run_all/_run_in_parallel",
      "name": "_run_in_parallel",
      "qname": "package_parser.cli._run_all._run_in_parallel",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._run_all/_run_in_parallel/fns",
          "name": "fns",
          "qname": "package_parser.cli._run_all._run_in_parallel.fns",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_in_parallel(*fns) -> dict:\n    manager = multiprocessing.Manager()\n    return_dict: dict[str, str] = manager.dict()\n    proc = []\n    for fn in fns:\n        p = multiprocessing.Process(target=fn, args=(return_dict,))\n        proc.append(p)\n        p.start()\n\n    for p in proc:\n        p.join()\n\n    return return_dict"
    },
    {
      "id": "packager-parser/package_parser.cli._run_annotations/_run_annotations",
      "name": "_run_annotations",
      "qname": "package_parser.cli._run_annotations._run_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._run_annotations/_run_annotations/api_file_path",
          "name": "api_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.api_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_annotations/_run_annotations/usages_file_path",
          "name": "usages_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.usages_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_annotations/_run_annotations/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\nAnnotations that are generated are: remove, constant, required, optional, enum and boundary.\n:param api_file_path: API file Path\n:param usages_file_path: UsageStore file Path\n:param annotations_file_path: Output file Path",
      "docstring": "Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\nAnnotations that are generated are: remove, constant, required, optional, enum and boundary.\n:param api_file_path: API file Path\n:param usages_file_path: UsageStore file Path\n:param annotations_file_path: Output file Path",
      "code": "def _run_annotations(\n    api_file_path: Path, usages_file_path: Path, annotations_file_path: Path\n) -> None:\n    \"\"\"\n    Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\n    Annotations that are generated are: remove, constant, required, optional, enum and boundary.\n    :param api_file_path: API file Path\n    :param usages_file_path: UsageStore file Path\n    :param annotations_file_path: Output file Path\n    \"\"\"\n\n    api = _read_api_file(api_file_path)\n    usages = _read_usages_file(usages_file_path)\n    annotations = generate_annotations(api, usages)\n    _write_annotations_file(annotations, annotations_file_path)"
    },
    {
      "id": "packager-parser/package_parser.cli._run_api/_run_api_command",
      "name": "_run_api_command",
      "qname": "package_parser.cli._run_api._run_api_command",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._run_api/_run_api_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_api._run_api_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_api/_run_api_command/src_dir_path",
          "name": "src_dir_path",
          "qname": "package_parser.cli._run_api._run_api_command.src_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_api/_run_api_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_api._run_api_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_api/_run_api_command/result_dict",
          "name": "result_dict",
          "qname": "package_parser.cli._run_api._run_api_command.result_dict",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_api_command(\n    package: str,\n    src_dir_path: Path,\n    out_dir_path: Path,\n    result_dict: Optional[dict] = None,\n) -> None:\n    api = get_api(package, src_dir_path)\n    api_dependencies = get_dependencies(api)\n\n    api_file_path = _write_api_file(api, out_dir_path)\n    _write_api_dependency_file(api, api_dependencies, out_dir_path)\n\n    if result_dict is not None:\n        result_dict[_API_KEY] = api_file_path"
    },
    {
      "id": "packager-parser/package_parser.cli._run_migrate/_run_migrate_command",
      "name": "_run_migrate_command",
      "qname": "package_parser.cli._run_migrate._run_migrate_command",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._run_migrate/_run_migrate_command/apiv1_file_path",
          "name": "apiv1_file_path",
          "qname": "package_parser.cli._run_migrate._run_migrate_command.apiv1_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_migrate/_run_migrate_command/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._run_migrate._run_migrate_command.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_migrate/_run_migrate_command/apiv2_file_path",
          "name": "apiv2_file_path",
          "qname": "package_parser.cli._run_migrate._run_migrate_command.apiv2_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_migrate/_run_migrate_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_migrate._run_migrate_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_migrate_command(\n    apiv1_file_path: Path,\n    annotations_file_path: Path,\n    apiv2_file_path: Path,\n    out_dir_path: Path,\n) -> None:\n    apiv1 = _read_api_file(apiv1_file_path)\n    apiv2 = _read_api_file(apiv2_file_path)\n    annotationsv1 = _read_annotations_file(annotations_file_path)\n\n    differ_init_list: list[tuple[type[AbstractDiffer], dict[str, Any]]] = [\n        (SimpleDiffer, {}),\n        (StrictDiffer, {}),\n        (InheritanceDiffer, {}),\n    ]\n    previous_base_differ = None\n    previous_mappings: list[Mapping] = []\n\n    for differ_init in differ_init_list:\n        differ_class, additional_parameters = differ_init\n        differ = differ_class(\n            previous_base_differ,\n            previous_mappings,\n            apiv1,\n            apiv2,\n            **additional_parameters\n        )\n        api_mapping = APIMapping(apiv1, apiv2, differ)\n        mappings = api_mapping.map_api()\n\n        previous_mappings = mappings\n        previous_base_differ = (\n            differ\n            if differ.get_related_mappings() is None\n            else differ.previous_base_differ\n        )\n\n    if previous_mappings is not None:\n        migration = Migration(annotationsv1, previous_mappings)\n        migration.migrate_annotations()\n        migration.print(apiv1, apiv2)\n        migrated_annotations_file = Path(\n            os.path.join(\n                out_dir_path, \"migrated_annotationsv\" + apiv2.version + \".json\"\n            )\n        )\n        unsure_migrated_annotations_file = Path(\n            os.path.join(\n                out_dir_path, \"unsure_migrated_annotationsv\" + apiv2.version + \".json\"\n            )\n        )\n        _write_annotations_file(\n            migration.migrated_annotation_store, migrated_annotations_file\n        )\n        _write_annotations_file(\n            migration.unsure_migrated_annotation_store, unsure_migrated_annotations_file\n        )"
    },
    {
      "id": "packager-parser/package_parser.cli._run_usages/_run_usages_command",
      "name": "_run_usages_command",
      "qname": "package_parser.cli._run_usages._run_usages_command",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.cli._run_usages/_run_usages_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_usages._run_usages_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_usages/_run_usages_command/client_dir_path",
          "name": "client_dir_path",
          "qname": "package_parser.cli._run_usages._run_usages_command.client_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_usages/_run_usages_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_usages._run_usages_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_usages/_run_usages_command/n_processes",
          "name": "n_processes",
          "qname": "package_parser.cli._run_usages._run_usages_command.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_usages/_run_usages_command/batch_size",
          "name": "batch_size",
          "qname": "package_parser.cli._run_usages._run_usages_command.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.cli._run_usages/_run_usages_command/result_dict",
          "name": "result_dict",
          "qname": "package_parser.cli._run_usages._run_usages_command.result_dict",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_usages_command(\n    package: str,\n    client_dir_path: Path,\n    out_dir_path: Path,\n    n_processes: int,\n    batch_size: int,\n    result_dict: Optional[dict] = None,\n) -> None:\n    usages = find_usages(package, client_dir_path, n_processes, batch_size)\n\n    out_file_usage_count = out_dir_path.joinpath(f\"{package}__usage_counts.json\")\n    ensure_file_exists(out_file_usage_count)\n    with out_file_usage_count.open(\"w\") as f:\n        json.dump(usages.to_json(), f, indent=2)\n\n    if result_dict is not None:\n        result_dict[_USAGES_KEY] = out_file_usage_count"
    },
    {
      "id": "packager-parser/package_parser.main/main",
      "name": "main",
      "qname": "package_parser.main.main",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def main() -> None:\n    start_time = time.time()\n\n    cli()\n\n    print(\"\\n============================================================\")\n    print(f\"Program ran in {time.time() - start_time}s\")"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_annotations/generate_annotations",
      "name": "generate_annotations",
      "qname": "package_parser.processing.annotations._generate_annotations.generate_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_annotations/generate_annotations/api",
          "name": "api",
          "qname": "package_parser.processing.annotations._generate_annotations.generate_annotations.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_annotations/generate_annotations/usages",
          "name": "usages",
          "qname": "package_parser.processing.annotations._generate_annotations.generate_annotations.usages",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def generate_annotations(api: API, usages: UsageCountStore) -> AnnotationStore:\n    _preprocess_usages(usages, api)\n\n    annotations = AnnotationStore()\n    _generate_remove_annotations(api, usages, annotations)\n    _generate_value_annotations(api, usages, annotations)\n    _generate_enum_annotations(api, annotations)\n    _generate_boundary_annotations(api, annotations)\n    return annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_boundary_annotations/_generate_boundary_annotations",
      "name": "_generate_boundary_annotations",
      "qname": "package_parser.processing.annotations._generate_boundary_annotations._generate_boundary_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_boundary_annotations/_generate_boundary_annotations/api",
          "name": "api",
          "qname": "package_parser.processing.annotations._generate_boundary_annotations._generate_boundary_annotations.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_boundary_annotations/_generate_boundary_annotations/annotations",
          "name": "annotations",
          "qname": "package_parser.processing.annotations._generate_boundary_annotations._generate_boundary_annotations.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Annotates all parameters which are a boundary.\n:param api: Description of the API\n:param annotations: AnnotationStore, that holds all annotations",
      "docstring": "Annotates all parameters which are a boundary.\n:param api: Description of the API\n:param annotations: AnnotationStore, that holds all annotations",
      "code": "def _generate_boundary_annotations(api: API, annotations: AnnotationStore) -> None:\n    \"\"\"\n    Annotates all parameters which are a boundary.\n    :param api: Description of the API\n    :param annotations: AnnotationStore, that holds all annotations\n    \"\"\"\n    # pylint: disable=duplicate-code\n    for _, parameter in api.parameters().items():\n\n        # Don't add boundary annotation to constant parameters\n        if parameter.id in set(\n            annotation.target\n            for annotation in annotations.valueAnnotations\n            if annotation.variant == ValueAnnotation.Variant.CONSTANT\n        ):\n            continue\n\n        parameter_type = parameter.type\n        if parameter_type is None:\n            continue\n\n        boundary_type: Optional[BoundaryType] = None\n\n        if isinstance(parameter_type, UnionType):\n            for type_in_union in parameter_type.types:\n                if isinstance(type_in_union, BoundaryType):\n                    boundary_type = type_in_union\n\n        if isinstance(parameter_type, BoundaryType):\n            boundary_type = parameter_type\n\n        if boundary_type is not None:\n            min_value = boundary_type.min\n            max_value = boundary_type.max\n\n            is_discrete = boundary_type.base_type == \"int\"\n\n            min_limit_type = 0\n            max_limit_type = 0\n            if not boundary_type.min_inclusive:\n                min_limit_type = 1\n            if not boundary_type.max_inclusive:\n                max_limit_type = 1\n            if min_value == \"NegativeInfinity\":\n                min_value = 0\n                min_limit_type = 2\n            if max_value == \"Infinity\":\n                max_value = 0\n                max_limit_type = 2\n\n            interval = Interval(\n                isDiscrete=is_discrete,\n                lowerIntervalLimit=min_value,\n                upperIntervalLimit=max_value,\n                lowerLimitType=min_limit_type,\n                upperLimitType=max_limit_type,\n            )\n            boundary = BoundaryAnnotation(\n                target=parameter.id,\n                authors=[autogen_author],\n                reviewers=[],\n                comment=f\"I turned this into a bounded number because the description contained {boundary_type.full_match}.\",\n                interval=interval,\n                reviewResult=EnumReviewResult.NONE,\n            )\n            annotations.boundaryAnnotations.append(boundary)"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_enum_instance_name",
      "name": "_enum_instance_name",
      "qname": "package_parser.processing.annotations._generate_enum_annotations._enum_instance_name",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_enum_instance_name/string_value",
          "name": "string_value",
          "qname": "package_parser.processing.annotations._generate_enum_annotations._enum_instance_name.string_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _enum_instance_name(string_value: str) -> str:\n    segments = re.split(r\"[_\\-.]\", string_value)\n\n    result = \"_\".join(\n        re.sub(r\"\\W\", \"\", segment).upper()\n        for segment in segments\n        if re.sub(r\"\\W\", \"\", segment) != \"\"\n    )\n\n    if len(result) == 0 or result[0].isdigit():\n        result = \"_\" + result\n\n    return result"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_enum_name",
      "name": "_enum_name",
      "qname": "package_parser.processing.annotations._generate_enum_annotations._enum_name",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_enum_name/parameter_name",
          "name": "parameter_name",
          "qname": "package_parser.processing.annotations._generate_enum_annotations._enum_name.parameter_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _enum_name(parameter_name: str) -> str:\n    segments = re.split(r\"_\", parameter_name)\n\n    return \"\".join([segment.capitalize() for segment in segments if segment != \"\"])"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_enum_pairs",
      "name": "_enum_pairs",
      "qname": "package_parser.processing.annotations._generate_enum_annotations._enum_pairs",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_enum_pairs/enum_type",
          "name": "enum_type",
          "qname": "package_parser.processing.annotations._generate_enum_annotations._enum_pairs.enum_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _enum_pairs(enum_type: EnumType) -> list[EnumPair]:\n    result = []\n\n    sorted_values = sorted(list(enum_type.values))\n    for string_value in sorted_values:\n        instance_name = _enum_instance_name(string_value)\n        result.append(EnumPair(stringValue=string_value, instanceName=instance_name))\n\n    return result"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_generate_enum_annotations",
      "name": "_generate_enum_annotations",
      "qname": "package_parser.processing.annotations._generate_enum_annotations._generate_enum_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_generate_enum_annotations/api",
          "name": "api",
          "qname": "package_parser.processing.annotations._generate_enum_annotations._generate_enum_annotations.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_enum_annotations/_generate_enum_annotations/annotations",
          "name": "annotations",
          "qname": "package_parser.processing.annotations._generate_enum_annotations._generate_enum_annotations.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns all parameters that are never used.\n:param api: API object for usages\n:param annotations: AnnotationStore object",
      "docstring": "Returns all parameters that are never used.\n:param api: API object for usages\n:param annotations: AnnotationStore object",
      "code": "def _generate_enum_annotations(api: API, annotations: AnnotationStore) -> None:\n    \"\"\"\n    Returns all parameters that are never used.\n    :param api: API object for usages\n    :param annotations: AnnotationStore object\n    \"\"\"\n    # pylint: disable=duplicate-code\n    for _, parameter in api.parameters().items():\n\n        # Don't add enum annotation to constant parameters\n        if parameter.id in set(\n            annotation.target\n            for annotation in annotations.valueAnnotations\n            if annotation.variant == ValueAnnotation.Variant.CONSTANT\n        ):\n            continue\n\n        parameter_type = parameter.type\n        if parameter_type is None:\n            continue\n\n        pairs = []\n        full_match = \"\"\n        if isinstance(parameter_type, EnumType):\n            pairs = _enum_pairs(parameter_type)\n            full_match = parameter_type.full_match\n\n        if len(pairs) > 0:\n            enum_name = _enum_name(parameter.name)\n            annotations.enumAnnotations.append(\n                EnumAnnotation(\n                    target=parameter.id,\n                    authors=[autogen_author],\n                    reviewers=[],\n                    comment=f\"I turned this into an enum because the type in the documentation contained {full_match}.\",\n                    enumName=enum_name,\n                    pairs=pairs,\n                    reviewResult=EnumReviewResult.NONE,\n                )\n            )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_remove_annotations/_create_explanation",
      "name": "_create_explanation",
      "qname": "package_parser.processing.annotations._generate_remove_annotations._create_explanation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_remove_annotations/_create_explanation/declaration_type",
          "name": "declaration_type",
          "qname": "package_parser.processing.annotations._generate_remove_annotations._create_explanation.declaration_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_remove_annotations/_create_explanation/n_usages",
          "name": "n_usages",
          "qname": "package_parser.processing.annotations._generate_remove_annotations._create_explanation.n_usages",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _create_explanation(declaration_type: str, n_usages: int) -> str:\n    result = f\"I removed this {declaration_type} because it has\"\n\n    if n_usages == 0:\n        result += \" no known usages.\"\n    elif n_usages == 1:\n        result += \" only one known usage.\"\n    else:\n        result += f\" only {n_usages} known usages.\"\n\n    return result"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_remove_annotations/_generate_remove_annotations",
      "name": "_generate_remove_annotations",
      "qname": "package_parser.processing.annotations._generate_remove_annotations._generate_remove_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_remove_annotations/_generate_remove_annotations/api",
          "name": "api",
          "qname": "package_parser.processing.annotations._generate_remove_annotations._generate_remove_annotations.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_remove_annotations/_generate_remove_annotations/usages",
          "name": "usages",
          "qname": "package_parser.processing.annotations._generate_remove_annotations._generate_remove_annotations.usages",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_remove_annotations/_generate_remove_annotations/annotations",
          "name": "annotations",
          "qname": "package_parser.processing.annotations._generate_remove_annotations._generate_remove_annotations.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Collect all functions and classes that are never used.\n:param usages: UsageStore object\n:param api: API object for usages\n:param annotations: AnnotationStore object",
      "docstring": "Collect all functions and classes that are never used.\n:param usages: UsageStore object\n:param api: API object for usages\n:param annotations: AnnotationStore object",
      "code": "def _generate_remove_annotations(\n    api: API, usages: UsageCountStore, annotations: AnnotationStore\n) -> None:\n    \"\"\"\n    Collect all functions and classes that are never used.\n    :param usages: UsageStore object\n    :param api: API object for usages\n    :param annotations: AnnotationStore object\n    \"\"\"\n    for class_ in api.classes.values():\n        n_class_usages = usages.n_class_usages(class_.id)\n        if n_class_usages == 0:\n            annotations.removeAnnotations.append(\n                RemoveAnnotation(\n                    target=class_.id,\n                    authors=[autogen_author],\n                    reviewers=[],\n                    comment=_create_explanation(\"class\", n_class_usages),\n                    reviewResult=EnumReviewResult.NONE,\n                )\n            )\n\n    for function in api.functions.values():\n        n_function_usages = usages.n_function_usages(function.id)\n        if n_function_usages == 0:\n            annotations.removeAnnotations.append(\n                RemoveAnnotation(\n                    target=function.id,\n                    authors=[autogen_author],\n                    reviewers=[],\n                    comment=_create_explanation(\"function\", n_function_usages),\n                    reviewResult=EnumReviewResult.NONE,\n                )\n            )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_constant_annotation",
      "name": "_generate_constant_annotation",
      "qname": "package_parser.processing.annotations._generate_value_annotations._generate_constant_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_constant_annotation/parameter",
          "name": "parameter",
          "qname": "package_parser.processing.annotations._generate_value_annotations._generate_constant_annotation.parameter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_constant_annotation/sole_stringified_value",
          "name": "sole_stringified_value",
          "qname": "package_parser.processing.annotations._generate_value_annotations._generate_constant_annotation.sole_stringified_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_constant_annotation/annotations",
          "name": "annotations",
          "qname": "package_parser.processing.annotations._generate_value_annotations._generate_constant_annotation.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Collect all parameters that are only ever assigned a single value.\n:param parameter: Parameter to be annotated\n:param sole_stringified_value: The sole value that is assigned to the parameter\n:param annotations: AnnotationStore object",
      "docstring": "Collect all parameters that are only ever assigned a single value.\n:param parameter: Parameter to be annotated\n:param sole_stringified_value: The sole value that is assigned to the parameter\n:param annotations: AnnotationStore object",
      "code": "def _generate_constant_annotation(\n    parameter: Parameter, sole_stringified_value: str, annotations: AnnotationStore\n) -> None:\n    \"\"\"\n    Collect all parameters that are only ever assigned a single value.\n    :param parameter: Parameter to be annotated\n    :param sole_stringified_value: The sole value that is assigned to the parameter\n    :param annotations: AnnotationStore object\n    \"\"\"\n\n    # Always set to original default value\n    if sole_stringified_value == parameter.default_value:\n        annotations.valueAnnotations.append(\n            OmittedAnnotation(\n                target=parameter.id,\n                authors=[autogen_author],\n                reviewers=[],\n                comment=f\"I omitted this parameter because it is always set to the original default value ({parameter.default_value}).\",\n                reviewResult=EnumReviewResult.NONE,\n            )\n        )\n        return\n\n    default_value_type, default_value = _get_type_and_value_for_stringified_value(\n        sole_stringified_value\n    )\n    if default_value_type is not None:\n        annotations.valueAnnotations.append(\n            ConstantAnnotation(\n                target=parameter.id,\n                authors=[autogen_author],\n                reviewers=[],\n                comment=f\"I replaced this parameter with a constant because it is always set to the same literal value ({sole_stringified_value}).\",\n                reviewResult=EnumReviewResult.NONE,\n                defaultValueType=default_value_type,\n                defaultValue=default_value,\n            )\n        )\n    else:\n        annotations.valueAnnotations.append(\n            RequiredAnnotation(\n                target=parameter.id,\n                authors=[autogen_author],\n                reviewers=[],\n                comment=f\"I made this parameter required because, even though it is always set to the same value ({sole_stringified_value}), that value is not a literal.\",\n                reviewResult=EnumReviewResult.NONE,\n            )\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_required_or_optional_annotation",
      "name": "_generate_required_or_optional_annotation",
      "qname": "package_parser.processing.annotations._generate_value_annotations._generate_required_or_optional_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_required_or_optional_annotation/parameter",
          "name": "parameter",
          "qname": "package_parser.processing.annotations._generate_value_annotations._generate_required_or_optional_annotation.parameter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_required_or_optional_annotation/usages",
          "name": "usages",
          "qname": "package_parser.processing.annotations._generate_value_annotations._generate_required_or_optional_annotation.usages",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_required_or_optional_annotation/annotations",
          "name": "annotations",
          "qname": "package_parser.processing.annotations._generate_value_annotations._generate_required_or_optional_annotation.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _generate_required_or_optional_annotation(\n    parameter: Parameter, usages: UsageCountStore, annotations: AnnotationStore\n) -> None:\n    most_common_values = usages.most_common_parameter_values(parameter.id)\n    if len(most_common_values) < 2:\n        return\n\n    # If the most common value is not a stringified literal, make parameter required\n    if not _is_stringified_literal(most_common_values[0]):\n        annotations.valueAnnotations.append(\n            RequiredAnnotation(\n                target=parameter.id,\n                authors=[autogen_author],\n                reviewers=[],\n                comment=f\"I made this parameter required because the most common value ({most_common_values[0]}) is not a literal.\",\n                reviewResult=EnumReviewResult.NONE,\n            )\n        )\n        return\n\n    # Compute metrics\n    most_common_value_count = usages.n_value_usages(parameter.id, most_common_values[0])\n    second_most_common_value_count = usages.n_value_usages(\n        parameter.id, most_common_values[1]\n    )\n\n    # Add appropriate annotation\n    should_be_required, comment = _should_be_required(\n        most_common_values[0],\n        most_common_value_count,\n        most_common_values[1],\n        second_most_common_value_count,\n    )\n    if should_be_required:\n        annotations.valueAnnotations.append(\n            RequiredAnnotation(\n                target=parameter.id,\n                authors=[autogen_author],\n                reviewers=[],\n                comment=comment,\n                reviewResult=EnumReviewResult.NONE,\n            )\n        )\n    else:\n        (\n            default_value_type,\n            default_value,\n        ) = _get_type_and_value_for_stringified_value(most_common_values[0])\n        if default_value_type is not None:  # Just for mypy, always true\n            annotations.valueAnnotations.append(\n                OptionalAnnotation(\n                    target=parameter.id,\n                    authors=[autogen_author],\n                    reviewers=[],\n                    comment=comment,\n                    reviewResult=EnumReviewResult.NONE,\n                    defaultValueType=default_value_type,\n                    defaultValue=default_value,\n                )\n            )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_value_annotations",
      "name": "_generate_value_annotations",
      "qname": "package_parser.processing.annotations._generate_value_annotations._generate_value_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_value_annotations/api",
          "name": "api",
          "qname": "package_parser.processing.annotations._generate_value_annotations._generate_value_annotations.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_value_annotations/usages",
          "name": "usages",
          "qname": "package_parser.processing.annotations._generate_value_annotations._generate_value_annotations.usages",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_generate_value_annotations/annotations",
          "name": "annotations",
          "qname": "package_parser.processing.annotations._generate_value_annotations._generate_value_annotations.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _generate_value_annotations(\n    api: API, usages: UsageCountStore, annotations: AnnotationStore\n) -> None:\n    for parameter in api.parameters().values():\n\n        # Don't create annotations for variadic parameters\n        if parameter.assigned_by in (\n            ParameterAssignment.POSITIONAL_VARARG,\n            ParameterAssignment.NAMED_VARARG,\n        ):\n            continue\n\n        parameter_values = usages.most_common_parameter_values(parameter.id)\n\n        if len(parameter_values) == 1:\n            _generate_constant_annotation(parameter, parameter_values[0], annotations)\n        elif len(parameter_values) > 1:\n            _generate_required_or_optional_annotation(parameter, usages, annotations)"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_get_type_and_value_for_stringified_value",
      "name": "_get_type_and_value_for_stringified_value",
      "qname": "package_parser.processing.annotations._generate_value_annotations._get_type_and_value_for_stringified_value",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_get_type_and_value_for_stringified_value/stringified_value",
          "name": "stringified_value",
          "qname": "package_parser.processing.annotations._generate_value_annotations._get_type_and_value_for_stringified_value.stringified_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_type_and_value_for_stringified_value(\n    stringified_value: str,\n) -> tuple[Optional[ValueAnnotation.DefaultValueType], Any]:\n    if stringified_value == \"None\":\n        return ValueAnnotation.DefaultValueType.NONE, None\n    if stringified_value in (\"True\", \"False\"):\n        return ValueAnnotation.DefaultValueType.BOOLEAN, stringified_value == \"True\"\n    if _is_float(stringified_value):\n        return ValueAnnotation.DefaultValueType.NUMBER, float(stringified_value)\n    if stringified_value[0] == \"'\" and stringified_value[-1] == \"'\":\n        return ValueAnnotation.DefaultValueType.STRING, stringified_value[1:-1]\n    return None, None"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_is_float",
      "name": "_is_float",
      "qname": "package_parser.processing.annotations._generate_value_annotations._is_float",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_is_float/stringified_value",
          "name": "stringified_value",
          "qname": "package_parser.processing.annotations._generate_value_annotations._is_float.stringified_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _is_float(stringified_value: str) -> bool:\n    try:\n        float(stringified_value)\n        return True\n    except ValueError:\n        return False"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_is_stringified_literal",
      "name": "_is_stringified_literal",
      "qname": "package_parser.processing.annotations._generate_value_annotations._is_stringified_literal",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_is_stringified_literal/stringified_value",
          "name": "stringified_value",
          "qname": "package_parser.processing.annotations._generate_value_annotations._is_stringified_literal.stringified_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _is_stringified_literal(stringified_value: str) -> bool:\n    default_type, _ = _get_type_and_value_for_stringified_value(stringified_value)\n    return default_type is not None"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_should_be_required",
      "name": "_should_be_required",
      "qname": "package_parser.processing.annotations._generate_value_annotations._should_be_required",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_should_be_required/most_common_value",
          "name": "most_common_value",
          "qname": "package_parser.processing.annotations._generate_value_annotations._should_be_required.most_common_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_should_be_required/most_common_value_count",
          "name": "most_common_value_count",
          "qname": "package_parser.processing.annotations._generate_value_annotations._should_be_required.most_common_value_count",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_should_be_required/second_most_common_value",
          "name": "second_most_common_value",
          "qname": "package_parser.processing.annotations._generate_value_annotations._should_be_required.second_most_common_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._generate_value_annotations/_should_be_required/second_most_common_value_count",
          "name": "second_most_common_value_count",
          "qname": "package_parser.processing.annotations._generate_value_annotations._should_be_required.second_most_common_value_count",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This function determines how to differentiate between an optional and a required parameter\n:param most_common_value_count: How often the most common value is used\n:param second_most_common_value_count: How often the second most common value is used\n:return: True means the parameter should be required, False means it should be optional. The second result is an\nexplanation.",
      "docstring": "This function determines how to differentiate between an optional and a required parameter\n:param most_common_value_count: How often the most common value is used\n:param second_most_common_value_count: How often the second most common value is used\n:return: True means the parameter should be required, False means it should be optional. The second result is an\nexplanation.",
      "code": "def _should_be_required(\n    most_common_value: str,\n    most_common_value_count: int,\n    second_most_common_value: str,\n    second_most_common_value_count: int,\n) -> tuple[bool, str]:\n    \"\"\"\n    This function determines how to differentiate between an optional and a required parameter\n    :param most_common_value_count: How often the most common value is used\n    :param second_most_common_value_count: How often the second most common value is used\n    :return: True means the parameter should be required, False means it should be optional. The second result is an\n    explanation.\n    \"\"\"\n\n    # Shortcut to speed up the check\n    if most_common_value_count == second_most_common_value_count:\n        return (\n            True,\n            f\"I made this parameter required because there is no single most common value ({most_common_value} and {second_most_common_value} are both used {pluralize(most_common_value_count, 'time')}).\",\n        )\n\n    # Precaution to ensure proper order of most_common_value_count and second_most_common_value_count\n    if second_most_common_value_count > most_common_value_count:\n        most_common_value_count, second_most_common_value_count = (\n            second_most_common_value_count,\n            most_common_value_count,\n        )\n\n    total = most_common_value_count + second_most_common_value_count\n\n    # Our null hypothesis is that the user chooses between the most common and second most common value by a fair coin\n    # toss. Unless this hypothesis is rejected, we make the parameter required. We reject the hypothesis if the p-value\n    # is less than or equal to 5%. The p-value is the probability that we observe results that are at least as extreme\n    # as the values we observed, assuming the null hypothesis is true.\n    p_value = 2 * sum(\n        binom.pmf(i, total, 0.5) for i in range(most_common_value_count, total + 1)\n    )\n    significance_level = 0.05\n\n    if p_value <= significance_level:\n        return (\n            False,\n            f\"I made this parameter optional because there is a statistically significant most common value (p-value {p_value:.2%} <= significance level {significance_level:.0%}).\",\n        )\n    return (\n        True,\n        f\"I made this parameter required because there is no statistically significant most common value (p-value ({p_value:.2%}) > significance level ({significance_level:.0%}).\",\n    )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor/_add_implicit_usages_of_default_value",
      "name": "_add_implicit_usages_of_default_value",
      "qname": "package_parser.processing.annotations._usages_preprocessor._add_implicit_usages_of_default_value",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor/_add_implicit_usages_of_default_value/usages",
          "name": "usages",
          "qname": "package_parser.processing.annotations._usages_preprocessor._add_implicit_usages_of_default_value.usages",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor/_add_implicit_usages_of_default_value/api",
          "name": "api",
          "qname": "package_parser.processing.annotations._usages_preprocessor._add_implicit_usages_of_default_value.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Adds the implicit usages of a parameters default value. When a function is called and a parameter is used with its\ndefault value, that usage of a value is not part of the UsageStore, so  we need to add it.\n\n:param usages: Usage store\n:param api: Description of the API",
      "docstring": "Adds the implicit usages of a parameters default value. When a function is called and a parameter is used with its\ndefault value, that usage of a value is not part of the UsageStore, so  we need to add it.\n\n:param usages: Usage store\n:param api: Description of the API",
      "code": "def _add_implicit_usages_of_default_value(usages: UsageCountStore, api: API) -> None:\n    \"\"\"\n    Adds the implicit usages of a parameters default value. When a function is called and a parameter is used with its\n    default value, that usage of a value is not part of the UsageStore, so  we need to add it.\n\n    :param usages: Usage store\n    :param api: Description of the API\n    \"\"\"\n\n    for parameter_id, parameter_usage_count in list(usages.parameter_usages.items()):\n        default_value = api.get_default_value(parameter_id)\n        if default_value is None:\n            continue\n\n        function_id = parent_id(parameter_id)\n        function_usage_count = usages.n_function_usages(function_id)\n\n        n_locations_of_implicit_usages_of_default_value = (\n            function_usage_count - parameter_usage_count\n        )\n        usages.add_value_usages(\n            parameter_id,\n            default_value,\n            n_locations_of_implicit_usages_of_default_value,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor/_add_unused_api_elements",
      "name": "_add_unused_api_elements",
      "qname": "package_parser.processing.annotations._usages_preprocessor._add_unused_api_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor/_add_unused_api_elements/usages",
          "name": "usages",
          "qname": "package_parser.processing.annotations._usages_preprocessor._add_unused_api_elements.usages",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor/_add_unused_api_elements/api",
          "name": "api",
          "qname": "package_parser.processing.annotations._usages_preprocessor._add_unused_api_elements.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Adds unused API elements to the UsageStore. When a class, function or parameter is not used, it is not content of\nthe UsageStore, so we need to add it.\n\n:param usages: Usage store\n:param api: Description of the API",
      "docstring": "Adds unused API elements to the UsageStore. When a class, function or parameter is not used, it is not content of\nthe UsageStore, so we need to add it.\n\n:param usages: Usage store\n:param api: Description of the API",
      "code": "def _add_unused_api_elements(usages: UsageCountStore, api: API) -> None:\n    \"\"\"\n    Adds unused API elements to the UsageStore. When a class, function or parameter is not used, it is not content of\n    the UsageStore, so we need to add it.\n\n    :param usages: Usage store\n    :param api: Description of the API\n    \"\"\"\n\n    for class_id in api.classes:\n        usages.add_class_usages(class_id, 0)\n\n    for function in api.functions.values():\n        usages.add_function_usages(function.id, 0)\n\n        for parameter in function.parameters:\n            usages.add_parameter_usages(parameter.id, 0)\n            usages.init_value(parameter.id)"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor/_preprocess_usages",
      "name": "_preprocess_usages",
      "qname": "package_parser.processing.annotations._usages_preprocessor._preprocess_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor/_preprocess_usages/usages",
          "name": "usages",
          "qname": "package_parser.processing.annotations._usages_preprocessor._preprocess_usages.usages",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations._usages_preprocessor/_preprocess_usages/api",
          "name": "api",
          "qname": "package_parser.processing.annotations._usages_preprocessor._preprocess_usages.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _preprocess_usages(usages: UsageCountStore, api: API) -> None:\n    _add_unused_api_elements(usages, api)\n    _add_implicit_usages_of_default_value(usages, api)"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/add_annotation",
      "name": "add_annotation",
      "qname": "package_parser.processing.annotations.model._AnnotationStore.AnnotationStore.add_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/add_annotation/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._AnnotationStore.AnnotationStore.add_annotation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/add_annotation/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.annotations.model._AnnotationStore.AnnotationStore.add_annotation.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_annotation(self, annotation: AbstractAnnotation) -> None:\n        if isinstance(annotation, BoundaryAnnotation):\n            self.boundaryAnnotations.append(annotation)\n        elif isinstance(annotation, CalledAfterAnnotation):\n            self.calledAfterAnnotations.append(annotation)\n        elif isinstance(annotation, CompleteAnnotation):\n            self.completeAnnotations.append(annotation)\n        elif isinstance(annotation, DescriptionAnnotation):\n            self.descriptionAnnotations.append(annotation)\n        elif isinstance(annotation, EnumAnnotation):\n            self.enumAnnotations.append(annotation)\n        elif isinstance(annotation, ExpertAnnotation):\n            self.expertAnnotations.append(annotation)\n        elif isinstance(annotation, GroupAnnotation):\n            self.groupAnnotations.append(annotation)\n        elif isinstance(annotation, MoveAnnotation):\n            self.moveAnnotations.append(annotation)\n        elif isinstance(annotation, PureAnnotation):\n            self.pureAnnotations.append(annotation)\n        elif isinstance(annotation, RemoveAnnotation):\n            self.removeAnnotations.append(annotation)\n        elif isinstance(annotation, RenameAnnotation):\n            self.renameAnnotations.append(annotation)\n        elif isinstance(annotation, TodoAnnotation):\n            self.todoAnnotations.append(annotation)\n        elif isinstance(annotation, ValueAnnotation):\n            self.valueAnnotations.append(annotation)"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._AnnotationStore.AnnotationStore.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._AnnotationStore.AnnotationStore.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> AnnotationStore:\n        if json[\"schemaVersion\"] == 1:\n            raise Exception(\n                \"Incompatible Annotation File: This file is not compatible with the current version.\"\n            )\n\n        boundaryAnnotations = []\n        for annotation in json[\"boundaryAnnotations\"].values():\n            boundaryAnnotations.append(BoundaryAnnotation.from_json(annotation))\n\n        calledAfterAnnotations = []\n        for annotation in json[\"calledAfterAnnotations\"].values():\n            calledAfterAnnotations.append(CalledAfterAnnotation.from_json(annotation))\n\n        completeAnnotations = []\n        for annotation in json[\"completeAnnotations\"].values():\n            completeAnnotations.append(CompleteAnnotation.from_json(annotation))\n\n        descriptionAnnotations = []\n        for annotation in json[\"descriptionAnnotations\"].values():\n            descriptionAnnotations.append(DescriptionAnnotation.from_json(annotation))\n\n        enumAnnotations = []\n        for annotation in json[\"enumAnnotations\"].values():\n            enumAnnotations.append(EnumAnnotation.from_json(annotation))\n\n        expertAnnotations = []\n        for annotation in json[\"expertAnnotations\"].values():\n            expertAnnotations.append(ExpertAnnotation.from_json(annotation))\n\n        groupAnnotations = []\n        for annotation in json[\"groupAnnotations\"].values():\n            groupAnnotations.append(GroupAnnotation.from_json(annotation))\n\n        moveAnnotations = []\n        for annotation in json[\"moveAnnotations\"].values():\n            moveAnnotations.append(MoveAnnotation.from_json(annotation))\n\n        pureAnnotations = []\n        for annotation in json[\"pureAnnotations\"].values():\n            pureAnnotations.append(PureAnnotation.from_json(annotation))\n\n        removeAnnotations = []\n        for annotation in json[\"removeAnnotations\"].values():\n            removeAnnotations.append(RemoveAnnotation.from_json(annotation))\n\n        renameAnnotations = []\n        for annotation in json[\"renameAnnotations\"].values():\n            renameAnnotations.append(RenameAnnotation.from_json(annotation))\n\n        todoAnnotations = []\n        for annotation in json[\"todoAnnotations\"].values():\n            todoAnnotations.append(TodoAnnotation.from_json(annotation))\n\n        valueAnnotations = []\n        for annotation in json[\"valueAnnotations\"].values():\n            valueAnnotations.append(ValueAnnotation.from_json(annotation))\n\n        return AnnotationStore(\n            boundaryAnnotations,\n            calledAfterAnnotations,\n            completeAnnotations,\n            descriptionAnnotations,\n            enumAnnotations,\n            expertAnnotations,\n            groupAnnotations,\n            moveAnnotations,\n            pureAnnotations,\n            removeAnnotations,\n            renameAnnotations,\n            todoAnnotations,\n            valueAnnotations,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._AnnotationStore.AnnotationStore.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._AnnotationStore/AnnotationStore/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._AnnotationStore.AnnotationStore.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"schemaVersion\": ANNOTATION_SCHEMA_VERSION,\n            \"boundaryAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.boundaryAnnotations\n            },\n            \"calledAfterAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.calledAfterAnnotations\n            },\n            \"completeAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.completeAnnotations\n            },\n            \"descriptionAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.descriptionAnnotations\n            },\n            \"enumAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.enumAnnotations\n            },\n            \"expertAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.expertAnnotations\n            },\n            \"groupAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.groupAnnotations\n            },\n            \"moveAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.moveAnnotations\n            },\n            \"pureAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.pureAnnotations\n            },\n            \"renameAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.renameAnnotations\n            },\n            \"removeAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.removeAnnotations\n            },\n            \"todoAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.todoAnnotations\n            },\n            \"valueAnnotations\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.valueAnnotations\n            },\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/AbstractAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.AbstractAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/AbstractAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.AbstractAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> AbstractAnnotation:\n        review_result = EnumReviewResult(json.get(\"reviewResult\", \"\"))\n\n        return AbstractAnnotation(\n            json[\"target\"],\n            json[\"authors\"],\n            json[\"reviewers\"],\n            json.get(\"comment\", \"\"),\n            review_result,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/AbstractAnnotation/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.AbstractAnnotation.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/AbstractAnnotation/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.AbstractAnnotation.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return asdict(self, dict_factory=EnumReviewResult.to_json)"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/BoundaryAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.BoundaryAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/BoundaryAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.BoundaryAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> BoundaryAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return BoundaryAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            Interval.from_json(json[\"interval\"]),\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/BoundaryAnnotation/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.BoundaryAnnotation.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/BoundaryAnnotation/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.BoundaryAnnotation.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"interval\": self.interval.to_json(),\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/CalledAfterAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.CalledAfterAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/CalledAfterAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.CalledAfterAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> CalledAfterAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return CalledAfterAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"calledAfterName\"],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/CompleteAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.CompleteAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/CompleteAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.CompleteAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> CompleteAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return CompleteAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ConstantAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.ConstantAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/ConstantAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.ConstantAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> ConstantAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return ConstantAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            ValueAnnotation.DefaultValueType(json[\"defaultValueType\"]),\n            json[\"defaultValue\"],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ConstantAnnotation/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.ConstantAnnotation.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/ConstantAnnotation/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.ConstantAnnotation.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"variant\": self.variant.value,\n            \"defaultValueType\": self.defaultValueType.value,\n            \"defaultValue\": self.defaultValue,\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/DescriptionAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.DescriptionAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/DescriptionAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.DescriptionAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> DescriptionAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return DescriptionAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"newDescription\"],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.EnumAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.EnumAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> EnumAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        pairs = [EnumPair.from_json(enum_pair) for enum_pair in json[\"pairs\"]]\n        return EnumAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"enumName\"],\n            pairs,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumAnnotation/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.EnumAnnotation.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumAnnotation/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.EnumAnnotation.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"enumName\": self.enumName,\n            \"pairs\": [pair.to_json() for pair in self.pairs],\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/__eq__",
      "name": "__eq__",
      "qname": "package_parser.processing.annotations.model._annotations.EnumPair.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/__eq__/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.EnumPair.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/__eq__/other",
          "name": "other",
          "qname": "package_parser.processing.annotations.model._annotations.EnumPair.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: Any) -> bool:\n        return (\n            isinstance(other, EnumPair)\n            and self.stringValue == other.stringValue\n            and self.instanceName == other.instanceName\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.EnumPair.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.EnumPair.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> EnumPair:\n        return EnumPair(json[\"stringValue\"], json[\"instanceName\"])"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.EnumPair.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumPair/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.EnumPair.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return asdict(self)"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumReviewResult/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.EnumReviewResult.to_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/EnumReviewResult/to_json/result",
          "name": "result",
          "qname": "package_parser.processing.annotations.model._annotations.EnumReviewResult.to_json.result",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def to_json(result: list[tuple[str, Any]]) -> dict[str, Any]:\n        for item in result:\n            if isinstance(item[1], EnumReviewResult):\n                result.append((item[0], item[1].value))\n                result.remove(item)\n        return dict(result)"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ExpertAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.ExpertAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/ExpertAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.ExpertAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> ExpertAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return ExpertAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/GroupAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.GroupAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/GroupAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.GroupAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> GroupAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return GroupAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"groupName\"],\n            json[\"parameters\"],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/Interval/__eq__",
      "name": "__eq__",
      "qname": "package_parser.processing.annotations.model._annotations.Interval.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/Interval/__eq__/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.Interval.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/Interval/__eq__/other",
          "name": "other",
          "qname": "package_parser.processing.annotations.model._annotations.Interval.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: Any) -> bool:\n        return (\n            isinstance(other, Interval)\n            and self.isDiscrete == other.isDiscrete\n            and self.lowerIntervalLimit == other.lowerIntervalLimit\n            and isinstance(self.lowerIntervalLimit, type(self.lowerIntervalLimit))\n            and self.lowerLimitType == other.lowerLimitType\n            and self.upperIntervalLimit == other.upperIntervalLimit\n            and isinstance(self.upperIntervalLimit, type(self.upperIntervalLimit))\n            and self.upperLimitType == self.upperLimitType\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/Interval/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.Interval.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/Interval/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.Interval.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Interval:\n        return Interval(\n            json[\"isDiscrete\"],\n            json[\"lowerIntervalLimit\"],\n            json[\"lowerLimitType\"],\n            json[\"upperIntervalLimit\"],\n            json[\"upperLimitType\"],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/Interval/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.Interval.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/Interval/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.Interval.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return asdict(self)"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/MoveAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.MoveAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/MoveAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.MoveAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> MoveAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return MoveAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"destination\"],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/OmittedAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.OmittedAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/OmittedAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.OmittedAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> OmittedAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return OmittedAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/OmittedAnnotation/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.OmittedAnnotation.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/OmittedAnnotation/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.OmittedAnnotation.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"variant\": self.variant.value,\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/OptionalAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.OptionalAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/OptionalAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.OptionalAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> OptionalAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return OptionalAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            ValueAnnotation.DefaultValueType(json[\"defaultValueType\"]),\n            json[\"defaultValue\"],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/OptionalAnnotation/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.OptionalAnnotation.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/OptionalAnnotation/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.OptionalAnnotation.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"variant\": self.variant.value,\n            \"defaultValueType\": self.defaultValueType.value,\n            \"defaultValue\": self.defaultValue,\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ParameterInfo/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.annotations.model._annotations.ParameterInfo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/ParameterInfo/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.ParameterInfo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/ParameterInfo/__init__/parameter_type",
          "name": "parameter_type",
          "qname": "package_parser.processing.annotations.model._annotations.ParameterInfo.__init__.parameter_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/ParameterInfo/__init__/value",
          "name": "value",
          "qname": "package_parser.processing.annotations.model._annotations.ParameterInfo.__init__.value",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/ParameterInfo/__init__/value_type",
          "name": "value_type",
          "qname": "package_parser.processing.annotations.model._annotations.ParameterInfo.__init__.value_type",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self, parameter_type: ParameterType, value: str = \"\", value_type: str = \"\"\n    ) -> None:\n        self.type = parameter_type\n        self.value = value\n        self.value_type = value_type"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/PureAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.PureAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/PureAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.PureAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> PureAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return PureAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/RemoveAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.RemoveAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/RemoveAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.RemoveAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> RemoveAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return RemoveAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/RenameAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.RenameAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/RenameAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.RenameAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> RenameAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return RenameAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"newName\"],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/RequiredAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.RequiredAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/RequiredAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.RequiredAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> RequiredAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return RequiredAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/RequiredAnnotation/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.annotations.model._annotations.RequiredAnnotation.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/RequiredAnnotation/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.annotations.model._annotations.RequiredAnnotation.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"target\": self.target,\n            \"authors\": self.authors,\n            \"reviewers\": self.reviewers,\n            \"comment\": self.comment,\n            \"reviewResult\": self.reviewResult.value,\n            \"variant\": self.variant.value,\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/TodoAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.TodoAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/TodoAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.TodoAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> TodoAnnotation:\n        annotation = AbstractAnnotation.from_json(json)\n        return TodoAnnotation(\n            annotation.target,\n            annotation.authors,\n            annotation.reviewers,\n            annotation.comment,\n            annotation.reviewResult,\n            json[\"newTodo\"],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.annotations.model._annotations/ValueAnnotation/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.annotations.model._annotations.ValueAnnotation.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.annotations.model._annotations/ValueAnnotation/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.annotations.model._annotations.ValueAnnotation.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> ValueAnnotation:\n        variant = json[\"variant\"]\n        if ValueAnnotation.Variant.CONSTANT.value == variant:\n            return ConstantAnnotation.from_json(json)\n        if ValueAnnotation.Variant.OMITTED.value == variant:\n            return OmittedAnnotation.from_json(json)\n        if ValueAnnotation.Variant.OPTIONAL.value == variant:\n            return OptionalAnnotation.from_json(json)\n        if ValueAnnotation.Variant.REQUIRED.value == variant:\n            return RequiredAnnotation.from_json(json)\n        raise Exception(\"unkonwn variant found\")"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id",
      "name": "__get_function_id",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_function_id",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_function_id.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id/name",
          "name": "name",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_function_id.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id/decorators",
          "name": "decorators",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_function_id.decorators",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __get_function_id(self, name: str, decorators: list[str]) -> str:\n        def is_getter() -> bool:\n            return \"property\" in decorators\n\n        def is_setter() -> bool:\n            for decorator in decorators:\n                if re.search(r\"^[^.]*.setter$\", decorator):\n                    return True\n\n            return False\n\n        def is_deleter() -> bool:\n            for decorator in decorators:\n                if re.search(r\"^[^.]*.deleter$\", decorator):\n                    return True\n\n            return False\n\n        result = self.__get_id(name)\n\n        if is_getter():\n            result += \"@getter\"\n        elif is_setter():\n            result += \"@setter\"\n        elif is_deleter():\n            result += \"@deleter\"\n\n        return result"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_id",
      "name": "__get_id",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_id",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_id/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_id.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_id/name",
          "name": "name",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_id.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __get_id(self, name: str) -> str:\n        segments = [self.api.package]\n        segments += [it.name for it in self.__declaration_stack]\n        segments += [name]\n\n        return \"/\".join(segments)"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__init__/documentation_parser",
          "name": "documentation_parser",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__init__.documentation_parser",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__init__/api",
          "name": "api",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__init__.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self, documentation_parser: AbstractDocumentationParser, api: API\n    ) -> None:\n        self.documentation_parser: AbstractDocumentationParser = documentation_parser\n        self.reexported: dict[str, list[str]] = {}\n        self.api: API = api\n        self.__declaration_stack: list[Union[Module, Class, Function]] = []"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_classdef",
      "name": "enter_classdef",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_classdef",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_classdef/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_classdef.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_classdef/class_node",
          "name": "class_node",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_classdef.class_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_classdef(self, class_node: astroid.ClassDef) -> None:\n        qname = class_node.qname()\n        instance_attributes = get_instance_attributes(class_node)\n\n        decorators: Optional[astroid.Decorators] = class_node.decorators\n        if decorators is not None:\n            decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n        else:\n            decorator_names = []\n\n        code = self.get_code(class_node)\n\n        # Remember class, so we can later add methods\n        class_ = Class(\n            id_=self.__get_id(class_node.name),\n            qname=qname,\n            decorators=decorator_names,\n            superclasses=class_node.basenames,\n            is_public=self.is_public(class_node.name, qname),\n            reexported_by=self.reexported.get(qname, []),\n            documentation=self.documentation_parser.get_class_documentation(class_node),\n            code=code,\n            instance_attributes=instance_attributes,\n        )\n        self.__declaration_stack.append(class_)"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_functiondef",
      "name": "enter_functiondef",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_functiondef",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_functiondef/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_functiondef.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_functiondef/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_functiondef.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_functiondef(self, function_node: astroid.FunctionDef) -> None:\n        qname = function_node.qname()\n\n        decorators: Optional[astroid.Decorators] = function_node.decorators\n        if decorators is not None:\n            decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n        else:\n            decorator_names = []\n\n        is_public = self.is_public(function_node.name, qname)\n\n        code = self.get_code(function_node)\n\n        function_id = self.__get_function_id(function_node.name, decorator_names)\n        function = Function(\n            id=function_id,\n            qname=qname,\n            decorators=decorator_names,\n            parameters=get_parameter_list(\n                self.documentation_parser,\n                function_node,\n                function_id,\n                qname,\n                is_public,\n            ),\n            results=[],  # TODO: results\n            is_public=is_public,\n            reexported_by=self.reexported.get(qname, []),\n            documentation=self.documentation_parser.get_function_documentation(\n                function_node\n            ),\n            code=code,\n        )\n        self.__declaration_stack.append(function)"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_module",
      "name": "enter_module",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_module",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_module/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_module.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_module/module_node",
          "name": "module_node",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_module.module_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_module(self, module_node: astroid.Module) -> None:\n        imports: list[Import] = []\n        from_imports: list[FromImport] = []\n        visited_global_nodes: set[astroid.NodeNG] = set()\n        id_ = f\"{self.api.package}/{module_node.qname()}\"\n\n        for _, global_node_list in module_node.globals.items():\n            global_node = global_node_list[0]\n\n            # For some reason from-imports get visited as often as there are imported names, leading to duplicates\n            if global_node in visited_global_nodes:\n                continue\n            visited_global_nodes.add(global_node)\n\n            # import X as Y\n            if isinstance(global_node, astroid.Import):\n                for name, alias in global_node.names:\n                    imports.append(Import(name, alias))\n\n            # from X import a as b\n            if isinstance(global_node, astroid.ImportFrom):\n                base_import_path = module_node.relative_to_absolute_name(\n                    global_node.modname, global_node.level\n                )\n\n                for name, alias in global_node.names:\n                    from_imports.append(FromImport(base_import_path, name, alias))\n\n                # Find re-exported declarations in __init__.py files\n                if _is_init_file(module_node.file) and is_public_module(\n                    module_node.qname()\n                ):\n                    for declaration, _ in global_node.names:\n                        context = InferenceContext()\n                        context.lookupname = declaration\n                        node = safe_infer(global_node, context)\n\n                        if node is None:\n                            logging.warning(\n                                f\"Could not resolve 'from {global_node.modname} import {declaration}\"\n                            )\n                            continue\n\n                        reexported_name = node.qname()\n\n                        if reexported_name.startswith(module_node.name):\n                            if reexported_name not in self.reexported:\n                                self.reexported[reexported_name] = []\n                            self.reexported[reexported_name].append(id_)\n\n        # Remember module, so we can later add classes and global functions\n        module = Module(\n            id_,\n            module_node.qname(),\n            imports,\n            from_imports,\n        )\n        self.__declaration_stack.append(module)"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/get_code",
      "name": "get_code",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.get_code",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/get_code/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.get_code.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/get_code/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.get_code.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_code(\n        self, function_node: Union[astroid.FunctionDef, astroid.ClassDef]\n    ) -> str:\n        code = \"\"\n        node: NodeNG = function_node\n        while node.parent is not None:\n            node = node.parent\n            if isinstance(node, astroid.Module):\n                code = trim_code(\n                    node.file_bytes,\n                    function_node.lineno,\n                    function_node.tolineno,\n                    node.file_encoding,\n                )\n                break\n        return code"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public",
      "name": "is_public",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.is_public",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.is_public.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public/name",
          "name": "name",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.is_public.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.is_public.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_public(self, name: str, qualified_name: str) -> bool:\n        if name.startswith(\"_\") and not name.endswith(\"__\"):\n            return False\n\n        if qualified_name in self.reexported:\n            return True\n\n        # Containing class is re-exported (always false if the current API element is not a method)\n        if (\n            isinstance(self.__declaration_stack[-1], Class)\n            and parent_qualified_name(qualified_name) in self.reexported\n        ):\n            return True\n\n        # The slicing is necessary so __init__ functions are not excluded (already handled in the first condition).\n        return all(not it.startswith(\"_\") for it in qualified_name.split(\".\")[:-1])"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_classdef",
      "name": "leave_classdef",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_classdef",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_classdef/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_classdef.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_classdef/_",
          "name": "_",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_classdef._",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_classdef(self, _: astroid.ClassDef) -> None:\n        class_ = self.__declaration_stack.pop()\n        if not isinstance(class_, Class):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        if len(self.__declaration_stack) > 0:\n            parent = self.__declaration_stack[-1]\n\n            # Ignore nested classes for now\n            if isinstance(parent, Module):\n                self.api.add_class(class_)\n                parent.add_class(class_.id)"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_functiondef",
      "name": "leave_functiondef",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_functiondef",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_functiondef/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_functiondef.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_functiondef/_",
          "name": "_",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_functiondef._",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_functiondef(self, _: astroid.FunctionDef) -> None:\n        function = self.__declaration_stack.pop()\n        if not isinstance(function, Function):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        if len(self.__declaration_stack) > 0:\n            parent = self.__declaration_stack[-1]\n\n            # Ignore nested functions for now\n            if isinstance(parent, Module):\n                self.api.add_function(function)\n                parent.add_function(function.id)\n            elif isinstance(parent, Class):\n                self.api.add_function(function)\n                parent.add_method(function.id)"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_module",
      "name": "leave_module",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_module",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_module/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_module.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_module/_",
          "name": "_",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_module._",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_module(self, _: astroid.Module) -> None:\n        module = self.__declaration_stack.pop()\n        if not isinstance(module, Module):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        self.api.add_module(module)"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/is_public_module",
      "name": "is_public_module",
      "qname": "package_parser.processing.api._ast_visitor.is_public_module",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/is_public_module/module_name",
          "name": "module_name",
          "qname": "package_parser.processing.api._ast_visitor.is_public_module.module_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def is_public_module(module_name: str) -> bool:\n    return all(not it.startswith(\"_\") for it in module_name.split(\".\"))"
    },
    {
      "id": "packager-parser/package_parser.processing.api._ast_visitor/trim_code",
      "name": "trim_code",
      "qname": "package_parser.processing.api._ast_visitor.trim_code",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/trim_code/code",
          "name": "code",
          "qname": "package_parser.processing.api._ast_visitor.trim_code.code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/trim_code/from_line_no",
          "name": "from_line_no",
          "qname": "package_parser.processing.api._ast_visitor.trim_code.from_line_no",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/trim_code/to_line_no",
          "name": "to_line_no",
          "qname": "package_parser.processing.api._ast_visitor.trim_code.to_line_no",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._ast_visitor/trim_code/encoding",
          "name": "encoding",
          "qname": "package_parser.processing.api._ast_visitor.trim_code.encoding",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def trim_code(\n    code: Optional[str], from_line_no: int, to_line_no: int, encoding: str\n) -> str:\n    if code is None:\n        return \"\"\n    if isinstance(code, bytes):\n        code = code.decode(encoding)\n    lines = code.split(\"\\n\")\n    return \"\\n\".join(lines[from_line_no - 1 : to_line_no])"
    },
    {
      "id": "packager-parser/package_parser.processing.api._file_filters/_is_init_file",
      "name": "_is_init_file",
      "qname": "package_parser.processing.api._file_filters._is_init_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._file_filters/_is_init_file/path",
          "name": "path",
          "qname": "package_parser.processing.api._file_filters._is_init_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _is_init_file(path: str) -> bool:\n    return path.endswith(\"__init__.py\")"
    },
    {
      "id": "packager-parser/package_parser.processing.api._file_filters/_is_test_file",
      "name": "_is_test_file",
      "qname": "package_parser.processing.api._file_filters._is_test_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._file_filters/_is_test_file/posix_path",
          "name": "posix_path",
          "qname": "package_parser.processing.api._file_filters._is_test_file.posix_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _is_test_file(posix_path: str) -> bool:\n    return \"/test/\" in posix_path or \"/tests/\" in posix_path"
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_api/__module_name",
      "name": "__module_name",
      "qname": "package_parser.processing.api._get_api.__module_name",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._get_api/__module_name/root",
          "name": "root",
          "qname": "package_parser.processing.api._get_api.__module_name.root",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._get_api/__module_name/file",
          "name": "file",
          "qname": "package_parser.processing.api._get_api.__module_name.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __module_name(root: Path, file: Path) -> str:\n    relative_path = file.relative_to(root.parent).as_posix()\n    return str(relative_path).replace(\".py\", \"\").replace(\"/\", \".\")"
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_api/get_api",
      "name": "get_api",
      "qname": "package_parser.processing.api._get_api.get_api",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._get_api/get_api/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.api._get_api.get_api.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._get_api/get_api/root",
          "name": "root",
          "qname": "package_parser.processing.api._get_api.get_api.root",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_api(package_name: str, root: Optional[Path] = None) -> API:\n    if root is None:\n        root = package_root(package_name)\n    dist = distribution(package_name) or \"\"\n    dist_version = distribution_version(dist) or \"\"\n    files = package_files(root)\n\n    api = API(dist, package_name, dist_version)\n    documentation_parser = NumpyDocParser()\n    callable_visitor = _AstVisitor(documentation_parser, api)\n    walker = ASTWalker(callable_visitor)\n\n    for file in files:\n        posix_path = Path(file).as_posix()\n        logging.info(f\"Working on file {posix_path}\")\n\n        if _is_test_file(posix_path):\n            logging.info(\"Skipping test file\")\n            continue\n\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            source = f.read()\n            walker.walk(\n                astroid.parse(\n                    source, module_name=__module_name(root, Path(file)), path=file\n                )\n            )\n\n    return callable_visitor.api"
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_instance_attributes/_get_type_of_attribute",
      "name": "_get_type_of_attribute",
      "qname": "package_parser.processing.api._get_instance_attributes._get_type_of_attribute",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._get_instance_attributes/_get_type_of_attribute/infered_value",
          "name": "infered_value",
          "qname": "package_parser.processing.api._get_instance_attributes._get_type_of_attribute.infered_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_type_of_attribute(infered_value: Any) -> Optional[str]:\n    if infered_value == astroid.Uninferable:\n        return None\n    if isinstance(infered_value, astroid.Const) and infered_value.value is None:\n        return None\n    if isinstance(infered_value, astroid.List):\n        return \"list\"\n    if isinstance(infered_value, astroid.Dict):\n        return \"dict\"\n    if isinstance(infered_value, astroid.ClassDef):\n        return \"type\"\n    if isinstance(infered_value, astroid.Tuple):\n        return \"tuple\"\n    if isinstance(infered_value, (astroid.FunctionDef, astroid.Lambda)):\n        return \"Callable\"\n    if isinstance(infered_value, astroid.Const):\n        return infered_value.value.__class__.__name__\n    if isinstance(infered_value, astroid.Instance):\n        return infered_value.name\n    return None"
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_instance_attributes/get_instance_attributes",
      "name": "get_instance_attributes",
      "qname": "package_parser.processing.api._get_instance_attributes.get_instance_attributes",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._get_instance_attributes/get_instance_attributes/class_node",
          "name": "class_node",
          "qname": "package_parser.processing.api._get_instance_attributes.get_instance_attributes.class_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_instance_attributes(class_node: astroid.ClassDef) -> list[Attribute]:\n    attributes = []\n    for name, assignments in class_node.instance_attrs.items():\n        types = set()\n        remove_types = {None}\n        inference_context = InferenceContext()\n        inference_context.lookupname = name\n        inference_context.extra_context = class_node.instance_attrs\n        for assignment in assignments:\n            inferred_nodes = assignment.infer(context=inference_context)\n            try:\n                for inferred_node in inferred_nodes:\n                    attribute_type = _get_type_of_attribute(inferred_node)\n                    if attribute_type is not None:\n                        types.add(attribute_type)\n            except astroid.InferenceError:\n                pass\n\n            if isinstance(assignment, astroid.AssignAttr) and isinstance(\n                assignment.parent, astroid.Assign\n            ):\n                attribute_type = _get_type_of_attribute(\n                    next(astroid.inference.infer_attribute(self=assignment))\n                )\n                if attribute_type is not None:\n                    types.add(attribute_type)\n                elif (\n                    isinstance(assignment.parent.value, Name)\n                    and isinstance(assignment.parent.parent, astroid.FunctionDef)\n                    and assignment.parent.parent.name == \"__init__\"\n                ):\n                    init_function = assignment.parent.parent\n                    parameter_name = assignment.parent.value.name\n                    for arg in init_function.args.args:\n                        i = init_function.args.args.index(arg)\n                        if (\n                            isinstance(\n                                init_function.args.args[i],\n                                (astroid.nodes.node_classes.AssignName, Name),\n                            )\n                            and init_function.args.args[i].name == parameter_name\n                        ):\n                            type_hint = init_function.args.annotations[i]\n                            if type_hint is not None:\n                                if isinstance(type_hint, Name):\n                                    types.add(type_hint.name)\n                                elif isinstance(type_hint, astroid.Attribute):\n                                    types.add(type_hint.attrname)\n                                elif (\n                                    isinstance(type_hint, Subscript)\n                                    and isinstance(type_hint.value, Name)\n                                    and isinstance(type_hint.slice, Name)\n                                ):\n                                    value = type_hint.value.name\n                                    slice_name = type_hint.slice.name\n                                    if value == \"Optional\":\n                                        types.add(\"NoneType\")\n                                        types.add(slice_name)\n                                    else:\n                                        types.add(value + \"[\" + slice_name + \"]\")\n                                        remove_types.add(value)\n                                        remove_types.add(value.lower())\n                                elif (\n                                    isinstance(type_hint, Subscript)\n                                    and isinstance(type_hint.value, Name)\n                                    and isinstance(type_hint.slice, astroid.Tuple)\n                                    and type_hint.value.name == \"Union\"\n                                ):\n                                    for type_name in type_hint.slice.elts:\n                                        if isinstance(type_name, Name):\n                                            types.add(type_name.name)\n                                    remove_types.add(type_hint.value.name)\n                                    remove_types.add(type_hint.value.name.lower())\n                            break\n        types = types - remove_types\n        if len(types) == 1:\n            attributes.append(Attribute(name, NamedType(types.pop())))\n        elif len(types) > 1:\n            attributes.append(\n                Attribute(name, UnionType([NamedType(type_) for type_ in types]))\n            )\n        else:\n            attributes.append(Attribute(name, None))\n    return attributes"
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_parameter_list/_get_parameters_assigned_by",
      "name": "_get_parameters_assigned_by",
      "qname": "package_parser.processing.api._get_parameter_list._get_parameters_assigned_by",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._get_parameter_list/_get_parameters_assigned_by/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api._get_parameter_list._get_parameters_assigned_by.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_parameters_assigned_by(\n    function_node: astroid.FunctionDef,\n) -> dict[str, ParameterAssignment]:\n    parameters = function_node.args\n    n_implicit_parameters = function_node.implicit_parameters()\n\n    result = {}\n    for arg in parameters.posonlyargs:\n        result[arg.name] = ParameterAssignment.POSITION_ONLY\n\n    for arg in parameters.args:\n        result[arg.name] = ParameterAssignment.POSITION_OR_NAME\n\n    if parameters.vararg is not None:\n        result[parameters.vararg] = ParameterAssignment.POSITIONAL_VARARG\n\n    for arg in parameters.kwonlyargs:\n        result[arg.name] = ParameterAssignment.NAME_ONLY\n\n    if parameters.kwarg is not None:\n        result[parameters.kwarg] = ParameterAssignment.NAMED_VARARG\n\n    # Overwrite assigned_by for implicit parameters. If first parameter of instance of class method is variadic,\n    # n_implicit_parameters is 0.\n    for arg in parameters.arguments[:n_implicit_parameters]:\n        result[arg.name] = ParameterAssignment.IMPLICIT\n\n    return result"
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_parameter_list/_get_stringified_default_value",
      "name": "_get_stringified_default_value",
      "qname": "package_parser.processing.api._get_parameter_list._get_stringified_default_value",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._get_parameter_list/_get_stringified_default_value/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api._get_parameter_list._get_stringified_default_value.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._get_parameter_list/_get_stringified_default_value/parameter_name",
          "name": "parameter_name",
          "qname": "package_parser.processing.api._get_parameter_list._get_stringified_default_value.parameter_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_stringified_default_value(\n    function_node: astroid.FunctionDef, parameter_name\n) -> Optional[str]:\n    try:\n        default_value = function_node.args.default_value(parameter_name)\n        if default_value is None:\n            return None\n        return default_value.as_string()\n    except astroid.exceptions.NoDefault:\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.api._get_parameter_list/get_parameter_list",
      "name": "get_parameter_list",
      "qname": "package_parser.processing.api._get_parameter_list.get_parameter_list",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._get_parameter_list/get_parameter_list/documentation_parser",
          "name": "documentation_parser",
          "qname": "package_parser.processing.api._get_parameter_list.get_parameter_list.documentation_parser",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._get_parameter_list/get_parameter_list/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api._get_parameter_list.get_parameter_list.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._get_parameter_list/get_parameter_list/function_id",
          "name": "function_id",
          "qname": "package_parser.processing.api._get_parameter_list.get_parameter_list.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._get_parameter_list/get_parameter_list/function_qname",
          "name": "function_qname",
          "qname": "package_parser.processing.api._get_parameter_list.get_parameter_list.function_qname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api._get_parameter_list/get_parameter_list/function_is_public",
          "name": "function_is_public",
          "qname": "package_parser.processing.api._get_parameter_list.get_parameter_list.function_is_public",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_parameter_list(\n    documentation_parser: AbstractDocumentationParser,\n    function_node: astroid.FunctionDef,\n    function_id: str,\n    function_qname: str,\n    function_is_public: bool,\n) -> list[Parameter]:\n    parameters_assigned_by = _get_parameters_assigned_by(function_node)\n    result = []\n\n    for parameter_name in function_node.argnames():\n        parameter_assigned_by = parameters_assigned_by[parameter_name]\n\n        result.append(\n            Parameter(\n                id_=function_id + \"/\" + parameter_name,\n                name=parameter_name,\n                qname=function_qname + \".\" + parameter_name,\n                default_value=_get_stringified_default_value(\n                    function_node, parameter_name\n                ),\n                assigned_by=parameter_assigned_by,\n                is_public=function_is_public,\n                documentation=documentation_parser.get_parameter_documentation(\n                    function_node, parameter_name, parameter_assigned_by\n                ),\n            )\n        )\n\n    return result"
    },
    {
      "id": "packager-parser/package_parser.processing.api._package_metadata/__move_init_files_to_front",
      "name": "__move_init_files_to_front",
      "qname": "package_parser.processing.api._package_metadata.__move_init_files_to_front",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._package_metadata/__move_init_files_to_front/files",
          "name": "files",
          "qname": "package_parser.processing.api._package_metadata.__move_init_files_to_front.files",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __move_init_files_to_front(files: list[str]) -> list[str]:\n    init_files = []\n    other_files = []\n\n    for file in files:\n        if _is_init_file(file):\n            init_files.append(file)\n        else:\n            other_files.append(file)\n\n    return init_files + other_files"
    },
    {
      "id": "packager-parser/package_parser.processing.api._package_metadata/distribution",
      "name": "distribution",
      "qname": "package_parser.processing.api._package_metadata.distribution",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._package_metadata/distribution/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.api._package_metadata.distribution.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def distribution(package_name: str) -> Optional[str]:\n    dist = packages_distributions().get(package_name)\n    if dist is None or len(dist) == 0:\n        return None\n\n    return dist[0]"
    },
    {
      "id": "packager-parser/package_parser.processing.api._package_metadata/distribution_version",
      "name": "distribution_version",
      "qname": "package_parser.processing.api._package_metadata.distribution_version",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._package_metadata/distribution_version/dist",
          "name": "dist",
          "qname": "package_parser.processing.api._package_metadata.distribution_version.dist",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def distribution_version(dist: Optional[str]) -> Optional[str]:\n    if dist is None:\n        return None\n\n    return version(dist)"
    },
    {
      "id": "packager-parser/package_parser.processing.api._package_metadata/package_files",
      "name": "package_files",
      "qname": "package_parser.processing.api._package_metadata.package_files",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._package_metadata/package_files/root",
          "name": "root",
          "qname": "package_parser.processing.api._package_metadata.package_files.root",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def package_files(root: Path) -> list[str]:\n    files = list_files(root, \".py\")\n    return __move_init_files_to_front(files)"
    },
    {
      "id": "packager-parser/package_parser.processing.api._package_metadata/package_root",
      "name": "package_root",
      "qname": "package_parser.processing.api._package_metadata.package_root",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api._package_metadata/package_root/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.api._package_metadata.package_root.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def package_root(package_name: str) -> Path:\n    path_as_string = importlib.import_module(package_name).__file__\n    if path_as_string is None:\n        raise AssertionError(f\"Cannot find package root for '{path_as_string}'.\")\n    return Path(path_as_string).parent"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_class_documentation",
      "name": "get_class_documentation",
      "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_class_documentation",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_class_documentation/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_class_documentation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_class_documentation/class_node",
          "name": "class_node",
          "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_class_documentation.class_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def get_class_documentation(\n        self, class_node: astroid.ClassDef\n    ) -> ClassDocumentation:\n        pass"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_function_documentation",
      "name": "get_function_documentation",
      "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_function_documentation",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_function_documentation/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_function_documentation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_function_documentation/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_function_documentation.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def get_function_documentation(\n        self, function_node: astroid.FunctionDef\n    ) -> FunctionDocumentation:\n        pass"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_parameter_documentation",
      "name": "get_parameter_documentation",
      "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_parameter_documentation",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_parameter_documentation/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_parameter_documentation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_parameter_documentation/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_parameter_documentation.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_parameter_documentation/parameter_name",
          "name": "parameter_name",
          "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_parameter_documentation.parameter_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._AbstractDocumentationParser/AbstractDocumentationParser/get_parameter_documentation/parameter_assigned_by",
          "name": "parameter_assigned_by",
          "qname": "package_parser.processing.api.documentation_parsing._AbstractDocumentationParser.AbstractDocumentationParser.get_parameter_documentation.parameter_assigned_by",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def get_parameter_documentation(\n        self,\n        function_node: astroid.FunctionDef,\n        parameter_name: str,\n        parameter_assigned_by: ParameterAssignment,\n    ) -> ParameterDocumentation:\n        pass"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_class_documentation",
      "name": "get_class_documentation",
      "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_class_documentation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_class_documentation/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_class_documentation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_class_documentation/class_node",
          "name": "class_node",
          "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_class_documentation.class_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_class_documentation(\n        self, class_node: astroid.ClassDef\n    ) -> ClassDocumentation:\n        return ClassDocumentation(\n            full_docstring=get_full_docstring(class_node),\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_function_documentation",
      "name": "get_function_documentation",
      "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_function_documentation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_function_documentation/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_function_documentation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_function_documentation/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_function_documentation.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_function_documentation(\n        self, function_node: astroid.FunctionDef\n    ) -> FunctionDocumentation:\n        return FunctionDocumentation(\n            full_docstring=get_full_docstring(function_node),\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_parameter_documentation",
      "name": "get_parameter_documentation",
      "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_parameter_documentation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_parameter_documentation/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_parameter_documentation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_parameter_documentation/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_parameter_documentation.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_parameter_documentation/parameter_name",
          "name": "parameter_name",
          "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_parameter_documentation.parameter_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._DefaultDocumentationParser/DefaultDocumentationParser/get_parameter_documentation/parameter_assigned_by",
          "name": "parameter_assigned_by",
          "qname": "package_parser.processing.api.documentation_parsing._DefaultDocumentationParser.DefaultDocumentationParser.get_parameter_documentation.parameter_assigned_by",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_parameter_documentation(\n        self,\n        function_node: astroid.FunctionDef,\n        parameter_name: str,\n        parameter_assigned_by: ParameterAssignment,\n    ) -> ParameterDocumentation:\n        return ParameterDocumentation()"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/__get_cached_function_numpydoc_string",
      "name": "__get_cached_function_numpydoc_string",
      "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.__get_cached_function_numpydoc_string",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/__get_cached_function_numpydoc_string/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.__get_cached_function_numpydoc_string.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/__get_cached_function_numpydoc_string/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.__get_cached_function_numpydoc_string.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/__get_cached_function_numpydoc_string/docstring",
          "name": "docstring",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.__get_cached_function_numpydoc_string.docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns the NumpyDocString for the given function node. It is only recomputed when the function node differs\nfrom the previous one that was passed to this function. This avoids reparsing the docstring for the function\nitself and all of its parameters.\n\nOn Lars's system this caused a significant performance improvement: Previously, 8.382s were spent inside the\nfunction get_parameter_documentation when parsing sklearn. Afterwards, it was only 2.113s.",
      "docstring": "Returns the NumpyDocString for the given function node. It is only recomputed when the function node differs\nfrom the previous one that was passed to this function. This avoids reparsing the docstring for the function\nitself and all of its parameters.\n\nOn Lars's system this caused a significant performance improvement: Previously, 8.382s were spent inside the\nfunction get_parameter_documentation when parsing sklearn. Afterwards, it was only 2.113s.",
      "code": "    def __get_cached_function_numpydoc_string(\n        self, function_node: astroid.FunctionDef, docstring: str\n    ) -> NumpyDocString:\n        \"\"\"\n        Returns the NumpyDocString for the given function node. It is only recomputed when the function node differs\n        from the previous one that was passed to this function. This avoids reparsing the docstring for the function\n        itself and all of its parameters.\n\n        On Lars's system this caused a significant performance improvement: Previously, 8.382s were spent inside the\n        function get_parameter_documentation when parsing sklearn. Afterwards, it was only 2.113s.\n        \"\"\"\n\n        if self.__cached_function_node is not function_node:\n            self.__cached_function_node = function_node\n            self.__cached_numpydoc_string = NumpyDocString(docstring)\n\n        return self.__cached_numpydoc_string"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Parses documentation in the NumpyDoc format. See https://numpydoc.readthedocs.io/en/latest/format.html for more\ninformation.\n\nThis class is not thread-safe. Each thread should create its own instance.",
      "docstring": "",
      "code": "    def __init__(self):\n        self.__cached_function_node: Optional[astroid.FunctionDef] = None\n        self.__cached_numpydoc_string: Optional[NumpyDocString] = None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_class_documentation",
      "name": "get_class_documentation",
      "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_class_documentation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_class_documentation/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_class_documentation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_class_documentation/class_node",
          "name": "class_node",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_class_documentation.class_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_class_documentation(\n        self, class_node: astroid.ClassDef\n    ) -> ClassDocumentation:\n        docstring = get_full_docstring(class_node)\n\n        return ClassDocumentation(\n            description=_get_description(NumpyDocString(docstring)),\n            full_docstring=docstring,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_function_documentation",
      "name": "get_function_documentation",
      "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_function_documentation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_function_documentation/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_function_documentation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_function_documentation/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_function_documentation.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_function_documentation(\n        self, function_node: astroid.FunctionDef\n    ) -> FunctionDocumentation:\n        docstring = get_full_docstring(function_node)\n\n        return FunctionDocumentation(\n            description=_get_description(\n                self.__get_cached_function_numpydoc_string(function_node, docstring)\n            ),\n            full_docstring=docstring,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_parameter_documentation",
      "name": "get_parameter_documentation",
      "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_parameter_documentation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_parameter_documentation/self",
          "name": "self",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_parameter_documentation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_parameter_documentation/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_parameter_documentation.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_parameter_documentation/parameter_name",
          "name": "parameter_name",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_parameter_documentation.parameter_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/NumpyDocParser/get_parameter_documentation/parameter_assigned_by",
          "name": "parameter_assigned_by",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser.NumpyDocParser.get_parameter_documentation.parameter_assigned_by",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_parameter_documentation(\n        self,\n        function_node: astroid.FunctionDef,\n        parameter_name: str,\n        parameter_assigned_by: ParameterAssignment,\n    ) -> ParameterDocumentation:\n\n        # For constructors (__init__ functions) the parameters are described on the class\n        if function_node.name == \"__init__\" and isinstance(\n            function_node.parent, astroid.ClassDef\n        ):\n            docstring = get_full_docstring(function_node.parent)\n        else:\n            docstring = get_full_docstring(function_node)\n\n        # Find matching parameter docstrings\n        function_numpydoc = self.__get_cached_function_numpydoc_string(\n            function_node, docstring\n        )\n        all_parameters_numpydoc: list[\n            numpydoc.docscrape.Parameter\n        ] = function_numpydoc.get(\"Parameters\", [])\n        matching_parameters_numpydoc = [\n            it\n            for it in all_parameters_numpydoc\n            if _is_matching_parameter_numpydoc(\n                it, parameter_name, parameter_assigned_by\n            )\n        ]\n\n        if len(matching_parameters_numpydoc) == 0:\n            return ParameterDocumentation(type=\"\", default_value=\"\", description=\"\")\n\n        last_parameter_numpydoc = matching_parameters_numpydoc[-1]\n        type_, default_value = _get_type_and_default_value(last_parameter_numpydoc)\n        return ParameterDocumentation(\n            type=type_,\n            default_value=default_value,\n            description=\"\\n\".join(\n                [line.rstrip() for line in last_parameter_numpydoc.desc]\n            ),\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_get_description",
      "name": "_get_description",
      "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser._get_description",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_get_description/numpydoc_string",
          "name": "numpydoc_string",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser._get_description.numpydoc_string",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns the concatenated summary and extended summary parts of the given docstring or an empty string if these parts\nare blank.",
      "docstring": "Returns the concatenated summary and extended summary parts of the given docstring or an empty string if these parts\nare blank.",
      "code": "def _get_description(numpydoc_string: NumpyDocString) -> str:\n    \"\"\"\n    Returns the concatenated summary and extended summary parts of the given docstring or an empty string if these parts\n    are blank.\n    \"\"\"\n\n    summary: list[str] = numpydoc_string.get(\"Summary\", [])\n    extended_summary: list[str] = numpydoc_string.get(\"Extended Summary\", [])\n\n    result = \"\"\n    result += \"\\n\".join([line.rstrip() for line in summary])\n    result += \"\\n\\n\"\n    result += \"\\n\".join([line.rstrip() for line in extended_summary])\n    return result.strip()"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_get_type_and_default_value",
      "name": "_get_type_and_default_value",
      "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser._get_type_and_default_value",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_get_type_and_default_value/parameter_numpydoc",
          "name": "parameter_numpydoc",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser._get_type_and_default_value.parameter_numpydoc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns the type and default value for the given NumpyDoc.",
      "docstring": "Returns the type and default value for the given NumpyDoc.",
      "code": "def _get_type_and_default_value(\n    parameter_numpydoc: numpydoc.docscrape.Parameter,\n) -> Tuple[str, str]:\n    \"\"\"\n    Returns the type and default value for the given NumpyDoc.\n    \"\"\"\n\n    type_ = parameter_numpydoc.type\n    parts = re.split(r\",\\s*optional|,\\s*default\\s*[:=]?\", type_)\n\n    if len(parts) != 2:\n        return type_.strip(), \"\"\n\n    return parts[0].strip(), parts[1].strip()"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_is_matching_parameter_numpydoc",
      "name": "_is_matching_parameter_numpydoc",
      "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser._is_matching_parameter_numpydoc",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_is_matching_parameter_numpydoc/parameter_numpydoc",
          "name": "parameter_numpydoc",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser._is_matching_parameter_numpydoc.parameter_numpydoc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_is_matching_parameter_numpydoc/parameter_name",
          "name": "parameter_name",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser._is_matching_parameter_numpydoc.parameter_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._NumpyDocParser/_is_matching_parameter_numpydoc/parameter_assigned_by",
          "name": "parameter_assigned_by",
          "qname": "package_parser.processing.api.documentation_parsing._NumpyDocParser._is_matching_parameter_numpydoc.parameter_assigned_by",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns whether the given NumpyDoc applied to the parameter with the given name.",
      "docstring": "Returns whether the given NumpyDoc applied to the parameter with the given name.",
      "code": "def _is_matching_parameter_numpydoc(\n    parameter_numpydoc: numpydoc.docscrape.Parameter,\n    parameter_name: str,\n    parameter_assigned_by: ParameterAssignment,\n) -> bool:\n    \"\"\"\n    Returns whether the given NumpyDoc applied to the parameter with the given name.\n    \"\"\"\n\n    if parameter_assigned_by == ParameterAssignment.POSITIONAL_VARARG:\n        lookup_name = f\"*{parameter_name}\"\n    elif parameter_assigned_by == ParameterAssignment.NAMED_VARARG:\n        lookup_name = f\"**{parameter_name}\"\n    else:\n        lookup_name = parameter_name\n\n    # Numpydoc allows multiple parameters to be documented at once. See\n    # https://numpydoc.readthedocs.io/en/latest/format.html#parameters for more information.\n    return any(\n        name.strip() == lookup_name for name in parameter_numpydoc.name.split(\",\")\n    )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.documentation_parsing._get_full_docstring/get_full_docstring",
      "name": "get_full_docstring",
      "qname": "package_parser.processing.api.documentation_parsing._get_full_docstring.get_full_docstring",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.documentation_parsing._get_full_docstring/get_full_docstring/declaration",
          "name": "declaration",
          "qname": "package_parser.processing.api.documentation_parsing._get_full_docstring.get_full_docstring.declaration",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns the full docstring of the given declaration or an empty string if no docstring is available. Indentation is\ncleaned up.",
      "docstring": "Returns the full docstring of the given declaration or an empty string if no docstring is available. Indentation is\ncleaned up.",
      "code": "def get_full_docstring(\n    declaration: Union[astroid.ClassDef, astroid.FunctionDef]\n) -> str:\n    \"\"\"\n    Returns the full docstring of the given declaration or an empty string if no docstring is available. Indentation is\n    cleaned up.\n    \"\"\"\n\n    doc_node = declaration.doc_node\n    if doc_node is None:\n        return \"\"\n    return inspect.cleandoc(doc_node.value)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.api.model._api.API.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/__init__/distribution",
          "name": "distribution",
          "qname": "package_parser.processing.api.model._api.API.__init__.distribution",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/__init__/package",
          "name": "package",
          "qname": "package_parser.processing.api.model._api.API.__init__.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/__init__/version",
          "name": "version",
          "qname": "package_parser.processing.api.model._api.API.__init__.version",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, distribution: str, package: str, version: str) -> None:\n        self.distribution: str = distribution\n        self.package: str = package\n        self.version: str = version\n        self.modules: dict[str, Module] = {}\n        self.classes: dict[str, Class] = {}\n        self.functions: dict[str, Function] = {}"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/add_class",
      "name": "add_class",
      "qname": "package_parser.processing.api.model._api.API.add_class",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/add_class/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.add_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/add_class/class_",
          "name": "class_",
          "qname": "package_parser.processing.api.model._api.API.add_class.class_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_class(self, class_: Class) -> None:\n        self.classes[class_.id] = class_"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/add_function",
      "name": "add_function",
      "qname": "package_parser.processing.api.model._api.API.add_function",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/add_function/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.add_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/add_function/function",
          "name": "function",
          "qname": "package_parser.processing.api.model._api.API.add_function.function",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_function(self, function: Function) -> None:\n        self.functions[function.id] = function"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/add_module",
      "name": "add_module",
      "qname": "package_parser.processing.api.model._api.API.add_module",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/add_module/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.add_module.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/add_module/module",
          "name": "module",
          "qname": "package_parser.processing.api.model._api.API.add_module.module",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_module(self, module: Module) -> None:\n        self.modules[module.id] = module"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/attributes",
      "name": "attributes",
      "qname": "package_parser.processing.api.model._api.API.attributes",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/attributes/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.attributes.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def attributes(self) -> dict[str, Attribute]:\n        result: dict[str, Attribute] = {}\n\n        for class_ in self.classes.values():\n            for attribute in class_.instance_attributes:\n                attribute_id = f\"{class_.id}/{attribute.name}\"\n                result[attribute_id] = attribute\n\n        return result"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/class_count",
      "name": "class_count",
      "qname": "package_parser.processing.api.model._api.API.class_count",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/class_count/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.class_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def class_count(self) -> int:\n        return len(self.classes)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._api.API.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._api.API.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> API:\n        result = API(json[\"distribution\"], json[\"package\"], json[\"version\"])\n\n        for module_json in json.get(\"modules\", []):\n            result.add_module(Module.from_json(module_json))\n\n        for class_json in json.get(\"classes\", []):\n            result.add_class(Class.from_json(class_json))\n\n        for function_json in json.get(\"functions\", []):\n            result.add_function(Function.from_json(function_json))\n\n        return result"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/function_count",
      "name": "function_count",
      "qname": "package_parser.processing.api.model._api.API.function_count",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/function_count/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.function_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def function_count(self) -> int:\n        return len(self.functions)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/get_default_value",
      "name": "get_default_value",
      "qname": "package_parser.processing.api.model._api.API.get_default_value",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/get_default_value/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.get_default_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/get_default_value/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.processing.api.model._api.API.get_default_value.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_value(self, parameter_id: str) -> Optional[str]:\n        function_id = parent_id(parameter_id)\n\n        if function_id not in self.functions:\n            return None\n\n        for parameter in self.functions[function_id].parameters:\n            if parameter.id == parameter_id:\n                return parameter.default_value\n\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/is_public_class",
      "name": "is_public_class",
      "qname": "package_parser.processing.api.model._api.API.is_public_class",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/is_public_class/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.is_public_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/is_public_class/class_id",
          "name": "class_id",
          "qname": "package_parser.processing.api.model._api.API.is_public_class.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_public_class(self, class_id: str) -> bool:\n        return class_id in self.classes and self.classes[class_id].is_public"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/is_public_function",
      "name": "is_public_function",
      "qname": "package_parser.processing.api.model._api.API.is_public_function",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/is_public_function/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.is_public_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/is_public_function/function_id",
          "name": "function_id",
          "qname": "package_parser.processing.api.model._api.API.is_public_function.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_public_function(self, function_id: str) -> bool:\n        return function_id in self.functions and self.functions[function_id].is_public"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/parameter_count",
      "name": "parameter_count",
      "qname": "package_parser.processing.api.model._api.API.parameter_count",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/parameter_count/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.parameter_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def parameter_count(self) -> int:\n        return len(self.parameters())"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/parameters",
      "name": "parameters",
      "qname": "package_parser.processing.api.model._api.API.parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/parameters/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.parameters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def parameters(self) -> dict[str, Parameter]:\n        result: dict[str, Parameter] = {}\n\n        for function in self.functions.values():\n            for parameter in function.parameters:\n                parameter_id = f\"{function.id}/{parameter.name}\"\n                result[parameter_id] = parameter\n\n        return result"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/public_class_count",
      "name": "public_class_count",
      "qname": "package_parser.processing.api.model._api.API.public_class_count",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/public_class_count/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.public_class_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def public_class_count(self) -> int:\n        return len([it for it in self.classes.values() if it.is_public])"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/public_function_count",
      "name": "public_function_count",
      "qname": "package_parser.processing.api.model._api.API.public_function_count",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/public_function_count/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.public_function_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def public_function_count(self) -> int:\n        return len([it for it in self.functions.values() if it.is_public])"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/public_parameter_count",
      "name": "public_parameter_count",
      "qname": "package_parser.processing.api.model._api.API.public_parameter_count",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/public_parameter_count/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.public_parameter_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def public_parameter_count(self) -> int:\n        return len([it for it in self.parameters().values() if it.is_public])"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/results",
      "name": "results",
      "qname": "package_parser.processing.api.model._api.API.results",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/results/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.results.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def results(self) -> dict[str, Result]:\n        result_dict: dict[str, Result] = {}\n\n        for function in self.functions.values():\n            for result in function.results:\n                result_id = f\"{function.id}/{result.name}\"\n                result_dict[result_id] = result\n\n        return result_dict"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/API/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._api.API.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/API/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.API.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"schemaVersion\": API_SCHEMA_VERSION,\n            \"distribution\": self.distribution,\n            \"package\": self.package,\n            \"version\": self.version,\n            \"modules\": [\n                module.to_json()\n                for module in sorted(self.modules.values(), key=lambda it: it.id)\n            ],\n            \"classes\": [\n                class_.to_json()\n                for class_ in sorted(self.classes.values(), key=lambda it: it.id)\n            ],\n            \"functions\": [\n                function.to_json()\n                for function in sorted(self.functions.values(), key=lambda it: it.id)\n            ],\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Attribute/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.api.model._api.Attribute.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Attribute/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Attribute.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash((self.name, self.class_id, self.types))"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Attribute/__repr__",
      "name": "__repr__",
      "qname": "package_parser.processing.api.model._api.Attribute.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Attribute/__repr__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Attribute.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        type_str = (\n            \" , type=\" + str(self.types.to_json()) if self.types is not None else \"None\"\n        )\n        return (\n            \"Attribute(class_id=\"\n            + str(self.class_id)\n            + \"/\"\n            + self.name\n            + type_str\n            + \")\"\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Attribute/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._api.Attribute.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Attribute/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._api.Attribute.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Attribute/from_json/class_id",
          "name": "class_id",
          "qname": "package_parser.processing.api.model._api.Attribute.from_json.class_id",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any, class_id: Optional[str] = None) -> Attribute:\n        return Attribute(\n            json[\"name\"], AbstractType.from_json(json.get(\"types\", {})), class_id\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Attribute/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._api.Attribute.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Attribute/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Attribute.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, Any]:\n        types_json = self.types.to_json() if self.types is not None else None\n        return {\"name\": self.name, \"types\": types_json}"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.api.model._api.Class.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Class.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/id_",
          "name": "id_",
          "qname": "package_parser.processing.api.model._api.Class.__init__.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/qname",
          "name": "qname",
          "qname": "package_parser.processing.api.model._api.Class.__init__.qname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/decorators",
          "name": "decorators",
          "qname": "package_parser.processing.api.model._api.Class.__init__.decorators",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/superclasses",
          "name": "superclasses",
          "qname": "package_parser.processing.api.model._api.Class.__init__.superclasses",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/is_public",
          "name": "is_public",
          "qname": "package_parser.processing.api.model._api.Class.__init__.is_public",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/reexported_by",
          "name": "reexported_by",
          "qname": "package_parser.processing.api.model._api.Class.__init__.reexported_by",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/documentation",
          "name": "documentation",
          "qname": "package_parser.processing.api.model._api.Class.__init__.documentation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/code",
          "name": "code",
          "qname": "package_parser.processing.api.model._api.Class.__init__.code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__init__/instance_attributes",
          "name": "instance_attributes",
          "qname": "package_parser.processing.api.model._api.Class.__init__.instance_attributes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        id_: str,\n        qname: str,\n        decorators: list[str],\n        superclasses: list[str],\n        is_public: bool,\n        reexported_by: list[str],\n        documentation: ClassDocumentation,\n        code: str,\n        instance_attributes: list[Attribute],\n    ) -> None:\n        self.id: str = id_\n        self.qname: str = qname\n        self.decorators: list[str] = decorators\n        self.superclasses: list[str] = superclasses\n        self.methods: list[str] = []\n        self.is_public: bool = is_public\n        self.reexported_by: list[str] = reexported_by\n        self.documentation: ClassDocumentation = documentation\n        self.code: str = code\n        self.instance_attributes = instance_attributes\n        self.formatted_code: Optional[str] = None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Class/__repr__",
      "name": "__repr__",
      "qname": "package_parser.processing.api.model._api.Class.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/__repr__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Class.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return \"Class(id=\" + self.id + \")\""
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Class/add_method",
      "name": "add_method",
      "qname": "package_parser.processing.api.model._api.Class.add_method",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/add_method/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Class.add_method.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/add_method/method_id",
          "name": "method_id",
          "qname": "package_parser.processing.api.model._api.Class.add_method.method_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_method(self, method_id: str) -> None:\n        self.methods.append(method_id)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Class/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._api.Class.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._api.Class.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Class:\n        result = Class(\n            json[\"id\"],\n            json[\"qname\"],\n            json.get(\"decorators\", []),\n            json.get(\"superclasses\", []),\n            json.get(\"is_public\", True),\n            json.get(\"reexported_by\", []),\n            ClassDocumentation(\n                description=json.get(\"description\", \"\"),\n                full_docstring=json.get(\"docstring\", \"\"),\n            ),\n            json.get(\"code\", \"\"),\n            [\n                Attribute.from_json(instance_attribute, json[\"id\"])\n                for instance_attribute in json.get(\"instance_attributes\", [])\n            ],\n        )\n\n        for method_id in json[\"methods\"]:\n            result.add_method(method_id)\n\n        return result"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Class/get_formatted_code",
      "name": "get_formatted_code",
      "qname": "package_parser.processing.api.model._api.Class.get_formatted_code",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/get_formatted_code/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Class.get_formatted_code.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_formatted_code(self) -> str:\n        if self.formatted_code is None:\n            self.formatted_code = _generate_formatted_code(self)\n        return self.formatted_code"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Class/name@getter",
      "name": "name",
      "qname": "package_parser.processing.api.model._api.Class.name",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/name@getter/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Class.name.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def name(self) -> str:\n        return self.qname.split(\".\")[-1]"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Class/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._api.Class.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Class/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Class.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"decorators\": self.decorators,\n            \"superclasses\": self.superclasses,\n            \"methods\": self.methods,\n            \"is_public\": self.is_public,\n            \"reexported_by\": self.reexported_by,\n            \"description\": self.documentation.description,\n            \"docstring\": self.documentation.full_docstring,\n            \"code\": self.code,\n            \"instance_attributes\": [\n                attribute.to_json() for attribute in self.instance_attributes\n            ],\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/FromImport/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._api.FromImport.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/FromImport/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._api.FromImport.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> FromImport:\n        return FromImport(json[\"module\"], json[\"declaration\"], json[\"alias\"])"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/FromImport/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._api.FromImport.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/FromImport/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.FromImport.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"module\": self.module_name,\n            \"declaration\": self.declaration_name,\n            \"alias\": self.alias,\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Function/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.api.model._api.Function.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Function/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Function.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(\n            (\n                self.id,\n                self.name,\n                self.qname,\n                frozenset(self.decorators),\n                frozenset(self.parameters),\n                frozenset(self.results),\n                self.is_public,\n                frozenset(self.reexported_by),\n                self.documentation,\n                self.code,\n            )\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Function/__post_init__",
      "name": "__post_init__",
      "qname": "package_parser.processing.api.model._api.Function.__post_init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Function/__post_init__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Function.__post_init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __post_init__(self) -> None:\n        self.formatted_code = None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Function/__repr__",
      "name": "__repr__",
      "qname": "package_parser.processing.api.model._api.Function.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Function/__repr__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Function.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return \"Function(id=\" + self.id + \")\""
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Function/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._api.Function.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Function/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._api.Function.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Function:\n        return Function(\n            json[\"id\"],\n            json[\"qname\"],\n            json.get(\"decorators\", []),\n            [\n                Parameter.from_json(parameter_json)\n                for parameter_json in json.get(\"parameters\", [])\n            ],\n            [Result.from_json(result_json) for result_json in json.get(\"results\", [])],\n            json.get(\"is_public\", True),\n            json.get(\"reexported_by\", []),\n            FunctionDocumentation(\n                description=json.get(\"description\", \"\"),\n                full_docstring=json.get(\"docstring\", \"\"),\n            ),\n            json.get(\"code\", \"\"),\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Function/get_formatted_code",
      "name": "get_formatted_code",
      "qname": "package_parser.processing.api.model._api.Function.get_formatted_code",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Function/get_formatted_code/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Function.get_formatted_code.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_formatted_code(self) -> str:\n        if self.formatted_code is None:\n            self.formatted_code = _generate_formatted_code(self)\n        return self.formatted_code"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Function/name@getter",
      "name": "name",
      "qname": "package_parser.processing.api.model._api.Function.name",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Function/name@getter/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Function.name.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def name(self) -> str:\n        return self.qname.rsplit(\".\", maxsplit=1)[-1]"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Function/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._api.Function.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Function/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Function.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"decorators\": self.decorators,\n            \"parameters\": [parameter.to_json() for parameter in self.parameters],\n            \"results\": [result.to_json() for result in self.results],\n            \"is_public\": self.is_public,\n            \"reexported_by\": self.reexported_by,\n            \"description\": self.documentation.description,\n            \"docstring\": self.documentation.full_docstring,\n            \"code\": self.code,\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Import/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._api.Import.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Import/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._api.Import.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Import:\n        return Import(json[\"module\"], json[\"alias\"])"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Import/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._api.Import.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Import/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Import.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\"module\": self.module_name, \"alias\": self.alias}"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Module/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.api.model._api.Module.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Module.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/__init__/id_",
          "name": "id_",
          "qname": "package_parser.processing.api.model._api.Module.__init__.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/__init__/name",
          "name": "name",
          "qname": "package_parser.processing.api.model._api.Module.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/__init__/imports",
          "name": "imports",
          "qname": "package_parser.processing.api.model._api.Module.__init__.imports",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/__init__/from_imports",
          "name": "from_imports",
          "qname": "package_parser.processing.api.model._api.Module.__init__.from_imports",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self, id_: str, name: str, imports: list[Import], from_imports: list[FromImport]\n    ):\n        self.id: str = id_\n        self.name: str = name\n        self.imports: list[Import] = imports\n        self.from_imports: list[FromImport] = from_imports\n        self.classes: list[str] = []\n        self.functions: list[str] = []"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Module/add_class",
      "name": "add_class",
      "qname": "package_parser.processing.api.model._api.Module.add_class",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/add_class/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Module.add_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/add_class/class_id",
          "name": "class_id",
          "qname": "package_parser.processing.api.model._api.Module.add_class.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_class(self, class_id: str) -> None:\n        self.classes.append(class_id)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Module/add_function",
      "name": "add_function",
      "qname": "package_parser.processing.api.model._api.Module.add_function",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/add_function/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Module.add_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/add_function/function_id",
          "name": "function_id",
          "qname": "package_parser.processing.api.model._api.Module.add_function.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_function(self, function_id: str) -> None:\n        self.functions.append(function_id)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Module/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._api.Module.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._api.Module.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Module:\n        result = Module(\n            json[\"id\"],\n            json[\"name\"],\n            [Import.from_json(import_json) for import_json in json.get(\"imports\", [])],\n            [\n                FromImport.from_json(from_import_json)\n                for from_import_json in json.get(\"from_imports\", [])\n            ],\n        )\n\n        for class_id in json.get(\"classes\", []):\n            result.add_class(class_id)\n\n        for function_id in json.get(\"functions\", []):\n            result.add_function(function_id)\n\n        return result"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Module/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._api.Module.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Module/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Module.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"imports\": [import_.to_json() for import_ in self.imports],\n            \"from_imports\": [\n                from_import.to_json() for from_import in self.from_imports\n            ],\n            \"classes\": self.classes,\n            \"functions\": self.functions,\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Result/__repr__",
      "name": "__repr__",
      "qname": "package_parser.processing.api.model._api.Result.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Result/__repr__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Result.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return (\n            \"Result(function_id=\" + str(self.function_id) + \", name=\" + self.name + \")\"\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Result/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._api.Result.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Result/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._api.Result.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Result/from_json/function_id",
          "name": "function_id",
          "qname": "package_parser.processing.api.model._api.Result.from_json.function_id",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any, function_id: Optional[str] = None) -> Result:\n        return Result(\n            json[\"name\"],\n            ResultDocstring.from_json(json.get(\"docstring\", {})),\n            function_id,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/Result/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._api.Result.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/Result/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.Result.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\"name\": self.name, \"docstring\": self.docstring.to_json()}"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/ResultDocstring/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._api.ResultDocstring.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/ResultDocstring/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._api.ResultDocstring.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> ResultDocstring:\n        return ResultDocstring(\n            json.get(\"type\", \"\"),\n            json.get(\"description\", \"\"),\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/ResultDocstring/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._api.ResultDocstring.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/ResultDocstring/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._api.ResultDocstring.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\"type\": self.type, \"description\": self.description}"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._api/_generate_formatted_code",
      "name": "_generate_formatted_code",
      "qname": "package_parser.processing.api.model._api._generate_formatted_code",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._api/_generate_formatted_code/api_element",
          "name": "api_element",
          "qname": "package_parser.processing.api.model._api._generate_formatted_code.api_element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _generate_formatted_code(api_element: Union[Class, Function]) -> str:\n    code = api_element.code\n    try:\n        code_tmp = format_str(code, mode=FileMode())\n    except (CannotSplit, CannotTransform, InvalidInput, BracketMatchError):\n        # As long as the api black has no documentation, we do not know which exceptions are raised\n        pass\n    else:\n        code = code_tmp\n    return code"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/ClassDocumentation/from_dict",
      "name": "from_dict",
      "qname": "package_parser.processing.api.model._documentation.ClassDocumentation.from_dict",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._documentation/ClassDocumentation/from_dict/d",
          "name": "d",
          "qname": "package_parser.processing.api.model._documentation.ClassDocumentation.from_dict.d",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_dict(d: dict) -> ClassDocumentation:\n        return ClassDocumentation(**d)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/ClassDocumentation/to_dict",
      "name": "to_dict",
      "qname": "package_parser.processing.api.model._documentation.ClassDocumentation.to_dict",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._documentation/ClassDocumentation/to_dict/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._documentation.ClassDocumentation.to_dict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_dict(self) -> dict:\n        return dataclasses.asdict(self)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.api.model._documentation.FunctionDocumentation.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._documentation.FunctionDocumentation.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(\n            (\n                self.description,\n                self.full_docstring,\n            )\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation/from_dict",
      "name": "from_dict",
      "qname": "package_parser.processing.api.model._documentation.FunctionDocumentation.from_dict",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation/from_dict/d",
          "name": "d",
          "qname": "package_parser.processing.api.model._documentation.FunctionDocumentation.from_dict.d",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_dict(d: dict) -> FunctionDocumentation:\n        return FunctionDocumentation(**d)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation/to_dict",
      "name": "to_dict",
      "qname": "package_parser.processing.api.model._documentation.FunctionDocumentation.to_dict",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._documentation/FunctionDocumentation/to_dict/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._documentation.FunctionDocumentation.to_dict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_dict(self) -> dict:\n        return dataclasses.asdict(self)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.api.model._documentation.ParameterDocumentation.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._documentation.ParameterDocumentation.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash((self.type, self.default_value, self.description))"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation/from_dict",
      "name": "from_dict",
      "qname": "package_parser.processing.api.model._documentation.ParameterDocumentation.from_dict",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation/from_dict/d",
          "name": "d",
          "qname": "package_parser.processing.api.model._documentation.ParameterDocumentation.from_dict.d",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_dict(d: dict) -> ParameterDocumentation:\n        return ParameterDocumentation(**d)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation/to_dict",
      "name": "to_dict",
      "qname": "package_parser.processing.api.model._documentation.ParameterDocumentation.to_dict",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._documentation/ParameterDocumentation/to_dict/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._documentation.ParameterDocumentation.to_dict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_dict(self) -> dict:\n        return dataclasses.asdict(self)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.api.model._parameters.Parameter.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(\n            (\n                self.id,\n                self.name,\n                self.qname,\n                self.default_value,\n                self.assigned_by,\n                self.is_public,\n                self.documentation,\n            )\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.api.model._parameters.Parameter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__/id_",
          "name": "id_",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__init__.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__/name",
          "name": "name",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__/qname",
          "name": "qname",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__init__.qname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__/default_value",
          "name": "default_value",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__init__.default_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__/assigned_by",
          "name": "assigned_by",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__init__.assigned_by",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__/is_public",
          "name": "is_public",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__init__.is_public",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__init__/documentation",
          "name": "documentation",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__init__.documentation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        id_: str,\n        name: str,\n        qname: str,\n        default_value: Optional[str],\n        assigned_by: ParameterAssignment,\n        is_public: bool,\n        documentation: ParameterDocumentation,\n    ) -> None:\n        self.id: str = id_\n        self.name: str = name\n        self.qname: str = qname\n        self.default_value: Optional[str] = default_value\n        self.assigned_by: ParameterAssignment = assigned_by\n        self.is_public: bool = is_public\n        self.documentation = documentation\n        self.type: Optional[AbstractType] = create_type(documentation)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__repr__",
      "name": "__repr__",
      "qname": "package_parser.processing.api.model._parameters.Parameter.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/__repr__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._parameters.Parameter.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return \"Parameter(id=\" + self.id + \")\""
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._parameters.Parameter.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._parameters.Parameter.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Parameter:\n        return Parameter(\n            json[\"id\"],\n            json[\"name\"],\n            json[\"qname\"],\n            json.get(\"default_value\", None),\n            ParameterAssignment[json.get(\"assigned_by\", \"POSITION_OR_NAME\")],\n            json.get(\"is_public\", True),\n            ParameterDocumentation.from_dict(json.get(\"docstring\", {})),\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/is_optional",
      "name": "is_optional",
      "qname": "package_parser.processing.api.model._parameters.Parameter.is_optional",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/is_optional/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._parameters.Parameter.is_optional.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_optional(self) -> bool:\n        return self.default_value is not None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/is_required",
      "name": "is_required",
      "qname": "package_parser.processing.api.model._parameters.Parameter.is_required",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/is_required/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._parameters.Parameter.is_required.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_required(self) -> bool:\n        return self.default_value is None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._parameters.Parameter.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._parameters/Parameter/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._parameters.Parameter.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"default_value\": self.default_value,\n            \"assigned_by\": self.assigned_by.name,\n            \"is_public\": self.is_public,\n            \"docstring\": self.documentation.to_dict(),\n            \"type\": self.type.to_json() if self.type is not None else {},\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/AbstractType/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._types.AbstractType.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/AbstractType/from_json/cls",
          "name": "cls",
          "qname": "package_parser.processing.api.model._types.AbstractType.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/AbstractType/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._types.AbstractType.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any) -> Optional[AbstractType]:\n        if json is None:\n            return None\n        value: Optional[AbstractType] = NamedType.from_json(json)\n        if value is not None:\n            return value\n        value = EnumType.from_json(json)\n        if value is not None:\n            return value\n        value = BoundaryType.from_json(json)\n        if value is not None:\n            return value\n        return UnionType.from_json(json)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/AbstractType/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._types.AbstractType.to_json",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/AbstractType/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.AbstractType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def to_json(self) -> dict[str, Any]:\n        pass"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/__eq__",
      "name": "__eq__",
      "qname": "package_parser.processing.api.model._types.BoundaryType.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/__eq__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.BoundaryType.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/__eq__/__o",
          "name": "__o",
          "qname": "package_parser.processing.api.model._types.BoundaryType.__eq__.__o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, __o: object) -> bool:\n        if isinstance(__o, BoundaryType):\n            eq = (\n                self.base_type == __o.base_type\n                and self.min == __o.min\n                and self.min_inclusive == __o.min_inclusive\n                and self.max == __o.max\n            )\n            if eq:\n                if self.max == BoundaryType.INFINITY:\n                    return True\n                return self.max_inclusive == __o.max_inclusive\n        return False"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.api.model._types.BoundaryType.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.BoundaryType.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(\n            (\n                self.base_type,\n                self.min,\n                self.min_inclusive,\n                self.max,\n                self.max_inclusive,\n                self.full_match,\n            )\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/_is_inclusive",
      "name": "_is_inclusive",
      "qname": "package_parser.processing.api.model._types.BoundaryType._is_inclusive",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/_is_inclusive/cls",
          "name": "cls",
          "qname": "package_parser.processing.api.model._types.BoundaryType._is_inclusive.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/_is_inclusive/bracket",
          "name": "bracket",
          "qname": "package_parser.processing.api.model._types.BoundaryType._is_inclusive.bracket",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def _is_inclusive(cls, bracket: str) -> bool:\n        if bracket in (\"(\", \")\"):\n            return False\n        if bracket in (\"[\", \"]\"):\n            return True\n        raise Exception(f\"{bracket} is not one of []()\")"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._types.BoundaryType.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/from_json/cls",
          "name": "cls",
          "qname": "package_parser.processing.api.model._types.BoundaryType.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._types.BoundaryType.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any) -> Optional[BoundaryType]:\n        if json[\"kind\"] == cls.__name__:\n            return BoundaryType(\n                json[\"base_type\"],\n                json[\"min\"],\n                json[\"max\"],\n                json[\"min_inclusive\"],\n                json[\"max_inclusive\"],\n            )\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/from_string",
      "name": "from_string",
      "qname": "package_parser.processing.api.model._types.BoundaryType.from_string",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/from_string/cls",
          "name": "cls",
          "qname": "package_parser.processing.api.model._types.BoundaryType.from_string.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/from_string/string",
          "name": "string",
          "qname": "package_parser.processing.api.model._types.BoundaryType.from_string.string",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_string(cls, string: str) -> Optional[BoundaryType]:\n        # language=PythonRegExp\n        pattern = r\"\"\"(?P<base_type>float|int)?[ ]  # optional base type of either float or int\n                    (in|of)[ ](the[ ])?(range|interval)[ ](of[ ])?  # 'in' or 'of', optional 'the', 'range' or 'interval', optional 'of'\n                    `?(?P<min_bracket>[\\[(])(?P<min>[-+]?\\d+(.\\d*)?|negative_infinity),[ ]  # left side of the range\n                    (?P<max>[-+]?\\d+(.\\d*)?|infinity)(?P<max_bracket>[\\])])`?\"\"\"  # right side of the range\n        match = re.search(pattern, string, re.VERBOSE)\n\n        if match is not None:\n            base_type = match.group(\"base_type\")\n            if base_type is None:\n                base_type = \"float\"\n\n            min_value: Union[str, int, float] = match.group(\"min\")\n            if min_value != \"negative_infinity\":\n                if base_type == \"int\":\n                    min_value = int(min_value)\n                else:\n                    min_value = float(min_value)\n            else:\n                min_value = BoundaryType.NEGATIVE_INFINITY\n\n            max_value: Union[str, int, float] = match.group(\"max\")\n            if max_value != \"infinity\":\n                if base_type == \"int\":\n                    max_value = int(max_value)\n                else:\n                    max_value = float(max_value)\n            else:\n                max_value = BoundaryType.INFINITY\n\n            min_bracket = match.group(\"min_bracket\")\n            max_bracket = match.group(\"max_bracket\")\n            min_inclusive = BoundaryType._is_inclusive(min_bracket)\n            max_inclusive = BoundaryType._is_inclusive(max_bracket)\n\n            return BoundaryType(\n                base_type=base_type,\n                min=min_value,\n                max=max_value,\n                min_inclusive=min_inclusive,\n                max_inclusive=max_inclusive,\n                full_match=match.group(0),\n            )\n\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._types.BoundaryType.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/BoundaryType/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.BoundaryType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, Any]:\n        return {\n            \"kind\": self.__class__.__name__,\n            \"base_type\": self.base_type,\n            \"min\": self.min,\n            \"max\": self.max,\n            \"min_inclusive\": self.min_inclusive,\n            \"max_inclusive\": self.max_inclusive,\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/EnumType/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.api.model._types.EnumType.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/EnumType/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.EnumType.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash((frozenset(self.values), self.full_match))"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/EnumType/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._types.EnumType.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/EnumType/from_json/cls",
          "name": "cls",
          "qname": "package_parser.processing.api.model._types.EnumType.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/EnumType/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._types.EnumType.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any) -> Optional[EnumType]:\n        if json[\"kind\"] == cls.__name__:\n            return EnumType(json[\"values\"])\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/EnumType/from_string",
      "name": "from_string",
      "qname": "package_parser.processing.api.model._types.EnumType.from_string",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/EnumType/from_string/cls",
          "name": "cls",
          "qname": "package_parser.processing.api.model._types.EnumType.from_string.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/EnumType/from_string/string",
          "name": "string",
          "qname": "package_parser.processing.api.model._types.EnumType.from_string.string",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_string(cls, string: str) -> Optional[EnumType]:\n        def remove_backslash(e: str) -> str:\n            e = e.replace(r\"\\\"\", '\"')\n            e = e.replace(r\"\\'\", \"'\")\n            return e\n\n        enum_match = re.search(r\"{(.*?)}\", string)\n        if enum_match:\n            quotes = \"'\\\"\"\n            values = set()\n            enum_str = enum_match.group(1)\n            value = \"\"\n            inside_value = False\n            curr_quote = None\n            for i, char in enumerate(enum_str):\n                if char in quotes and (i == 0 or (i > 0 and enum_str[i - 1] != \"\\\\\")):\n                    if not inside_value:\n                        inside_value = True\n                        curr_quote = char\n                    elif inside_value:\n                        if curr_quote == char:\n                            inside_value = False\n                            curr_quote = None\n                            values.add(remove_backslash(value))\n                            value = \"\"\n                        else:\n                            value += char\n                elif inside_value:\n                    value += char\n\n            return EnumType(values, enum_match.group(0))\n\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/EnumType/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._types.EnumType.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/EnumType/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.EnumType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, Any]:\n        return {\"kind\": self.__class__.__name__, \"values\": self.values}"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/EnumType/update",
      "name": "update",
      "qname": "package_parser.processing.api.model._types.EnumType.update",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/EnumType/update/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.EnumType.update.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/EnumType/update/enum",
          "name": "enum",
          "qname": "package_parser.processing.api.model._types.EnumType.update.enum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def update(self, enum: EnumType) -> None:\n        self.values.update(enum.values)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/NamedType/__eq__",
      "name": "__eq__",
      "qname": "package_parser.processing.api.model._types.NamedType.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/NamedType/__eq__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.NamedType.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/NamedType/__eq__/other",
          "name": "other",
          "qname": "package_parser.processing.api.model._types.NamedType.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: object) -> bool:\n        if isinstance(other, self.__class__):\n            return self.name == other.name\n        return False"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/NamedType/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.api.model._types.NamedType.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/NamedType/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.NamedType.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(self.name)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/NamedType/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._types.NamedType.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/NamedType/from_json/cls",
          "name": "cls",
          "qname": "package_parser.processing.api.model._types.NamedType.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/NamedType/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._types.NamedType.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any) -> Optional[NamedType]:\n        if json.get(\"kind\", \"\") == cls.__name__:\n            return NamedType(json[\"name\"])\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/NamedType/from_string",
      "name": "from_string",
      "qname": "package_parser.processing.api.model._types.NamedType.from_string",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/NamedType/from_string/cls",
          "name": "cls",
          "qname": "package_parser.processing.api.model._types.NamedType.from_string.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/NamedType/from_string/string",
          "name": "string",
          "qname": "package_parser.processing.api.model._types.NamedType.from_string.string",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_string(cls, string: str) -> NamedType:\n        return NamedType(string)"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/NamedType/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._types.NamedType.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/NamedType/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.NamedType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, str]:\n        return {\"kind\": self.__class__.__name__, \"name\": self.name}"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/UnionType/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.api.model._types.UnionType.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/UnionType/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.UnionType.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash((frozenset(self.types)))"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/UnionType/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.api.model._types.UnionType.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/UnionType/from_json/cls",
          "name": "cls",
          "qname": "package_parser.processing.api.model._types.UnionType.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.api.model._types/UnionType/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.api.model._types.UnionType.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any) -> Optional[UnionType]:\n        if json[\"kind\"] == cls.__name__:\n            types = []\n            for element in json[\"types\"]:\n                type_ = AbstractType.from_json(element)\n                if type_ is not None:\n                    types.append(type_)\n            return UnionType(types)\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/UnionType/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.api.model._types.UnionType.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/UnionType/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.api.model._types.UnionType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, Any]:\n        type_list = []\n        for t in self.types:\n            type_list.append(t.to_json())\n\n        return {\"kind\": self.__class__.__name__, \"types\": type_list}"
    },
    {
      "id": "packager-parser/package_parser.processing.api.model._types/create_type",
      "name": "create_type",
      "qname": "package_parser.processing.api.model._types.create_type",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.api.model._types/create_type/parameter_documentation",
          "name": "parameter_documentation",
          "qname": "package_parser.processing.api.model._types.create_type.parameter_documentation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def create_type(\n    parameter_documentation: ParameterDocumentation,\n) -> Optional[AbstractType]:\n    type_string = parameter_documentation.type\n    types: list[AbstractType] = []\n\n    # Collapse whitespaces\n    type_string = re.sub(r\"\\s+\", \" \", type_string)\n\n    # Get boundary from description\n    boundary = BoundaryType.from_string(parameter_documentation.description)\n    if boundary is not None:\n        types.append(boundary)\n\n    # Find all enums and remove them from doc_string\n    enum_array_matches = re.findall(r\"\\{.*?}\", type_string)\n    type_string = re.sub(r\"\\{.*?}\", \" \", type_string)\n    for enum in enum_array_matches:\n        enum_type = EnumType.from_string(enum)\n        if enum_type is not None:\n            types.append(enum_type)\n\n    # Remove default value from doc_string\n    type_string = re.sub(\"default=.*\", \" \", type_string)\n\n    # Create a list with all values and types\n    # \") or (\" must be replaced by a very unlikely string (\"&%&\") so that it is not removed when filtering out.\n    # The string will be replaced by \") or (\" again after filtering out.\n    type_string = re.sub(r\"\\) or \\(\", \"&%&\", type_string)\n    type_string = re.sub(r\" ?, ?or \", \", \", type_string)\n    type_string = re.sub(r\" or \", \", \", type_string)\n    type_string = re.sub(\"&%&\", \") or (\", type_string)\n\n    brackets = 0\n    build_string = \"\"\n    for c in type_string:\n        if c == \"(\":\n            brackets += 1\n        elif c == \")\":\n            brackets -= 1\n\n        if brackets > 0:\n            build_string += c\n            continue\n\n        if brackets == 0 and c != \",\":\n            build_string += c\n        elif brackets == 0 and c == \",\":\n            # remove leading and trailing whitespaces\n            build_string = build_string.strip()\n            if build_string != \"\":\n                named = NamedType.from_string(build_string)\n                types.append(named)\n                build_string = \"\"\n\n    build_string = build_string.strip()\n\n    # Append the last remaining entry\n    if build_string != \"\":\n        named = NamedType.from_string(build_string)\n        types.append(named)\n\n    if len(types) == 1:\n        return types[0]\n    if len(types) == 0:\n        return None\n    return UnionType(types)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause",
      "name": "extract_pattern_parameter_adverbial_clause",
      "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause/dependent_param",
          "name": "dependent_param",
          "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause.dependent_param",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause/func_parameters",
          "name": "func_parameters",
          "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause.func_parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause/match",
          "name": "match",
          "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause.match",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause/param_docstring",
          "name": "param_docstring",
          "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause.param_docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def extract_pattern_parameter_adverbial_clause(\n        dependent_param: Parameter,\n        func_parameters: List[Parameter],\n        match: Tuple,\n        param_docstring: Doc,\n    ) -> Union[Dependency, None]:\n        is_depending_on_param_index = match[1][2]\n        is_depending_on_param_name = param_docstring[is_depending_on_param_index].text\n        is_depending_on_param = next(\n            filter(\n                lambda param: param.name == is_depending_on_param_name, func_parameters\n            ),\n            None,\n        )\n        if is_depending_on_param is None:\n            # Likely not a correct dependency match\n            return None\n\n        condition_token = param_docstring[match[1][1]]\n        condition = extract_condition(condition_token)\n\n        action_token = param_docstring[match[1][0]]\n        action = extract_action(action_token, condition_token)\n\n        return Dependency(\n            hasDependentParameter=dependent_param,\n            isDependingOn=is_depending_on_param,\n            hasCondition=condition,\n            hasAction=action,\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_action",
      "name": "extract_action",
      "qname": "package_parser.processing.dependencies._get_dependency.extract_action",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_action/action_token",
          "name": "action_token",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_action.action_token",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_action/condition_token",
          "name": "condition_token",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_action.condition_token",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create action object given head token of action phrase in docstring.\nCondition token used to avoid traversing into the condition phrase dependency subtree of the docstring.",
      "docstring": "Create action object given head token of action phrase in docstring.\nCondition token used to avoid traversing into the condition phrase dependency subtree of the docstring.",
      "code": "def extract_action(action_token: Token, condition_token: Token) -> Action:\n    \"\"\"\n    Create action object given head token of action phrase in docstring.\n    Condition token used to avoid traversing into the condition phrase dependency subtree of the docstring.\n    \"\"\"\n    action_tokens = []\n    action_lefts = list(action_token.lefts)\n    action_rights = list(action_token.rights)\n\n    for token in action_lefts:\n        if token != condition_token:\n            action_tokens.extend(extract_lefts_and_rights(token))\n    action_tokens.append(action_token.text)\n    for token in action_rights:\n        if token != condition_token:\n            action_tokens.extend(extract_lefts_and_rights(token))\n\n    # Remove trailing punctuation\n    if any(p == action_tokens[-1] for p in [\",\", \".\"]):\n        del action_tokens[-1]\n    action_text = \" \".join(action_tokens)\n\n    ignored_phrases = [\n        \"ignored\",\n        \"not used\",\n        \"no impact\",\n        \"only supported\",\n        \"only applies\",\n    ]\n    illegal_phrases = [\"raise\", \"exception\", \"must be\", \"must not be\"]\n    if any(phrase in action_text.lower() for phrase in ignored_phrases):\n        return ParameterIsIgnored(action=action_text)\n    elif any(phrase in action_text.lower() for phrase in illegal_phrases):\n        return ParameterIsIllegal(action=action_text)\n    else:\n        return Action(action=action_text)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_condition",
      "name": "extract_condition",
      "qname": "package_parser.processing.dependencies._get_dependency.extract_condition",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_condition/condition_token",
          "name": "condition_token",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_condition.condition_token",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create condition object given head token of condition phrase in docstring.",
      "docstring": "Create condition object given head token of condition phrase in docstring.",
      "code": "def extract_condition(condition_token: Token) -> Condition:\n    \"\"\"\n    Create condition object given head token of condition phrase in docstring.\n    \"\"\"\n    condition_token_subtree = list(condition_token.subtree)\n    condition_text = \" \".join([token.text for token in condition_token_subtree])\n\n    is_none_phrases = [\n        \"is none\",\n        \"is also none\" \"is not set\",\n        \"is not specified\",\n        \"is not none\",\n        \"if none\",\n        \"if not none\",\n    ]\n    has_value_phrases = [\n        \"equals\",\n        \"is true\",\n        \"is false\",\n        \"is set to\",\n        \"is greater than\",\n        \"is less than\",\n    ]\n    if any(phrase in condition_text.lower() for phrase in is_none_phrases):\n        return ParameterIsNone(condition=condition_text)\n    elif any(phrase in condition_text.lower() for phrase in has_value_phrases):\n        return ParameterHasValue(condition=condition_text)\n    else:\n        return Condition(condition=condition_text)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring",
      "name": "extract_dependencies_from_docstring",
      "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/parameter",
          "name": "parameter",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.parameter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/func_parameters",
          "name": "func_parameters",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.func_parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/param_docstring",
          "name": "param_docstring",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.param_docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/matches",
          "name": "matches",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.matches",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/spacy_id_to_pattern_id_mapping",
          "name": "spacy_id_to_pattern_id_mapping",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.spacy_id_to_pattern_id_mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Extract readable dependencies in a Docstring from pattern matches.\nFunction fetched from class DependencyExtractor, when 'extract_' + pattern name match function name in the class.",
      "docstring": "Extract readable dependencies in a Docstring from pattern matches.\nFunction fetched from class DependencyExtractor, when 'extract_' + pattern name match function name in the class.",
      "code": "def extract_dependencies_from_docstring(\n    parameter: Parameter,\n    func_parameters: List[Parameter],\n    param_docstring: Span,\n    matches: List,\n    spacy_id_to_pattern_id_mapping: Dict,\n) -> List[Dependency]:\n    \"\"\"\n    Extract readable dependencies in a Docstring from pattern matches.\n    Function fetched from class DependencyExtractor, when 'extract_' + pattern name match function name in the class.\n    \"\"\"\n    dependencies = list()\n    for match in matches:\n        pattern_id = spacy_id_to_pattern_id_mapping[match[0]]\n        extract_dependency_method = getattr(\n            DependencyExtractor, f\"extract_{pattern_id}\"\n        )\n        dependency = extract_dependency_method(\n            parameter, func_parameters, match, param_docstring\n        )\n        if dependency is not None:\n            dependencies.append(dependency)\n    return dependencies"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_lefts_and_rights",
      "name": "extract_lefts_and_rights",
      "qname": "package_parser.processing.dependencies._get_dependency.extract_lefts_and_rights",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_lefts_and_rights/curr_token",
          "name": "curr_token",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_lefts_and_rights.curr_token",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/extract_lefts_and_rights/extracted",
          "name": "extracted",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_lefts_and_rights.extracted",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Given a spaCy token, extract recursively all tokens in its dependency subtree in inorder traversal.",
      "docstring": "Given a spaCy token, extract recursively all tokens in its dependency subtree in inorder traversal.",
      "code": "def extract_lefts_and_rights(curr_token: Token, extracted: Union[List, None] = None):\n    \"\"\"\n    Given a spaCy token, extract recursively all tokens in its dependency subtree in inorder traversal.\n    \"\"\"\n    if extracted is None:\n        extracted = []\n\n    token_lefts = list(curr_token.lefts)\n    for token in token_lefts:\n        extract_lefts_and_rights(token, extracted)\n\n    extracted.append(curr_token.text)\n\n    token_rights = list(curr_token.rights)\n    for token in token_rights:\n        extract_lefts_and_rights(token, extracted)\n\n    return extracted"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._get_dependency/get_dependencies",
      "name": "get_dependencies",
      "qname": "package_parser.processing.dependencies._get_dependency.get_dependencies",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._get_dependency/get_dependencies/api",
          "name": "api",
          "qname": "package_parser.processing.dependencies._get_dependency.get_dependencies.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Loop through all functions in the API\nParse and preprocess each doc string from every function\nExtract and return all dependencies as a dict with function and parameter names as keys",
      "docstring": "Loop through all functions in the API\nParse and preprocess each doc string from every function\nExtract and return all dependencies as a dict with function and parameter names as keys",
      "code": "def get_dependencies(api: API) -> APIDependencies:\n    \"\"\"\n    Loop through all functions in the API\n    Parse and preprocess each doc string from every function\n    Extract and return all dependencies as a dict with function and parameter names as keys\n    \"\"\"\n    nlp = spacy.load(PIPELINE)\n\n    matcher = DependencyMatcher(nlp.vocab)\n    spacy_id_to_pattern_id_mapping: Dict = dict()\n    for pattern_id, pattern in dependency_matcher_patterns.items():\n        matcher.add(pattern_id, [pattern])\n        spacy_id_to_pattern_id_mapping[nlp.vocab.strings[pattern_id]] = pattern_id\n    all_dependencies: Dict = dict()\n    endpoint_functions = api.functions\n\n    for function_name, function in endpoint_functions.items():\n        parameters = function.parameters\n        all_dependencies[function_name] = {}\n        for parameter in parameters:\n            docstring = parameter.documentation.description\n            docstring_preprocessed = preprocess_docstring(docstring)\n            doc = nlp(docstring_preprocessed)\n            param_dependencies = []\n            for sentence in doc.sents:\n                sentence_dependency_matches = matcher(sentence)\n                sentence_dependencies = extract_dependencies_from_docstring(\n                    parameter,\n                    parameters,\n                    sentence,\n                    sentence_dependency_matches,\n                    spacy_id_to_pattern_id_mapping,\n                )\n                if sentence_dependencies:\n                    param_dependencies.extend(sentence_dependencies)\n            if param_dependencies:\n                all_dependencies[function_name][parameter.name] = param_dependencies\n\n    return APIDependencies(dependencies=all_dependencies)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/APIDependencies/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.APIDependencies.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/APIDependencies/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.APIDependencies.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Dict:\n        return {\n            function_name: {\n                parameter_name: [dependency.to_json() for dependency in dependencies]\n                for parameter_name, dependencies in parameter_name.items()\n            }\n            for function_name, parameter_name in self.dependencies.items()\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Action/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.Action.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Action/from_json/cls",
          "name": "cls",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.Action.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Action/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.Action.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any):\n        return cls(json[\"action\"])"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Action/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.Action.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Action/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.Action.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Dict:\n        return {\"action\": self.action}"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Condition/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.Condition.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Condition/from_json/cls",
          "name": "cls",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.Condition.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Condition/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.Condition.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any):\n        return cls(json[\"condition\"])"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Condition/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.Condition.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Condition/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.Condition.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Dict:\n        return {\"condition\": self.condition}"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Dependency/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.Dependency.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Dependency/from_json/cls",
          "name": "cls",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.Dependency.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Dependency/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.Dependency.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any):\n        return cls(\n            Parameter.from_json(json[\"hasDependentParameter\"]),\n            Parameter.from_json(json[\"isDependingOn\"]),\n            Condition.from_json(json[\"hasCondition\"]),\n            Action.from_json(json[\"hasAction\"]),\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Dependency/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.Dependency.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/Dependency/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.Dependency.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"hasDependentParameter\": self.hasDependentParameter.to_json(),\n            \"isDependingOn\": self.isDependingOn.to_json(),\n            \"hasCondition\": self.hasCondition.to_json(),\n            \"hasAction\": self.hasAction.to_json(),\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterHasValue/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterHasValue.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterHasValue/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterHasValue.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterHasValue/__init__/condition",
          "name": "condition",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterHasValue.__init__.condition",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, condition: str) -> None:\n        super().__init__(condition)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIgnored/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsIgnored.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIgnored/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsIgnored.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIgnored/__init__/action",
          "name": "action",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsIgnored.__init__.action",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, action: str) -> None:\n        super().__init__(action)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIllegal/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsIllegal.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIllegal/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsIllegal.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsIllegal/__init__/action",
          "name": "action",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsIllegal.__init__.action",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, action: str) -> None:\n        super().__init__(action)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsNone/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsNone.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsNone/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsNone.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/ParameterIsNone/__init__/condition",
          "name": "condition",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.ParameterIsNone.__init__.condition",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, condition: str) -> None:\n        super().__init__(condition)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeAction/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.RuntimeAction.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeAction/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.RuntimeAction.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeAction/__init__/action",
          "name": "action",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.RuntimeAction.__init__.action",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, action: str) -> None:\n        super().__init__(action)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeCondition/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.RuntimeCondition.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeCondition/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.RuntimeCondition.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/RuntimeCondition/__init__/condition",
          "name": "condition",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.RuntimeCondition.__init__.condition",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, condition: str) -> None:\n        super().__init__(condition)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticAction/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.StaticAction.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticAction/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.StaticAction.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticAction/__init__/action",
          "name": "action",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.StaticAction.__init__.action",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, action: str) -> None:\n        super().__init__(action)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticCondition/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.dependencies._parameter_dependencies.StaticCondition.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticCondition/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.StaticCondition.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.dependencies._parameter_dependencies/StaticCondition/__init__/condition",
          "name": "condition",
          "qname": "package_parser.processing.dependencies._parameter_dependencies.StaticCondition.__init__.condition",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, condition: str) -> None:\n        super().__init__(condition)"
    },
    {
      "id": "packager-parser/package_parser.processing.dependencies._preprocess_docstring/preprocess_docstring",
      "name": "preprocess_docstring",
      "qname": "package_parser.processing.dependencies._preprocess_docstring.preprocess_docstring",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.dependencies._preprocess_docstring/preprocess_docstring/docstring",
          "name": "docstring",
          "qname": "package_parser.processing.dependencies._preprocess_docstring.preprocess_docstring.docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "1. Remove cluttered punctuation around parameter references\n2. Set '=', ==' to 'equals' and set '!=' to 'does not equal'\n3. Handle cases of step two where the signs are not separate tokens, e.g. \"a=b\".\nNote ordered dict since \"=\" is a substring of the other symbols.",
      "docstring": "1. Remove cluttered punctuation around parameter references\n2. Set '=', ==' to 'equals' and set '!=' to 'does not equal'\n3. Handle cases of step two where the signs are not separate tokens, e.g. \"a=b\".\nNote ordered dict since \"=\" is a substring of the other symbols.",
      "code": "def preprocess_docstring(docstring: str) -> str:\n    \"\"\"\n    1. Remove cluttered punctuation around parameter references\n    2. Set '=', ==' to 'equals' and set '!=' to 'does not equal'\n    3. Handle cases of step two where the signs are not separate tokens, e.g. \"a=b\".\n    Note ordered dict since \"=\" is a substring of the other symbols.\n    \"\"\"\n\n    docstring = re.sub(r'[\"\u201c\u201d`]', \"\", docstring)\n    docstring = re.sub(r\"'\", \"\", docstring)\n    docstring = re.sub(r\"!=\", \" does not equal \", docstring)\n    docstring = re.sub(r\"==?\", \" equals \", docstring)\n    docstring = re.sub(r\"\\s+\", \" \", docstring)\n\n    return docstring"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/differ",
          "name": "differ",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/threshold_of_similarity_for_creation_of_mappings",
          "name": "threshold_of_similarity_for_creation_of_mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.threshold_of_similarity_for_creation_of_mappings",
          "default_value": "0.5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/threshold_of_similarity_between_mappings",
          "name": "threshold_of_similarity_between_mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.threshold_of_similarity_between_mappings",
          "default_value": "0.05",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/threshold_of_merging_mappings",
          "name": "threshold_of_merging_mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.threshold_of_merging_mappings",
          "default_value": "0.3",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        apiv1: API,\n        apiv2: API,\n        differ: AbstractDiffer,\n        threshold_of_similarity_for_creation_of_mappings: float = 0.5,\n        threshold_of_similarity_between_mappings: float = 0.05,\n        threshold_of_merging_mappings: float = 0.3,\n    ) -> None:\n        self.apiv1 = apiv1\n        self.apiv2 = apiv2\n        self.differ = differ\n        self.threshold_of_similarity_for_creation_of_mappings = (\n            threshold_of_similarity_for_creation_of_mappings\n        )\n        self.threshold_of_similarity_between_mappings = (\n            threshold_of_similarity_between_mappings\n        )\n        self.threshold_of_merging_mappings = threshold_of_merging_mappings"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements",
      "name": "_get_mappings_for_api_elements",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements/api_elementv1_list",
          "name": "api_elementv1_list",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements.api_elementv1_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements/api_elementv2_list",
          "name": "api_elementv2_list",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements.api_elementv2_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements/compute_similarity",
          "name": "compute_similarity",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements.compute_similarity",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mappings_for_api_elements(\n        self,\n        api_elementv1_list: List[API_ELEMENTS],\n        api_elementv2_list: List[API_ELEMENTS],\n        compute_similarity: Callable[[API_ELEMENTS, API_ELEMENTS], float],\n    ) -> list[Mapping]:\n        element_mappings: list[Mapping] = []\n        for api_elementv1 in api_elementv1_list:\n            mapping_for_api_elementv1: list[Mapping] = []\n            for api_elementv2 in api_elementv2_list:\n                similarity = compute_similarity(api_elementv1, api_elementv2)\n                if similarity >= self.threshold_of_similarity_for_creation_of_mappings:\n                    mapping_for_api_elementv1.append(\n                        OneToOneMapping(similarity, api_elementv1, api_elementv2)\n                    )\n            mapping_for_api_elementv1.sort(key=Mapping.get_similarity, reverse=True)\n            new_mapping = self._merge_similar_mappings(mapping_for_api_elementv1)\n            if new_mapping is not None:\n                self._merge_mappings_with_same_elements(new_mapping, element_mappings)\n        return element_mappings"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements",
      "name": "_merge_mappings_with_same_elements",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_mappings_with_same_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_mappings_with_same_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements/mapping_to_be_appended",
          "name": "mapping_to_be_appended",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_mappings_with_same_elements.mapping_to_be_appended",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_mappings_with_same_elements.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This method prevents that an element in a mapping appears multiple times in a list of mappings\nby merging the affected mappings and include the result in the list. If there is no such element,\nthe mapping will be included without any merge.\n\n:param mapping_to_be_appended: the mapping that should be included in mappings\n:param mappings: the list, in which mapping_to_be_appended should be appended",
      "docstring": "This method prevents that an element in a mapping appears multiple times in a list of mappings\nby merging the affected mappings and include the result in the list. If there is no such element,\nthe mapping will be included without any merge.\n\n:param mapping_to_be_appended: the mapping that should be included in mappings\n:param mappings: the list, in which mapping_to_be_appended should be appended",
      "code": "    def _merge_mappings_with_same_elements(\n        self, mapping_to_be_appended: Mapping, mappings: list[Mapping]\n    ) -> None:\n        \"\"\"\n        This method prevents that an element in a mapping appears multiple times in a list of mappings\n        by merging the affected mappings and include the result in the list. If there is no such element,\n        the mapping will be included without any merge.\n\n        :param mapping_to_be_appended: the mapping that should be included in mappings\n        :param mappings: the list, in which mapping_to_be_appended should be appended\n        \"\"\"\n        duplicated: list[Mapping] = []\n        for mapping in mappings:\n            duplicated_element = False\n            for element in mapping.get_apiv2_elements():\n                for element_2 in mapping_to_be_appended.get_apiv2_elements():\n                    if element == element_2:\n                        duplicated_element = True\n                        break\n            if duplicated_element:\n                duplicated.append(mapping)\n\n        if len(duplicated) == 0:\n            mappings.append(mapping_to_be_appended)\n            return\n\n        for conflicted_mapping in duplicated:\n            mapping_to_be_appended = merge_mappings(\n                mapping_to_be_appended, conflicted_mapping\n            )\n            mappings.remove(conflicted_mapping)\n\n        mappings.append(mapping_to_be_appended)"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_similar_mappings",
      "name": "_merge_similar_mappings",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_similar_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_similar_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_similar_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_similar_mappings/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_similar_mappings.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\nfrom this apiv1 element to apiv2 elements by merging the first and second elements recursively,\nif the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n:param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n:return: the first element of the sorted list that could be a result of merged similar mappings",
      "docstring": "Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\nfrom this apiv1 element to apiv2 elements by merging the first and second elements recursively,\nif the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n:param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n:return: the first element of the sorted list that could be a result of merged similar mappings",
      "code": "    def _merge_similar_mappings(self, mappings: List[Mapping]) -> Optional[Mapping]:\n        \"\"\"\n        Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\n        from this apiv1 element to apiv2 elements by merging the first and second elements recursively,\n        if the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n        :param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n        :return: the first element of the sorted list that could be a result of merged similar mappings\n        \"\"\"\n        if len(mappings) == 0:\n            return None\n        if len(mappings) == 1:\n            return mappings[0]\n        while (len(mappings) > 1) and (\n            (mappings[0].similarity - mappings[1].similarity)\n            < self.threshold_of_similarity_between_mappings\n        ):\n            mappings[0] = merge_mappings(mappings[0], mappings[1])\n            mappings.pop(1)\n        return mappings[0]"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/map_api",
      "name": "map_api",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping.map_api",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._api_mapping/APIMapping/map_api/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.map_api.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def map_api(self) -> List[Mapping]:\n        mappings: List[Mapping] = []\n        related_mappings = self.differ.get_related_mappings()\n        if related_mappings is not None:\n            for mapping in related_mappings:\n                new_mapping = None\n                if isinstance(\n                    mapping.get_apiv1_elements()[0], Attribute\n                ) and isinstance(mapping.get_apiv2_elements()[0], Attribute):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        self.differ.compute_attribute_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Class) and isinstance(\n                    mapping.get_apiv2_elements()[0], Class\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Class)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Class)\n                        ],\n                        self.differ.compute_class_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Function\n                ) and isinstance(mapping.get_apiv2_elements()[0], Function):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Function)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Function)\n                        ],\n                        self.differ.compute_function_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Parameter\n                ) and isinstance(mapping.get_apiv2_elements()[0], Parameter):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        self.differ.compute_parameter_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Result) and isinstance(\n                    mapping.get_apiv2_elements()[0], Result\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Result)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Result)\n                        ],\n                        self.differ.compute_result_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                if new_mapping is not None and len(new_mapping) > 0:\n                    self.differ.notify_new_mapping(new_mapping)\n        else:\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.classes.values()),\n                    list(self.apiv2.classes.values()),\n                    self.differ.compute_class_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.functions.values()),\n                    list(self.apiv2.functions.values()),\n                    self.differ.compute_function_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.parameters().values()),\n                    list(self.apiv2.parameters().values()),\n                    self.differ.compute_parameter_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        attribute\n                        for class_ in self.apiv1.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    [\n                        attribute\n                        for class_ in self.apiv2.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    self.differ.compute_attribute_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        result\n                        for function in self.apiv1.functions.values()\n                        for result in function.results\n                    ],\n                    [\n                        result\n                        for function in self.apiv2.functions.values()\n                        for result in function.results\n                    ],\n                    self.differ.compute_result_similarity,\n                )\n            )\n        mappings.extend(self.differ.get_additional_mappings())\n        mappings.sort(key=Mapping.get_similarity, reverse=True)\n        return mappings"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration/__post_init__",
      "name": "__post_init__",
      "qname": "package_parser.processing.migration._migrate.Migration.__post_init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/__post_init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration.__post_init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __post_init__(self) -> None:\n        self.migrated_annotation_store = AnnotationStore()\n        self.unsure_migrated_annotation_store = AnnotationStore()"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_mapping_from_annotation",
      "name": "_get_mapping_from_annotation",
      "qname": "package_parser.processing.migration._migrate.Migration._get_mapping_from_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_mapping_from_annotation/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._get_mapping_from_annotation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_mapping_from_annotation/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration._migrate.Migration._get_mapping_from_annotation.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mapping_from_annotation(\n        self, annotation: AbstractAnnotation\n    ) -> Optional[Mapping]:\n        for mapping in self.mappings:\n            for element in mapping.get_apiv1_elements():\n                if (\n                    not isinstance(element, (Attribute, Result))\n                    and element.id == annotation.target\n                ):\n                    return mapping\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_mappings_for_table",
      "name": "_get_mappings_for_table",
      "qname": "package_parser.processing.migration._migrate.Migration._get_mappings_for_table",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_mappings_for_table/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._get_mappings_for_table.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mappings_for_table(self) -> list[str]:\n        table_rows: list[str] = []\n        for mapping in self.mappings:\n\n            def print_api_element(\n                api_element: Union[Attribute, Class, Function, Parameter, Result]\n            ) -> str:\n                if isinstance(api_element, Result):\n                    return api_element.name\n                if isinstance(api_element, Attribute):\n                    return str(api_element.class_id) + \"/\" + api_element.name\n                return api_element.id\n\n            apiv1_elements = \", \".join(\n                [\n                    print_api_element(api_element)\n                    for api_element in mapping.get_apiv1_elements()\n                ]\n            )\n            apiv2_elements = \", \".join(\n                [\n                    print_api_element(api_element)\n                    for api_element in mapping.get_apiv2_elements()\n                ]\n            )\n            apiv1_elements = \"`\" + apiv1_elements + \"`\"\n            apiv2_elements = \"`\" + apiv2_elements + \"`\"\n            table_rows.append(\n                f\"{mapping.similarity:.4}|{apiv1_elements}|{apiv2_elements}|\"\n            )\n        return table_rows"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string",
      "name": "_get_not_mapped_api_elements_as_string",
      "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_as_string",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_as_string.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string/api",
          "name": "api",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_as_string.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string/print_for_apiv2",
          "name": "print_for_apiv2",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_as_string.print_for_apiv2",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_not_mapped_api_elements_as_string(\n        self, api: API, print_for_apiv2: bool = False\n    ) -> list[str]:\n        not_mapped_api_elements: list[str] = []\n\n        def is_included(\n            api_element: Union[Attribute, Class, Function, Parameter, Result]\n        ) -> bool:\n            if not print_for_apiv2:\n                for mapping in self.mappings:\n                    for element in mapping.get_apiv1_elements():\n                        if isinstance(api_element, Attribute) and isinstance(\n                            element, Attribute\n                        ):\n                            if element.name == api_element.name and isinstance(\n                                element.types, type(api_element.types)\n                            ):\n                                return True\n                        if isinstance(api_element, Result) and isinstance(\n                            element, Result\n                        ):\n                            if (\n                                element.name == api_element.name\n                                and element.docstring == api_element.docstring\n                            ):\n                                return True\n                        if not isinstance(\n                            api_element, (Attribute, Result)\n                        ) and not isinstance(element, (Attribute, Result)):\n                            if element.id == api_element.id:\n                                return True\n                return False\n            for mapping in self.mappings:\n                for element in mapping.get_apiv2_elements():\n                    if isinstance(api_element, Attribute) and isinstance(\n                        element, Attribute\n                    ):\n                        if element.name == api_element.name and isinstance(\n                            element.types, type(api_element.types)\n                        ):\n                            return True\n                    if isinstance(api_element, Result) and isinstance(element, Result):\n                        if (\n                            element.name == api_element.name\n                            and element.docstring == api_element.docstring\n                        ):\n                            return True\n                    if not isinstance(\n                        api_element, (Attribute, Result)\n                    ) and not isinstance(element, (Attribute, Result)):\n                        if element.id == api_element.id:\n                            return True\n            return False\n\n        for class_ in api.classes.values():\n            if not is_included(class_):\n                not_mapped_api_elements.append(class_.id)\n        for function in api.functions.values():\n            if not is_included(function):\n                not_mapped_api_elements.append(function.id)\n        for parameter in api.parameters().values():\n            if not is_included(parameter):\n                not_mapped_api_elements.append(parameter.id)\n        for attribute, class_ in [\n            (attribute, class_)\n            for class_ in api.classes.values()\n            for attribute in class_.instance_attributes\n        ]:\n            if not is_included(attribute):\n                not_mapped_api_elements.append(class_.id + \"/\" + attribute.name)\n        for result, function in [\n            (result, function)\n            for function in api.functions.values()\n            for result in function.results\n        ]:\n            if not is_included(result):\n                not_mapped_api_elements.append(function.id + \"/\" + result.name)\n        return not_mapped_api_elements"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table",
      "name": "_get_not_mapped_api_elements_for_table",
      "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_for_table",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_for_table.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_for_table.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_for_table.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_not_mapped_api_elements_for_table(\n        self, apiv1: API, apiv2: API\n    ) -> list[str]:\n        not_mapped_api_elements: list[str] = []\n        not_mapped_apiv1_elements = self._get_not_mapped_api_elements_as_string(apiv1)\n        for element_id in not_mapped_apiv1_elements:\n            not_mapped_api_elements.append(f\"-|`{element_id}`||\")\n        not_mapped_apiv2_elements = self._get_not_mapped_api_elements_as_string(\n            apiv2, print_for_apiv2=True\n        )\n        for element_id in not_mapped_apiv2_elements:\n            not_mapped_api_elements.append(f\"-||`{element_id}`|\")\n        return not_mapped_api_elements"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_handle_duplicates",
      "name": "_handle_duplicates",
      "qname": "package_parser.processing.migration._migrate.Migration._handle_duplicates",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/_handle_duplicates/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._handle_duplicates.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _handle_duplicates(self) -> None:\n        for annotation_type in [\n            \"boundaryAnnotations\",\n            \"calledAfterAnnotations\",\n            \"descriptionAnnotations\",\n            \"enumAnnotations\",\n            \"expertAnnotations\",\n            \"groupAnnotations\",\n            \"moveAnnotations\",\n            \"pureAnnotations\",\n            \"removeAnnotations\",\n            \"renameAnnotations\",\n            \"todoAnnotations\",\n            \"valueAnnotations\",\n        ]:\n            migrated_annotations = [\n                annotation\n                for annotation_store in [\n                    self.migrated_annotation_store,\n                    self.unsure_migrated_annotation_store,\n                ]\n                for annotation in getattr(annotation_store, annotation_type)\n            ]\n            duplicates_dict: dict[str, list[AbstractAnnotation]] = {}\n            for duplicated_annotations in migrated_annotations:\n                if duplicated_annotations.target in duplicates_dict:\n                    duplicates_dict[duplicated_annotations.target].append(\n                        duplicated_annotations\n                    )\n                    continue\n                for annotation in migrated_annotations:\n                    if (\n                        duplicated_annotations is annotation\n                        or annotation.target in duplicates_dict\n                    ):\n                        continue\n                    if (\n                        isinstance(annotation, type(duplicated_annotations))\n                        and annotation.target == duplicated_annotations.target\n                    ):\n                        duplicates = duplicates_dict.get(annotation.target, [])\n                        duplicates.append(annotation)\n                        duplicates.append(duplicated_annotations)\n                        duplicates_dict[duplicated_annotations.target] = duplicates\n                        break\n\n            for duplicates in duplicates_dict.values():\n                if len(duplicates) > 1:\n                    duplicates = sorted(\n                        duplicates, key=lambda annotation: annotation.reviewResult.name\n                    )\n                    different_values = set()\n                    first_annotation_and_value: Optional[\n                        tuple[AbstractAnnotation, str]\n                    ] = None\n                    for annotation in duplicates:\n                        annotation_dict = annotation.to_json()\n                        for key in [\n                            \"target\",\n                            \"authors\",\n                            \"reviewers\",\n                            \"comment\",\n                            \"reviewResult\",\n                        ]:\n                            del annotation_dict[key]\n                        annotation_value = str(annotation_dict)\n                        if first_annotation_and_value is None:\n                            first_annotation_and_value = annotation, annotation_value\n                        different_values.add(annotation_value)\n\n                    if first_annotation_and_value is not None:\n                        first_annotation, first_value = first_annotation_and_value\n                        if len(different_values) > 1:\n                            different_values.remove(first_value)\n                            comment = (\n                                \"Conflicting Attribute during migration: \"\n                                + \", \".join(sorted(different_values))\n                            )\n                            first_annotation.comment = (\n                                \"\\n\".join([comment, first_annotation.comment])\n                                if len(first_annotation.comment) > 0\n                                else comment\n                            )\n                            first_annotation.reviewResult = EnumReviewResult.UNSURE\n                        for annotation_store in [\n                            self.migrated_annotation_store,\n                            self.unsure_migrated_annotation_store,\n                        ]:\n                            for annotation in duplicates:\n                                if annotation is first_annotation:\n                                    continue\n                                annotations: list[AbstractAnnotation] = getattr(\n                                    annotation_store, annotation_type\n                                )\n                                if annotation in annotations:\n                                    annotations.remove(annotation)"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity",
      "name": "add_annotations_based_on_similarity",
      "qname": "package_parser.processing.migration._migrate.Migration.add_annotations_based_on_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration.add_annotations_based_on_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration._migrate.Migration.add_annotations_based_on_similarity.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity/similarity",
          "name": "similarity",
          "qname": "package_parser.processing.migration._migrate.Migration.add_annotations_based_on_similarity.similarity",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_annotations_based_on_similarity(\n        self, annotation: AbstractAnnotation, similarity: float\n    ) -> None:\n        if similarity >= self.reliable_similarity:\n            self.migrated_annotation_store.add_annotation(annotation)\n        elif similarity >= self.unsure_similarity:\n            annotation.reviewResult = EnumReviewResult.UNSURE\n            self.migrated_annotation_store.add_annotation(annotation)\n        else:\n            self.unsure_migrated_annotation_store.add_annotation(annotation)"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration/migrate_annotations",
      "name": "migrate_annotations",
      "qname": "package_parser.processing.migration._migrate.Migration.migrate_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/migrate_annotations/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration.migrate_annotations.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def migrate_annotations(self) -> None:\n        for boundary_annotation in self.annotationsv1.boundaryAnnotations:\n            mapping = self._get_mapping_from_annotation(boundary_annotation)\n            if mapping is not None:\n                for annotation in migrate_boundary_annotation(\n                    boundary_annotation, mapping\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for called_after_annotation in self.annotationsv1.calledAfterAnnotations:\n            mapping = self._get_mapping_from_annotation(called_after_annotation)\n            if mapping is not None:\n                for annotation in migrate_called_after_annotation(\n                    called_after_annotation, mapping, self.mappings\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for description_annotation in self.annotationsv1.descriptionAnnotations:\n            mapping = self._get_mapping_from_annotation(description_annotation)\n            if mapping is not None:\n                for annotation in migrate_description_annotation(\n                    description_annotation, mapping\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for enum_annotation in self.annotationsv1.enumAnnotations:\n            mapping = self._get_mapping_from_annotation(enum_annotation)\n            if mapping is not None:\n                for annotation in migrate_enum_annotation(enum_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for expert_annotation in self.annotationsv1.expertAnnotations:\n            mapping = self._get_mapping_from_annotation(expert_annotation)\n            if mapping is not None:\n                for annotation in migrate_expert_annotation(expert_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for group_annotation in self.annotationsv1.groupAnnotations:\n            mapping = self._get_mapping_from_annotation(group_annotation)\n            if mapping is not None:\n                for annotation in migrate_group_annotation(\n                    group_annotation, mapping, self.mappings\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for move_annotation in self.annotationsv1.moveAnnotations:\n            mapping = self._get_mapping_from_annotation(move_annotation)\n            if mapping is not None:\n                for annotation in migrate_move_annotation(move_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for rename_annotation in self.annotationsv1.renameAnnotations:\n            mapping = self._get_mapping_from_annotation(rename_annotation)\n            if mapping is not None:\n                for annotation in migrate_rename_annotation(rename_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for remove_annotation in self.annotationsv1.removeAnnotations:\n            mapping = self._get_mapping_from_annotation(remove_annotation)\n            if mapping is not None:\n                for annotation in migrate_remove_annotation(remove_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for todo_annotation in self.annotationsv1.todoAnnotations:\n            mapping = self._get_mapping_from_annotation(todo_annotation)\n            if mapping is not None:\n                for annotation in migrate_todo_annotation(todo_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for value_annotation in self.annotationsv1.valueAnnotations:\n            mapping = self._get_mapping_from_annotation(value_annotation)\n            if mapping is not None:\n                for annotation in migrate_value_annotation(value_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n        self._handle_duplicates()"
    },
    {
      "id": "packager-parser/package_parser.processing.migration._migrate/Migration/print",
      "name": "print",
      "qname": "package_parser.processing.migration._migrate.Migration.print",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/print/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration.print.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/print/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration._migrate.Migration.print.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration._migrate/Migration/print/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration._migrate.Migration.print.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print(self, apiv1: API, apiv2: API) -> None:\n        print(\n            \"**Similarity**|**APIV1**|**APIV2**|**comment**\\n:-----:|:-----:|:-----:|:----:|\"\n        )\n        table_body = self._get_mappings_for_table()\n        table_body.extend(self._get_not_mapped_api_elements_for_table(apiv1, apiv2))\n        table_body.sort(\n            key=lambda row: max(len(cell.split(\"/\")) for cell in row.split(\"|\")[:-1])\n        )\n        print(\"\\n\".join(table_body))"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element",
      "name": "get_annotated_api_element",
      "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element/api_element_list",
          "name": "api_element_list",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element.api_element_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_annotated_api_element(\n    annotation: AbstractAnnotation,\n    api_element_list: List[Union[Attribute, Class, Function, Parameter, Result]],\n) -> Optional[Union[Class, Function, Parameter]]:\n    for element in api_element_list:\n        if (\n            isinstance(element, (Class, Function, Parameter))\n            and element.id == annotation.target\n        ):\n            return element\n    return None"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element_by_type",
      "name": "get_annotated_api_element_by_type",
      "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element_by_type",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element_by_type/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element_by_type.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element_by_type/api_element_list",
          "name": "api_element_list",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element_by_type.api_element_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element_by_type/api_type",
          "name": "api_type",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element_by_type.api_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_annotated_api_element_by_type(\n    annotation: AbstractAnnotation,\n    api_element_list: List[Union[Attribute, Class, Function, Parameter, Result]],\n    api_type: type[API_ELEMENTS],\n) -> Optional[API_ELEMENTS]:\n    for element in api_element_list:\n        if isinstance(element, api_type) and element.id == annotation.target:\n            return element\n    return None"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text/_get_further_information",
      "name": "_get_further_information",
      "qname": "package_parser.processing.migration.annotations._get_migration_text._get_further_information",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text/_get_further_information/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._get_migration_text._get_further_information.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_further_information(annotation: AbstractAnnotation) -> str:\n    if isinstance(\n        annotation,\n        (CompleteAnnotation, ExpertAnnotation, PureAnnotation, RemoveAnnotation),\n    ):\n        return \"\"\n    if isinstance(annotation, BoundaryAnnotation):\n        return \" with the interval '\" + str(annotation.interval.to_json()) + \"'\"\n    if isinstance(annotation, CalledAfterAnnotation):\n        return (\n            \" with the method '\"\n            + annotation.calledAfterName\n            + \"' that should be called before\"\n        )\n    if isinstance(annotation, DescriptionAnnotation):\n        return \" with the new description '\" + annotation.newDescription + \"'\"\n    if isinstance(annotation, EnumAnnotation):\n        return (\n            \" with the new enum '\"\n            + annotation.enumName\n            + \" (\"\n            + \", \".join(\n                map(\n                    lambda enum_pair: enum_pair.stringValue\n                    + \", \"\n                    + enum_pair.instanceName,\n                    annotation.pairs,\n                )\n            )\n            + \")'\"\n        )\n    if isinstance(annotation, GroupAnnotation):\n        return (\n            \" with the group name '\"\n            + annotation.groupName\n            + \"' and the grouped parameters: '\"\n            + \", \".join(annotation.parameters)\n            + \"'\"\n        )\n    if isinstance(annotation, MoveAnnotation):\n        return \" with the destination: '\" + annotation.destination + \"'\"\n    if isinstance(annotation, RenameAnnotation):\n        return \" with the new name '\" + annotation.newName + \"'\"\n    if isinstance(annotation, TodoAnnotation):\n        return \" with the todo '\" + annotation.newTodo + \"'\"\n    if isinstance(annotation, ValueAnnotation):\n        value = \" with the variant '\" + annotation.variant.value\n        if isinstance(annotation, (ConstantAnnotation, OptionalAnnotation)):\n            value += (\n                \"' and the default Value '\"\n                + str(annotation.defaultValue)\n                + \" ( type: \"\n                + str(annotation.defaultValueType.value)\n                + \" )\"\n            )\n        value += \"'\"\n        return value\n    return \" with the data '\" + str(annotation.to_json()) + \"'\""
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text/_list_api_elements",
      "name": "_list_api_elements",
      "qname": "package_parser.processing.migration.annotations._get_migration_text._list_api_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text/_list_api_elements/api_elements",
          "name": "api_elements",
          "qname": "package_parser.processing.migration.annotations._get_migration_text._list_api_elements.api_elements",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _list_api_elements(\n    api_elements: Sequence[Attribute | Class | Function | Parameter | Result],\n) -> str:\n    return \", \".join(\n        map(\n            lambda api_element: api_element.id\n            if hasattr(api_element, \"id\")\n            else api_element.name,\n            api_elements,\n        )\n    )"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text",
      "name": "get_migration_text",
      "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text/for_todo_annotation",
          "name": "for_todo_annotation",
          "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text.for_todo_annotation",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text/additional_information",
          "name": "additional_information",
          "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text.additional_information",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_migration_text(\n    annotation: AbstractAnnotation,\n    mapping: Mapping,\n    for_todo_annotation: bool = False,\n    additional_information: Any = None,\n) -> str:\n    class_name = str(annotation.__class__.__name__)\n    if class_name.endswith(\"Annotation\"):\n        class_name = class_name[:-10]\n    if issubclass(type(annotation), ValueAnnotation):\n        class_name = \"Value\"\n    migrate_text = (\n        \"The @\" + class_name + \" Annotation\" + _get_further_information(annotation)\n    )\n    migrate_text += (\n        \" from the previous version was at '\"\n        + annotation.target\n        + \"' and the possible alternatives in the new version of the api are: \"\n        + _list_api_elements(mapping.get_apiv2_elements())\n    )\n    if additional_information is not None and isinstance(additional_information, list):\n        functions = [\n            function\n            for function in additional_information\n            if isinstance(function, Function)\n        ]\n        if len(functions) > 0:\n            migrate_text += (\n                \" and the possible replacements (\" + _list_api_elements(functions) + \")\"\n            )\n\n        parameters = [\n            parameter\n            for parameter in additional_information\n            if isinstance(parameter, Parameter)\n        ]\n        if len(parameters) > 0:\n            migrate_text += (\n                \" and the possible replacements (\"\n                + _list_api_elements(parameters)\n                + \")\"\n            )\n    migration_text = migrate_text\n    if for_todo_annotation:\n        return migration_text\n    if len(annotation.comment) == 0:\n        return migration_text\n    return annotation.comment + \"\\n\" + migration_text"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/_contains_number_and_is_discrete",
      "name": "_contains_number_and_is_discrete",
      "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation._contains_number_and_is_discrete",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/_contains_number_and_is_discrete/type_",
          "name": "type_",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation._contains_number_and_is_discrete.type_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _contains_number_and_is_discrete(\n    type_: Optional[AbstractType],\n) -> Tuple[bool, bool]:\n    if type_ is None:\n        return False, False\n    if isinstance(type_, NamedType):\n        return type_.name in (\"int\", \"float\"), type_.name == \"int\"\n    if isinstance(type_, UnionType):\n        for element in type_.types:\n            is_number, is_discrete = _contains_number_and_is_discrete(element)\n            if is_number:\n                return is_number, is_discrete\n    return False, False"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_boundary_annotation",
      "name": "migrate_boundary_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_boundary_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_boundary_annotation/boundary_annotation",
          "name": "boundary_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_boundary_annotation.boundary_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_boundary_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_boundary_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_boundary_annotation(\n    boundary_annotation: BoundaryAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    boundary_annotation = deepcopy(boundary_annotation)\n    authors = boundary_annotation.authors\n    authors.append(migration_author)\n    boundary_annotation.authors = authors\n\n    annotated_apiv1_element = get_annotated_api_element(\n        boundary_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None or not isinstance(\n        annotated_apiv1_element, Parameter\n    ):\n        return []\n\n    if isinstance(mapping, (OneToOneMapping, ManyToOneMapping)):\n        parameter = mapping.get_apiv2_elements()[0]\n        if isinstance(parameter, (Attribute, Result)):\n            return []\n        if isinstance(parameter, Parameter):\n            (\n                parameter_expects_number,\n                parameter_type_is_discrete,\n            ) = _contains_number_and_is_discrete(parameter.type)\n            if parameter.type is None and annotated_apiv1_element.type is not None:\n                boundary_annotation.reviewResult = EnumReviewResult.UNSURE\n                boundary_annotation.comment = get_migration_text(\n                    boundary_annotation, mapping\n                )\n                boundary_annotation.target = parameter.id\n                return [boundary_annotation]\n            if parameter_expects_number or (\n                parameter.type is None and annotated_apiv1_element.type is None\n            ):\n                if (\n                    parameter_type_is_discrete\n                    != boundary_annotation.interval.isDiscrete\n                ) and not (\n                    parameter.type is None and annotated_apiv1_element.type is None\n                ):\n                    boundary_annotation.reviewResult = EnumReviewResult.UNSURE\n                    boundary_annotation.comment = get_migration_text(\n                        boundary_annotation, mapping\n                    )\n                    if parameter_expects_number:\n                        boundary_annotation.interval = (\n                            migrate_interval_to_fit_parameter_type(\n                                boundary_annotation.interval, parameter_type_is_discrete\n                            )\n                        )\n                boundary_annotation.target = parameter.id\n                return [boundary_annotation]\n        return [\n            TodoAnnotation(\n                parameter.id,\n                authors,\n                boundary_annotation.reviewers,\n                boundary_annotation.comment,\n                EnumReviewResult.NONE,\n                get_migration_text(\n                    boundary_annotation, mapping, for_todo_annotation=True\n                ),\n            )\n        ]\n    migrated_annotations: list[AbstractAnnotation] = []\n    if isinstance(mapping, (OneToManyMapping, ManyToManyMapping)):\n        for parameter in mapping.get_apiv2_elements():\n            if isinstance(parameter, Parameter):\n                is_number, is_discrete = _contains_number_and_is_discrete(\n                    parameter.type\n                )\n                if (\n                    parameter.type is not None\n                    and is_number\n                    and is_discrete == boundary_annotation.interval.isDiscrete\n                ) or (parameter.type is None and annotated_apiv1_element.type is None):\n                    migrated_annotations.append(\n                        BoundaryAnnotation(\n                            parameter.id,\n                            authors,\n                            boundary_annotation.reviewers,\n                            boundary_annotation.comment,\n                            EnumReviewResult.NONE,\n                            boundary_annotation.interval,\n                        )\n                    )\n                elif parameter.type is not None and is_number:\n                    migrated_annotations.append(\n                        BoundaryAnnotation(\n                            parameter.id,\n                            authors,\n                            boundary_annotation.reviewers,\n                            get_migration_text(boundary_annotation, mapping),\n                            EnumReviewResult.UNSURE,\n                            migrate_interval_to_fit_parameter_type(\n                                boundary_annotation.interval,\n                                is_discrete,\n                            ),\n                        )\n                    )\n                elif parameter.type is None:\n                    migrated_annotations.append(\n                        BoundaryAnnotation(\n                            parameter.id,\n                            authors,\n                            boundary_annotation.reviewers,\n                            get_migration_text(boundary_annotation, mapping),\n                            EnumReviewResult.UNSURE,\n                            boundary_annotation.interval,\n                        )\n                    )\n                continue\n            if not isinstance(parameter, (Attribute, Result)):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        parameter.id,\n                        authors,\n                        boundary_annotation.reviewers,\n                        boundary_annotation.comment,\n                        EnumReviewResult.NONE,\n                        get_migration_text(\n                            boundary_annotation, mapping, for_todo_annotation=True\n                        ),\n                    )\n                )\n    return migrated_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_interval_to_fit_parameter_type",
      "name": "migrate_interval_to_fit_parameter_type",
      "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_interval_to_fit_parameter_type",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_interval_to_fit_parameter_type/intervalv1",
          "name": "intervalv1",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_interval_to_fit_parameter_type.intervalv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_interval_to_fit_parameter_type/is_discrete",
          "name": "is_discrete",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_interval_to_fit_parameter_type.is_discrete",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_interval_to_fit_parameter_type(\n    intervalv1: Interval, is_discrete: bool\n) -> Interval:\n    intervalv2 = deepcopy(intervalv1)\n    if intervalv2.isDiscrete == is_discrete:\n        return intervalv2\n    if is_discrete:\n        intervalv2.isDiscrete = True\n        if intervalv1.upperLimitType in (0, 1):\n            intervalv2.upperIntervalLimit = int(intervalv1.upperIntervalLimit)\n            intervalv2.upperLimitType = 1\n            if intervalv2.upperIntervalLimit == intervalv1.upperIntervalLimit:\n                intervalv2.upperLimitType = intervalv1.upperLimitType\n        if intervalv1.lowerLimitType in (0, 1):\n            intervalv2.lowerIntervalLimit = int(intervalv1.lowerIntervalLimit)\n            intervalv2.lowerLimitType = 1\n            if intervalv2.lowerIntervalLimit == intervalv1.lowerIntervalLimit:\n                intervalv2.lowerLimitType = intervalv1.lowerLimitType\n            else:\n                intervalv2.lowerIntervalLimit += 1\n    else:\n        intervalv2.isDiscrete = False\n        if intervalv1.upperLimitType in (0, 1):\n            intervalv2.upperIntervalLimit = float(intervalv1.upperIntervalLimit)\n        if intervalv1.lowerLimitType in (0, 1):\n            intervalv2.lowerIntervalLimit = float(intervalv1.lowerIntervalLimit)\n    return intervalv2"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/_get_function_called_before_replacements",
      "name": "_get_function_called_before_replacements",
      "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation._get_function_called_before_replacements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/_get_function_called_before_replacements/called_after_annotation",
          "name": "called_after_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation._get_function_called_before_replacements.called_after_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/_get_function_called_before_replacements/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation._get_function_called_before_replacements.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/_get_function_called_before_replacements/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation._get_function_called_before_replacements.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_function_called_before_replacements(\n    called_after_annotation: CalledAfterAnnotation,\n    mappings: list[Mapping],\n    functionv2: Function,\n) -> list[Function]:\n    called_before_idv1 = (\n        \"/\".join(called_after_annotation.target.split(\"/\")[:-1])\n        + \"/\"\n        + called_after_annotation.calledAfterName\n    )\n    called_before_idv2_prefix = \"/\".join(functionv2.id.split(\"/\")[:-1]) + \"/\"\n    functions_in_same_class: list[Function] = []\n    for mapping in mappings:\n        found_mapped_function_in_same_class = False\n        for element in mapping.get_apiv1_elements():\n            if isinstance(element, Function) and called_before_idv1 == element.id:\n                found_mapped_function_in_same_class = True\n                break\n\n        if found_mapped_function_in_same_class:\n            for replacement in mapping.get_apiv2_elements():\n                if isinstance(replacement, Function) and replacement.id.startswith(\n                    called_before_idv2_prefix\n                ):\n                    functions_in_same_class.append(replacement)\n            break\n    return functions_in_same_class"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/migrate_called_after_annotation",
      "name": "migrate_called_after_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation.migrate_called_after_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/migrate_called_after_annotation/called_after_annotation",
          "name": "called_after_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation.migrate_called_after_annotation.called_after_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/migrate_called_after_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation.migrate_called_after_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/migrate_called_after_annotation/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation.migrate_called_after_annotation.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_called_after_annotation(\n    called_after_annotation: CalledAfterAnnotation,\n    mapping: Mapping,\n    mappings: list[Mapping],\n) -> list[AbstractAnnotation]:\n    called_after_annotation = deepcopy(called_after_annotation)\n    authors = called_after_annotation.authors\n    authors.append(migration_author)\n    called_after_annotation.authors = authors\n\n    migrated_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if not isinstance(element, Function):\n            if not isinstance(element, (Attribute, Result)):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        element.id,\n                        authors,\n                        called_after_annotation.reviewers,\n                        called_after_annotation.comment,\n                        EnumReviewResult.NONE,\n                        get_migration_text(\n                            called_after_annotation, mapping, for_todo_annotation=True\n                        ),\n                    )\n                )\n            continue\n\n        called_before_functions = _get_function_called_before_replacements(\n            called_after_annotation, mappings, element\n        )\n        if len(called_before_functions) == 0:\n            migrated_annotations.append(\n                CalledAfterAnnotation(\n                    element.id,\n                    authors,\n                    called_after_annotation.reviewers,\n                    get_migration_text(\n                        called_after_annotation,\n                        mapping,\n                        additional_information=called_before_functions,\n                    ),\n                    EnumReviewResult.UNSURE,\n                    called_after_annotation.calledAfterName,\n                )\n            )\n        elif (\n            len(called_before_functions) == 1 and called_before_functions[0] != element\n        ):\n            migrated_annotations.append(\n                CalledAfterAnnotation(\n                    element.id,\n                    authors,\n                    called_after_annotation.reviewers,\n                    called_after_annotation.comment,\n                    called_after_annotation.reviewResult,\n                    called_before_functions[0].name,\n                )\n            )\n        else:\n            migrated_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    called_after_annotation.reviewers,\n                    called_after_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        called_after_annotation,\n                        mapping,\n                        for_todo_annotation=True,\n                        additional_information=called_before_functions,\n                    ),\n                )\n            )\n    return migrated_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_description_annotation/migrate_description_annotation",
      "name": "migrate_description_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_description_annotation.migrate_description_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_description_annotation/migrate_description_annotation/description_annotation",
          "name": "description_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_description_annotation.migrate_description_annotation.description_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_description_annotation/migrate_description_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_description_annotation.migrate_description_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_description_annotation(\n    description_annotation: DescriptionAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    description_annotation = deepcopy(description_annotation)\n    authors = description_annotation.authors\n    authors.append(migration_author)\n    description_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        description_annotation.target = element.id\n        return [description_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        description_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    description_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if isinstance(element, type(annotated_apiv1_element)) and not isinstance(\n            element, (Attribute, Result)\n        ):\n            description_annotations.append(\n                DescriptionAnnotation(\n                    element.id,\n                    authors,\n                    description_annotation.reviewers,\n                    description_annotation.comment,\n                    EnumReviewResult.NONE,\n                    newDescription=description_annotation.newDescription,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            description_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    description_annotation.reviewers,\n                    description_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        description_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return description_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_contains_string",
      "name": "_contains_string",
      "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._contains_string",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_contains_string/type_",
          "name": "type_",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._contains_string.type_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _contains_string(type_: AbstractType) -> bool:\n    if isinstance(type_, NamedType):\n        return type_.name == \"str\"\n    if isinstance(type_, UnionType):\n        for element in type_.types:\n            if _contains_string(element):\n                return True\n    return False"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_default_value_is_in_instance_values_or_is_empty",
      "name": "_default_value_is_in_instance_values_or_is_empty",
      "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._default_value_is_in_instance_values_or_is_empty",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_default_value_is_in_instance_values_or_is_empty/default_value",
          "name": "default_value",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._default_value_is_in_instance_values_or_is_empty.default_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_default_value_is_in_instance_values_or_is_empty/pairs",
          "name": "pairs",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._default_value_is_in_instance_values_or_is_empty.pairs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _default_value_is_in_instance_values_or_is_empty(\n    default_value: Optional[str], pairs: List[EnumPair]\n) -> bool:\n    return (\n        default_value is None\n        or default_value in map(lambda pair: pair.stringValue, pairs)\n        or len(default_value) == 0\n    )"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/migrate_enum_annotation",
      "name": "migrate_enum_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation.migrate_enum_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/migrate_enum_annotation/enum_annotation",
          "name": "enum_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation.migrate_enum_annotation.enum_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/migrate_enum_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation.migrate_enum_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_enum_annotation(\n    enum_annotation: EnumAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    enum_annotation = deepcopy(enum_annotation)\n    authors = enum_annotation.authors\n    authors.append(migration_author)\n    enum_annotation.authors = authors\n\n    annotated_apiv1_element = get_annotated_api_element(\n        enum_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None or not isinstance(\n        annotated_apiv1_element, Parameter\n    ):\n        return []\n\n    if isinstance(mapping, (OneToOneMapping, ManyToOneMapping)):\n        parameter = mapping.get_apiv2_elements()[0]\n        if isinstance(parameter, (Attribute, Result)):\n            return []\n        if isinstance(parameter, Parameter):\n            if (\n                parameter.type is not None\n                and _contains_string(parameter.type)\n                and _default_value_is_in_instance_values_or_is_empty(\n                    parameter.default_value, enum_annotation.pairs\n                )\n            ) or (parameter.type is None and annotated_apiv1_element.type is None):\n                enum_annotation.target = parameter.id\n                return [enum_annotation]\n            if isinstance(parameter.type, NamedType):\n                # assuming api has been chanced to an enum type:\n                # do not migrate annotation\n                return []\n            enum_annotation.reviewResult = EnumReviewResult.UNSURE\n            enum_annotation.comment = get_migration_text(enum_annotation, mapping)\n            enum_annotation.target = parameter.id\n            return [enum_annotation]\n        return [\n            TodoAnnotation(\n                parameter.id,\n                authors,\n                enum_annotation.reviewers,\n                enum_annotation.comment,\n                EnumReviewResult.NONE,\n                get_migration_text(enum_annotation, mapping, for_todo_annotation=True),\n            )\n        ]\n\n    migrated_annotations: list[AbstractAnnotation] = []\n    if isinstance(mapping, (OneToManyMapping, ManyToManyMapping)):\n        for parameter in mapping.get_apiv2_elements():\n            if isinstance(parameter, Parameter):\n                if (\n                    parameter.type is not None\n                    and _contains_string(parameter.type)\n                    and _default_value_is_in_instance_values_or_is_empty(\n                        parameter.default_value, enum_annotation.pairs\n                    )\n                ) or (parameter.type is None and annotated_apiv1_element.type is None):\n                    migrated_annotations.append(\n                        EnumAnnotation(\n                            parameter.id,\n                            authors,\n                            enum_annotation.reviewers,\n                            enum_annotation.comment,\n                            EnumReviewResult.NONE,\n                            enum_annotation.enumName,\n                            enum_annotation.pairs,\n                        )\n                    )\n                    continue\n                if isinstance(parameter.type, NamedType):\n                    continue\n                migrated_annotations.append(\n                    EnumAnnotation(\n                        parameter.id,\n                        authors,\n                        enum_annotation.reviewers,\n                        get_migration_text(enum_annotation, mapping),\n                        EnumReviewResult.UNSURE,\n                        enum_annotation.enumName,\n                        enum_annotation.pairs,\n                    )\n                )\n            elif not isinstance(parameter, (Attribute, Result)):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        parameter.id,\n                        authors,\n                        enum_annotation.reviewers,\n                        enum_annotation.comment,\n                        EnumReviewResult.NONE,\n                        get_migration_text(\n                            enum_annotation, mapping, for_todo_annotation=True\n                        ),\n                    )\n                )\n    return migrated_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_expert_annotation/migrate_expert_annotation",
      "name": "migrate_expert_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_expert_annotation.migrate_expert_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_expert_annotation/migrate_expert_annotation/expert_annotation",
          "name": "expert_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_expert_annotation.migrate_expert_annotation.expert_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_expert_annotation/migrate_expert_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_expert_annotation.migrate_expert_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_expert_annotation(\n    expert_annotation: ExpertAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    expert_annotation = deepcopy(expert_annotation)\n    authors = expert_annotation.authors\n    authors.append(migration_author)\n    expert_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        expert_annotation.target = element.id\n        return [expert_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        expert_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    expert_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if isinstance(element, type(annotated_apiv1_element)) and not isinstance(\n            element, (Attribute, Result)\n        ):\n            expert_annotations.append(\n                ExpertAnnotation(\n                    element.id,\n                    authors,\n                    expert_annotation.reviewers,\n                    expert_annotation.comment,\n                    EnumReviewResult.NONE,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            expert_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    expert_annotation.reviewers,\n                    expert_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        expert_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return expert_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/_get_mappings_for_grouped_parameters",
      "name": "_get_mappings_for_grouped_parameters",
      "qname": "package_parser.processing.migration.annotations._migrate_group_annotation._get_mappings_for_grouped_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/_get_mappings_for_grouped_parameters/group_annotation",
          "name": "group_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation._get_mappings_for_grouped_parameters.group_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/_get_mappings_for_grouped_parameters/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation._get_mappings_for_grouped_parameters.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/_get_mappings_for_grouped_parameters/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation._get_mappings_for_grouped_parameters.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_mappings_for_grouped_parameters(\n    group_annotation: GroupAnnotation, mappings: list[Mapping], functionv2: Function\n) -> list[list[Parameter]]:\n    parameter_ids = [\n        group_annotation.target + \"/\" + parameter_name\n        for parameter_name in group_annotation.parameters\n    ]\n\n    matched_parameters: list[list[Parameter]] = []\n    for parameter_id in parameter_ids:\n        for mapping in mappings:\n            for parameterv1 in mapping.get_apiv1_elements():\n                if (\n                    isinstance(parameterv1, Parameter)\n                    and parameterv1.id == parameter_id\n                ):\n                    mapped_parameters: list[Parameter] = []\n                    for parameterv2 in mapping.get_apiv2_elements():\n                        if isinstance(\n                            parameterv2, Parameter\n                        ) and parameterv2.id.startswith(functionv2.id + \"/\"):\n                            mapped_parameters.append(parameterv2)\n                    matched_parameters.append(mapped_parameters)\n                    break\n    return matched_parameters"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/migrate_group_annotation",
      "name": "migrate_group_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_group_annotation.migrate_group_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/migrate_group_annotation/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation.migrate_group_annotation.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/migrate_group_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation.migrate_group_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_group_annotation/migrate_group_annotation/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation.migrate_group_annotation.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_group_annotation(\n    annotation: GroupAnnotation, mapping: Mapping, mappings: list[Mapping]\n) -> list[AbstractAnnotation]:\n    group_annotation = deepcopy(annotation)\n    authors = group_annotation.authors\n    authors.append(migration_author)\n    group_annotation.authors = authors\n\n    migrated_annotations: list[AbstractAnnotation] = []\n\n    for functionv2 in mapping.get_apiv2_elements():\n        if isinstance(functionv2, (Attribute, Result)):\n            continue\n        if not isinstance(functionv2, Function):\n            migrated_annotations.append(\n                TodoAnnotation(\n                    target=functionv2.id,\n                    authors=authors,\n                    reviewers=group_annotation.reviewers,\n                    comment=group_annotation.comment,\n                    reviewResult=EnumReviewResult.NONE,\n                    newTodo=get_migration_text(\n                        group_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n        else:\n            parameter_replacements = _get_mappings_for_grouped_parameters(\n                group_annotation, mappings, functionv2\n            )\n            grouped_parameters: list[Parameter] = []\n            name_modifier = \"\"\n\n            for parameter_list in parameter_replacements:\n                if len(parameter_list) == 0:\n                    name_modifier = \"0\" + name_modifier\n                else:\n                    grouped_parameters.extend(parameter_list)\n                    if len(parameter_list) == 1:\n                        name_modifier = \"1\" + name_modifier\n                    else:\n                        name_modifier = \"0\" + name_modifier\n\n            remove_duplicates_and_preserve_order = [\n                i\n                for n, i in enumerate(grouped_parameters)\n                if i not in grouped_parameters[:n]\n            ]\n            grouped_parameters = remove_duplicates_and_preserve_order\n\n            if len(grouped_parameters) < 2 < len(group_annotation.parameters):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        target=functionv2.id,\n                        authors=authors,\n                        reviewers=group_annotation.reviewers,\n                        comment=group_annotation.comment,\n                        reviewResult=EnumReviewResult.NONE,\n                        newTodo=get_migration_text(\n                            group_annotation,\n                            mapping,\n                            for_todo_annotation=True,\n                            additional_information=grouped_parameters,\n                        ),\n                    )\n                )\n                continue\n\n            if len(grouped_parameters) != len(group_annotation.parameters):\n                group_name = group_annotation.groupName + str(\n                    int(name_modifier, base=2)\n                )\n                migrated_annotations.append(\n                    GroupAnnotation(\n                        target=functionv2.id,\n                        authors=authors,\n                        reviewers=group_annotation.reviewers,\n                        comment=get_migration_text(\n                            group_annotation,\n                            mapping,\n                            additional_information=grouped_parameters,\n                        ),\n                        reviewResult=EnumReviewResult.UNSURE,\n                        groupName=group_name,\n                        parameters=[parameter.name for parameter in grouped_parameters],\n                    )\n                )\n            else:\n                migrated_annotations.append(\n                    GroupAnnotation(\n                        target=functionv2.id,\n                        authors=authors,\n                        reviewers=group_annotation.reviewers,\n                        comment=group_annotation.comment,\n                        reviewResult=EnumReviewResult.NONE,\n                        groupName=group_annotation.groupName,\n                        parameters=[parameter.name for parameter in grouped_parameters],\n                    )\n                )\n\n    return migrated_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_move_annotation/is_moveable",
      "name": "is_moveable",
      "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.is_moveable",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_move_annotation/is_moveable/element",
          "name": "element",
          "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.is_moveable.element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def is_moveable(element: Attribute | Class | Function | Parameter | Result) -> bool:\n    if isinstance(element, (Attribute, Result)):\n        return False\n    if isinstance(element, Function):\n        # check for global function\n        element_parents = element.id.split(\"/\")\n        return len(element_parents) == 3\n    return isinstance(element, Class)"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_move_annotation/migrate_move_annotation",
      "name": "migrate_move_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.migrate_move_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_move_annotation/migrate_move_annotation/move_annotation",
          "name": "move_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.migrate_move_annotation.move_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_move_annotation/migrate_move_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.migrate_move_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_move_annotation(\n    move_annotation: MoveAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    move_annotation = deepcopy(move_annotation)\n    authors = move_annotation.authors\n    authors.append(migration_author)\n    move_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        if not is_moveable(element):\n            return [\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    move_annotation.reviewers,\n                    move_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        move_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            ]\n        move_annotation.target = element.id\n        return [move_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        move_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    move_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if (\n            isinstance(element, type(annotated_apiv1_element))\n            and is_moveable(element)\n            and not isinstance(element, (Attribute, Result))\n        ):\n            move_annotations.append(\n                MoveAnnotation(\n                    element.id,\n                    authors,\n                    move_annotation.reviewers,\n                    move_annotation.comment,\n                    EnumReviewResult.NONE,\n                    move_annotation.destination,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            move_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    move_annotation.reviewers,\n                    move_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        move_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return move_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/is_removeable",
      "name": "is_removeable",
      "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.is_removeable",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/is_removeable/element",
          "name": "element",
          "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.is_removeable.element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def is_removeable(element: Attribute | Class | Function | Parameter | Result) -> bool:\n    return isinstance(element, (Class, Function))"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/migrate_remove_annotation",
      "name": "migrate_remove_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.migrate_remove_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/migrate_remove_annotation/remove_annotation",
          "name": "remove_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.migrate_remove_annotation.remove_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/migrate_remove_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.migrate_remove_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_remove_annotation(\n    remove_annotation: RemoveAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    remove_annotation = deepcopy(remove_annotation)\n    authors = remove_annotation.authors\n    authors.append(migration_author)\n    remove_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        if not is_removeable(element):\n            return [\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    remove_annotation.reviewers,\n                    remove_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        remove_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            ]\n        remove_annotation.target = element.id\n        return [remove_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        remove_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    remove_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if (\n            isinstance(element, type(annotated_apiv1_element))\n            and is_removeable(element)\n            and not isinstance(element, (Attribute, Result))\n        ):\n            remove_annotations.append(\n                RemoveAnnotation(\n                    element.id,\n                    authors,\n                    remove_annotation.reviewers,\n                    remove_annotation.comment,\n                    EnumReviewResult.NONE,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            remove_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    remove_annotation.reviewers,\n                    remove_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        remove_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return remove_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_rename_annotation/migrate_rename_annotation",
      "name": "migrate_rename_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_rename_annotation.migrate_rename_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_rename_annotation/migrate_rename_annotation/rename_annotation",
          "name": "rename_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_rename_annotation.migrate_rename_annotation.rename_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_rename_annotation/migrate_rename_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_rename_annotation.migrate_rename_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_rename_annotation(\n    rename_annotation: RenameAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    rename_annotation = deepcopy(rename_annotation)\n    new_name = rename_annotation.newName\n    authors = rename_annotation.authors\n    authors.append(migration_author)\n    rename_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        rename_annotation.target = element.id\n        return [rename_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        rename_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if isinstance(element, type(annotated_apiv1_element)) and not isinstance(\n            element, (Attribute, Result)\n        ):\n            if element.name not in (\n                new_name,\n                rename_annotation.target.split(\".\")[-1],\n            ):\n                annotations.append(\n                    RenameAnnotation(\n                        element.id,\n                        authors,\n                        rename_annotation.reviewers,\n                        get_migration_text(rename_annotation, mapping),\n                        EnumReviewResult.UNSURE,\n                        rename_annotation.newName,\n                    )\n                )\n            else:\n                annotations.append(\n                    RenameAnnotation(\n                        element.id,\n                        authors,\n                        rename_annotation.reviewers,\n                        rename_annotation.comment,\n                        EnumReviewResult.NONE,\n                        rename_annotation.newName,\n                    )\n                )\n        elif not isinstance(element, (Attribute, Result)):\n            annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    rename_annotation.reviewers,\n                    rename_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        rename_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_todo_annotation/migrate_todo_annotation",
      "name": "migrate_todo_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_todo_annotation.migrate_todo_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_todo_annotation/migrate_todo_annotation/todo_annotation",
          "name": "todo_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_todo_annotation.migrate_todo_annotation.todo_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_todo_annotation/migrate_todo_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_todo_annotation.migrate_todo_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_todo_annotation(\n    todo_annotation: TodoAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    todo_annotation = deepcopy(todo_annotation)\n    authors = todo_annotation.authors\n    authors.append(migration_author)\n    todo_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        todo_annotation.target = element.id\n        return [todo_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        todo_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    todo_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if isinstance(element, type(annotated_apiv1_element)) and not isinstance(\n            element, (Attribute, Result)\n        ):\n            todo_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    todo_annotation.reviewers,\n                    todo_annotation.comment,\n                    EnumReviewResult.NONE,\n                    todo_annotation.newTodo,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            todo_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    todo_annotation.reviewers,\n                    todo_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        todo_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return todo_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_type",
      "name": "_have_same_type",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_type",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_type/typev1",
          "name": "typev1",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_type.typev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_type/typev2",
          "name": "typev2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_type.typev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _have_same_type(\n    typev1: Optional[AbstractType],\n    typev2: Optional[AbstractType],\n) -> bool:\n    if typev2 is None and typev1 is None:\n        return True\n    if typev2 is None or typev1 is None:\n        return False\n    if isinstance(typev2, NamedType):\n        if typev2.name in (\"int\", \"interger\") or typev2.name.startswith(\"int \"):\n            types = [typev1]\n            if isinstance(typev1, UnionType):\n                types = typev1.types\n            for element in types:\n                if isinstance(element, NamedType) and (\n                    element.name in (\"int\", \"integer\")\n                    or element.name.startswith(\"int \")\n                ):\n                    return True\n        elif typev2.name == \"float\" or typev2.name.startswith(\"float \"):\n            types = [typev1]\n            if isinstance(typev1, UnionType):\n                types = typev1.types\n            for element in types:\n                if isinstance(element, NamedType) and (\n                    element.name == \"float\" or element.name.startswith(\"float \")\n                ):\n                    return True\n        elif typev2.name in (\"bool\", \"boolean\"):\n            types = [typev1]\n            if isinstance(typev1, UnionType):\n                types = typev1.types\n            for element in types:\n                if isinstance(element, NamedType) and (\n                    element.name in (\"bool\", \"boolean\")\n                ):\n                    return True\n        elif typev2.name in (\"str\", \"string\"):\n            types = [typev1]\n            if isinstance(typev1, UnionType):\n                types = typev1.types\n            for element in types:\n                if isinstance(element, NamedType) and (\n                    element.name in (\"str\", \"string\")\n                ):\n                    return True\n    elif isinstance(typev2, UnionType):\n        for element in typev2.types:\n            if _have_same_type(typev1, element):\n                return True\n    return False"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_value",
      "name": "_have_same_value",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_value",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_value/parameterv1_default_value",
          "name": "parameterv1_default_value",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_value.parameterv1_default_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_value/parameterv2_default_value",
          "name": "parameterv2_default_value",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_value.parameterv2_default_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _have_same_value(\n    parameterv1_default_value: Optional[str], parameterv2_default_value: Optional[str]\n) -> bool:\n    if parameterv1_default_value is None and parameterv2_default_value is None:\n        return True\n    if parameterv1_default_value is None or parameterv2_default_value is None:\n        return False\n    if parameterv1_default_value == \"None\" and parameterv2_default_value == \"None\":\n        return True\n    try:\n        intv1_value = int(parameterv1_default_value)\n        intv2_value = int(parameterv2_default_value)\n        return intv1_value == intv2_value\n    except ValueError:\n        try:\n            floatv1_value = float(parameterv1_default_value)\n            floatv2_value = float(parameterv2_default_value)\n            return floatv1_value == floatv2_value\n        except ValueError:\n            try:\n                int(parameterv1_default_value)\n                float(parameterv2_default_value)\n                return False\n            except ValueError:\n                try:\n                    int(parameterv2_default_value)\n                    float(parameterv1_default_value)\n                    return False\n                except ValueError:\n                    pass\n    if parameterv1_default_value in (\n        \"True\",\n        \"False\",\n    ) and parameterv2_default_value in (\"True\", \"False\"):\n        return bool(parameterv1_default_value) == bool(parameterv2_default_value)\n    valuev1_is_in_quotation_marks = (\n        parameterv1_default_value.startswith(\"'\")\n        and parameterv1_default_value.endswith(\"'\")\n    ) or (\n        parameterv1_default_value.startswith('\"')\n        and parameterv1_default_value.endswith('\"')\n    )\n    valuev2_is_in_quotation_marks = (\n        parameterv2_default_value.startswith(\"'\")\n        and parameterv2_default_value.endswith(\"'\")\n    ) or (\n        parameterv2_default_value.startswith('\"')\n        and parameterv2_default_value.endswith('\"')\n    )\n    if valuev1_is_in_quotation_marks and valuev2_is_in_quotation_marks:\n        return parameterv1_default_value[1:-1] == parameterv2_default_value[1:-1]\n    return False"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_constant_annotation",
      "name": "migrate_constant_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_constant_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_constant_annotation/constant_annotation",
          "name": "constant_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_constant_annotation.constant_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_constant_annotation/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_constant_annotation.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_constant_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_constant_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_constant_annotation(\n    constant_annotation: ConstantAnnotation, parameterv2: Parameter, mapping: Mapping\n) -> Optional[ConstantAnnotation]:\n    parameterv1 = get_annotated_api_element_by_type(\n        constant_annotation, mapping.get_apiv1_elements(), Parameter\n    )\n    if parameterv1 is None:\n        return None\n    if not _have_same_type(parameterv1.type, parameterv2.type):\n        return None\n    if not _have_same_value(parameterv1.default_value, parameterv2.default_value):\n        return ConstantAnnotation(\n            parameterv2.id,\n            constant_annotation.authors,\n            constant_annotation.reviewers,\n            get_migration_text(constant_annotation, mapping),\n            EnumReviewResult.UNSURE,\n            constant_annotation.defaultValueType,\n            constant_annotation.defaultValue,\n        )\n    return ConstantAnnotation(\n        parameterv2.id,\n        constant_annotation.authors,\n        constant_annotation.reviewers,\n        constant_annotation.comment,\n        EnumReviewResult.NONE,\n        constant_annotation.defaultValueType,\n        constant_annotation.defaultValue,\n    )"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_omitted_annotation",
      "name": "migrate_omitted_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_omitted_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_omitted_annotation/omitted_annotation",
          "name": "omitted_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_omitted_annotation.omitted_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_omitted_annotation/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_omitted_annotation.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_omitted_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_omitted_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_omitted_annotation(\n    omitted_annotation: OmittedAnnotation, parameterv2: Parameter, mapping: Mapping\n) -> Optional[OmittedAnnotation]:\n    parameterv1 = get_annotated_api_element_by_type(\n        omitted_annotation, mapping.get_apiv1_elements(), Parameter\n    )\n    if parameterv1 is None:\n        return None\n    if _have_same_type(parameterv1.type, parameterv2.type) and _have_same_value(\n        parameterv1.default_value, parameterv2.default_value\n    ):\n        return OmittedAnnotation(\n            parameterv2.id,\n            omitted_annotation.authors,\n            omitted_annotation.reviewers,\n            omitted_annotation.comment,\n            EnumReviewResult.NONE,\n        )\n    if _have_same_type(parameterv1.type, parameterv2.type) and not _have_same_value(\n        parameterv1.default_value, parameterv2.default_value\n    ):\n        return OmittedAnnotation(\n            parameterv2.id,\n            omitted_annotation.authors,\n            omitted_annotation.reviewers,\n            get_migration_text(omitted_annotation, mapping),\n            EnumReviewResult.UNSURE,\n        )\n\n    return None"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_optional_annotation",
      "name": "migrate_optional_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_optional_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_optional_annotation/optional_annotation",
          "name": "optional_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_optional_annotation.optional_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_optional_annotation/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_optional_annotation.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_optional_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_optional_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_optional_annotation(\n    optional_annotation: OptionalAnnotation, parameterv2: Parameter, mapping: Mapping\n) -> Optional[OptionalAnnotation]:\n    parameterv1 = get_annotated_api_element_by_type(\n        optional_annotation, mapping.get_apiv1_elements(), Parameter\n    )\n    if parameterv1 is None:\n        return None\n    if _have_same_type(parameterv1.type, parameterv2.type) and _have_same_value(\n        parameterv1.default_value, parameterv2.default_value\n    ):\n        return OptionalAnnotation(\n            parameterv2.id,\n            optional_annotation.authors,\n            optional_annotation.reviewers,\n            optional_annotation.comment,\n            EnumReviewResult.NONE,\n            optional_annotation.defaultValueType,\n            optional_annotation.defaultValue,\n        )\n    have_implicit_same_value = False\n    if parameterv1.default_value is not None and parameterv2.default_value is not None:\n        try:\n            have_implicit_same_value = float(parameterv1.default_value) == float(\n                parameterv2.default_value\n            )\n        except ValueError:\n            pass\n    if (\n        _have_same_type(parameterv1.type, parameterv2.type)\n        or (\n            (parameterv1.default_value is None)\n            is not (parameterv2.default_value is None)\n        )\n        or have_implicit_same_value\n    ):\n        return OptionalAnnotation(\n            parameterv2.id,\n            optional_annotation.authors,\n            optional_annotation.reviewers,\n            get_migration_text(optional_annotation, mapping),\n            EnumReviewResult.UNSURE,\n            optional_annotation.defaultValueType,\n            optional_annotation.defaultValue,\n        )\n\n    return None"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_required_annotation",
      "name": "migrate_required_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_required_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_required_annotation/required_annotation",
          "name": "required_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_required_annotation.required_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_required_annotation/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_required_annotation.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_required_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_required_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_required_annotation(\n    required_annotation: RequiredAnnotation, parameterv2: Parameter, mapping: Mapping\n) -> Optional[RequiredAnnotation]:\n    parameterv1 = get_annotated_api_element_by_type(\n        required_annotation, mapping.get_apiv1_elements(), Parameter\n    )\n    if parameterv1 is None:\n        return None\n    if _have_same_type(parameterv1.type, parameterv2.type) and (\n        (\n            parameterv1.default_value is not None\n            and parameterv2.default_value is not None\n        )\n        or (parameterv1.default_value is None and parameterv2.default_value is None)\n    ):\n        return RequiredAnnotation(\n            parameterv2.id,\n            required_annotation.authors,\n            required_annotation.reviewers,\n            required_annotation.comment,\n            EnumReviewResult.NONE,\n        )\n    return None"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_value_annotation",
      "name": "migrate_value_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_value_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_value_annotation/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_value_annotation.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_value_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_value_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_value_annotation(\n    annotation: ValueAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    value_annotation = deepcopy(annotation)\n    authors = value_annotation.authors\n    authors.append(migration_author)\n    value_annotation.authors = authors\n\n    if isinstance(mapping, (OneToOneMapping, ManyToOneMapping)):\n        parameter = mapping.get_apiv2_elements()[0]\n        if isinstance(parameter, (Attribute, Result)):\n            return []\n        if isinstance(parameter, Parameter):\n            if isinstance(value_annotation, ConstantAnnotation):\n                migrated_constant_annotation = migrate_constant_annotation(\n                    value_annotation, parameter, mapping\n                )\n                if migrated_constant_annotation is not None:\n                    return [migrated_constant_annotation]\n            if isinstance(value_annotation, OmittedAnnotation):\n                migrated_omitted_annotation = migrate_omitted_annotation(\n                    value_annotation, parameter, mapping\n                )\n                if migrated_omitted_annotation is not None:\n                    return [migrated_omitted_annotation]\n            if isinstance(value_annotation, OptionalAnnotation):\n                migrated_optional_annotation = migrate_optional_annotation(\n                    value_annotation, parameter, mapping\n                )\n                if migrated_optional_annotation is not None:\n                    return [migrated_optional_annotation]\n            if isinstance(value_annotation, RequiredAnnotation):\n                migrated_required_annotation = migrate_required_annotation(\n                    value_annotation, parameter, mapping\n                )\n                if migrated_required_annotation is not None:\n                    return [migrated_required_annotation]\n        return [\n            TodoAnnotation(\n                parameter.id,\n                authors,\n                value_annotation.reviewers,\n                value_annotation.comment,\n                EnumReviewResult.NONE,\n                get_migration_text(value_annotation, mapping),\n            )\n        ]\n    migrated_annotations: list[AbstractAnnotation] = []\n    if isinstance(mapping, (OneToManyMapping, ManyToManyMapping)):\n        for parameter in mapping.get_apiv2_elements():\n            if isinstance(parameter, (Result, Attribute)):\n                continue\n            if isinstance(parameter, Parameter):\n                if isinstance(value_annotation, ConstantAnnotation):\n                    migrated_constant_annotation = migrate_constant_annotation(\n                        value_annotation, parameter, mapping\n                    )\n                    if migrated_constant_annotation is not None:\n                        migrated_annotations.append(migrated_constant_annotation)\n                        continue\n                elif isinstance(value_annotation, OmittedAnnotation):\n                    migrated_omitted_annotation = migrate_omitted_annotation(\n                        value_annotation, parameter, mapping\n                    )\n                    if migrated_omitted_annotation is not None:\n                        migrated_annotations.append(migrated_omitted_annotation)\n                        continue\n                elif isinstance(value_annotation, OptionalAnnotation):\n                    migrated_optional_annotation = migrate_optional_annotation(\n                        value_annotation, parameter, mapping\n                    )\n                    if migrated_optional_annotation is not None:\n                        migrated_annotations.append(migrated_optional_annotation)\n                        continue\n                elif isinstance(value_annotation, RequiredAnnotation):\n                    migrated_required_annotation = migrate_required_annotation(\n                        value_annotation, parameter, mapping\n                    )\n                    if migrated_required_annotation is not None:\n                        migrated_annotations.append(migrated_required_annotation)\n                        continue\n            if not isinstance(parameter, (Attribute, Result)):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        parameter.id,\n                        authors,\n                        value_annotation.reviewers,\n                        value_annotation.comment,\n                        EnumReviewResult.NONE,\n                        get_migration_text(value_annotation, mapping),\n                    )\n                )\n    return migrated_annotations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/differ",
          "name": "differ",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/threshold_of_similarity_for_creation_of_mappings",
          "name": "threshold_of_similarity_for_creation_of_mappings",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.threshold_of_similarity_for_creation_of_mappings",
          "default_value": "0.5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/threshold_of_similarity_between_mappings",
          "name": "threshold_of_similarity_between_mappings",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.threshold_of_similarity_between_mappings",
          "default_value": "0.05",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        apiv1: API,\n        apiv2: API,\n        differ: AbstractDiffer,\n        threshold_of_similarity_for_creation_of_mappings: float = 0.5,\n        threshold_of_similarity_between_mappings: float = 0.05,\n    ) -> None:\n        self.apiv1 = apiv1\n        self.apiv2 = apiv2\n        self.differ = differ\n        self.threshold_of_similarity_for_creation_of_mappings = (\n            threshold_of_similarity_for_creation_of_mappings\n        )\n        self.threshold_of_similarity_between_mappings = (\n            threshold_of_similarity_between_mappings\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements",
      "name": "_get_mappings_for_api_elements",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements/api_elementv1_list",
          "name": "api_elementv1_list",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements.api_elementv1_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements/api_elementv2_list",
          "name": "api_elementv2_list",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements.api_elementv2_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements/compute_similarity",
          "name": "compute_similarity",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements.compute_similarity",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mappings_for_api_elements(\n        self,\n        api_elementv1_list: List[API_ELEMENTS],\n        api_elementv2_list: List[API_ELEMENTS],\n        compute_similarity: Callable[[API_ELEMENTS, API_ELEMENTS], float],\n    ) -> list[Mapping]:\n        element_mappings: list[Mapping] = []\n        for api_elementv1 in api_elementv1_list:\n            mapping_for_class_1: list[Mapping] = []\n            for api_elementv2 in api_elementv2_list:\n                similarity = compute_similarity(api_elementv1, api_elementv2)\n                if similarity >= self.threshold_of_similarity_for_creation_of_mappings:\n                    mapping_for_class_1.append(\n                        OneToOneMapping(similarity, api_elementv1, api_elementv2)\n                    )\n            mapping_for_class_1.sort(key=Mapping.get_similarity, reverse=True)\n            new_mapping = self._merge_similar_mappings(mapping_for_class_1)\n            if new_mapping is not None:\n                self._merge_mappings_with_same_elements(new_mapping, element_mappings)\n        return element_mappings"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements",
      "name": "_merge_mappings_with_same_elements",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_mappings_with_same_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_mappings_with_same_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements/mapping_to_be_appended",
          "name": "mapping_to_be_appended",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_mappings_with_same_elements.mapping_to_be_appended",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_mappings_with_same_elements.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This method prevents that an element in a mapping appears multiple times in a list of mappings\nby merging the affected mappings and include the result in the list. If there is no such element,\nthe mapping will be included without any merge.\n\n:param mapping_to_be_appended: the mapping that should be included in mappings\n:param mappings: the list, in which mapping_to_be_appended should be appended",
      "docstring": "This method prevents that an element in a mapping appears multiple times in a list of mappings\nby merging the affected mappings and include the result in the list. If there is no such element,\nthe mapping will be included without any merge.\n\n:param mapping_to_be_appended: the mapping that should be included in mappings\n:param mappings: the list, in which mapping_to_be_appended should be appended",
      "code": "    def _merge_mappings_with_same_elements(\n        self, mapping_to_be_appended: Mapping, mappings: list[Mapping]\n    ) -> None:\n        \"\"\"\n        This method prevents that an element in a mapping appears multiple times in a list of mappings\n        by merging the affected mappings and include the result in the list. If there is no such element,\n        the mapping will be included without any merge.\n\n        :param mapping_to_be_appended: the mapping that should be included in mappings\n        :param mappings: the list, in which mapping_to_be_appended should be appended\n        \"\"\"\n        duplicated: list[Mapping] = []\n        for mapping in mappings:\n            duplicated_element = False\n            for element in mapping.get_apiv2_elements():\n                for element_2 in mapping_to_be_appended.get_apiv2_elements():\n                    if element == element_2:\n                        duplicated_element = True\n                        break\n            if duplicated_element:\n                duplicated.append(mapping)\n\n        if len(duplicated) == 0:\n            mappings.append(mapping_to_be_appended)\n            return\n\n        for conflicted_mapping in duplicated:\n            mapping_to_be_appended = merge_mappings(\n                mapping_to_be_appended, conflicted_mapping\n            )\n            mappings.remove(conflicted_mapping)\n\n        mappings.append(mapping_to_be_appended)"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_similar_mappings",
      "name": "_merge_similar_mappings",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_similar_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_similar_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_similar_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_similar_mappings/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_similar_mappings.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\nfrom this apiv1 element to apiv2 elements by merging the first and second elements recursively,\nif the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n:param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n:return: the first element of the sorted list that could be a result of merged similar mappings",
      "docstring": "Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\nfrom this apiv1 element to apiv2 elements by merging the first and second elements recursively,\nif the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n:param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n:return: the first element of the sorted list that could be a result of merged similar mappings",
      "code": "    def _merge_similar_mappings(self, mappings: List[Mapping]) -> Optional[Mapping]:\n        \"\"\"\n        Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\n        from this apiv1 element to apiv2 elements by merging the first and second elements recursively,\n        if the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n        :param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n        :return: the first element of the sorted list that could be a result of merged similar mappings\n        \"\"\"\n        if len(mappings) == 0:\n            return None\n        if len(mappings) == 1:\n            return mappings[0]\n        if (\n            mappings[0].similarity - mappings[1].similarity\n            < self.threshold_of_similarity_between_mappings\n        ):\n            mappings[0] = merge_mappings(mappings[0], mappings[1])\n            mappings.pop(1)\n            return self._merge_similar_mappings(mappings)\n        return mappings[0]"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/map_api",
      "name": "map_api",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.map_api",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._api_mapping/APIMapping/map_api/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.map_api.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def map_api(self) -> List[Mapping]:\n        mappings: List[Mapping] = []\n        previous_mappings = self.differ.get_related_mappings()\n        if previous_mappings is not None:\n            for mapping in previous_mappings:\n                new_mapping = None\n                if isinstance(\n                    mapping.get_apiv1_elements()[0], Attribute\n                ) and isinstance(mapping.get_apiv2_elements()[0], Attribute):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        self.differ.compute_attribute_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Class) and isinstance(\n                    mapping.get_apiv2_elements()[0], Class\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Class)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Class)\n                        ],\n                        self.differ.compute_class_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Function\n                ) and isinstance(mapping.get_apiv2_elements()[0], Function):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Function)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Function)\n                        ],\n                        self.differ.compute_function_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Parameter\n                ) and isinstance(mapping.get_apiv2_elements()[0], Parameter):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        self.differ.compute_parameter_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Result) and isinstance(\n                    mapping.get_apiv2_elements()[0], Result\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Result)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Result)\n                        ],\n                        self.differ.compute_result_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                if new_mapping is not None:\n                    self.differ.notify_new_mapping(new_mapping)\n        else:\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.classes.values()),\n                    list(self.apiv2.classes.values()),\n                    self.differ.compute_class_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.functions.values()),\n                    list(self.apiv2.functions.values()),\n                    self.differ.compute_function_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.parameters().values()),\n                    list(self.apiv2.parameters().values()),\n                    self.differ.compute_parameter_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        attribute\n                        for class_ in self.apiv1.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    [\n                        attribute\n                        for class_ in self.apiv2.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    self.differ.compute_attribute_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        result\n                        for function in self.apiv1.functions.values()\n                        for result in function.results\n                    ],\n                    [\n                        result\n                        for function in self.apiv2.functions.values()\n                        for result in function.results\n                    ],\n                    self.differ.compute_result_similarity,\n                )\n            )\n\n        mappings.sort(key=Mapping.get_similarity, reverse=True)\n        return mappings"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity",
      "name": "compute_attribute_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_attribute_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_attribute_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity/attributev1",
          "name": "attributev1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_attribute_similarity.attributev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity/attributev2",
          "name": "attributev2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_attribute_similarity.attributev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_attribute_similarity(\n        self,\n        attributev1: Attribute,\n        attributev2: Attribute,\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity",
      "name": "compute_class_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_class_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_class_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity/classv1",
          "name": "classv1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_class_similarity.classv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity/classv2",
          "name": "classv2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_class_similarity.classv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between classes from apiv1 and apiv2.\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between classes from apiv1 and apiv2.\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2.\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity",
      "name": "compute_function_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_function_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_function_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity/functionv1",
          "name": "functionv1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_function_similarity.functionv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_function_similarity.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity",
      "name": "compute_parameter_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_parameter_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_parameter_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity/parameterv1",
          "name": "parameterv1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_parameter_similarity.parameterv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_parameter_similarity.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity",
      "name": "compute_result_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_result_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_result_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity/resultv1",
          "name": "resultv1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_result_similarity.resultv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity/resultv2",
          "name": "resultv2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_result_similarity.resultv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between results from apiv1 and apiv2.\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between results from apiv1 and apiv2.\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2.\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_additional_mappings",
      "name": "get_additional_mappings",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.get_additional_mappings",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_additional_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.get_additional_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This method allows the differ to add further mappings from previous differs\n:return: additional mappings that should be included in the result of the differentiation",
      "docstring": "This method allows the differ to add further mappings from previous differs\n:return: additional mappings that should be included in the result of the differentiation",
      "code": "    @abstractmethod\n    def get_additional_mappings(self) -> list[Mapping]:\n        \"\"\"\n        This method allows the differ to add further mappings from previous differs\n        :return: additional mappings that should be included in the result of the differentiation\n        \"\"\""
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_related_mappings",
      "name": "get_related_mappings",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.get_related_mappings",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_related_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.get_related_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Indicates whether all api elements should be compared with each other\nor just the ones that are mapped to each other.\n:return: a list of Mappings if only previously mapped api elements should be mapped to each other or else None.",
      "docstring": "Indicates whether all api elements should be compared with each other\nor just the ones that are mapped to each other.\n:return: a list of Mappings if only previously mapped api elements should be mapped to each other or else None.",
      "code": "    @abstractmethod\n    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        \"\"\"\n        Indicates whether all api elements should be compared with each other\n        or just the ones that are mapped to each other.\n        :return: a list of Mappings if only previously mapped api elements should be mapped to each other or else None.\n        \"\"\""
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/notify_new_mapping",
      "name": "notify_new_mapping",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.notify_new_mapping",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/notify_new_mapping/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.notify_new_mapping.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/AbstractDiffer/notify_new_mapping/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.notify_new_mapping.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "If previous mappings returns None, the differ will be notified about a new mapping.\nThereby the differ can calculate the similarity with more information.\n:param mappings: a list of mappings new appended mappings.",
      "docstring": "If previous mappings returns None, the differ will be notified about a new mapping.\nThereby the differ can calculate the similarity with more information.\n:param mappings: a list of mappings new appended mappings.",
      "code": "    @abstractmethod\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        \"\"\"\n        If previous mappings returns None, the differ will be notified about a new mapping.\n        Thereby the differ can calculate the similarity with more information.\n        :param mappings: a list of mappings new appended mappings.\n        \"\"\""
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/previous_base_differ",
          "name": "previous_base_differ",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.previous_base_differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/previous_mappings",
          "name": "previous_mappings",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.previous_mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        previous_base_differ: Optional[AbstractDiffer],\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        distance_between_implicit_and_explicit = 0.3\n        distance_between_vararg_and_normal = 0.3\n        distance_between_position_and_named = 0.3\n        distance_between_both_to_one = 0.15\n        distance_between_one_to_both = 0.15\n        self.assigned_by_look_up_similarity = {\n            ParameterAssignment.IMPLICIT: {\n                ParameterAssignment.IMPLICIT: 1.0,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_implicit_and_explicit,\n            },\n            ParameterAssignment.NAMED_VARARG: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.NAMED_VARARG: 1.0,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0 - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n            },\n            ParameterAssignment.POSITIONAL_VARARG: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_vararg_and_normal,\n            },\n            ParameterAssignment.POSITION_OR_NAME: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_both_to_one,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_both_to_one,\n                ParameterAssignment.POSITION_OR_NAME: 1.0,\n                ParameterAssignment.NAME_ONLY: 1.0 - distance_between_both_to_one,\n                ParameterAssignment.POSITION_ONLY: 1.0 - distance_between_both_to_one,\n            },\n            ParameterAssignment.NAME_ONLY: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_position_and_named,\n            },\n            ParameterAssignment.POSITION_ONLY: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_ONLY: 1.0,\n            },\n        }"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity",
      "name": "_compute_assignment_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_assignment_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_assignment_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity/assigned_byv1",
          "name": "assigned_byv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_assignment_similarity.assigned_byv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity/assigned_byv2",
          "name": "assigned_byv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_assignment_similarity.assigned_byv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_assignment_similarity(\n        self, assigned_byv1: ParameterAssignment, assigned_byv2: ParameterAssignment\n    ) -> float:\n        return self.assigned_by_look_up_similarity[assigned_byv1][assigned_byv2]"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity",
      "name": "_compute_code_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_code_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_code_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity/codev1",
          "name": "codev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_code_similarity.codev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity/codev2",
          "name": "codev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_code_similarity.codev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_code_similarity(self, codev1: str, codev2: str) -> float:\n        splitv1 = codev1.split(\"\\n\")\n        splitv2 = codev2.split(\"\\n\")\n        diff_code = distance(splitv1, splitv2) / max(len(splitv1), len(splitv2), 1)\n        return 1 - diff_code"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity",
      "name": "_compute_default_value_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_default_value_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_default_value_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity/default_valuev1",
          "name": "default_valuev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_default_value_similarity.default_valuev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity/default_valuev2",
          "name": "default_valuev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_default_value_similarity.default_valuev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_default_value_similarity(\n        self, default_valuev1: Optional[str], default_valuev2: Optional[str]\n    ) -> float:\n        if default_valuev1 is None and default_valuev2 is None:\n            return -1.0\n        if default_valuev1 is None or default_valuev2 is None:\n            return 0.0\n        if default_valuev1 == \"None\" and default_valuev2 == \"None\":\n            return 1.0\n        try:\n            intv1_value = int(default_valuev1)\n            intv2_value = int(default_valuev2)\n            if intv1_value == intv2_value:\n                return 1.0\n            return 0.5\n        except ValueError:\n            try:\n                floatv1_value = float(default_valuev1)\n                floatv2_value = float(default_valuev2)\n                if floatv1_value == floatv2_value:\n                    return 1.0\n            except ValueError:\n                try:\n                    if float(int(default_valuev1)) == float(default_valuev2):\n                        return 0.75\n                except ValueError:\n                    try:\n                        if float(int(default_valuev2)) == float(default_valuev1):\n                            return 0.75\n                    except ValueError:\n                        pass\n        if default_valuev1 in (\n            \"True\",\n            \"False\",\n        ) and default_valuev2 in (\"True\", \"False\"):\n            if bool(default_valuev1) == bool(default_valuev2):\n                return 1.0\n            return 0.5\n        valuev1_is_in_quotation_marks = (\n            default_valuev1.startswith(\"'\") and default_valuev1.endswith(\"'\")\n        ) or (default_valuev1.startswith('\"') and default_valuev1.endswith('\"'))\n        valuev2_is_in_quotation_marks = (\n            default_valuev2.startswith(\"'\") and default_valuev2.endswith(\"'\")\n        ) or (default_valuev2.startswith('\"') and default_valuev2.endswith('\"'))\n        if valuev1_is_in_quotation_marks and valuev2_is_in_quotation_marks:\n            if default_valuev1[1:-1] == default_valuev2[1:-1]:\n                return 1.0\n            return 0.5\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity",
      "name": "_compute_documentation_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_documentation_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_documentation_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity/documentationv1",
          "name": "documentationv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_documentation_similarity.documentationv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity/documentationv2",
          "name": "documentationv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_documentation_similarity.documentationv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_documentation_similarity(\n        self,\n        documentationv1: Union[\n            ClassDocumentation, FunctionDocumentation, ParameterDocumentation\n        ],\n        documentationv2: Union[\n            ClassDocumentation, FunctionDocumentation, ParameterDocumentation\n        ],\n    ) -> float:\n        if len(documentationv1.description) == len(documentationv2.description) == 0:\n            return -1.0\n        descriptionv1 = re.split(\"[\\n ]\", documentationv1.description)\n        descriptionv2 = re.split(\"[\\n ]\", documentationv2.description)\n\n        documentation_similarity = distance(descriptionv1, descriptionv2) / max(\n            len(descriptionv1), len(descriptionv2), 1\n        )\n        return 1 - documentation_similarity"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity",
      "name": "_compute_id_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_id_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_id_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity/idv1",
          "name": "idv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_id_similarity.idv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity/idv2",
          "name": "idv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_id_similarity.idv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_id_similarity(self, idv1: str, idv2: str) -> float:\n        module_pathv1 = idv1.split(\"/\")[1].split(\".\")\n        additional_module_pathv1 = idv1.split(\"/\")[2:-1]\n        if len(additional_module_pathv1) > 0:\n            module_pathv1.extend(additional_module_pathv1)\n        module_pathv2 = idv2.split(\"/\")[1].split(\".\")\n        additional_module_pathv2 = idv2.split(\"/\")[2:-1]\n        if len(additional_module_pathv2) > 0:\n            module_pathv2.extend(additional_module_pathv2)\n\n        def cost_function(iteration: int, max_iteration: int) -> float:\n            return (max_iteration - iteration + 1) / max_iteration\n\n        total_costs, max_iterations = distance_elements_with_cost_function(\n            module_pathv1, module_pathv2, cost_function\n        )\n        return 1 - (total_costs / (sum(range(1, max_iterations + 1)) / max_iterations))"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity",
      "name": "_compute_name_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_name_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_name_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity/namev1",
          "name": "namev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_name_similarity.namev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity/namev2",
          "name": "namev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_name_similarity.namev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_name_similarity(self, namev1: str, namev2: str) -> float:\n        name_similarity = distance(namev1, namev2) / max(len(namev1), len(namev2), 1)\n        return 1 - name_similarity"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity",
      "name": "_compute_type_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_type_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_type_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity/typev1",
          "name": "typev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_type_similarity.typev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity/typev2",
          "name": "typev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_type_similarity.typev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_type_similarity(\n        self, typev1: Optional[AbstractType], typev2: Optional[AbstractType]\n    ) -> float:\n        if typev1 is None:\n            if typev2 is None:\n                return 1\n            return 0\n        if typev2 is None:\n            return 0\n\n        type_listv1 = self._create_list_from_type(typev1)\n        type_listv2 = self._create_list_from_type(typev2)\n        diff_elements = distance(type_listv1, type_listv2) / max(\n            len(type_listv1), len(type_listv2), 1\n        )\n        return 1 - diff_elements"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_create_list_from_type",
      "name": "_create_list_from_type",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._create_list_from_type",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_create_list_from_type/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._create_list_from_type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_create_list_from_type/abstract_type",
          "name": "abstract_type",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._create_list_from_type.abstract_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _create_list_from_type(\n        self, abstract_type: Optional[AbstractType]\n    ) -> Sequence[Optional[AbstractType]]:\n        if abstract_type is not None and isinstance(abstract_type, UnionType):\n            return abstract_type.types\n        return [abstract_type]"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity",
      "name": "compute_attribute_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_attribute_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_attribute_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity/attributev1",
          "name": "attributev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_attribute_similarity.attributev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity/attributev2",
          "name": "attributev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_attribute_similarity.attributev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between attributes from apiv1 and apiv2 with the respect to their name and type.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between attributes from apiv1 and apiv2 with the respect to their name and type.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_attribute_similarity(\n        self,\n        attributev1: Attribute,\n        attributev2: Attribute,\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2 with the respect to their name and type.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        name_similarity = self._compute_name_similarity(\n            attributev1.name, attributev2.name\n        )\n        type_listv1 = self._create_list_from_type(attributev1.types)\n        type_listv2 = self._create_list_from_type(attributev2.types)\n        type_similarity = distance(type_listv1, type_listv2) / max(\n            len(type_listv1), len(type_listv2), 1\n        )\n        type_similarity = 1 - type_similarity\n        return (name_similarity + type_similarity) / 2"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity",
      "name": "compute_class_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_class_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_class_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity/classv1",
          "name": "classv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_class_similarity.classv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity/classv2",
          "name": "classv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_class_similarity.classv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between classes from apiv1 and apiv2 with the respect to their name, id, code, and attributes.\n:param classv1: attribute from apiv1\n:param classv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between classes from apiv1 and apiv2 with the respect to their name, id, code, and attributes.\n:param classv1: attribute from apiv1\n:param classv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2 with the respect to their name, id, code, and attributes.\n        :param classv1: attribute from apiv1\n        :param classv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        normalize_similarity = 6\n\n        code_similarity = self._compute_code_similarity(\n            classv1.get_formatted_code(), classv2.get_formatted_code()\n        )\n        name_similarity = self._compute_name_similarity(classv1.name, classv2.name)\n\n        attributes_similarity = distance(\n            classv1.instance_attributes, classv2.instance_attributes\n        )\n        attributes_similarity = attributes_similarity / (\n            max(len(classv1.instance_attributes), len(classv2.instance_attributes), 1)\n        )\n        attributes_similarity = 1 - attributes_similarity\n\n        function_similarity = distance(\n            classv1.methods,\n            classv2.methods,\n        ) / max(len(classv1.methods), len(classv2.methods), 1)\n        function_similarity = 1 - function_similarity\n\n        id_similarity = self._compute_id_similarity(classv1.id, classv2.id)\n\n        documentation_similarity = self._compute_documentation_similarity(\n            classv1.documentation, classv2.documentation\n        )\n        if documentation_similarity < 0:\n            documentation_similarity = 0\n            normalize_similarity -= 1\n\n        return (\n            name_similarity\n            + attributes_similarity\n            + function_similarity\n            + code_similarity\n            + id_similarity\n            + documentation_similarity\n        ) / normalize_similarity"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity",
      "name": "compute_function_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_function_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_function_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity/functionv1",
          "name": "functionv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_function_similarity.functionv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_function_similarity.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between functions from apiv1 and apiv2 with the respect to their code, name, id, and parameters.\n:param functionv1: attribute from apiv1\n:param functionv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between functions from apiv1 and apiv2 with the respect to their code, name, id, and parameters.\n:param functionv1: attribute from apiv1\n:param functionv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2 with the respect to their code, name, id, and parameters.\n        :param functionv1: attribute from apiv1\n        :param functionv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        if (\n            functionv1.id in self.previous_function_similarity\n            and functionv2.id in self.previous_function_similarity[functionv1.id]\n        ):\n            return self.previous_function_similarity[functionv1.id][functionv2.id]\n\n        normalize_similarity = 5\n\n        code_similarity = self._compute_code_similarity(\n            functionv1.get_formatted_code(), functionv2.get_formatted_code()\n        )\n        name_similarity = self._compute_name_similarity(\n            functionv1.name, functionv2.name\n        )\n\n        parameter_similarity = distance(\n            functionv1.parameters,\n            functionv2.parameters,\n        ) / max(len(functionv1.parameters), len(functionv2.parameters), 1)\n        parameter_similarity = 1 - parameter_similarity\n\n        id_similarity = self._compute_id_similarity(functionv1.id, functionv2.id)\n\n        documentation_similarity = self._compute_documentation_similarity(\n            functionv1.documentation, functionv2.documentation\n        )\n        if documentation_similarity < 0:\n            documentation_similarity = 0\n            normalize_similarity -= 1\n\n        result = (\n            code_similarity\n            + name_similarity\n            + parameter_similarity\n            + id_similarity\n            + documentation_similarity\n        ) / normalize_similarity\n        if functionv1.id not in self.previous_function_similarity:\n            self.previous_function_similarity[functionv1.id] = {}\n        self.previous_function_similarity[functionv1.id][functionv2.id] = result\n        return result"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity",
      "name": "compute_parameter_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_parameter_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_parameter_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity/parameterv1",
          "name": "parameterv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_parameter_similarity.parameterv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_parameter_similarity.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between parameters from apiv1 and apiv2 with the respect to their name, type, assignment, default value, documentation, and id.\n:param parameterv1: attribute from apiv1\n:param parameterv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between parameters from apiv1 and apiv2 with the respect to their name, type, assignment, default value, documentation, and id.\n:param parameterv1: attribute from apiv1\n:param parameterv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2 with the respect to their name, type, assignment, default value, documentation, and id.\n        :param parameterv1: attribute from apiv1\n        :param parameterv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        if (\n            parameterv1.id in self.previous_parameter_similarity\n            and parameterv2.id in self.previous_parameter_similarity[parameterv1.id]\n        ):\n            return self.previous_parameter_similarity[parameterv1.id][parameterv2.id]\n\n        normalize_similarity = 6\n        parameter_name_similarity = self._compute_name_similarity(\n            parameterv1.name, parameterv2.name\n        )\n        parameter_type_similarity = self._compute_type_similarity(\n            parameterv1.type, parameterv2.type\n        )\n        parameter_assignment_similarity = self._compute_assignment_similarity(\n            parameterv1.assigned_by, parameterv2.assigned_by\n        )\n        if parameter_assignment_similarity < 0:\n            parameter_assignment_similarity = 0\n            normalize_similarity -= 1\n        parameter_default_value_similarity = self._compute_default_value_similarity(\n            parameterv1.default_value, parameterv2.default_value\n        )\n        if parameter_default_value_similarity < 0:\n            parameter_default_value_similarity = 0\n            normalize_similarity -= 1\n        parameter_documentation_similarity = self._compute_documentation_similarity(\n            parameterv1.documentation, parameterv2.documentation\n        )\n        if parameter_documentation_similarity < 0:\n            parameter_documentation_similarity = 0\n            normalize_similarity -= 1\n\n        id_similarity = self._compute_id_similarity(parameterv1.id, parameterv2.id)\n\n        result = (\n            parameter_name_similarity\n            + parameter_type_similarity\n            + parameter_assignment_similarity\n            + parameter_default_value_similarity\n            + parameter_documentation_similarity\n            + id_similarity\n        ) / normalize_similarity\n        if parameterv1.id not in self.previous_parameter_similarity:\n            self.previous_parameter_similarity[parameterv1.id] = {}\n        self.previous_parameter_similarity[parameterv1.id][parameterv2.id] = result\n        return result"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity",
      "name": "compute_result_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_result_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_result_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity/resultv1",
          "name": "resultv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_result_similarity.resultv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity/resultv2",
          "name": "resultv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_result_similarity.resultv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between results from apiv1 and apiv2 with the respect to their name.\n:param resultv1: attribute from apiv1\n:param resultv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between results from apiv1 and apiv2 with the respect to their name.\n:param resultv1: attribute from apiv1\n:param resultv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2 with the respect to their name.\n        :param resultv1: attribute from apiv1\n        :param resultv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        return self._compute_name_similarity(resultv1.name, resultv2.name)"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_additional_mappings",
      "name": "get_additional_mappings",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.get_additional_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_additional_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.get_additional_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_additional_mappings(self) -> list[Mapping]:\n        return []"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_related_mappings",
      "name": "get_related_mappings",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.get_related_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_related_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.get_related_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/notify_new_mapping",
      "name": "notify_new_mapping",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.notify_new_mapping",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/notify_new_mapping/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.notify_new_mapping.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/SimpleDiffer/notify_new_mapping/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.notify_new_mapping.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        return"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function",
      "name": "distance_elements_with_cost_function",
      "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/listv1",
          "name": "listv1",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.listv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/listv2",
          "name": "listv2",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.listv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/cost_function",
          "name": "cost_function",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.cost_function",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/are_similar",
          "name": "are_similar",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.are_similar",
          "default_value": "lambda x, y: x == y",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/iteration",
          "name": "iteration",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.iteration",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def distance_elements_with_cost_function(\n    listv1: list[X],\n    listv2: list[X],\n    cost_function: Callable[[int, int], float],\n    are_similar: Callable[[X, X], bool] = lambda x, y: x == y,\n    iteration: int = 1,\n) -> Tuple[float, int]:\n    if len(listv1) == 0 and len(listv2) == 0:\n        return 0.0, iteration - 1\n    if len(listv1) == 0:\n        total_costs = 0.0\n        max_iterations = iteration + len(listv2)\n        for i in range(0, len(listv2)):\n            total_costs += cost_function(iteration + i, max_iterations)\n        return total_costs, max_iterations\n    if len(listv2) == 0:\n        total_costs = 0.0\n        max_iterations = iteration + len(listv1)\n        for i in range(0, len(listv1)):\n            total_costs += cost_function(iteration + i, max_iterations)\n        return total_costs, max_iterations\n    if are_similar(listv1[0], listv2[0]):\n        total_costs, max_iterations = distance_elements_with_cost_function(\n            listv1[1:], listv2[1:], cost_function, are_similar, iteration + 1\n        )\n        return total_costs, max_iterations\n    recursive_results = [\n        distance_elements_with_cost_function(\n            listv1[1:], listv2, cost_function, are_similar, iteration + 1\n        ),\n        distance_elements_with_cost_function(\n            listv1, listv2[1:], cost_function, are_similar, iteration + 1\n        ),\n        distance_elements_with_cost_function(\n            listv1[1:], listv2[1:], cost_function, are_similar, iteration + 1\n        ),\n    ]\n    total_costs, max_iterations = sorted(\n        recursive_results, key=lambda tuple_: tuple_[0]\n    )[0]\n    total_costs += cost_function(iteration, max_iterations)\n    return total_costs, max_iterations"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/previous_base_differ",
          "name": "previous_base_differ",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.previous_base_differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/previous_mappings",
          "name": "previous_mappings",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.previous_mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/boost_value",
          "name": "boost_value",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.boost_value",
          "default_value": "0.15",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        previous_base_differ: AbstractDiffer,\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n        boost_value: float = 0.15,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        self.differ = previous_base_differ\n        self.boost_value = boost_value\n        self.inheritance = {}\n        self.new_mappings = []\n        for class_v2 in self.apiv2.classes.values():\n            additional_v1_elements = []\n            for mapping in previous_mappings:\n                if isinstance(mapping.get_apiv2_elements()[0], Class):\n                    is_inheritance_mapping = class_v2.id in map(\n                        lambda class_: class_.id if isinstance(class_, Class) else \"\",\n                        mapping.get_apiv2_elements(),\n                    )\n                    if not is_inheritance_mapping:\n                        for inheritance_class_v2 in mapping.get_apiv2_elements():\n                            if isinstance(inheritance_class_v2, Class):\n                                if (\n                                    inheritance_class_v2.name in class_v2.superclasses\n                                    or class_v2.name\n                                    in inheritance_class_v2.superclasses\n                                ):\n                                    is_inheritance_mapping = True\n                                    break\n                    if is_inheritance_mapping:\n                        for class_v1 in mapping.get_apiv1_elements():\n                            if isinstance(class_v1, Class):\n                                additional_v1_elements.append(class_v1.id)\n            if len(additional_v1_elements) > 0:\n                self.inheritance[class_v2.id] = additional_v1_elements"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements",
      "name": "_get_not_mapped_api_elements",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements/mapped_apiv1_elements",
          "name": "mapped_apiv1_elements",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements.mapped_apiv1_elements",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements/mapped_apiv2_elements",
          "name": "mapped_apiv2_elements",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements.mapped_apiv2_elements",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements/get_api_element",
          "name": "get_api_element",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements.get_api_element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_not_mapped_api_elements(\n        self,\n        mapped_apiv1_elements: list[api_element],\n        mapped_apiv2_elements: list[api_element],\n        get_api_element: Callable[[API], list[api_element]],\n    ) -> Optional[Mapping]:\n        not_mapped_v1_elements = []\n        for api_elementv1 in get_api_element(self.apiv1):\n            if api_elementv1 not in mapped_apiv1_elements:\n                not_mapped_v1_elements.append(api_elementv1)\n        not_mapped_v2_elements = []\n        for api_elementv2 in get_api_element(self.apiv2):\n            if api_elementv2 not in mapped_apiv2_elements:\n                not_mapped_v2_elements.append(api_elementv2)\n        if len(not_mapped_v1_elements) > 0 and len(not_mapped_v2_elements) > 0:\n            return ManyToManyMapping(\n                -1.0, not_mapped_v1_elements, not_mapped_v2_elements\n            )\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity",
      "name": "compute_attribute_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_attribute_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_attribute_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity/attributev1",
          "name": "attributev1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_attribute_similarity.attributev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity/attributev2",
          "name": "attributev2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_attribute_similarity.attributev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: if the parent of the attributes are mapped onto each other\n or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.",
      "docstring": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: if the parent of the attributes are mapped onto each other\n or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.",
      "code": "    def compute_attribute_similarity(\n        self, attributev1: Attribute, attributev2: Attribute\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: if the parent of the attributes are mapped onto each other\n         or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if (\n            attributev2.class_id in self.inheritance\n            and attributev1.class_id in self.inheritance[attributev2.class_id]\n        ):\n            return (\n                self.differ.compute_attribute_similarity(attributev1, attributev2)\n                * (1 - self.boost_value)\n            ) + self.boost_value\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity",
      "name": "compute_class_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_class_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_class_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity/classv1",
          "name": "classv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_class_similarity.classv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity/classv2",
          "name": "classv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_class_similarity.classv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between classes from apiv1 and apiv2\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: if the classes are mapped onto each other or onto a super- or subclass,\nthe normalized similarity of the previous differ plus boost_value, or else 0.",
      "docstring": "Computes similarity between classes from apiv1 and apiv2\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: if the classes are mapped onto each other or onto a super- or subclass,\nthe normalized similarity of the previous differ plus boost_value, or else 0.",
      "code": "    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: if the classes are mapped onto each other or onto a super- or subclass,\n        the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if classv2.id in self.inheritance:\n            for mapping in self.previous_mappings:\n                for elementv2 in mapping.get_apiv2_elements():\n                    if isinstance(elementv2, Class):\n                        if elementv2.id in self.inheritance[classv2.id]:\n                            return (\n                                self.differ.compute_class_similarity(classv1, classv2)\n                                * (1 - self.boost_value)\n                            ) + self.boost_value\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity",
      "name": "compute_function_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_function_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_function_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity/functionv1",
          "name": "functionv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_function_similarity.functionv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_function_similarity.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: if functions are not global functions and its parent are mapped onto each other\n or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.",
      "docstring": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: if functions are not global functions and its parent are mapped onto each other\n or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.",
      "code": "    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: if functions are not global functions and its parent are mapped onto each other\n         or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        functionv1_is_global = len(functionv1.id.split(\"/\")) == 3\n        functionv2_is_global = len(functionv2.id.split(\"/\")) == 3\n        if functionv1_is_global or functionv2_is_global:\n            return 0.0\n        class_id_functionv1 = \"/\".join(functionv1.id.split(\"/\")[:-1])\n        class_id_functionv2 = \"/\".join(functionv2.id.split(\"/\")[:-1])\n        if (\n            class_id_functionv2 in self.inheritance\n            and class_id_functionv1 in self.inheritance[class_id_functionv2]\n        ):\n            base_similarity = self.differ.compute_function_similarity(\n                functionv1, functionv2\n            )\n            return (base_similarity * (1 - self.boost_value)) + self.boost_value\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity",
      "name": "compute_parameter_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_parameter_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_parameter_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity/parameterv1",
          "name": "parameterv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_parameter_similarity.parameterv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_parameter_similarity.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: if their parents are mapped together, the normalized similarity of the previous differ plus boost_value,\nor else 0.",
      "docstring": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: if their parents are mapped together, the normalized similarity of the previous differ plus boost_value,\nor else 0.",
      "code": "    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: if their parents are mapped together, the normalized similarity of the previous differ plus boost_value,\n        or else 0.\n        \"\"\"\n        parameterv2_id_splitted = parameterv2.id.split(\"/\")\n        if \"/\".join(parameterv2_id_splitted[:-2]) in self.inheritance:\n            functionv1_id = \"/\".join(parameterv1.id.split(\"/\")[:-1])\n            for mapping in self.new_mappings:\n                for functionv1 in mapping.get_apiv1_elements():\n                    if (\n                        isinstance(functionv1, Function)\n                        and functionv1_id == functionv1.id\n                    ):\n                        for functionv2 in mapping.get_apiv2_elements():\n                            if (\n                                isinstance(functionv2, Function)\n                                and \"/\".join(parameterv2_id_splitted[:-1])\n                                == functionv2.id\n                            ):\n                                return (\n                                    self.differ.compute_parameter_similarity(\n                                        parameterv1, parameterv2\n                                    )\n                                    * (1 - self.boost_value)\n                                ) + self.boost_value\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity",
      "name": "compute_result_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_result_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_result_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity/resultv1",
          "name": "resultv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_result_similarity.resultv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity/resultv2",
          "name": "resultv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_result_similarity.resultv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between results from apiv1 and apiv2\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: if their parents are mapped together,\nthe normalized similarity of the previous differ plus boost_value, or else 0.",
      "docstring": "Computes similarity between results from apiv1 and apiv2\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: if their parents are mapped together,\nthe normalized similarity of the previous differ plus boost_value, or else 0.",
      "code": "    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: if their parents are mapped together,\n        the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if (\n            resultv2.function_id is not None\n            and \"/\".join(resultv2.function_id.split(\"/\")[:-1]) in self.inheritance\n        ):\n            for mapping in self.new_mappings:\n                for functionv1 in mapping.get_apiv1_elements():\n                    if (\n                        isinstance(functionv1, Function)\n                        and resultv1.function_id == functionv1.id\n                    ):\n                        for functionv2 in mapping.get_apiv2_elements():\n                            if (\n                                isinstance(functionv2, Function)\n                                and resultv2.function_id == functionv2.id\n                            ):\n                                return (\n                                    self.differ.compute_result_similarity(\n                                        resultv1, resultv2\n                                    )\n                                    * (1 - self.boost_value)\n                                ) + self.boost_value\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_additional_mappings",
      "name": "get_additional_mappings",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.get_additional_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_additional_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.get_additional_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_additional_mappings(self) -> list[Mapping]:\n        return self.previous_mappings"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_related_mappings",
      "name": "get_related_mappings",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.get_related_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_related_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.get_related_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Indicates whether all api elements should be compared with each other\nor just the ones that are mapped to each other.\n:return: a list of Mappings by type whose elements are not already mapped",
      "docstring": "Indicates whether all api elements should be compared with each other\nor just the ones that are mapped to each other.\n:return: a list of Mappings by type whose elements are not already mapped",
      "code": "    def get_related_mappings(self) -> Optional[list[Mapping]]:\n        \"\"\"\n        Indicates whether all api elements should be compared with each other\n        or just the ones that are mapped to each other.\n        :return: a list of Mappings by type whose elements are not already mapped\n        \"\"\"\n        related_mappings = []\n        mapped_apiv1_elements = [\n            element\n            for mapping in self.previous_mappings\n            for element in mapping.get_apiv1_elements()\n        ]\n        mapped_apiv2_elements = [\n            element\n            for mapping in self.previous_mappings\n            for element in mapping.get_apiv2_elements()\n        ]\n        for get_api_element in [\n            lambda api: api.classes.values(),\n            lambda api: api.functions.values(),\n            lambda api: api.attributes().values(),\n            lambda api: api.parameters().values(),\n            lambda api: api.results().values(),\n        ]:\n            not_mapped_elements_mapping = self._get_not_mapped_api_elements(\n                mapped_apiv1_elements, mapped_apiv2_elements, get_api_element\n            )\n            if not_mapped_elements_mapping is not None:\n                related_mappings.append(not_mapped_elements_mapping)\n        return related_mappings"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/notify_new_mapping",
      "name": "notify_new_mapping",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.notify_new_mapping",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/notify_new_mapping/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.notify_new_mapping.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/notify_new_mapping/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.notify_new_mapping.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        self.new_mappings.extend(mappings)"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping.get_apiv1_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv1_elements(self) -> list[api_element]:\n        return self.apiv1_elements"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping.get_apiv2_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv2_elements(self) -> list[api_element]:\n        return self.apiv2_elements"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping.get_apiv1_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv1_elements(self) -> list[api_element]:\n        return self.apiv1_elements"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping.get_apiv2_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv2_elements(self) -> list[api_element]:\n        return [self.apiv2_element]"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.Mapping.get_apiv1_elements",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.Mapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def get_apiv1_elements(self) -> list[api_element]:\n        pass"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.Mapping.get_apiv2_elements",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.Mapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def get_apiv2_elements(self) -> list[api_element]:\n        pass"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/Mapping/get_similarity",
      "name": "get_similarity",
      "qname": "package_parser.processing.migration.model._mapping.Mapping.get_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/Mapping/get_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.Mapping.get_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_similarity(self) -> float:\n        return self.similarity"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping.get_apiv1_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv1_elements(self) -> list[api_element]:\n        return [self.apiv1_element]"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping.get_apiv2_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv2_elements(self) -> list[api_element]:\n        return self.apiv2_elements"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping.get_apiv1_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv1_elements(self) -> list[api_element]:\n        return [self.apiv1_element]"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping.get_apiv2_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv2_elements(self) -> list[api_element]:\n        return [self.apiv2_element]"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/merge_api_elements_and_remove_duplicates",
      "name": "merge_api_elements_and_remove_duplicates",
      "qname": "package_parser.processing.migration.model._mapping.merge_api_elements_and_remove_duplicates",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/merge_api_elements_and_remove_duplicates/list_a",
          "name": "list_a",
          "qname": "package_parser.processing.migration.model._mapping.merge_api_elements_and_remove_duplicates.list_a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/merge_api_elements_and_remove_duplicates/list_b",
          "name": "list_b",
          "qname": "package_parser.processing.migration.model._mapping.merge_api_elements_and_remove_duplicates.list_b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def merge_api_elements_and_remove_duplicates(\n    list_a: list[api_element], list_b: list[api_element]\n) -> list[api_element]:\n    api_elements: list[api_element] = []\n    api_elements.extend(list_a)\n    api_elements.extend(list_b)\n    id_list: list[str] = []\n    merged_list: list[api_element] = []\n    for element in api_elements:\n        element_id = \"\"\n        if isinstance(element, (Class, Function, Parameter)):\n            element_id = element.id\n        elif isinstance(element, Attribute):\n            element_id = str(element.class_id) + \"/\" + element.name\n        elif isinstance(element, Result):\n            element_id = str(element.function_id) + \"/\" + element.name\n        if len(element_id) > 0 and element_id not in id_list:\n            merged_list.append(element)\n            id_list.append(element_id)\n    return merged_list"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._mapping/merge_mappings",
      "name": "merge_mappings",
      "qname": "package_parser.processing.migration.model._mapping.merge_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/merge_mappings/mapping_a",
          "name": "mapping_a",
          "qname": "package_parser.processing.migration.model._mapping.merge_mappings.mapping_a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._mapping/merge_mappings/mapping_b",
          "name": "mapping_b",
          "qname": "package_parser.processing.migration.model._mapping.merge_mappings.mapping_b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def merge_mappings(mapping_a: Mapping, mapping_b: Mapping) -> Mapping:\n    similarity = (mapping_a.similarity + mapping_b.similarity) / 2\n    codomain = merge_api_elements_and_remove_duplicates(\n        mapping_a.get_apiv2_elements(), mapping_b.get_apiv2_elements()\n    )\n    domain: list[api_element] = merge_api_elements_and_remove_duplicates(\n        mapping_a.get_apiv1_elements(), mapping_b.get_apiv1_elements()\n    )\n    if len(domain) == 1 and len(codomain) == 1:\n        return OneToOneMapping(similarity, domain[0], codomain[0])\n    if len(domain) == 1:\n        return OneToManyMapping(similarity, domain[0], codomain)\n    if len(codomain) == 1:\n        return ManyToOneMapping(similarity, domain, codomain[0])\n    return ManyToManyMapping(similarity, domain, codomain)"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/previous_base_differ",
          "name": "previous_base_differ",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.previous_base_differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/previous_mappings",
          "name": "previous_mappings",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.previous_mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        previous_base_differ: AbstractDiffer,\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        self.differ = previous_base_differ\n        self.new_mappings = []"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other",
      "name": "_api_elements_are_mapped_to_each_other",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._api_elements_are_mapped_to_each_other",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._api_elements_are_mapped_to_each_other.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other/api_elementv1",
          "name": "api_elementv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._api_elements_are_mapped_to_each_other.api_elementv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other/api_elementv2",
          "name": "api_elementv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._api_elements_are_mapped_to_each_other.api_elementv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _api_elements_are_mapped_to_each_other(\n        self,\n        api_elementv1: DEPENDENT_API_ELEMENTS,\n        api_elementv2: DEPENDENT_API_ELEMENTS,\n    ) -> bool:\n        (\n            relevant_apiv1_mappings,\n            relevant_apiv2_mappings,\n        ) = self._get_mapping_for_elements(api_elementv1, api_elementv2)\n        relevant_apiv2_mappings_include_functionv1 = (\n            len(\n                [\n                    parent\n                    for mapping in relevant_apiv2_mappings\n                    for parent in mapping.get_apiv1_elements()\n                    if self._is_parent(parent, api_elementv1)\n                ]\n            )\n            == 1\n        )\n        relevant_apiv2_mappings_include_functionv2 = (\n            len(\n                [\n                    parent\n                    for mapping in relevant_apiv1_mappings\n                    for parent in mapping.get_apiv2_elements()\n                    if self._is_parent(parent, api_elementv2)\n                ]\n            )\n            == 1\n        )\n        return (\n            relevant_apiv2_mappings_include_functionv1\n            and relevant_apiv2_mappings_include_functionv2\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements",
      "name": "_get_mapping_for_elements",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._get_mapping_for_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._get_mapping_for_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements/apiv1_element",
          "name": "apiv1_element",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._get_mapping_for_elements.apiv1_element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements/apiv2_element",
          "name": "apiv2_element",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._get_mapping_for_elements.apiv2_element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mapping_for_elements(\n        self,\n        apiv1_element: DEPENDENT_API_ELEMENTS,\n        apiv2_element: DEPENDENT_API_ELEMENTS,\n    ) -> tuple[list[Mapping], list[Mapping]]:\n        mapping_for_apiv1_elements = []\n        mapping_for_apiv2_elements = []\n        for mapping in self.new_mappings:\n            if isinstance(mapping.get_apiv1_elements()[0], (Class, Function)):\n                for element in mapping.get_apiv1_elements():\n                    if self._is_parent(element, apiv1_element):\n                        mapping_for_apiv1_elements.append(mapping)\n                for element in mapping.get_apiv2_elements():\n                    if self._is_parent(element, apiv2_element):\n                        mapping_for_apiv2_elements.append(mapping)\n        return mapping_for_apiv1_elements, mapping_for_apiv2_elements"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent",
      "name": "_is_parent",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._is_parent",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._is_parent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent/possible_parent",
          "name": "possible_parent",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._is_parent.possible_parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent/child",
          "name": "child",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._is_parent.child",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _is_parent(\n        self,\n        possible_parent: Union[Class, Function, Attribute, Parameter, Result],\n        child: DEPENDENT_API_ELEMENTS,\n    ) -> bool:\n        if isinstance(child, Attribute) and isinstance(possible_parent, Class):\n            return child.class_id == possible_parent.id\n        if isinstance(child, Result) and isinstance(possible_parent, Function):\n            return child.function_id == possible_parent.id\n        if isinstance(child, Parameter) and isinstance(possible_parent, Function):\n            return \"/\".join(child.id.split(\"/\")[:-1]) == possible_parent.id\n        if isinstance(child, Function) and isinstance(possible_parent, Class):\n            return \"/\".join(child.id.split(\"/\")[:-1]) == possible_parent.id\n        return False"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity",
      "name": "compute_attribute_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_attribute_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_attribute_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity/attributev1",
          "name": "attributev1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_attribute_similarity.attributev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity/attributev2",
          "name": "attributev2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_attribute_similarity.attributev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_attribute_similarity(\n        self, attributev1: Attribute, attributev2: Attribute\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(attributev1, attributev2):\n            return self.differ.compute_attribute_similarity(attributev1, attributev2)\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity",
      "name": "compute_class_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_class_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_class_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity/classv1",
          "name": "classv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_class_similarity.classv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity/classv2",
          "name": "classv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_class_similarity.classv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between classes from apiv1 and apiv2\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: if the classes are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between classes from apiv1 and apiv2\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: if the classes are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: if the classes are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        for mapping in self.previous_mappings:\n            if (\n                classv1 in mapping.get_apiv1_elements()\n                and classv2 in mapping.get_apiv2_elements()\n            ):\n                return self.differ.compute_class_similarity(classv1, classv2)\n        return 0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity",
      "name": "compute_function_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_function_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_function_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity/functionv1",
          "name": "functionv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_function_similarity.functionv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_function_similarity.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        is_global_functionv1 = len(functionv1.id.split(\"/\")) == 3\n        is_global_functionv2 = len(functionv2.id.split(\"/\")) == 3\n        if is_global_functionv1 and is_global_functionv2:\n            for mapping in self.previous_mappings:\n                if (\n                    functionv1 in mapping.get_apiv1_elements()\n                    and functionv2 in mapping.get_apiv2_elements()\n                ):\n                    return self.differ.compute_function_similarity(\n                        functionv1, functionv2\n                    )\n        elif (\n            not is_global_functionv1 and not is_global_functionv2\n        ) and self._api_elements_are_mapped_to_each_other(functionv1, functionv2):\n            return self.differ.compute_function_similarity(functionv1, functionv2)\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity",
      "name": "compute_parameter_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_parameter_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_parameter_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity/parameterv1",
          "name": "parameterv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_parameter_similarity.parameterv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_parameter_similarity.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(parameterv1, parameterv2):\n            return self.differ.compute_parameter_similarity(parameterv1, parameterv2)\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity",
      "name": "compute_result_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_result_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_result_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity/resultv1",
          "name": "resultv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_result_similarity.resultv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity/resultv2",
          "name": "resultv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_result_similarity.resultv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between results from apiv1 and apiv2.\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between results from apiv1 and apiv2.\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2.\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(resultv1, resultv2):\n            return self.differ.compute_result_similarity(resultv1, resultv2)\n        return 0.0"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_additional_mappings",
      "name": "get_additional_mappings",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.get_additional_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_additional_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.get_additional_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_additional_mappings(self) -> list[Mapping]:\n        return []"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_related_mappings",
      "name": "get_related_mappings",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.get_related_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_related_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.get_related_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        sort_order = {\n            Class: 0,\n            Attribute: 1,\n            Function: 2,\n            Parameter: 3,\n            Result: 4,\n        }\n        return sorted(\n            self.previous_mappings,\n            key=lambda mapping: sort_order[type(mapping.get_apiv1_elements()[0])],\n        )"
    },
    {
      "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/notify_new_mapping",
      "name": "notify_new_mapping",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.notify_new_mapping",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/notify_new_mapping/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.notify_new_mapping.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/notify_new_mapping/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.notify_new_mapping.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        self.new_mappings.extend(mappings)"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.__init__.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, package_name: str) -> None:\n        self.package_name: str = package_name\n        self.usages: UsageCountStore = UsageCountStore()"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call",
      "name": "enter_call",
      "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.enter_call",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call/self",
          "name": "self",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.enter_call.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call/node",
          "name": "node",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.enter_call.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_call(self, node: astroid.Call):\n        called_tuple = _analyze_declaration_called_by(node, self.package_name)\n        if called_tuple is None:\n            return\n        called, function_id, parameters, n_implicit_parameters = called_tuple\n\n        bound_parameters = _bound_parameters(\n            parameters, CallSite.from_call(node), n_implicit_parameters\n        )\n        if bound_parameters is None:\n            return\n\n        # Add class usage\n        if (\n            isinstance(called, (astroid.BoundMethod, astroid.UnboundMethod))\n            or isinstance(called, astroid.FunctionDef)\n            and called.is_method()\n        ):\n            self.usages.add_class_usages(parent_id(function_id))\n\n        # Add function usage\n        self.usages.add_function_usages(function_id)\n\n        # Add parameter & value usage\n        for parameter_name, value in bound_parameters.items():\n            parameter_id = f\"{function_id}/{parameter_name}\"\n            self.usages.add_parameter_usages(parameter_id)\n\n            value = _stringify_value(value)\n            self.usages.add_value_usages(parameter_id, value)"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/__called_constructor",
      "name": "__called_constructor",
      "qname": "package_parser.processing.usages._ast_visitor.__called_constructor",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/__called_constructor/class_def",
          "name": "class_def",
          "qname": "package_parser.processing.usages._ast_visitor.__called_constructor.class_def",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __called_constructor(class_def: astroid.ClassDef) -> Optional[astroid.FunctionDef]:\n    try:\n        # Use last __init__\n        constructor = class_def.local_attr(\"__init__\")[-1]\n    except astroid.NotFoundError:\n        return None\n\n    if isinstance(constructor, astroid.FunctionDef):\n        return constructor\n    else:\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name",
      "name": "__is_relevant_qualified_name",
      "qname": "package_parser.processing.usages._ast_visitor.__is_relevant_qualified_name",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor.__is_relevant_qualified_name.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.processing.usages._ast_visitor.__is_relevant_qualified_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __is_relevant_qualified_name(package_name: str, qualified_name: str) -> bool:\n    return qualified_name.startswith(package_name)"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/__n_implicit_parameters",
      "name": "__n_implicit_parameters",
      "qname": "package_parser.processing.usages._ast_visitor.__n_implicit_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/__n_implicit_parameters/called",
          "name": "called",
          "qname": "package_parser.processing.usages._ast_visitor.__n_implicit_parameters.called",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __n_implicit_parameters(called: astroid.NodeNG) -> int:\n    return called.implicit_parameters() if hasattr(called, \"implicit_parameters\") else 0"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by",
      "name": "_analyze_declaration_called_by",
      "qname": "package_parser.processing.usages._ast_visitor._analyze_declaration_called_by",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by/node",
          "name": "node",
          "qname": "package_parser.processing.usages._ast_visitor._analyze_declaration_called_by.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._analyze_declaration_called_by.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns None if the called declaration could not be determined or if it is not relevant for us. Otherwise, it\nreturns a tuple with the form (called, qualified_name, parameters, n_implicit_parameters).",
      "docstring": "Returns None if the called declaration could not be determined or if it is not relevant for us. Otherwise, it\nreturns a tuple with the form (called, qualified_name, parameters, n_implicit_parameters).",
      "code": "def _analyze_declaration_called_by(\n    node: astroid.Call, package_name: str\n) -> Optional[tuple[astroid.NodeNG, str, astroid.Arguments, int]]:\n    \"\"\"\n    Returns None if the called declaration could not be determined or if it is not relevant for us. Otherwise, it\n    returns a tuple with the form (called, qualified_name, parameters, n_implicit_parameters).\n    \"\"\"\n\n    called = safe_infer(node.func)\n    if called is None or not __is_relevant_qualified_name(package_name, called.qname()):\n        return None\n\n    n_implicit_parameters = __n_implicit_parameters(called)\n\n    if isinstance(called, astroid.ClassDef):\n        called = __called_constructor(called)\n        if called is None:\n            return None\n\n    if isinstance(\n        called, (astroid.BoundMethod, astroid.UnboundMethod, astroid.FunctionDef)\n    ):\n        return called, _id(package_name, called), called.args, n_implicit_parameters\n    else:\n        return None"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/_bound_parameters",
      "name": "_bound_parameters",
      "qname": "package_parser.processing.usages._ast_visitor._bound_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_bound_parameters/parameters",
          "name": "parameters",
          "qname": "package_parser.processing.usages._ast_visitor._bound_parameters.parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_bound_parameters/arguments",
          "name": "arguments",
          "qname": "package_parser.processing.usages._ast_visitor._bound_parameters.arguments",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_bound_parameters/n_implicit_parameters",
          "name": "n_implicit_parameters",
          "qname": "package_parser.processing.usages._ast_visitor._bound_parameters.n_implicit_parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _bound_parameters(\n    parameters: astroid.Arguments, arguments: CallSite, n_implicit_parameters: int\n) -> Optional[dict[str, astroid.NodeNG]]:\n    # Improper call\n    if (\n        parameters.args is None\n        or arguments.has_invalid_arguments()\n        or arguments.has_invalid_keywords()\n    ):\n        return None\n\n    result: dict[str, astroid.NodeNG] = arguments.keyword_arguments.copy()\n\n    positional_parameter_names = [\n        it.name for it in (parameters.posonlyargs + parameters.args)\n    ][n_implicit_parameters:]\n\n    for index, arg in enumerate(arguments.positional_arguments):\n        if index >= len(positional_parameter_names):\n            break\n\n        result[positional_parameter_names[index]] = arg\n\n    return result"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/_id",
      "name": "_id",
      "qname": "package_parser.processing.usages._ast_visitor._id",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_id/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._id.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_id/called",
          "name": "called",
          "qname": "package_parser.processing.usages._ast_visitor._id.called",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _id(\n    package_name: str, called: Union[astroid.UnboundMethod, astroid.FunctionDef]\n) -> str:\n    path = _path(package_name, called)\n\n    decorators: Optional[astroid.Decorators] = called.decorators\n    if decorators is not None:\n        decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n    else:\n        decorator_names = []\n\n    def is_getter() -> bool:\n        return \"property\" in decorator_names\n\n    def is_setter() -> bool:\n        for decorator in decorator_names:\n            if re.search(r\"^[^.]*.setter$\", decorator):\n                return True\n\n        return False\n\n    def is_deleter() -> bool:\n        for decorator in decorator_names:\n            if re.search(r\"^[^.]*.deleter$\", decorator):\n                return True\n\n        return False\n\n    result = \"/\".join(path)\n\n    if is_getter():\n        result += \"@getter\"\n    elif is_setter():\n        result += \"@setter\"\n    elif is_deleter():\n        result += \"@deleter\"\n\n    return result"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/_path",
      "name": "_path",
      "qname": "package_parser.processing.usages._ast_visitor._path",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_path/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._path.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_path/current",
          "name": "current",
          "qname": "package_parser.processing.usages._ast_visitor._path.current",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _path(package_name: str, current: astroid.NodeNG) -> list[str]:\n    if current is None:\n        return []\n\n    if isinstance(current, astroid.Module):\n        return [package_name, current.name]\n    elif hasattr(current, \"name\"):\n        return _path(package_name, current.parent) + [current.name]\n    else:\n        return _path(package_name, current.parent)"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._ast_visitor/_stringify_value",
      "name": "_stringify_value",
      "qname": "package_parser.processing.usages._ast_visitor._stringify_value",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._ast_visitor/_stringify_value/value",
          "name": "value",
          "qname": "package_parser.processing.usages._ast_visitor._stringify_value.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _stringify_value(value: astroid.NodeNG):\n    return value.as_string()"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file",
      "name": "__is_relevant_python_file",
      "qname": "package_parser.processing.usages._find_usages.__is_relevant_python_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages.__is_relevant_python_file.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file/source_code",
          "name": "source_code",
          "qname": "package_parser.processing.usages._find_usages.__is_relevant_python_file.source_code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __is_relevant_python_file(package_name: str, source_code: str) -> bool:\n    return package_name in source_code"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch",
      "name": "_find_usages_in_batch",
      "qname": "package_parser.processing.usages._find_usages._find_usages_in_batch",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_batch.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch/python_files",
          "name": "python_files",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_batch.python_files",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _find_usages_in_batch(\n    package_name: str, python_files: list[str]\n) -> UsageCountStore:\n    ast_builder = AstroidBuilder()\n    usage_finder = _UsageFinder(package_name)\n    ast_walker = ASTWalker(usage_finder)\n\n    for python_file in python_files:\n        _find_usages_in_single_file(package_name, python_file, ast_builder, ast_walker)\n\n    return usage_finder.usages"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file",
      "name": "_find_usages_in_single_file",
      "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/python_file",
          "name": "python_file",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.python_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/ast_builder",
          "name": "ast_builder",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.ast_builder",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/ast_walker",
          "name": "ast_walker",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.ast_walker",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _find_usages_in_single_file(\n    package_name: str,\n    python_file: str,\n    ast_builder: AstroidBuilder,\n    ast_walker: ASTWalker,\n) -> None:\n    logging.info(f\"Working on {python_file}\")\n\n    # noinspection PyBroadException\n    try:\n        with open(python_file, \"r\", encoding=\"UTF-8\") as f:\n            source = f.read()\n\n        if __is_relevant_python_file(package_name, source):\n            module = parse_python_code(source, ast_builder=ast_builder)\n            ast_walker.walk(module)\n        else:\n            logging.info(f\"Skipping {python_file} (irrelevant file)\")\n\n    except UnicodeError:\n        logging.warning(f\"Skipping {python_file} (broken encoding)\")\n    except astroid.exceptions.AstroidSyntaxError:\n        logging.warning(f\"Skipping {python_file} (invalid syntax)\")\n    except RecursionError:\n        logging.warning(f\"Skipping {python_file} (infinite recursion)\")\n    except Exception as e:\n        logging.error(f\"Skipping {python_file} (unknown error: {e})\")"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._find_usages/_initializer",
      "name": "_initializer",
      "qname": "package_parser.processing.usages._find_usages._initializer",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/_initializer/log_level",
          "name": "log_level",
          "qname": "package_parser.processing.usages._find_usages._initializer.log_level",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Ignore CTRL+C in the worker process.",
      "docstring": "Ignore CTRL+C in the worker process.",
      "code": "def _initializer(log_level: int) -> None:\n    \"\"\"\n    Ignore CTRL+C in the worker process.\n    \"\"\"\n\n    logging.basicConfig(level=log_level)\n    signal.signal(signal.SIGINT, signal.SIG_IGN)"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._find_usages/_split_into_batches",
      "name": "_split_into_batches",
      "qname": "package_parser.processing.usages._find_usages._split_into_batches",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/_split_into_batches/list_",
          "name": "list_",
          "qname": "package_parser.processing.usages._find_usages._split_into_batches.list_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/_split_into_batches/batch_size",
          "name": "batch_size",
          "qname": "package_parser.processing.usages._find_usages._split_into_batches.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Splits a list into batches of size batch_size.",
      "docstring": "Splits a list into batches of size batch_size.",
      "code": "def _split_into_batches(list_: list[T], batch_size: int) -> list[list[T]]:\n    \"\"\"\n    Splits a list into batches of size batch_size.\n    \"\"\"\n\n    batches = []\n    batch = []\n\n    for python_file in list_:\n        batch.append(python_file)\n        if len(batch) >= batch_size:\n            batches.append(batch)\n            batch = []\n\n    if len(batch) > 0:\n        batches.append(batch)\n\n    return batches"
    },
    {
      "id": "packager-parser/package_parser.processing.usages._find_usages/find_usages",
      "name": "find_usages",
      "qname": "package_parser.processing.usages._find_usages.find_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/find_usages/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages.find_usages.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/find_usages/src_dir",
          "name": "src_dir",
          "qname": "package_parser.processing.usages._find_usages.find_usages.src_dir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/find_usages/n_processes",
          "name": "n_processes",
          "qname": "package_parser.processing.usages._find_usages.find_usages.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages._find_usages/find_usages/batch_size",
          "name": "batch_size",
          "qname": "package_parser.processing.usages._find_usages.find_usages.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def find_usages(\n    package_name: str, src_dir: Path, n_processes: int, batch_size: int\n) -> UsageCountStore:\n    python_files = list_files(src_dir, \".py\")\n    python_file_batches = _split_into_batches(python_files, batch_size)\n\n    aggregated_counts = UsageCountStore()\n\n    for batch_index in range(0, len(python_file_batches), n_processes):\n        python_file_batches_slice = python_file_batches[\n            batch_index : batch_index + n_processes\n        ]\n        n_process_to_spawn = min(n_processes, len(python_file_batches_slice))\n\n        with Pool(\n            processes=n_process_to_spawn,\n            initializer=_initializer,\n            initargs=[logging.root.level],\n        ) as pool:\n            batch_counts = pool.starmap(\n                _find_usages_in_batch,\n                [[package_name, it] for it in python_file_batches_slice],\n            )\n\n            for batch_count in batch_counts:\n                aggregated_counts.merge_other_into_self(batch_count)\n\n    return aggregated_counts"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__eq__",
      "name": "__eq__",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__eq__/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__eq__/other",
          "name": "other",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: object) -> bool:\n        if isinstance(other, UsageCountStore):\n            return (\n                self.class_usages == other.class_usages\n                and self.function_usages == other.function_usages\n                and self.parameter_usages == other.parameter_usages\n                and self.value_usages == other.value_usages\n            )\n\n        return False"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__hash__",
      "name": "__hash__",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__hash__/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(tuple(sorted(self.__dict__.items())))"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Counts how often classes, functions, parameters, and parameter values are used.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self.class_usages: Counter[ClassId] = Counter()\n        self.function_usages: Counter[FunctionId] = Counter()\n        self.parameter_usages: Counter[ParameterId] = Counter()\n        self.value_usages: dict[ParameterId, Counter[StringifiedValue]] = {}"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_class_usages",
      "name": "add_class_usages",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_class_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_class_usages/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_class_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_class_usages/class_id",
          "name": "class_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_class_usages.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_class_usages/count",
          "name": "count",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_class_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the class with the given name by the given count.",
      "docstring": "Increases the usage count of the class with the given name by the given count.",
      "code": "    def add_class_usages(self, class_id: ClassId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the class with the given name by the given count.\"\"\"\n\n        self.class_usages[class_id] += count"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_function_usages",
      "name": "add_function_usages",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_function_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_function_usages/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_function_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_function_usages/function_id",
          "name": "function_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_function_usages.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_function_usages/count",
          "name": "count",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_function_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the function with the given name by the given count.",
      "docstring": "Increases the usage count of the function with the given name by the given count.",
      "code": "    def add_function_usages(self, function_id: FunctionId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the function with the given name by the given count.\"\"\"\n\n        self.function_usages[function_id] += count"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_parameter_usages",
      "name": "add_parameter_usages",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_parameter_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_parameter_usages/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_parameter_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_parameter_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_parameter_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_parameter_usages/count",
          "name": "count",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_parameter_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the parameter with the given name by the given count.",
      "docstring": "Increases the usage count of the parameter with the given name by the given count.",
      "code": "    def add_parameter_usages(self, parameter_id: ParameterId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the parameter with the given name by the given count.\"\"\"\n\n        self.parameter_usages[parameter_id] += count"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_value_usages",
      "name": "add_value_usages",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_value_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_value_usages/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_value_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_value_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_value_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_value_usages/value",
          "name": "value",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_value_usages.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/add_value_usages/count",
          "name": "count",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.add_value_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the given value for the parameter with the given name by the given count.",
      "docstring": "Increases the usage count of the given value for the parameter with the given name by the given count.",
      "code": "    def add_value_usages(\n        self, parameter_id: ParameterId, value: StringifiedValue, count: int = 1\n    ) -> None:\n        \"\"\"Increases the usage count of the given value for the parameter with the given name by the given count.\"\"\"\n\n        self.init_value(parameter_id)\n        self.value_usages[parameter_id][value] += count"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/from_json",
      "name": "from_json",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/from_json/json",
          "name": "json",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Creates an instance of this class from a dictionary.",
      "docstring": "Creates an instance of this class from a dictionary.",
      "code": "    @staticmethod\n    def from_json(json: Any) -> UsageCountStore:\n        \"\"\"Creates an instance of this class from a dictionary.\"\"\"\n\n        result = UsageCountStore()\n\n        # Revive class counts\n        class_counts = json[\"class_counts\"]\n        for class_id, count in class_counts.items():\n            result.add_class_usages(class_id, count)\n\n        # Revive function counts\n        function_counts = json[\"function_counts\"]\n        for function_id, count in function_counts.items():\n            result.add_function_usages(function_id, count)\n\n        # Revive parameter counts\n        parameter_counts = json[\"parameter_counts\"]\n        for parameter_id, count in parameter_counts.items():\n            result.add_parameter_usages(parameter_id, count)\n\n        # Revive value counts\n        value_counts = json[\"value_counts\"]\n        for parameter_id, values in value_counts.items():\n            for value, count in values.items():\n                result.add_value_usages(parameter_id, value, count)\n\n        return result"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/init_value",
      "name": "init_value",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.init_value",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/init_value/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.init_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/init_value/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.init_value.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Ensures the dictionary for the value counts has the given parameter name as a key.",
      "docstring": "Ensures the dictionary for the value counts has the given parameter name as a key.",
      "code": "    def init_value(self, parameter_id: ParameterId) -> None:\n        \"\"\"Ensures the dictionary for the value counts has the given parameter name as a key.\"\"\"\n\n        if parameter_id not in self.value_usages:\n            self.value_usages[parameter_id] = Counter()"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/merge_other_into_self",
      "name": "merge_other_into_self",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.merge_other_into_self",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/merge_other_into_self/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.merge_other_into_self.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/merge_other_into_self/other_usage_store",
          "name": "other_usage_store",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.merge_other_into_self.other_usage_store",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Merges the other usage store into this one **in-place** and returns this store.\n\n:param other_usage_store: The usage store to merge into this one.\n:return: This usage store.",
      "docstring": "Merges the other usage store into this one **in-place** and returns this store.\n\n:param other_usage_store: The usage store to merge into this one.\n:return: This usage store.",
      "code": "    def merge_other_into_self(\n        self, other_usage_store: UsageCountStore\n    ) -> UsageCountStore:\n        \"\"\"\n        Merges the other usage store into this one **in-place** and returns this store.\n\n        :param other_usage_store: The usage store to merge into this one.\n        :return: This usage store.\n        \"\"\"\n\n        # Merge class usages\n        self.class_usages += other_usage_store.class_usages\n\n        # Merge function usages\n        self.function_usages += other_usage_store.function_usages\n\n        # Merge parameter usages\n        self.parameter_usages += other_usage_store.parameter_usages\n\n        # Merge value usages\n        for parameter_id, value_usages in other_usage_store.value_usages.items():\n            self.init_value(parameter_id)\n            self.value_usages[parameter_id] += value_usages\n\n        return self"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/most_common_parameter_values",
      "name": "most_common_parameter_values",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.most_common_parameter_values",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/most_common_parameter_values/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.most_common_parameter_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/most_common_parameter_values/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.most_common_parameter_values.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns all values that have been set for the parameter with the given name sorted by their count in descending order.",
      "docstring": "Returns all values that have been set for the parameter with the given name sorted by their count in descending order.",
      "code": "    def most_common_parameter_values(self, parameter_id: ParameterId) -> list[str]:\n        \"\"\"Returns all values that have been set for the parameter with the given name sorted by their count in descending order.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return [\n                value\n                for value, count in self.value_usages[parameter_id].most_common()\n                if count > 0\n            ]\n\n        return []"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_class_usages",
      "name": "n_class_usages",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_class_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_class_usages/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_class_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_class_usages/class_id",
          "name": "class_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_class_usages.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the class is used, i.e. how often any of its methods are called.",
      "docstring": "Returns how often the class is used, i.e. how often any of its methods are called.",
      "code": "    def n_class_usages(self, class_id: ClassId) -> int:\n        \"\"\"Returns how often the class is used, i.e. how often any of its methods are called.\"\"\"\n\n        return self.class_usages[class_id]"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_function_usages",
      "name": "n_function_usages",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_function_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_function_usages/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_function_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_function_usages/function_id",
          "name": "function_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_function_usages.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the function is called.",
      "docstring": "Returns how often the function is called.",
      "code": "    def n_function_usages(self, function_id: FunctionId) -> int:\n        \"\"\"Returns how often the function is called.\"\"\"\n\n        return self.function_usages[function_id]"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_parameter_usages",
      "name": "n_parameter_usages",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_parameter_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_parameter_usages/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_parameter_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_parameter_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_parameter_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the parameter is set.",
      "docstring": "Returns how often the parameter is set.",
      "code": "    def n_parameter_usages(self, parameter_id: ParameterId) -> int:\n        \"\"\"Returns how often the parameter is set.\"\"\"\n\n        return self.parameter_usages[parameter_id]"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_value_usages",
      "name": "n_value_usages",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_value_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_value_usages/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_value_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_value_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_value_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/n_value_usages/value",
          "name": "value",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.n_value_usages.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the parameter with the given name is set to the given value.",
      "docstring": "Returns how often the parameter with the given name is set to the given value.",
      "code": "    def n_value_usages(self, parameter_id: ParameterId, value: str) -> int:\n        \"\"\"Returns how often the parameter with the given name is set to the given value.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return self.value_usages[parameter_id][value]\n\n        return 0"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_class",
      "name": "remove_class",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.remove_class",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_class/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.remove_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_class/class_id",
          "name": "class_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.remove_class.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Removes all usages of classes with the given name and usages of their methods.",
      "docstring": "Removes all usages of classes with the given name and usages of their methods.",
      "code": "    def remove_class(self, class_id: ClassId) -> None:\n        \"\"\"Removes all usages of classes with the given name and usages of their methods.\"\"\"\n\n        if class_id in self.class_usages:\n            del self.class_usages[class_id]\n\n        for function_id in list(self.function_usages.keys()):\n            if function_id.startswith(class_id):\n                self.remove_function(function_id)"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_function",
      "name": "remove_function",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.remove_function",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_function/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.remove_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_function/function_id",
          "name": "function_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.remove_function.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Removes all usages of functions with the given name and usages of their parameters.",
      "docstring": "Removes all usages of functions with the given name and usages of their parameters.",
      "code": "    def remove_function(self, function_id: FunctionId) -> None:\n        \"\"\"Removes all usages of functions with the given name and usages of their parameters.\"\"\"\n\n        if function_id in self.function_usages:\n            del self.function_usages[function_id]\n\n        for parameter_id in list(self.parameter_usages.keys()):\n            if parameter_id.startswith(function_id):\n                self.remove_parameter(parameter_id)"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_parameter",
      "name": "remove_parameter",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.remove_parameter",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_parameter/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.remove_parameter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/remove_parameter/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.remove_parameter.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Removes all parameter and value usages of parameters with the given name.",
      "docstring": "Removes all parameter and value usages of parameters with the given name.",
      "code": "    def remove_parameter(self, parameter_id: ParameterId) -> None:\n        \"\"\"Removes all parameter and value usages of parameters with the given name.\"\"\"\n\n        if parameter_id in self.parameter_usages:\n            del self.parameter_usages[parameter_id]\n\n        if parameter_id in self.value_usages:\n            del self.value_usages[parameter_id]"
    },
    {
      "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/to_json",
      "name": "to_json",
      "qname": "package_parser.processing.usages.model._usages.UsageCountStore.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.processing.usages.model._usages/UsageCountStore/to_json/self",
          "name": "self",
          "qname": "package_parser.processing.usages.model._usages.UsageCountStore.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Converts this class to a dictionary, which can later be serialized as JSON.",
      "docstring": "Converts this class to a dictionary, which can later be serialized as JSON.",
      "code": "    def to_json(self) -> Any:\n        \"\"\"Converts this class to a dictionary, which can later be serialized as JSON.\"\"\"\n\n        return {\n            \"schemaVersion\": USAGES_SCHEMA_VERSION,\n            \"class_counts\": {\n                class_id: usage_count\n                for class_id, usage_count in self.class_usages.most_common()\n            },\n            \"function_counts\": {\n                function_id: usage_count\n                for function_id, usage_count in self.function_usages.most_common()\n            },\n            \"parameter_counts\": {\n                parameter_id: usage_count\n                for parameter_id, usage_count in self.parameter_usages.most_common()\n            },\n            \"value_counts\": {\n                parameter_id: {\n                    value: usage_count for value, usage_count in values.most_common()\n                }\n                for parameter_id, values in self.value_usages.items()\n            },\n        }"
    },
    {
      "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__enter",
      "name": "__enter",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__enter/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__enter/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[0]\n        if method is not None:\n            method(node)"
    },
    {
      "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks",
      "name": "__get_callbacks",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __get_callbacks(self, node: astroid.NodeNG) -> _EnterAndLeaveFunctions:\n        klass = node.__class__\n        methods = self._cache.get(klass)\n\n        if methods is None:\n            handler = self._handler\n            class_name = klass.__name__.lower()\n            enter_method = getattr(\n                handler, f\"enter_{class_name}\", getattr(handler, \"enter_default\", None)\n            )\n            leave_method = getattr(\n                handler, f\"leave_{class_name}\", getattr(handler, \"leave_default\", None)\n            )\n            self._cache[klass] = (enter_method, leave_method)\n        else:\n            enter_method, leave_method = methods\n\n        return enter_method, leave_method"
    },
    {
      "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__init__",
      "name": "__init__",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__init__/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__init__/handler",
          "name": "handler",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__.handler",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "docstring": "",
      "code": "    def __init__(self, handler: Any) -> None:\n        self._handler = handler\n        self._cache: dict[Type, _EnterAndLeaveFunctions] = {}"
    },
    {
      "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__leave",
      "name": "__leave",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__leave/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__leave/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __leave(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[1]\n        if method is not None:\n            method(node)"
    },
    {
      "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__walk",
      "name": "__walk",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/visited_nodes",
          "name": "visited_nodes",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.visited_nodes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __walk(self, node: astroid.NodeNG, visited_nodes: set[astroid.NodeNG]) -> None:\n        if node in visited_nodes:\n            raise AssertionError(\"Node visited twice\")\n        visited_nodes.add(node)\n\n        self.__enter(node)\n        for child_node in node.get_children():\n            self.__walk(child_node, visited_nodes)\n        self.__leave(node)"
    },
    {
      "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/walk",
      "name": "walk",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.walk",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/walk/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.walk.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._ASTWalker/ASTWalker/walk/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.walk.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def walk(self, node: astroid.NodeNG) -> None:\n        self.__walk(node, set())"
    },
    {
      "id": "packager-parser/package_parser.utils._files/__read_lines",
      "name": "__read_lines",
      "qname": "package_parser.utils._files.__read_lines",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._files/__read_lines/f",
          "name": "f",
          "qname": "package_parser.utils._files.__read_lines.f",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __read_lines(f: TextIO) -> list[str]:\n    return [it.strip() for it in f.readlines() if it != \"\"]"
    },
    {
      "id": "packager-parser/package_parser.utils._files/__write_lines",
      "name": "__write_lines",
      "qname": "package_parser.utils._files.__write_lines",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._files/__write_lines/f",
          "name": "f",
          "qname": "package_parser.utils._files.__write_lines.f",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._files/__write_lines/lines",
          "name": "lines",
          "qname": "package_parser.utils._files.__write_lines.lines",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __write_lines(f: TextIO, lines: list[str]) -> None:\n    f.writelines(f\"{it}\\n\" for it in lines)"
    },
    {
      "id": "packager-parser/package_parser.utils._files/ensure_file_exists",
      "name": "ensure_file_exists",
      "qname": "package_parser.utils._files.ensure_file_exists",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._files/ensure_file_exists/file",
          "name": "file",
          "qname": "package_parser.utils._files.ensure_file_exists.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Creates a file and all parent directories if they don't exist already.\n\n:param file: The file path.",
      "docstring": "Creates a file and all parent directories if they don't exist already.\n\n:param file: The file path.",
      "code": "def ensure_file_exists(file: Path) -> None:\n    \"\"\"\n    Creates a file and all parent directories if they don't exist already.\n\n    :param file: The file path.\n    \"\"\"\n\n    file.parent.mkdir(parents=True, exist_ok=True)\n    file.touch(exist_ok=True)"
    },
    {
      "id": "packager-parser/package_parser.utils._files/initialize_and_read_exclude_file",
      "name": "initialize_and_read_exclude_file",
      "qname": "package_parser.utils._files.initialize_and_read_exclude_file",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._files/initialize_and_read_exclude_file/exclude_file",
          "name": "exclude_file",
          "qname": "package_parser.utils._files.initialize_and_read_exclude_file.exclude_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def initialize_and_read_exclude_file(exclude_file: Path) -> list[str]:\n    exclude_file.parent.mkdir(parents=True, exist_ok=True)\n    try:\n        with exclude_file.open(\"r\") as f:\n            return __read_lines(f)\n    except FileNotFoundError:\n        return []"
    },
    {
      "id": "packager-parser/package_parser.utils._files/list_files",
      "name": "list_files",
      "qname": "package_parser.utils._files.list_files",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._files/list_files/root_dir",
          "name": "root_dir",
          "qname": "package_parser.utils._files.list_files.root_dir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._files/list_files/extension",
          "name": "extension",
          "qname": "package_parser.utils._files.list_files.extension",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": ":param root_dir: The directory containing the files.\n:param extension: The extension the files should have.\n:return: A list with absolute paths to the files.",
      "docstring": ":param root_dir: The directory containing the files.\n:param extension: The extension the files should have.\n:return: A list with absolute paths to the files.",
      "code": "def list_files(root_dir: Path, extension: str = \"\") -> list[str]:\n    \"\"\"\n    :param root_dir: The directory containing the files.\n    :param extension: The extension the files should have.\n    :return: A list with absolute paths to the files.\n    \"\"\"\n\n    result: list[str] = []\n\n    for root, _, files in os.walk(root_dir):\n        for filename in files:\n            if filename.endswith(extension):\n                result.append(str(os.path.join(root, filename)))\n\n    return result"
    },
    {
      "id": "packager-parser/package_parser.utils._names/declaration_qname_to_name",
      "name": "declaration_qname_to_name",
      "qname": "package_parser.utils._names.declaration_qname_to_name",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._names/declaration_qname_to_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.utils._names.declaration_qname_to_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def declaration_qname_to_name(qualified_name: str) -> str:\n    return qualified_name.split(\".\")[-1]"
    },
    {
      "id": "packager-parser/package_parser.utils._names/parent_id",
      "name": "parent_id",
      "qname": "package_parser.utils._names.parent_id",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._names/parent_id/id_",
          "name": "id_",
          "qname": "package_parser.utils._names.parent_id.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def parent_id(id_: str) -> str:\n    return \"/\".join(id_.split(\"/\")[:-1])"
    },
    {
      "id": "packager-parser/package_parser.utils._names/parent_qualified_name",
      "name": "parent_qualified_name",
      "qname": "package_parser.utils._names.parent_qualified_name",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._names/parent_qualified_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.utils._names.parent_qualified_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def parent_qualified_name(qualified_name: str) -> str:\n    return \".\".join(qualified_name.split(\".\")[:-1])"
    },
    {
      "id": "packager-parser/package_parser.utils._parsing/parse_python_code",
      "name": "parse_python_code",
      "qname": "package_parser.utils._parsing.parse_python_code",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._parsing/parse_python_code/code",
          "name": "code",
          "qname": "package_parser.utils._parsing.parse_python_code.code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._parsing/parse_python_code/module_name",
          "name": "module_name",
          "qname": "package_parser.utils._parsing.parse_python_code.module_name",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._parsing/parse_python_code/path",
          "name": "path",
          "qname": "package_parser.utils._parsing.parse_python_code.path",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._parsing/parse_python_code/ast_builder",
          "name": "ast_builder",
          "qname": "package_parser.utils._parsing.parse_python_code.ast_builder",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Parses a source string in order to obtain an astroid AST from it\n\n:param str code: The code for the module.\n:param str module_name: The name for the module, if any\n:param str path: The path for the module\n:param ast_builder: The Astroid builder to use",
      "docstring": "Parses a source string in order to obtain an astroid AST from it\n\n:param str code: The code for the module.\n:param str module_name: The name for the module, if any\n:param str path: The path for the module\n:param ast_builder: The Astroid builder to use",
      "code": "def parse_python_code(\n    code: str,\n    module_name: str = \"\",\n    path: str = None,\n    ast_builder: AstroidBuilder = None,\n) -> astroid.Module:\n    \"\"\"Parses a source string in order to obtain an astroid AST from it\n\n    :param str code: The code for the module.\n    :param str module_name: The name for the module, if any\n    :param str path: The path for the module\n    :param ast_builder: The Astroid builder to use\n    \"\"\"\n\n    if ast_builder is None:\n        ast_builder = AstroidBuilder()\n\n    code = textwrap.dedent(code)\n    return ast_builder.string_build(code, modname=module_name, path=path)"
    },
    {
      "id": "packager-parser/package_parser.utils._strings/pluralize",
      "name": "pluralize",
      "qname": "package_parser.utils._strings.pluralize",
      "decorators": [],
      "parameters": [
        {
          "id": "packager-parser/package_parser.utils._strings/pluralize/count",
          "name": "count",
          "qname": "package_parser.utils._strings.pluralize.count",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "packager-parser/package_parser.utils._strings/pluralize/word",
          "name": "word",
          "qname": "package_parser.utils._strings.pluralize.word",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def pluralize(count: int, word: str) -> str:\n    if count == 1:\n        return f\"{count} {word}\"\n    else:\n        return f\"{count} {word}s\""
    }
  ]
}