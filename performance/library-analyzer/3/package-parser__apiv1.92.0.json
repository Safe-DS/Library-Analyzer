{
  "schemaVersion": 1,
  "distribution": "",
  "package": "package-parser",
  "version": "",
  "modules": [],
  "classes": [
    {
      "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder",
      "name": "CustomEncoder",
      "qname": "package_parser.cli._json_encoder.CustomEncoder",
      "decorators": [],
      "superclasses": [
        "JSONEncoder"
      ],
      "methods": [
        "package-parser/package_parser.cli._json_encoder/CustomEncoder/default"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class CustomEncoder(JSONEncoder):\n    def default(self, o: Any) -> Any:\n        if isinstance(o, set):\n            return list(o)\n        return super().default(o)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping",
      "name": "APIMapping",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__",
        "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements",
        "package-parser/package_parser.processing.migration._api_mapping/APIMapping/map_api",
        "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_similar_mappings",
        "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class APIMapping:\n    threshold_of_similarity_between_mappings: float\n    threshold_of_similarity_for_creation_of_mappings: float\n    threshold_of_merging_mappings: float\n    apiv1: API\n    apiv2: API\n    differ: AbstractDiffer\n\n    def __init__(\n        self,\n        apiv1: API,\n        apiv2: API,\n        differ: AbstractDiffer,\n        threshold_of_similarity_for_creation_of_mappings: float = 0.5,\n        threshold_of_similarity_between_mappings: float = 0.05,\n        threshold_of_merging_mappings: float = 0.3,\n    ) -> None:\n        self.apiv1 = apiv1\n        self.apiv2 = apiv2\n        self.differ = differ\n        self.threshold_of_similarity_for_creation_of_mappings = (\n            threshold_of_similarity_for_creation_of_mappings\n        )\n        self.threshold_of_similarity_between_mappings = (\n            threshold_of_similarity_between_mappings\n        )\n        self.threshold_of_merging_mappings = threshold_of_merging_mappings\n\n    def _get_mappings_for_api_elements(\n        self,\n        api_elementv1_list: List[API_ELEMENTS],\n        api_elementv2_list: List[API_ELEMENTS],\n        compute_similarity: Callable[[API_ELEMENTS, API_ELEMENTS], float],\n    ) -> list[Mapping]:\n        element_mappings: list[Mapping] = []\n        for api_elementv1 in api_elementv1_list:\n            mapping_for_api_elementv1: list[Mapping] = []\n            for api_elementv2 in api_elementv2_list:\n                similarity = compute_similarity(api_elementv1, api_elementv2)\n                if similarity >= self.threshold_of_similarity_for_creation_of_mappings:\n                    mapping_for_api_elementv1.append(\n                        OneToOneMapping(similarity, api_elementv1, api_elementv2)\n                    )\n            mapping_for_api_elementv1.sort(key=Mapping.get_similarity, reverse=True)\n            new_mapping = self._merge_similar_mappings(mapping_for_api_elementv1)\n            if new_mapping is not None:\n                self._merge_mappings_with_same_elements(new_mapping, element_mappings)\n        return element_mappings\n\n    def map_api(self) -> List[Mapping]:\n        mappings: List[Mapping] = []\n        related_mappings = self.differ.get_related_mappings()\n        if related_mappings is not None:\n            for mapping in related_mappings:\n                new_mapping = None\n                if isinstance(\n                    mapping.get_apiv1_elements()[0], Attribute\n                ) and isinstance(mapping.get_apiv2_elements()[0], Attribute):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        self.differ.compute_attribute_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Class) and isinstance(\n                    mapping.get_apiv2_elements()[0], Class\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Class)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Class)\n                        ],\n                        self.differ.compute_class_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Function\n                ) and isinstance(mapping.get_apiv2_elements()[0], Function):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Function)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Function)\n                        ],\n                        self.differ.compute_function_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Parameter\n                ) and isinstance(mapping.get_apiv2_elements()[0], Parameter):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        self.differ.compute_parameter_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Result) and isinstance(\n                    mapping.get_apiv2_elements()[0], Result\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Result)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Result)\n                        ],\n                        self.differ.compute_result_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                if new_mapping is not None and len(new_mapping) > 0:\n                    self.differ.notify_new_mapping(new_mapping)\n        else:\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.classes.values()),\n                    list(self.apiv2.classes.values()),\n                    self.differ.compute_class_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.functions.values()),\n                    list(self.apiv2.functions.values()),\n                    self.differ.compute_function_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.parameters().values()),\n                    list(self.apiv2.parameters().values()),\n                    self.differ.compute_parameter_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        attribute\n                        for class_ in self.apiv1.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    [\n                        attribute\n                        for class_ in self.apiv2.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    self.differ.compute_attribute_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        result\n                        for function in self.apiv1.functions.values()\n                        for result in function.results\n                    ],\n                    [\n                        result\n                        for function in self.apiv2.functions.values()\n                        for result in function.results\n                    ],\n                    self.differ.compute_result_similarity,\n                )\n            )\n        mappings.extend(self.differ.get_additional_mappings())\n        mappings.sort(key=Mapping.get_similarity, reverse=True)\n        return mappings\n\n    def _merge_similar_mappings(self, mappings: List[Mapping]) -> Optional[Mapping]:\n        \"\"\"\n        Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\n        from this apiv1 element to apiv2 elements by merging the first and second elements recursively,\n        if the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n        :param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n        :return: the first element of the sorted list that could be a result of merged similar mappings\n        \"\"\"\n        if len(mappings) == 0:\n            return None\n        if len(mappings) == 1:\n            return mappings[0]\n        while (len(mappings) > 1) and (\n            (mappings[0].similarity - mappings[1].similarity)\n            < self.threshold_of_similarity_between_mappings\n        ):\n            mappings[0] = merge_mappings(mappings[0], mappings[1])\n            mappings.pop(1)\n        return mappings[0]\n\n    def _merge_mappings_with_same_elements(\n        self, mapping_to_be_appended: Mapping, mappings: list[Mapping]\n    ) -> None:\n        \"\"\"\n        This method prevents that an element in a mapping appears multiple times in a list of mappings\n        by merging the affected mappings and include the result in the list. If there is no such element,\n        the mapping will be included without any merge.\n\n        :param mapping_to_be_appended: the mapping that should be included in mappings\n        :param mappings: the list, in which mapping_to_be_appended should be appended\n        \"\"\"\n        duplicated: list[Mapping] = []\n        for mapping in mappings:\n            duplicated_element = False\n            for element in mapping.get_apiv2_elements():\n                for element_2 in mapping_to_be_appended.get_apiv2_elements():\n                    if element == element_2:\n                        duplicated_element = True\n                        break\n            if duplicated_element:\n                duplicated.append(mapping)\n\n        if len(duplicated) == 0:\n            mappings.append(mapping_to_be_appended)\n            return\n\n        for conflicted_mapping in duplicated:\n            mapping_to_be_appended = merge_mappings(\n                mapping_to_be_appended, conflicted_mapping\n            )\n            mappings.remove(conflicted_mapping)\n\n        mappings.append(mapping_to_be_appended)",
      "instance_attributes": [
        {
          "name": "apiv1",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "apiv2",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "differ",
          "types": {
            "kind": "NamedType",
            "name": "AbstractDiffer"
          }
        },
        {
          "name": "threshold_of_similarity_for_creation_of_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "threshold_of_similarity_between_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "threshold_of_merging_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration",
      "name": "Migration",
      "qname": "package_parser.processing.migration._migrate.Migration",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.processing.migration._migrate/Migration/__post_init__",
        "package-parser/package_parser.processing.migration._migrate/Migration/_get_mapping_from_annotation",
        "package-parser/package_parser.processing.migration._migrate/Migration/migrate_annotations",
        "package-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity",
        "package-parser/package_parser.processing.migration._migrate/Migration/_get_mappings_for_table",
        "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table",
        "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string",
        "package-parser/package_parser.processing.migration._migrate/Migration/print",
        "package-parser/package_parser.processing.migration._migrate/Migration/_handle_duplicates"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Migration:\n    annotationsv1: AnnotationStore\n    mappings: list[Mapping]\n    reliable_similarity: float = 0.9\n    unsure_similarity: float = 0.8\n    migrated_annotation_store: AnnotationStore = field(init=False)\n    unsure_migrated_annotation_store: AnnotationStore = field(init=False)\n\n    def __post_init__(self) -> None:\n        self.migrated_annotation_store = AnnotationStore()\n        self.unsure_migrated_annotation_store = AnnotationStore()\n\n    def _get_mapping_from_annotation(\n        self, annotation: AbstractAnnotation\n    ) -> Optional[Mapping]:\n        for mapping in self.mappings:\n            for element in mapping.get_apiv1_elements():\n                if (\n                    not isinstance(element, (Attribute, Result))\n                    and element.id == annotation.target\n                ):\n                    return mapping\n        return None\n\n    def migrate_annotations(self) -> None:\n        for boundary_annotation in self.annotationsv1.boundaryAnnotations:\n            mapping = self._get_mapping_from_annotation(boundary_annotation)\n            if mapping is not None:\n                for annotation in migrate_boundary_annotation(\n                    boundary_annotation, mapping\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for called_after_annotation in self.annotationsv1.calledAfterAnnotations:\n            mapping = self._get_mapping_from_annotation(called_after_annotation)\n            if mapping is not None:\n                for annotation in migrate_called_after_annotation(\n                    called_after_annotation, mapping, self.mappings\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for description_annotation in self.annotationsv1.descriptionAnnotations:\n            mapping = self._get_mapping_from_annotation(description_annotation)\n            if mapping is not None:\n                for annotation in migrate_description_annotation(\n                    description_annotation, mapping\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for enum_annotation in self.annotationsv1.enumAnnotations:\n            mapping = self._get_mapping_from_annotation(enum_annotation)\n            if mapping is not None:\n                for annotation in migrate_enum_annotation(enum_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for expert_annotation in self.annotationsv1.expertAnnotations:\n            mapping = self._get_mapping_from_annotation(expert_annotation)\n            if mapping is not None:\n                for annotation in migrate_expert_annotation(expert_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for group_annotation in self.annotationsv1.groupAnnotations:\n            mapping = self._get_mapping_from_annotation(group_annotation)\n            if mapping is not None:\n                for annotation in migrate_group_annotation(\n                    group_annotation, mapping, self.mappings\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for move_annotation in self.annotationsv1.moveAnnotations:\n            mapping = self._get_mapping_from_annotation(move_annotation)\n            if mapping is not None:\n                for annotation in migrate_move_annotation(move_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for rename_annotation in self.annotationsv1.renameAnnotations:\n            mapping = self._get_mapping_from_annotation(rename_annotation)\n            if mapping is not None:\n                for annotation in migrate_rename_annotation(rename_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for remove_annotation in self.annotationsv1.removeAnnotations:\n            mapping = self._get_mapping_from_annotation(remove_annotation)\n            if mapping is not None:\n                for annotation in migrate_remove_annotation(remove_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for todo_annotation in self.annotationsv1.todoAnnotations:\n            mapping = self._get_mapping_from_annotation(todo_annotation)\n            if mapping is not None:\n                for annotation in migrate_todo_annotation(todo_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for value_annotation in self.annotationsv1.valueAnnotations:\n            mapping = self._get_mapping_from_annotation(value_annotation)\n            if mapping is not None:\n                for annotation in migrate_value_annotation(value_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n        self._handle_duplicates()\n\n    def add_annotations_based_on_similarity(\n        self, annotation: AbstractAnnotation, similarity: float\n    ) -> None:\n        if similarity >= self.reliable_similarity:\n            self.migrated_annotation_store.add_annotation(annotation)\n        elif similarity >= self.unsure_similarity:\n            annotation.reviewResult = EnumReviewResult.UNSURE\n            self.migrated_annotation_store.add_annotation(annotation)\n        else:\n            self.unsure_migrated_annotation_store.add_annotation(annotation)\n\n    def _get_mappings_for_table(self) -> list[str]:\n        table_rows: list[str] = []\n        for mapping in self.mappings:\n\n            def print_api_element(\n                api_element: Union[Attribute, Class, Function, Parameter, Result]\n            ) -> str:\n                if isinstance(api_element, Result):\n                    return api_element.name\n                if isinstance(api_element, Attribute):\n                    return str(api_element.class_id) + \"/\" + api_element.name\n                return api_element.id\n\n            apiv1_elements = \", \".join(\n                [\n                    print_api_element(api_element)\n                    for api_element in mapping.get_apiv1_elements()\n                ]\n            )\n            apiv2_elements = \", \".join(\n                [\n                    print_api_element(api_element)\n                    for api_element in mapping.get_apiv2_elements()\n                ]\n            )\n            apiv1_elements = \"`\" + apiv1_elements + \"`\"\n            apiv2_elements = \"`\" + apiv2_elements + \"`\"\n            table_rows.append(\n                f\"{mapping.similarity:.4}|{apiv1_elements}|{apiv2_elements}|\"\n            )\n        return table_rows\n\n    def _get_not_mapped_api_elements_for_table(\n        self, apiv1: API, apiv2: API\n    ) -> list[str]:\n        not_mapped_api_elements: list[str] = []\n        not_mapped_apiv1_elements = self._get_not_mapped_api_elements_as_string(apiv1)\n        for element_id in not_mapped_apiv1_elements:\n            not_mapped_api_elements.append(f\"-|`{element_id}`||\")\n        not_mapped_apiv2_elements = self._get_not_mapped_api_elements_as_string(\n            apiv2, print_for_apiv2=True\n        )\n        for element_id in not_mapped_apiv2_elements:\n            not_mapped_api_elements.append(f\"-||`{element_id}`|\")\n        return not_mapped_api_elements\n\n    def _get_not_mapped_api_elements_as_string(\n        self, api: API, print_for_apiv2: bool = False\n    ) -> list[str]:\n        not_mapped_api_elements: list[str] = []\n\n        def is_included(\n            api_element: Union[Attribute, Class, Function, Parameter, Result]\n        ) -> bool:\n            if not print_for_apiv2:\n                for mapping in self.mappings:\n                    for element in mapping.get_apiv1_elements():\n                        if isinstance(api_element, Attribute) and isinstance(\n                            element, Attribute\n                        ):\n                            if element.name == api_element.name and isinstance(\n                                element.types, type(api_element.types)\n                            ):\n                                return True\n                        if isinstance(api_element, Result) and isinstance(\n                            element, Result\n                        ):\n                            if (\n                                element.name == api_element.name\n                                and element.docstring == api_element.docstring\n                            ):\n                                return True\n                        if not isinstance(\n                            api_element, (Attribute, Result)\n                        ) and not isinstance(element, (Attribute, Result)):\n                            if element.id == api_element.id:\n                                return True\n                return False\n            for mapping in self.mappings:\n                for element in mapping.get_apiv2_elements():\n                    if isinstance(api_element, Attribute) and isinstance(\n                        element, Attribute\n                    ):\n                        if element.name == api_element.name and isinstance(\n                            element.types, type(api_element.types)\n                        ):\n                            return True\n                    if isinstance(api_element, Result) and isinstance(element, Result):\n                        if (\n                            element.name == api_element.name\n                            and element.docstring == api_element.docstring\n                        ):\n                            return True\n                    if not isinstance(\n                        api_element, (Attribute, Result)\n                    ) and not isinstance(element, (Attribute, Result)):\n                        if element.id == api_element.id:\n                            return True\n            return False\n\n        for class_ in api.classes.values():\n            if not is_included(class_):\n                not_mapped_api_elements.append(class_.id)\n        for function in api.functions.values():\n            if not is_included(function):\n                not_mapped_api_elements.append(function.id)\n        for parameter in api.parameters().values():\n            if not is_included(parameter):\n                not_mapped_api_elements.append(parameter.id)\n        for attribute, class_ in [\n            (attribute, class_)\n            for class_ in api.classes.values()\n            for attribute in class_.instance_attributes\n        ]:\n            if not is_included(attribute):\n                not_mapped_api_elements.append(class_.id + \"/\" + attribute.name)\n        for result, function in [\n            (result, function)\n            for function in api.functions.values()\n            for result in function.results\n        ]:\n            if not is_included(result):\n                not_mapped_api_elements.append(function.id + \"/\" + result.name)\n        return not_mapped_api_elements\n\n    def print(self, apiv1: API, apiv2: API) -> None:\n        print(\n            \"**Similarity**|**APIV1**|**APIV2**|**comment**\\n:-----:|:-----:|:-----:|:----:|\"\n        )\n        table_body = self._get_mappings_for_table()\n        table_body.extend(self._get_not_mapped_api_elements_for_table(apiv1, apiv2))\n        table_body.sort(\n            key=lambda row: max(len(cell.split(\"/\")) for cell in row.split(\"|\")[:-1])\n        )\n        print(\"\\n\".join(table_body))\n\n    def _handle_duplicates(self) -> None:\n        for annotation_type in [\n            \"boundaryAnnotations\",\n            \"calledAfterAnnotations\",\n            \"descriptionAnnotations\",\n            \"enumAnnotations\",\n            \"expertAnnotations\",\n            \"groupAnnotations\",\n            \"moveAnnotations\",\n            \"pureAnnotations\",\n            \"removeAnnotations\",\n            \"renameAnnotations\",\n            \"todoAnnotations\",\n            \"valueAnnotations\",\n        ]:\n            migrated_annotations = [\n                annotation\n                for annotation_store in [\n                    self.migrated_annotation_store,\n                    self.unsure_migrated_annotation_store,\n                ]\n                for annotation in getattr(annotation_store, annotation_type)\n            ]\n            duplicates_dict: dict[str, list[AbstractAnnotation]] = {}\n            for duplicated_annotations in migrated_annotations:\n                if duplicated_annotations.target in duplicates_dict:\n                    duplicates_dict[duplicated_annotations.target].append(\n                        duplicated_annotations\n                    )\n                    continue\n                for annotation in migrated_annotations:\n                    if (\n                        duplicated_annotations is annotation\n                        or annotation.target in duplicates_dict\n                    ):\n                        continue\n                    if (\n                        isinstance(annotation, type(duplicated_annotations))\n                        and annotation.target == duplicated_annotations.target\n                    ):\n                        duplicates = duplicates_dict.get(annotation.target, [])\n                        duplicates.append(annotation)\n                        duplicates.append(duplicated_annotations)\n                        duplicates_dict[duplicated_annotations.target] = duplicates\n                        break\n\n            for duplicates in duplicates_dict.values():\n                if len(duplicates) > 1:\n                    duplicates = sorted(\n                        duplicates, key=lambda annotation: annotation.reviewResult.name\n                    )\n                    different_values = set()\n                    first_annotation_and_value: Optional[\n                        tuple[AbstractAnnotation, str]\n                    ] = None\n                    for annotation in duplicates:\n                        annotation_dict = annotation.to_json()\n                        for key in [\n                            \"target\",\n                            \"authors\",\n                            \"reviewers\",\n                            \"comment\",\n                            \"reviewResult\",\n                        ]:\n                            del annotation_dict[key]\n                        annotation_value = str(annotation_dict)\n                        if first_annotation_and_value is None:\n                            first_annotation_and_value = annotation, annotation_value\n                        different_values.add(annotation_value)\n\n                    if first_annotation_and_value is not None:\n                        first_annotation, first_value = first_annotation_and_value\n                        if len(different_values) > 1:\n                            different_values.remove(first_value)\n                            comment = (\n                                \"Conflicting Attribute during migration: \"\n                                + \", \".join(sorted(different_values))\n                            )\n                            first_annotation.comment = (\n                                \"\\n\".join([comment, first_annotation.comment])\n                                if len(first_annotation.comment) > 0\n                                else comment\n                            )\n                            first_annotation.reviewResult = EnumReviewResult.UNSURE\n                        for annotation_store in [\n                            self.migrated_annotation_store,\n                            self.unsure_migrated_annotation_store,\n                        ]:\n                            for annotation in duplicates:\n                                if annotation is first_annotation:\n                                    continue\n                                annotations: list[AbstractAnnotation] = getattr(\n                                    annotation_store, annotation_type\n                                )\n                                if annotation in annotations:\n                                    annotations.remove(annotation)",
      "instance_attributes": [
        {
          "name": "migrated_annotation_store",
          "types": {
            "kind": "NamedType",
            "name": "AnnotationStore"
          }
        },
        {
          "name": "unsure_migrated_annotation_store",
          "types": {
            "kind": "NamedType",
            "name": "AnnotationStore"
          }
        },
        {
          "name": "annotationsv1",
          "types": {
            "kind": "NamedType",
            "name": "AnnotationStore"
          }
        },
        {
          "name": "mappings",
          "types": null
        },
        {
          "name": "reliable_similarity",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "unsure_similarity",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping",
      "name": "APIMapping",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__",
        "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements",
        "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/map_api",
        "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_similar_mappings",
        "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class APIMapping:\n    threshold_of_similarity_between_mappings: float\n    threshold_of_similarity_for_creation_of_mappings: float\n    apiv1: API\n    apiv2: API\n    differ: AbstractDiffer\n\n    def __init__(\n        self,\n        apiv1: API,\n        apiv2: API,\n        differ: AbstractDiffer,\n        threshold_of_similarity_for_creation_of_mappings: float = 0.5,\n        threshold_of_similarity_between_mappings: float = 0.05,\n    ) -> None:\n        self.apiv1 = apiv1\n        self.apiv2 = apiv2\n        self.differ = differ\n        self.threshold_of_similarity_for_creation_of_mappings = (\n            threshold_of_similarity_for_creation_of_mappings\n        )\n        self.threshold_of_similarity_between_mappings = (\n            threshold_of_similarity_between_mappings\n        )\n\n    def _get_mappings_for_api_elements(\n        self,\n        api_elementv1_list: List[API_ELEMENTS],\n        api_elementv2_list: List[API_ELEMENTS],\n        compute_similarity: Callable[[API_ELEMENTS, API_ELEMENTS], float],\n    ) -> list[Mapping]:\n        element_mappings: list[Mapping] = []\n        for api_elementv1 in api_elementv1_list:\n            mapping_for_class_1: list[Mapping] = []\n            for api_elementv2 in api_elementv2_list:\n                similarity = compute_similarity(api_elementv1, api_elementv2)\n                if similarity >= self.threshold_of_similarity_for_creation_of_mappings:\n                    mapping_for_class_1.append(\n                        OneToOneMapping(similarity, api_elementv1, api_elementv2)\n                    )\n            mapping_for_class_1.sort(key=Mapping.get_similarity, reverse=True)\n            new_mapping = self._merge_similar_mappings(mapping_for_class_1)\n            if new_mapping is not None:\n                self._merge_mappings_with_same_elements(new_mapping, element_mappings)\n        return element_mappings\n\n    def map_api(self) -> List[Mapping]:\n        mappings: List[Mapping] = []\n        previous_mappings = self.differ.get_related_mappings()\n        if previous_mappings is not None:\n            for mapping in previous_mappings:\n                new_mapping = None\n                if isinstance(\n                    mapping.get_apiv1_elements()[0], Attribute\n                ) and isinstance(mapping.get_apiv2_elements()[0], Attribute):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        self.differ.compute_attribute_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Class) and isinstance(\n                    mapping.get_apiv2_elements()[0], Class\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Class)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Class)\n                        ],\n                        self.differ.compute_class_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Function\n                ) and isinstance(mapping.get_apiv2_elements()[0], Function):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Function)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Function)\n                        ],\n                        self.differ.compute_function_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Parameter\n                ) and isinstance(mapping.get_apiv2_elements()[0], Parameter):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        self.differ.compute_parameter_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Result) and isinstance(\n                    mapping.get_apiv2_elements()[0], Result\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Result)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Result)\n                        ],\n                        self.differ.compute_result_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                if new_mapping is not None:\n                    self.differ.notify_new_mapping(new_mapping)\n        else:\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.classes.values()),\n                    list(self.apiv2.classes.values()),\n                    self.differ.compute_class_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.functions.values()),\n                    list(self.apiv2.functions.values()),\n                    self.differ.compute_function_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.parameters().values()),\n                    list(self.apiv2.parameters().values()),\n                    self.differ.compute_parameter_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        attribute\n                        for class_ in self.apiv1.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    [\n                        attribute\n                        for class_ in self.apiv2.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    self.differ.compute_attribute_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        result\n                        for function in self.apiv1.functions.values()\n                        for result in function.results\n                    ],\n                    [\n                        result\n                        for function in self.apiv2.functions.values()\n                        for result in function.results\n                    ],\n                    self.differ.compute_result_similarity,\n                )\n            )\n\n        mappings.sort(key=Mapping.get_similarity, reverse=True)\n        return mappings\n\n    def _merge_similar_mappings(self, mappings: List[Mapping]) -> Optional[Mapping]:\n        \"\"\"\n        Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\n        from this apiv1 element to apiv2 elements by merging the first and second elements recursively,\n        if the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n        :param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n        :return: the first element of the sorted list that could be a result of merged similar mappings\n        \"\"\"\n        if len(mappings) == 0:\n            return None\n        if len(mappings) == 1:\n            return mappings[0]\n        if (\n            mappings[0].similarity - mappings[1].similarity\n            < self.threshold_of_similarity_between_mappings\n        ):\n            mappings[0] = merge_mappings(mappings[0], mappings[1])\n            mappings.pop(1)\n            return self._merge_similar_mappings(mappings)\n        return mappings[0]\n\n    def _merge_mappings_with_same_elements(\n        self, mapping_to_be_appended: Mapping, mappings: list[Mapping]\n    ) -> None:\n        \"\"\"\n        This method prevents that an element in a mapping appears multiple times in a list of mappings\n        by merging the affected mappings and include the result in the list. If there is no such element,\n        the mapping will be included without any merge.\n\n        :param mapping_to_be_appended: the mapping that should be included in mappings\n        :param mappings: the list, in which mapping_to_be_appended should be appended\n        \"\"\"\n        duplicated: list[Mapping] = []\n        for mapping in mappings:\n            duplicated_element = False\n            for element in mapping.get_apiv2_elements():\n                for element_2 in mapping_to_be_appended.get_apiv2_elements():\n                    if element == element_2:\n                        duplicated_element = True\n                        break\n            if duplicated_element:\n                duplicated.append(mapping)\n\n        if len(duplicated) == 0:\n            mappings.append(mapping_to_be_appended)\n            return\n\n        for conflicted_mapping in duplicated:\n            mapping_to_be_appended = merge_mappings(\n                mapping_to_be_appended, conflicted_mapping\n            )\n            mappings.remove(conflicted_mapping)\n\n        mappings.append(mapping_to_be_appended)",
      "instance_attributes": [
        {
          "name": "apiv1",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "apiv2",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "differ",
          "types": {
            "kind": "NamedType",
            "name": "AbstractDiffer"
          }
        },
        {
          "name": "threshold_of_similarity_for_creation_of_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "threshold_of_similarity_between_mappings",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer",
      "name": "AbstractDiffer",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity",
        "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity",
        "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity",
        "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity",
        "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity",
        "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_related_mappings",
        "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/notify_new_mapping",
        "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_additional_mappings"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AbstractDiffer(ABC):\n    previous_base_differ: Optional[AbstractDiffer]\n    previous_mappings: list[Mapping]\n    apiv1: API\n    apiv2: API\n\n    @abstractmethod\n    def compute_attribute_similarity(\n        self,\n        attributev1: Attribute,\n        attributev2: Attribute,\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2.\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2.\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n\n    @abstractmethod\n    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        \"\"\"\n        Indicates whether all api elements should be compared with each other\n        or just the ones that are mapped to each other.\n        :return: a list of Mappings if only previously mapped api elements should be mapped to each other or else None.\n        \"\"\"\n\n    @abstractmethod\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        \"\"\"\n        If previous mappings returns None, the differ will be notified about a new mapping.\n        Thereby the differ can calculate the similarity with more information.\n        :param mappings: a list of mappings new appended mappings.\n        \"\"\"\n\n    @abstractmethod\n    def get_additional_mappings(self) -> list[Mapping]:\n        \"\"\"\n        This method allows the differ to add further mappings from previous differs\n        :return: additional mappings that should be included in the result of the differentiation\n        \"\"\"",
      "instance_attributes": [
        {
          "name": "previous_base_differ",
          "types": null
        },
        {
          "name": "previous_mappings",
          "types": null
        },
        {
          "name": "apiv1",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "apiv2",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer",
      "name": "SimpleDiffer",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer",
      "decorators": [],
      "superclasses": [
        "AbstractDiffer"
      ],
      "methods": [
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_related_mappings",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/notify_new_mapping",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_additional_mappings",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_create_list_from_type",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity",
        "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SimpleDiffer(AbstractDiffer):\n    assigned_by_look_up_similarity: dict[\n        ParameterAssignment, dict[ParameterAssignment, float]\n    ]\n    previous_parameter_similarity: dict[str, dict[str, float]] = {}\n    previous_function_similarity: dict[str, dict[str, float]] = {}\n\n    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        return None\n\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        return\n\n    def get_additional_mappings(self) -> list[Mapping]:\n        return []\n\n    def __init__(\n        self,\n        previous_base_differ: Optional[AbstractDiffer],\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        distance_between_implicit_and_explicit = 0.3\n        distance_between_vararg_and_normal = 0.3\n        distance_between_position_and_named = 0.3\n        distance_between_both_to_one = 0.15\n        distance_between_one_to_both = 0.15\n        self.assigned_by_look_up_similarity = {\n            ParameterAssignment.IMPLICIT: {\n                ParameterAssignment.IMPLICIT: 1.0,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_implicit_and_explicit,\n            },\n            ParameterAssignment.NAMED_VARARG: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.NAMED_VARARG: 1.0,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0 - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n            },\n            ParameterAssignment.POSITIONAL_VARARG: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_vararg_and_normal,\n            },\n            ParameterAssignment.POSITION_OR_NAME: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_both_to_one,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_both_to_one,\n                ParameterAssignment.POSITION_OR_NAME: 1.0,\n                ParameterAssignment.NAME_ONLY: 1.0 - distance_between_both_to_one,\n                ParameterAssignment.POSITION_ONLY: 1.0 - distance_between_both_to_one,\n            },\n            ParameterAssignment.NAME_ONLY: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_position_and_named,\n            },\n            ParameterAssignment.POSITION_ONLY: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_ONLY: 1.0,\n            },\n        }\n\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2 with the respect to their name, id, code, and attributes.\n        :param classv1: attribute from apiv1\n        :param classv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        normalize_similarity = 6\n\n        code_similarity = self._compute_code_similarity(\n            classv1.get_formatted_code(), classv2.get_formatted_code()\n        )\n        name_similarity = self._compute_name_similarity(classv1.name, classv2.name)\n\n        attributes_similarity = distance(\n            classv1.instance_attributes, classv2.instance_attributes\n        )\n        attributes_similarity = attributes_similarity / (\n            max(len(classv1.instance_attributes), len(classv2.instance_attributes), 1)\n        )\n        attributes_similarity = 1 - attributes_similarity\n\n        function_similarity = distance(\n            classv1.methods,\n            classv2.methods,\n        ) / max(len(classv1.methods), len(classv2.methods), 1)\n        function_similarity = 1 - function_similarity\n\n        id_similarity = self._compute_id_similarity(classv1.id, classv2.id)\n\n        documentation_similarity = self._compute_documentation_similarity(\n            classv1.documentation, classv2.documentation\n        )\n        if documentation_similarity < 0:\n            documentation_similarity = 0\n            normalize_similarity -= 1\n\n        return (\n            name_similarity\n            + attributes_similarity\n            + function_similarity\n            + code_similarity\n            + id_similarity\n            + documentation_similarity\n        ) / normalize_similarity\n\n    def _compute_name_similarity(self, namev1: str, namev2: str) -> float:\n        name_similarity = distance(namev1, namev2) / max(len(namev1), len(namev2), 1)\n        return 1 - name_similarity\n\n    def compute_attribute_similarity(\n        self,\n        attributev1: Attribute,\n        attributev2: Attribute,\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2 with the respect to their name and type.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        name_similarity = self._compute_name_similarity(\n            attributev1.name, attributev2.name\n        )\n        type_listv1 = self._create_list_from_type(attributev1.types)\n        type_listv2 = self._create_list_from_type(attributev2.types)\n        type_similarity = distance(type_listv1, type_listv2) / max(\n            len(type_listv1), len(type_listv2), 1\n        )\n        type_similarity = 1 - type_similarity\n        return (name_similarity + type_similarity) / 2\n\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2 with the respect to their code, name, id, and parameters.\n        :param functionv1: attribute from apiv1\n        :param functionv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        if (\n            functionv1.id in self.previous_function_similarity\n            and functionv2.id in self.previous_function_similarity[functionv1.id]\n        ):\n            return self.previous_function_similarity[functionv1.id][functionv2.id]\n\n        normalize_similarity = 5\n\n        code_similarity = self._compute_code_similarity(\n            functionv1.get_formatted_code(), functionv2.get_formatted_code()\n        )\n        name_similarity = self._compute_name_similarity(\n            functionv1.name, functionv2.name\n        )\n\n        parameter_similarity = distance(\n            functionv1.parameters,\n            functionv2.parameters,\n        ) / max(len(functionv1.parameters), len(functionv2.parameters), 1)\n        parameter_similarity = 1 - parameter_similarity\n\n        id_similarity = self._compute_id_similarity(functionv1.id, functionv2.id)\n\n        documentation_similarity = self._compute_documentation_similarity(\n            functionv1.documentation, functionv2.documentation\n        )\n        if documentation_similarity < 0:\n            documentation_similarity = 0\n            normalize_similarity -= 1\n\n        result = (\n            code_similarity\n            + name_similarity\n            + parameter_similarity\n            + id_similarity\n            + documentation_similarity\n        ) / normalize_similarity\n        if functionv1.id not in self.previous_function_similarity:\n            self.previous_function_similarity[functionv1.id] = {}\n        self.previous_function_similarity[functionv1.id][functionv2.id] = result\n        return result\n\n    def _compute_code_similarity(self, codev1: str, codev2: str) -> float:\n        splitv1 = codev1.split(\"\\n\")\n        splitv2 = codev2.split(\"\\n\")\n        diff_code = distance(splitv1, splitv2) / max(len(splitv1), len(splitv2), 1)\n        return 1 - diff_code\n\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2 with the respect to their name, type, assignment, default value, documentation, and id.\n        :param parameterv1: attribute from apiv1\n        :param parameterv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        if (\n            parameterv1.id in self.previous_parameter_similarity\n            and parameterv2.id in self.previous_parameter_similarity[parameterv1.id]\n        ):\n            return self.previous_parameter_similarity[parameterv1.id][parameterv2.id]\n\n        normalize_similarity = 6\n        parameter_name_similarity = self._compute_name_similarity(\n            parameterv1.name, parameterv2.name\n        )\n        parameter_type_similarity = self._compute_type_similarity(\n            parameterv1.type, parameterv2.type\n        )\n        parameter_assignment_similarity = self._compute_assignment_similarity(\n            parameterv1.assigned_by, parameterv2.assigned_by\n        )\n        if parameter_assignment_similarity < 0:\n            parameter_assignment_similarity = 0\n            normalize_similarity -= 1\n        parameter_default_value_similarity = self._compute_default_value_similarity(\n            parameterv1.default_value, parameterv2.default_value\n        )\n        if parameter_default_value_similarity < 0:\n            parameter_default_value_similarity = 0\n            normalize_similarity -= 1\n        parameter_documentation_similarity = self._compute_documentation_similarity(\n            parameterv1.documentation, parameterv2.documentation\n        )\n        if parameter_documentation_similarity < 0:\n            parameter_documentation_similarity = 0\n            normalize_similarity -= 1\n\n        id_similarity = self._compute_id_similarity(parameterv1.id, parameterv2.id)\n\n        result = (\n            parameter_name_similarity\n            + parameter_type_similarity\n            + parameter_assignment_similarity\n            + parameter_default_value_similarity\n            + parameter_documentation_similarity\n            + id_similarity\n        ) / normalize_similarity\n        if parameterv1.id not in self.previous_parameter_similarity:\n            self.previous_parameter_similarity[parameterv1.id] = {}\n        self.previous_parameter_similarity[parameterv1.id][parameterv2.id] = result\n        return result\n\n    def _compute_type_similarity(\n        self, typev1: Optional[AbstractType], typev2: Optional[AbstractType]\n    ) -> float:\n        if typev1 is None:\n            if typev2 is None:\n                return 1\n            return 0\n        if typev2 is None:\n            return 0\n\n        type_listv1 = self._create_list_from_type(typev1)\n        type_listv2 = self._create_list_from_type(typev2)\n        diff_elements = distance(type_listv1, type_listv2) / max(\n            len(type_listv1), len(type_listv2), 1\n        )\n        return 1 - diff_elements\n\n    def _create_list_from_type(\n        self, abstract_type: Optional[AbstractType]\n    ) -> Sequence[Optional[AbstractType]]:\n        if abstract_type is not None and isinstance(abstract_type, UnionType):\n            return abstract_type.types\n        return [abstract_type]\n\n    def _compute_assignment_similarity(\n        self, assigned_byv1: ParameterAssignment, assigned_byv2: ParameterAssignment\n    ) -> float:\n        return self.assigned_by_look_up_similarity[assigned_byv1][assigned_byv2]\n\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2 with the respect to their name.\n        :param resultv1: attribute from apiv1\n        :param resultv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        return self._compute_name_similarity(resultv1.name, resultv2.name)\n\n    def _compute_default_value_similarity(\n        self, default_valuev1: Optional[str], default_valuev2: Optional[str]\n    ) -> float:\n        if default_valuev1 is None and default_valuev2 is None:\n            return -1.0\n        if default_valuev1 is None or default_valuev2 is None:\n            return 0.0\n        if default_valuev1 == \"None\" and default_valuev2 == \"None\":\n            return 1.0\n        try:\n            intv1_value = int(default_valuev1)\n            intv2_value = int(default_valuev2)\n            if intv1_value == intv2_value:\n                return 1.0\n            return 0.5\n        except ValueError:\n            try:\n                floatv1_value = float(default_valuev1)\n                floatv2_value = float(default_valuev2)\n                if floatv1_value == floatv2_value:\n                    return 1.0\n            except ValueError:\n                try:\n                    if float(int(default_valuev1)) == float(default_valuev2):\n                        return 0.75\n                except ValueError:\n                    try:\n                        if float(int(default_valuev2)) == float(default_valuev1):\n                            return 0.75\n                    except ValueError:\n                        pass\n        if default_valuev1 in (\n            \"True\",\n            \"False\",\n        ) and default_valuev2 in (\"True\", \"False\"):\n            if bool(default_valuev1) == bool(default_valuev2):\n                return 1.0\n            return 0.5\n        valuev1_is_in_quotation_marks = (\n            default_valuev1.startswith(\"'\") and default_valuev1.endswith(\"'\")\n        ) or (default_valuev1.startswith('\"') and default_valuev1.endswith('\"'))\n        valuev2_is_in_quotation_marks = (\n            default_valuev2.startswith(\"'\") and default_valuev2.endswith(\"'\")\n        ) or (default_valuev2.startswith('\"') and default_valuev2.endswith('\"'))\n        if valuev1_is_in_quotation_marks and valuev2_is_in_quotation_marks:\n            if default_valuev1[1:-1] == default_valuev2[1:-1]:\n                return 1.0\n            return 0.5\n        return 0.0\n\n    def _compute_documentation_similarity(\n        self,\n        documentationv1: Union[\n            ClassDocumentation, FunctionDocumentation, ParameterDocumentation\n        ],\n        documentationv2: Union[\n            ClassDocumentation, FunctionDocumentation, ParameterDocumentation\n        ],\n    ) -> float:\n        if len(documentationv1.description) == len(documentationv2.description) == 0:\n            return -1.0\n        descriptionv1 = re.split(\"[\\n ]\", documentationv1.description)\n        descriptionv2 = re.split(\"[\\n ]\", documentationv2.description)\n\n        documentation_similarity = distance(descriptionv1, descriptionv2) / max(\n            len(descriptionv1), len(descriptionv2), 1\n        )\n        return 1 - documentation_similarity\n\n    def _compute_id_similarity(self, idv1: str, idv2: str) -> float:\n        module_pathv1 = idv1.split(\"/\")[1].split(\".\")\n        additional_module_pathv1 = idv1.split(\"/\")[2:-1]\n        if len(additional_module_pathv1) > 0:\n            module_pathv1.extend(additional_module_pathv1)\n        module_pathv2 = idv2.split(\"/\")[1].split(\".\")\n        additional_module_pathv2 = idv2.split(\"/\")[2:-1]\n        if len(additional_module_pathv2) > 0:\n            module_pathv2.extend(additional_module_pathv2)\n\n        def cost_function(iteration: int, max_iteration: int) -> float:\n            return (max_iteration - iteration + 1) / max_iteration\n\n        total_costs, max_iterations = distance_elements_with_cost_function(\n            module_pathv1, module_pathv2, cost_function\n        )\n        return 1 - (total_costs / (sum(range(1, max_iterations + 1)) / max_iterations))",
      "instance_attributes": [
        {
          "name": "assigned_by_look_up_similarity",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer",
      "name": "InheritanceDiffer",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer",
      "decorators": [],
      "superclasses": [
        "AbstractDiffer"
      ],
      "methods": [
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__",
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity",
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity",
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity",
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity",
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity",
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_related_mappings",
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements",
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/notify_new_mapping",
        "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_additional_mappings"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class InheritanceDiffer(AbstractDiffer):\n    boost_value: float\n    differ: AbstractDiffer\n    inheritance: dict[str, list[str]]\n    new_mappings: list[Mapping]\n\n    def __init__(\n        self,\n        previous_base_differ: AbstractDiffer,\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n        boost_value: float = 0.15,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        self.differ = previous_base_differ\n        self.boost_value = boost_value\n        self.inheritance = {}\n        self.new_mappings = []\n        for class_v2 in self.apiv2.classes.values():\n            additional_v1_elements = []\n            for mapping in previous_mappings:\n                if isinstance(mapping.get_apiv2_elements()[0], Class):\n                    is_inheritance_mapping = class_v2.id in map(\n                        lambda class_: class_.id if isinstance(class_, Class) else \"\",\n                        mapping.get_apiv2_elements(),\n                    )\n                    if not is_inheritance_mapping:\n                        for inheritance_class_v2 in mapping.get_apiv2_elements():\n                            if isinstance(inheritance_class_v2, Class):\n                                if (\n                                    inheritance_class_v2.name in class_v2.superclasses\n                                    or class_v2.name\n                                    in inheritance_class_v2.superclasses\n                                ):\n                                    is_inheritance_mapping = True\n                                    break\n                    if is_inheritance_mapping:\n                        for class_v1 in mapping.get_apiv1_elements():\n                            if isinstance(class_v1, Class):\n                                additional_v1_elements.append(class_v1.id)\n            if len(additional_v1_elements) > 0:\n                self.inheritance[class_v2.id] = additional_v1_elements\n\n    def compute_attribute_similarity(\n        self, attributev1: Attribute, attributev2: Attribute\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: if the parent of the attributes are mapped onto each other\n         or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if (\n            attributev2.class_id in self.inheritance\n            and attributev1.class_id in self.inheritance[attributev2.class_id]\n        ):\n            return (\n                self.differ.compute_attribute_similarity(attributev1, attributev2)\n                * (1 - self.boost_value)\n            ) + self.boost_value\n        return 0.0\n\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: if the classes are mapped onto each other or onto a super- or subclass,\n        the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if classv2.id in self.inheritance:\n            for mapping in self.previous_mappings:\n                for elementv2 in mapping.get_apiv2_elements():\n                    if isinstance(elementv2, Class):\n                        if elementv2.id in self.inheritance[classv2.id]:\n                            return (\n                                self.differ.compute_class_similarity(classv1, classv2)\n                                * (1 - self.boost_value)\n                            ) + self.boost_value\n        return 0.0\n\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: if functions are not global functions and its parent are mapped onto each other\n         or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        functionv1_is_global = len(functionv1.id.split(\"/\")) == 3\n        functionv2_is_global = len(functionv2.id.split(\"/\")) == 3\n        if functionv1_is_global or functionv2_is_global:\n            return 0.0\n        class_id_functionv1 = \"/\".join(functionv1.id.split(\"/\")[:-1])\n        class_id_functionv2 = \"/\".join(functionv2.id.split(\"/\")[:-1])\n        if (\n            class_id_functionv2 in self.inheritance\n            and class_id_functionv1 in self.inheritance[class_id_functionv2]\n        ):\n            base_similarity = self.differ.compute_function_similarity(\n                functionv1, functionv2\n            )\n            return (base_similarity * (1 - self.boost_value)) + self.boost_value\n        return 0.0\n\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: if their parents are mapped together, the normalized similarity of the previous differ plus boost_value,\n        or else 0.\n        \"\"\"\n        parameterv2_id_splitted = parameterv2.id.split(\"/\")\n        if \"/\".join(parameterv2_id_splitted[:-2]) in self.inheritance:\n            functionv1_id = \"/\".join(parameterv1.id.split(\"/\")[:-1])\n            for mapping in self.new_mappings:\n                for functionv1 in mapping.get_apiv1_elements():\n                    if (\n                        isinstance(functionv1, Function)\n                        and functionv1_id == functionv1.id\n                    ):\n                        for functionv2 in mapping.get_apiv2_elements():\n                            if (\n                                isinstance(functionv2, Function)\n                                and \"/\".join(parameterv2_id_splitted[:-1])\n                                == functionv2.id\n                            ):\n                                return (\n                                    self.differ.compute_parameter_similarity(\n                                        parameterv1, parameterv2\n                                    )\n                                    * (1 - self.boost_value)\n                                ) + self.boost_value\n        return 0.0\n\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: if their parents are mapped together,\n        the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if (\n            resultv2.function_id is not None\n            and \"/\".join(resultv2.function_id.split(\"/\")[:-1]) in self.inheritance\n        ):\n            for mapping in self.new_mappings:\n                for functionv1 in mapping.get_apiv1_elements():\n                    if (\n                        isinstance(functionv1, Function)\n                        and resultv1.function_id == functionv1.id\n                    ):\n                        for functionv2 in mapping.get_apiv2_elements():\n                            if (\n                                isinstance(functionv2, Function)\n                                and resultv2.function_id == functionv2.id\n                            ):\n                                return (\n                                    self.differ.compute_result_similarity(\n                                        resultv1, resultv2\n                                    )\n                                    * (1 - self.boost_value)\n                                ) + self.boost_value\n        return 0.0\n\n    def get_related_mappings(self) -> Optional[list[Mapping]]:\n        \"\"\"\n        Indicates whether all api elements should be compared with each other\n        or just the ones that are mapped to each other.\n        :return: a list of Mappings by type whose elements are not already mapped\n        \"\"\"\n        related_mappings = []\n        mapped_apiv1_elements = [\n            element\n            for mapping in self.previous_mappings\n            for element in mapping.get_apiv1_elements()\n        ]\n        mapped_apiv2_elements = [\n            element\n            for mapping in self.previous_mappings\n            for element in mapping.get_apiv2_elements()\n        ]\n        for get_api_element in [\n            lambda api: api.classes.values(),\n            lambda api: api.functions.values(),\n            lambda api: api.attributes().values(),\n            lambda api: api.parameters().values(),\n            lambda api: api.results().values(),\n        ]:\n            not_mapped_elements_mapping = self._get_not_mapped_api_elements(\n                mapped_apiv1_elements, mapped_apiv2_elements, get_api_element\n            )\n            if not_mapped_elements_mapping is not None:\n                related_mappings.append(not_mapped_elements_mapping)\n        return related_mappings\n\n    def _get_not_mapped_api_elements(\n        self,\n        mapped_apiv1_elements: list[api_element],\n        mapped_apiv2_elements: list[api_element],\n        get_api_element: Callable[[API], list[api_element]],\n    ) -> Optional[Mapping]:\n        not_mapped_v1_elements = []\n        for api_elementv1 in get_api_element(self.apiv1):\n            if api_elementv1 not in mapped_apiv1_elements:\n                not_mapped_v1_elements.append(api_elementv1)\n        not_mapped_v2_elements = []\n        for api_elementv2 in get_api_element(self.apiv2):\n            if api_elementv2 not in mapped_apiv2_elements:\n                not_mapped_v2_elements.append(api_elementv2)\n        if len(not_mapped_v1_elements) > 0 and len(not_mapped_v2_elements) > 0:\n            return ManyToManyMapping(\n                -1.0, not_mapped_v1_elements, not_mapped_v2_elements\n            )\n        return None\n\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        self.new_mappings.extend(mappings)\n\n    def get_additional_mappings(self) -> list[Mapping]:\n        return self.previous_mappings",
      "instance_attributes": [
        {
          "name": "differ",
          "types": {
            "kind": "NamedType",
            "name": "AbstractDiffer"
          }
        },
        {
          "name": "boost_value",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "inheritance",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "new_mappings",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping",
      "name": "ManyToManyMapping",
      "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "Mapping"
      ],
      "methods": [
        "package-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv1_elements",
        "package-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv2_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ManyToManyMapping(Mapping):\n    apiv1_elements: list[api_element]\n    apiv2_elements: list[api_element]\n\n    def get_apiv1_elements(self) -> list[api_element]:\n        return self.apiv1_elements\n\n    def get_apiv2_elements(self) -> list[api_element]:\n        return self.apiv2_elements",
      "instance_attributes": [
        {
          "name": "apiv1_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "apiv2_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping",
      "name": "ManyToOneMapping",
      "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "Mapping"
      ],
      "methods": [
        "package-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv1_elements",
        "package-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv2_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ManyToOneMapping(Mapping):\n    apiv1_elements: list[api_element]\n    apiv2_element: api_element\n\n    def get_apiv1_elements(self) -> list[api_element]:\n        return self.apiv1_elements\n\n    def get_apiv2_elements(self) -> list[api_element]:\n        return [self.apiv2_element]",
      "instance_attributes": [
        {
          "name": "apiv1_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "apiv2_element",
          "types": null
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/Mapping",
      "name": "Mapping",
      "qname": "package_parser.processing.migration.model._mapping.Mapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "package-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv1_elements",
        "package-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv2_elements",
        "package-parser/package_parser.processing.migration.model._mapping/Mapping/get_similarity"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Mapping(ABC):\n    similarity: float\n\n    @abstractmethod\n    def get_apiv1_elements(self) -> list[api_element]:\n        pass\n\n    @abstractmethod\n    def get_apiv2_elements(self) -> list[api_element]:\n        pass\n\n    def get_similarity(self) -> float:\n        return self.similarity",
      "instance_attributes": [
        {
          "name": "similarity",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/OneToManyMapping",
      "name": "OneToManyMapping",
      "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "Mapping"
      ],
      "methods": [
        "package-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv1_elements",
        "package-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv2_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class OneToManyMapping(Mapping):\n    apiv1_element: api_element\n    apiv2_elements: list[api_element]\n\n    def get_apiv1_elements(self) -> list[api_element]:\n        return [self.apiv1_element]\n\n    def get_apiv2_elements(self) -> list[api_element]:\n        return self.apiv2_elements",
      "instance_attributes": [
        {
          "name": "apiv1_element",
          "types": null
        },
        {
          "name": "apiv2_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/OneToOneMapping",
      "name": "OneToOneMapping",
      "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "Mapping"
      ],
      "methods": [
        "package-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv1_elements",
        "package-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv2_elements"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class OneToOneMapping(Mapping):\n    apiv1_element: api_element\n    apiv2_element: api_element\n\n    def get_apiv1_elements(self) -> list[api_element]:\n        return [self.apiv1_element]\n\n    def get_apiv2_elements(self) -> list[api_element]:\n        return [self.apiv2_element]",
      "instance_attributes": [
        {
          "name": "apiv1_element",
          "types": null
        },
        {
          "name": "apiv2_element",
          "types": null
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer",
      "name": "StrictDiffer",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer",
      "decorators": [],
      "superclasses": [
        "AbstractDiffer"
      ],
      "methods": [
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_related_mappings",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/notify_new_mapping",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_additional_mappings",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity",
        "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class StrictDiffer(AbstractDiffer):\n    new_mappings: list[Mapping]\n    differ: AbstractDiffer\n\n    def __init__(\n        self,\n        previous_base_differ: AbstractDiffer,\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        self.differ = previous_base_differ\n        self.new_mappings = []\n\n    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        sort_order = {\n            Class: 0,\n            Attribute: 1,\n            Function: 2,\n            Parameter: 3,\n            Result: 4,\n        }\n        return sorted(\n            self.previous_mappings,\n            key=lambda mapping: sort_order[type(mapping.get_apiv1_elements()[0])],\n        )\n\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        self.new_mappings.extend(mappings)\n\n    def get_additional_mappings(self) -> list[Mapping]:\n        return []\n\n    def _is_parent(\n        self,\n        possible_parent: Union[Class, Function, Attribute, Parameter, Result],\n        child: DEPENDENT_API_ELEMENTS,\n    ) -> bool:\n        if isinstance(child, Attribute) and isinstance(possible_parent, Class):\n            return child.class_id == possible_parent.id\n        if isinstance(child, Result) and isinstance(possible_parent, Function):\n            return child.function_id == possible_parent.id\n        if isinstance(child, Parameter) and isinstance(possible_parent, Function):\n            return \"/\".join(child.id.split(\"/\")[:-1]) == possible_parent.id\n        if isinstance(child, Function) and isinstance(possible_parent, Class):\n            return \"/\".join(child.id.split(\"/\")[:-1]) == possible_parent.id\n        return False\n\n    def _api_elements_are_mapped_to_each_other(\n        self,\n        api_elementv1: DEPENDENT_API_ELEMENTS,\n        api_elementv2: DEPENDENT_API_ELEMENTS,\n    ) -> bool:\n        (\n            relevant_apiv1_mappings,\n            relevant_apiv2_mappings,\n        ) = self._get_mapping_for_elements(api_elementv1, api_elementv2)\n        relevant_apiv2_mappings_include_functionv1 = (\n            len(\n                [\n                    parent\n                    for mapping in relevant_apiv2_mappings\n                    for parent in mapping.get_apiv1_elements()\n                    if self._is_parent(parent, api_elementv1)\n                ]\n            )\n            == 1\n        )\n        relevant_apiv2_mappings_include_functionv2 = (\n            len(\n                [\n                    parent\n                    for mapping in relevant_apiv1_mappings\n                    for parent in mapping.get_apiv2_elements()\n                    if self._is_parent(parent, api_elementv2)\n                ]\n            )\n            == 1\n        )\n        return (\n            relevant_apiv2_mappings_include_functionv1\n            and relevant_apiv2_mappings_include_functionv2\n        )\n\n    def _get_mapping_for_elements(\n        self,\n        apiv1_element: DEPENDENT_API_ELEMENTS,\n        apiv2_element: DEPENDENT_API_ELEMENTS,\n    ) -> tuple[list[Mapping], list[Mapping]]:\n        mapping_for_apiv1_elements = []\n        mapping_for_apiv2_elements = []\n        for mapping in self.new_mappings:\n            if isinstance(mapping.get_apiv1_elements()[0], (Class, Function)):\n                for element in mapping.get_apiv1_elements():\n                    if self._is_parent(element, apiv1_element):\n                        mapping_for_apiv1_elements.append(mapping)\n                for element in mapping.get_apiv2_elements():\n                    if self._is_parent(element, apiv2_element):\n                        mapping_for_apiv2_elements.append(mapping)\n        return mapping_for_apiv1_elements, mapping_for_apiv2_elements\n\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: if the classes are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        for mapping in self.previous_mappings:\n            if (\n                classv1 in mapping.get_apiv1_elements()\n                and classv2 in mapping.get_apiv2_elements()\n            ):\n                return self.differ.compute_class_similarity(classv1, classv2)\n        return 0\n\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        is_global_functionv1 = len(functionv1.id.split(\"/\")) == 3\n        is_global_functionv2 = len(functionv2.id.split(\"/\")) == 3\n        if is_global_functionv1 and is_global_functionv2:\n            for mapping in self.previous_mappings:\n                if (\n                    functionv1 in mapping.get_apiv1_elements()\n                    and functionv2 in mapping.get_apiv2_elements()\n                ):\n                    return self.differ.compute_function_similarity(\n                        functionv1, functionv2\n                    )\n        elif (\n            not is_global_functionv1 and not is_global_functionv2\n        ) and self._api_elements_are_mapped_to_each_other(functionv1, functionv2):\n            return self.differ.compute_function_similarity(functionv1, functionv2)\n        return 0.0\n\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(parameterv1, parameterv2):\n            return self.differ.compute_parameter_similarity(parameterv1, parameterv2)\n        return 0.0\n\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2.\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(resultv1, resultv2):\n            return self.differ.compute_result_similarity(resultv1, resultv2)\n        return 0.0\n\n    def compute_attribute_similarity(\n        self, attributev1: Attribute, attributev2: Attribute\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(attributev1, attributev2):\n            return self.differ.compute_attribute_similarity(attributev1, attributev2)\n        return 0.0",
      "instance_attributes": [
        {
          "name": "differ",
          "types": {
            "kind": "NamedType",
            "name": "AbstractDiffer"
          }
        },
        {
          "name": "new_mappings",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker",
      "name": "ASTWalker",
      "qname": "package_parser.utils._ASTWalker.ASTWalker",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "docstring": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "code": "class ASTWalker:\n    \"\"\"A walker visiting a tree in preorder, calling on the handler:\n\n    * enter_<class_name> on entering a node, where class name is the class of\n    the node in lower case.\n\n    * leave_<class_name> on leaving a node, where class name is the class of\n    the node in lower case.\n    \"\"\"\n\n    def __init__(self, handler: Any) -> None:\n        self._handler = handler\n        self._cache: dict[Type, _EnterAndLeaveFunctions] = {}\n\n    def walk(self, node: astroid.NodeNG) -> None:\n        self.__walk(node, set())\n\n    def __walk(self, node: astroid.NodeNG, visited_nodes: set[astroid.NodeNG]) -> None:\n        if node in visited_nodes:\n            raise AssertionError(\"Node visited twice\")\n        visited_nodes.add(node)\n\n        self.__enter(node)\n        for child_node in node.get_children():\n            self.__walk(child_node, visited_nodes)\n        self.__leave(node)\n\n    def __enter(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[0]\n        if method is not None:\n            method(node)\n\n    def __leave(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[1]\n        if method is not None:\n            method(node)\n\n    def __get_callbacks(self, node: astroid.NodeNG) -> _EnterAndLeaveFunctions:\n        klass = node.__class__\n        methods = self._cache.get(klass)\n\n        if methods is None:\n            handler = self._handler\n            class_name = klass.__name__.lower()\n            enter_method = getattr(\n                handler, f\"enter_{class_name}\", getattr(handler, \"enter_default\", None)\n            )\n            leave_method = getattr(\n                handler, f\"leave_{class_name}\", getattr(handler, \"leave_default\", None)\n            )\n            self._cache[klass] = (enter_method, leave_method)\n        else:\n            enter_method, leave_method = methods\n\n        return enter_method, leave_method",
      "instance_attributes": [
        {
          "name": "_handler",
          "types": {
            "kind": "NamedType",
            "name": "Any"
          }
        },
        {
          "name": "_cache",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    }
  ],
  "functions": [
    {
      "id": "package-parser/package_parser.cli._cli/_add_all_subparser",
      "name": "_add_all_subparser",
      "qname": "package_parser.cli._cli._add_all_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_all_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_all_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_all_subparser(subparsers: _SubParsersAction) -> None:\n    all_parser = subparsers.add_parser(\n        _ALL_COMMAND,\n        help=\"Run api and usages command in parallel and then run annotations command.\",\n    )\n    all_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package.\",\n        type=str,\n        required=True,\n    )\n    all_parser.add_argument(\n        \"-s\",\n        \"--src\",\n        help=\"Directory containing the Python code of the package. If this is omitted, we try to locate the package \"\n        \"with the given name in the current Python interpreter.\",\n        type=Path,\n        required=False,\n        default=None,\n    )\n    all_parser.add_argument(\n        \"-c\",\n        \"--client\",\n        help=\"Directory containing Python code that uses the package.\",\n        type=Path,\n        required=True,\n    )\n    all_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )\n    all_parser.add_argument(\n        \"--processes\",\n        help=\"How many processes should be spawned during processing.\",\n        type=int,\n        required=False,\n        default=4,\n    )\n    all_parser.add_argument(\n        \"--batchsize\",\n        help=\"How many files to process in one go. Higher values lead to higher memory usage but better performance.\",\n        type=int,\n        required=False,\n        default=100,\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_annotations_subparser",
      "name": "_add_annotations_subparser",
      "qname": "package_parser.cli._cli._add_annotations_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_annotations_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_annotations_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_annotations_subparser(subparsers) -> None:\n    generate_parser = subparsers.add_parser(\n        _ANNOTATIONS_COMMAND, help=\"Generate Annotations automatically.\"\n    )\n    generate_parser.add_argument(\n        \"-a\",\n        \"--api\",\n        help=\"File created by the 'api' command.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-u\",\n        \"--usages\",\n        help=\"File created by the 'usages' command that contains usage counts.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_api_subparser",
      "name": "_add_api_subparser",
      "qname": "package_parser.cli._cli._add_api_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_api_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_api_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_api_subparser(subparsers: _SubParsersAction) -> None:\n    api_parser = subparsers.add_parser(_API_COMMAND, help=\"List the API of a package.\")\n    api_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package.\",\n        type=str,\n        required=True,\n    )\n    api_parser.add_argument(\n        \"-s\",\n        \"--src\",\n        help=\"Directory containing the Python code of the package. If this is omitted, we try to locate the package \"\n        \"with the given name in the current Python interpreter.\",\n        type=Path,\n        required=False,\n        default=None,\n    )\n    api_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_migrate_subparser",
      "name": "_add_migrate_subparser",
      "qname": "package_parser.cli._cli._add_migrate_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_migrate_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_migrate_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_migrate_subparser(subparsers) -> None:\n    generate_parser = subparsers.add_parser(\n        _MIGRATE_COMMAND,\n        help=\"Migrate Annotations for the new version based on the previous version.\",\n    )\n    generate_parser.add_argument(\n        \"-a1\",\n        \"--apiv1\",\n        help=\"File created with the 'api' command from the previous version.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-a2\",\n        \"--apiv2\",\n        help=\"File created by the 'api' command from the new version.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-a\",\n        \"--annotations\",\n        help=\"File that includes all annotations of the previous version.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_usages_subparser",
      "name": "_add_usages_subparser",
      "qname": "package_parser.cli._cli._add_usages_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_usages_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_usages_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_usages_subparser(subparsers: _SubParsersAction) -> None:\n    usages_parser = subparsers.add_parser(\n        _USAGES_COMMAND, help=\"Find usages of API elements.\"\n    )\n    usages_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package. It must be installed in the current interpreter.\",\n        type=str,\n        required=True,\n    )\n    usages_parser.add_argument(\n        \"-c\",\n        \"--client\",\n        help=\"Directory containing Python code that uses the package.\",\n        type=Path,\n        required=True,\n    )\n    usages_parser.add_argument(\n        \"--processes\",\n        help=\"How many processes should be spawned during processing.\",\n        type=int,\n        required=False,\n        default=4,\n    ),\n    usages_parser.add_argument(\n        \"--batchsize\",\n        help=\"How many files to process in one go. Higher values lead to higher memory usage but better performance.\",\n        type=int,\n        required=False,\n        default=100,\n    )\n    usages_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_get_args",
      "name": "_get_args",
      "qname": "package_parser.cli._cli._get_args",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(description=\"Analyze Python code.\")\n    parser.add_argument(\n        \"-v\", \"--verbose\", help=\"show info messages\", action=\"store_true\"\n    )\n\n    # Commands\n    subparsers = parser.add_subparsers(dest=\"command\")\n    _add_api_subparser(subparsers)\n    _add_usages_subparser(subparsers)\n    _add_annotations_subparser(subparsers)\n    _add_all_subparser(subparsers)\n    _add_migrate_subparser(subparsers)\n\n    return parser.parse_args()"
    },
    {
      "id": "package-parser/package_parser.cli._cli/cli",
      "name": "cli",
      "qname": "package_parser.cli._cli.cli",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def cli() -> None:\n    args = _get_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.INFO)\n\n    if args.command == _API_COMMAND:\n        _run_api_command(args.package, args.src, args.out)\n    elif args.command == _USAGES_COMMAND:\n        _run_usages_command(\n            args.package, args.client, args.out, args.processes, args.batchsize\n        )\n    elif args.command == _ANNOTATIONS_COMMAND:\n        _run_annotations(args.api, args.usages, args.out)\n    elif args.command == _ALL_COMMAND:\n        _run_all_command(\n            args.package,\n            args.src,\n            args.client,\n            args.out,\n            args.processes,\n            args.batchsize,\n        )\n    elif args.command == _MIGRATE_COMMAND:\n        _run_migrate_command(args.apiv1, args.annotations, args.apiv2, args.out)"
    },
    {
      "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder/default",
      "name": "default",
      "qname": "package_parser.cli._json_encoder.CustomEncoder.default",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder/default/self",
          "name": "self",
          "qname": "package_parser.cli._json_encoder.CustomEncoder.default.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder/default/o",
          "name": "o",
          "qname": "package_parser.cli._json_encoder.CustomEncoder.default.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def default(self, o: Any) -> Any:\n        if isinstance(o, set):\n            return list(o)\n        return super().default(o)"
    },
    {
      "id": "package-parser/package_parser.cli._read_and_write_file/_read_annotations_file",
      "name": "_read_annotations_file",
      "qname": "package_parser.cli._read_and_write_file._read_annotations_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_read_annotations_file/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._read_and_write_file._read_annotations_file.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_annotations_file(annotations_file_path: Path) -> AnnotationStore:\n    with open(annotations_file_path, encoding=\"utf-8\") as annotations_file:\n        annotations_json = json.load(annotations_file)\n\n    return AnnotationStore.from_json(annotations_json)"
    },
    {
      "id": "package-parser/package_parser.cli._read_and_write_file/_read_api_file",
      "name": "_read_api_file",
      "qname": "package_parser.cli._read_and_write_file._read_api_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_read_api_file/api_file_path",
          "name": "api_file_path",
          "qname": "package_parser.cli._read_and_write_file._read_api_file.api_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_api_file(api_file_path: Path) -> API:\n    with open(api_file_path, encoding=\"utf-8\") as api_file:\n        api_json = json.load(api_file)\n\n    return API.from_json(api_json)"
    },
    {
      "id": "package-parser/package_parser.cli._read_and_write_file/_read_usages_file",
      "name": "_read_usages_file",
      "qname": "package_parser.cli._read_and_write_file._read_usages_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_read_usages_file/usages_file_path",
          "name": "usages_file_path",
          "qname": "package_parser.cli._read_and_write_file._read_usages_file.usages_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_usages_file(usages_file_path: Path) -> UsageCountStore:\n    with open(usages_file_path, encoding=\"utf-8\") as usages_file:\n        usages_json = json.load(usages_file)\n\n    return UsageCountStore.from_json(usages_json)"
    },
    {
      "id": "package-parser/package_parser.cli._read_and_write_file/_write_annotations_file",
      "name": "_write_annotations_file",
      "qname": "package_parser.cli._read_and_write_file._write_annotations_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_write_annotations_file/annotations",
          "name": "annotations",
          "qname": "package_parser.cli._read_and_write_file._write_annotations_file.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_write_annotations_file/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._read_and_write_file._write_annotations_file.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_annotations_file(\n    annotations: AnnotationStore, annotations_file_path: Path\n) -> None:\n    ensure_file_exists(annotations_file_path)\n    with annotations_file_path.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(annotations.to_json(), f, indent=2)"
    },
    {
      "id": "package-parser/package_parser.cli._read_and_write_file/_write_api_dependency_file",
      "name": "_write_api_dependency_file",
      "qname": "package_parser.cli._read_and_write_file._write_api_dependency_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_write_api_dependency_file/api",
          "name": "api",
          "qname": "package_parser.cli._read_and_write_file._write_api_dependency_file.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_write_api_dependency_file/api_dependencies",
          "name": "api_dependencies",
          "qname": "package_parser.cli._read_and_write_file._write_api_dependency_file.api_dependencies",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_write_api_dependency_file/out",
          "name": "out",
          "qname": "package_parser.cli._read_and_write_file._write_api_dependency_file.out",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_api_dependency_file(api: API, api_dependencies, out):\n    out_file_api_dependencies = out.joinpath(f\"{api.package}__api_dependencies.json\")\n    ensure_file_exists(out_file_api_dependencies)\n    with out_file_api_dependencies.open(\"w\") as f:\n        json.dump(api_dependencies.to_json(), f, indent=2, cls=CustomEncoder)"
    },
    {
      "id": "package-parser/package_parser.cli._read_and_write_file/_write_api_file",
      "name": "_write_api_file",
      "qname": "package_parser.cli._read_and_write_file._write_api_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_write_api_file/api",
          "name": "api",
          "qname": "package_parser.cli._read_and_write_file._write_api_file.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._read_and_write_file/_write_api_file/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._read_and_write_file._write_api_file.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_api_file(api: API, out_dir_path: Path) -> Path:\n    out_file_api = out_dir_path.joinpath(f\"{api.package}__api.json\")\n    ensure_file_exists(out_file_api)\n    with out_file_api.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(api.to_json(), f, indent=2, cls=CustomEncoder)\n    return out_file_api"
    },
    {
      "id": "package-parser/package_parser.cli._run_all/_run_all_command",
      "name": "_run_all_command",
      "qname": "package_parser.cli._run_all._run_all_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_all._run_all_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/src_dir_path",
          "name": "src_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.src_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/client_dir_path",
          "name": "client_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.client_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/n_processes",
          "name": "n_processes",
          "qname": "package_parser.cli._run_all._run_all_command.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/batch_size",
          "name": "batch_size",
          "qname": "package_parser.cli._run_all._run_all_command.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_all_command(\n    package: str,\n    src_dir_path: Path,\n    client_dir_path: Path,\n    out_dir_path: Path,\n    n_processes: int,\n    batch_size: int,\n) -> None:\n    out_file_annotations = out_dir_path.joinpath(\"annotations.json\")\n    results = _run_in_parallel(\n        partial(_run_api_command, package, src_dir_path, out_dir_path),\n        partial(\n            _run_usages_command,\n            package,\n            client_dir_path,\n            out_dir_path,\n            n_processes,\n            batch_size,\n        ),\n    )\n    _run_annotations(results[_API_KEY], results[_USAGES_KEY], out_file_annotations)"
    },
    {
      "id": "package-parser/package_parser.cli._run_all/_run_in_parallel",
      "name": "_run_in_parallel",
      "qname": "package_parser.cli._run_all._run_in_parallel",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_all/_run_in_parallel/fns",
          "name": "fns",
          "qname": "package_parser.cli._run_all._run_in_parallel.fns",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_in_parallel(*fns) -> dict:\n    manager = multiprocessing.Manager()\n    return_dict: dict[str, str] = manager.dict()\n    proc = []\n    for fn in fns:\n        p = multiprocessing.Process(target=fn, args=(return_dict,))\n        proc.append(p)\n        p.start()\n\n    for p in proc:\n        p.join()\n\n    return return_dict"
    },
    {
      "id": "package-parser/package_parser.cli._run_annotations/_run_annotations",
      "name": "_run_annotations",
      "qname": "package_parser.cli._run_annotations._run_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_annotations/_run_annotations/api_file_path",
          "name": "api_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.api_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_annotations/_run_annotations/usages_file_path",
          "name": "usages_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.usages_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_annotations/_run_annotations/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\nAnnotations that are generated are: remove, constant, required, optional, enum and boundary.\n:param api_file_path: API file Path\n:param usages_file_path: UsageStore file Path\n:param annotations_file_path: Output file Path",
      "docstring": "Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\nAnnotations that are generated are: remove, constant, required, optional, enum and boundary.\n:param api_file_path: API file Path\n:param usages_file_path: UsageStore file Path\n:param annotations_file_path: Output file Path",
      "code": "def _run_annotations(\n    api_file_path: Path, usages_file_path: Path, annotations_file_path: Path\n) -> None:\n    \"\"\"\n    Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\n    Annotations that are generated are: remove, constant, required, optional, enum and boundary.\n    :param api_file_path: API file Path\n    :param usages_file_path: UsageStore file Path\n    :param annotations_file_path: Output file Path\n    \"\"\"\n\n    api = _read_api_file(api_file_path)\n    usages = _read_usages_file(usages_file_path)\n    annotations = generate_annotations(api, usages)\n    _write_annotations_file(annotations, annotations_file_path)"
    },
    {
      "id": "package-parser/package_parser.cli._run_api/_run_api_command",
      "name": "_run_api_command",
      "qname": "package_parser.cli._run_api._run_api_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_api._run_api_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/src_dir_path",
          "name": "src_dir_path",
          "qname": "package_parser.cli._run_api._run_api_command.src_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_api._run_api_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/result_dict",
          "name": "result_dict",
          "qname": "package_parser.cli._run_api._run_api_command.result_dict",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_api_command(\n    package: str,\n    src_dir_path: Path,\n    out_dir_path: Path,\n    result_dict: Optional[dict] = None,\n) -> None:\n    api = get_api(package, src_dir_path)\n    api_dependencies = get_dependencies(api)\n\n    api_file_path = _write_api_file(api, out_dir_path)\n    _write_api_dependency_file(api, api_dependencies, out_dir_path)\n\n    if result_dict is not None:\n        result_dict[_API_KEY] = api_file_path"
    },
    {
      "id": "package-parser/package_parser.cli._run_migrate/_run_migrate_command",
      "name": "_run_migrate_command",
      "qname": "package_parser.cli._run_migrate._run_migrate_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_migrate/_run_migrate_command/apiv1_file_path",
          "name": "apiv1_file_path",
          "qname": "package_parser.cli._run_migrate._run_migrate_command.apiv1_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_migrate/_run_migrate_command/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._run_migrate._run_migrate_command.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_migrate/_run_migrate_command/apiv2_file_path",
          "name": "apiv2_file_path",
          "qname": "package_parser.cli._run_migrate._run_migrate_command.apiv2_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_migrate/_run_migrate_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_migrate._run_migrate_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_migrate_command(\n    apiv1_file_path: Path,\n    annotations_file_path: Path,\n    apiv2_file_path: Path,\n    out_dir_path: Path,\n) -> None:\n    apiv1 = _read_api_file(apiv1_file_path)\n    apiv2 = _read_api_file(apiv2_file_path)\n    annotationsv1 = _read_annotations_file(annotations_file_path)\n\n    differ_init_list: list[tuple[type[AbstractDiffer], dict[str, Any]]] = [\n        (SimpleDiffer, {}),\n        (StrictDiffer, {}),\n        (InheritanceDiffer, {}),\n    ]\n    previous_base_differ = None\n    previous_mappings: list[Mapping] = []\n\n    for differ_init in differ_init_list:\n        differ_class, additional_parameters = differ_init\n        differ = differ_class(\n            previous_base_differ,\n            previous_mappings,\n            apiv1,\n            apiv2,\n            **additional_parameters\n        )\n        api_mapping = APIMapping(apiv1, apiv2, differ)\n        mappings = api_mapping.map_api()\n\n        previous_mappings = mappings\n        previous_base_differ = (\n            differ\n            if differ.get_related_mappings() is None\n            else differ.previous_base_differ\n        )\n\n    if previous_mappings is not None:\n        migration = Migration(annotationsv1, previous_mappings)\n        migration.migrate_annotations()\n        migration.print(apiv1, apiv2)\n        migrated_annotations_file = Path(\n            os.path.join(\n                out_dir_path, \"migrated_annotationsv\" + apiv2.version + \".json\"\n            )\n        )\n        unsure_migrated_annotations_file = Path(\n            os.path.join(\n                out_dir_path, \"unsure_migrated_annotationsv\" + apiv2.version + \".json\"\n            )\n        )\n        _write_annotations_file(\n            migration.migrated_annotation_store, migrated_annotations_file\n        )\n        _write_annotations_file(\n            migration.unsure_migrated_annotation_store, unsure_migrated_annotations_file\n        )"
    },
    {
      "id": "package-parser/package_parser.cli._run_usages/_run_usages_command",
      "name": "_run_usages_command",
      "qname": "package_parser.cli._run_usages._run_usages_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_usages._run_usages_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/client_dir_path",
          "name": "client_dir_path",
          "qname": "package_parser.cli._run_usages._run_usages_command.client_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_usages._run_usages_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/n_processes",
          "name": "n_processes",
          "qname": "package_parser.cli._run_usages._run_usages_command.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/batch_size",
          "name": "batch_size",
          "qname": "package_parser.cli._run_usages._run_usages_command.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/result_dict",
          "name": "result_dict",
          "qname": "package_parser.cli._run_usages._run_usages_command.result_dict",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_usages_command(\n    package: str,\n    client_dir_path: Path,\n    out_dir_path: Path,\n    n_processes: int,\n    batch_size: int,\n    result_dict: Optional[dict] = None,\n) -> None:\n    usages = find_usages(package, client_dir_path, n_processes, batch_size)\n\n    out_file_usage_count = out_dir_path.joinpath(f\"{package}__usage_counts.json\")\n    ensure_file_exists(out_file_usage_count)\n    with out_file_usage_count.open(\"w\") as f:\n        json.dump(usages.to_json(), f, indent=2)\n\n    if result_dict is not None:\n        result_dict[_USAGES_KEY] = out_file_usage_count"
    },
    {
      "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/differ",
          "name": "differ",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/threshold_of_similarity_for_creation_of_mappings",
          "name": "threshold_of_similarity_for_creation_of_mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.threshold_of_similarity_for_creation_of_mappings",
          "default_value": "0.5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/threshold_of_similarity_between_mappings",
          "name": "threshold_of_similarity_between_mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.threshold_of_similarity_between_mappings",
          "default_value": "0.05",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/__init__/threshold_of_merging_mappings",
          "name": "threshold_of_merging_mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.__init__.threshold_of_merging_mappings",
          "default_value": "0.3",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        apiv1: API,\n        apiv2: API,\n        differ: AbstractDiffer,\n        threshold_of_similarity_for_creation_of_mappings: float = 0.5,\n        threshold_of_similarity_between_mappings: float = 0.05,\n        threshold_of_merging_mappings: float = 0.3,\n    ) -> None:\n        self.apiv1 = apiv1\n        self.apiv2 = apiv2\n        self.differ = differ\n        self.threshold_of_similarity_for_creation_of_mappings = (\n            threshold_of_similarity_for_creation_of_mappings\n        )\n        self.threshold_of_similarity_between_mappings = (\n            threshold_of_similarity_between_mappings\n        )\n        self.threshold_of_merging_mappings = threshold_of_merging_mappings"
    },
    {
      "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements",
      "name": "_get_mappings_for_api_elements",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements/api_elementv1_list",
          "name": "api_elementv1_list",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements.api_elementv1_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements/api_elementv2_list",
          "name": "api_elementv2_list",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements.api_elementv2_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_get_mappings_for_api_elements/compute_similarity",
          "name": "compute_similarity",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._get_mappings_for_api_elements.compute_similarity",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mappings_for_api_elements(\n        self,\n        api_elementv1_list: List[API_ELEMENTS],\n        api_elementv2_list: List[API_ELEMENTS],\n        compute_similarity: Callable[[API_ELEMENTS, API_ELEMENTS], float],\n    ) -> list[Mapping]:\n        element_mappings: list[Mapping] = []\n        for api_elementv1 in api_elementv1_list:\n            mapping_for_api_elementv1: list[Mapping] = []\n            for api_elementv2 in api_elementv2_list:\n                similarity = compute_similarity(api_elementv1, api_elementv2)\n                if similarity >= self.threshold_of_similarity_for_creation_of_mappings:\n                    mapping_for_api_elementv1.append(\n                        OneToOneMapping(similarity, api_elementv1, api_elementv2)\n                    )\n            mapping_for_api_elementv1.sort(key=Mapping.get_similarity, reverse=True)\n            new_mapping = self._merge_similar_mappings(mapping_for_api_elementv1)\n            if new_mapping is not None:\n                self._merge_mappings_with_same_elements(new_mapping, element_mappings)\n        return element_mappings"
    },
    {
      "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements",
      "name": "_merge_mappings_with_same_elements",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_mappings_with_same_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_mappings_with_same_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements/mapping_to_be_appended",
          "name": "mapping_to_be_appended",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_mappings_with_same_elements.mapping_to_be_appended",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_mappings_with_same_elements/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_mappings_with_same_elements.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This method prevents that an element in a mapping appears multiple times in a list of mappings\nby merging the affected mappings and include the result in the list. If there is no such element,\nthe mapping will be included without any merge.\n\n:param mapping_to_be_appended: the mapping that should be included in mappings\n:param mappings: the list, in which mapping_to_be_appended should be appended",
      "docstring": "This method prevents that an element in a mapping appears multiple times in a list of mappings\nby merging the affected mappings and include the result in the list. If there is no such element,\nthe mapping will be included without any merge.\n\n:param mapping_to_be_appended: the mapping that should be included in mappings\n:param mappings: the list, in which mapping_to_be_appended should be appended",
      "code": "    def _merge_mappings_with_same_elements(\n        self, mapping_to_be_appended: Mapping, mappings: list[Mapping]\n    ) -> None:\n        \"\"\"\n        This method prevents that an element in a mapping appears multiple times in a list of mappings\n        by merging the affected mappings and include the result in the list. If there is no such element,\n        the mapping will be included without any merge.\n\n        :param mapping_to_be_appended: the mapping that should be included in mappings\n        :param mappings: the list, in which mapping_to_be_appended should be appended\n        \"\"\"\n        duplicated: list[Mapping] = []\n        for mapping in mappings:\n            duplicated_element = False\n            for element in mapping.get_apiv2_elements():\n                for element_2 in mapping_to_be_appended.get_apiv2_elements():\n                    if element == element_2:\n                        duplicated_element = True\n                        break\n            if duplicated_element:\n                duplicated.append(mapping)\n\n        if len(duplicated) == 0:\n            mappings.append(mapping_to_be_appended)\n            return\n\n        for conflicted_mapping in duplicated:\n            mapping_to_be_appended = merge_mappings(\n                mapping_to_be_appended, conflicted_mapping\n            )\n            mappings.remove(conflicted_mapping)\n\n        mappings.append(mapping_to_be_appended)"
    },
    {
      "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_similar_mappings",
      "name": "_merge_similar_mappings",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_similar_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_similar_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_similar_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/_merge_similar_mappings/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping._merge_similar_mappings.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\nfrom this apiv1 element to apiv2 elements by merging the first and second elements recursively,\nif the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n:param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n:return: the first element of the sorted list that could be a result of merged similar mappings",
      "docstring": "Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\nfrom this apiv1 element to apiv2 elements by merging the first and second elements recursively,\nif the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n:param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n:return: the first element of the sorted list that could be a result of merged similar mappings",
      "code": "    def _merge_similar_mappings(self, mappings: List[Mapping]) -> Optional[Mapping]:\n        \"\"\"\n        Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\n        from this apiv1 element to apiv2 elements by merging the first and second elements recursively,\n        if the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n        :param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n        :return: the first element of the sorted list that could be a result of merged similar mappings\n        \"\"\"\n        if len(mappings) == 0:\n            return None\n        if len(mappings) == 1:\n            return mappings[0]\n        while (len(mappings) > 1) and (\n            (mappings[0].similarity - mappings[1].similarity)\n            < self.threshold_of_similarity_between_mappings\n        ):\n            mappings[0] = merge_mappings(mappings[0], mappings[1])\n            mappings.pop(1)\n        return mappings[0]"
    },
    {
      "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/map_api",
      "name": "map_api",
      "qname": "package_parser.processing.migration._api_mapping.APIMapping.map_api",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._api_mapping/APIMapping/map_api/self",
          "name": "self",
          "qname": "package_parser.processing.migration._api_mapping.APIMapping.map_api.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def map_api(self) -> List[Mapping]:\n        mappings: List[Mapping] = []\n        related_mappings = self.differ.get_related_mappings()\n        if related_mappings is not None:\n            for mapping in related_mappings:\n                new_mapping = None\n                if isinstance(\n                    mapping.get_apiv1_elements()[0], Attribute\n                ) and isinstance(mapping.get_apiv2_elements()[0], Attribute):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        self.differ.compute_attribute_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Class) and isinstance(\n                    mapping.get_apiv2_elements()[0], Class\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Class)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Class)\n                        ],\n                        self.differ.compute_class_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Function\n                ) and isinstance(mapping.get_apiv2_elements()[0], Function):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Function)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Function)\n                        ],\n                        self.differ.compute_function_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Parameter\n                ) and isinstance(mapping.get_apiv2_elements()[0], Parameter):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        self.differ.compute_parameter_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Result) and isinstance(\n                    mapping.get_apiv2_elements()[0], Result\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Result)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Result)\n                        ],\n                        self.differ.compute_result_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                if new_mapping is not None and len(new_mapping) > 0:\n                    self.differ.notify_new_mapping(new_mapping)\n        else:\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.classes.values()),\n                    list(self.apiv2.classes.values()),\n                    self.differ.compute_class_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.functions.values()),\n                    list(self.apiv2.functions.values()),\n                    self.differ.compute_function_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.parameters().values()),\n                    list(self.apiv2.parameters().values()),\n                    self.differ.compute_parameter_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        attribute\n                        for class_ in self.apiv1.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    [\n                        attribute\n                        for class_ in self.apiv2.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    self.differ.compute_attribute_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        result\n                        for function in self.apiv1.functions.values()\n                        for result in function.results\n                    ],\n                    [\n                        result\n                        for function in self.apiv2.functions.values()\n                        for result in function.results\n                    ],\n                    self.differ.compute_result_similarity,\n                )\n            )\n        mappings.extend(self.differ.get_additional_mappings())\n        mappings.sort(key=Mapping.get_similarity, reverse=True)\n        return mappings"
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration/__post_init__",
      "name": "__post_init__",
      "qname": "package_parser.processing.migration._migrate.Migration.__post_init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/__post_init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration.__post_init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __post_init__(self) -> None:\n        self.migrated_annotation_store = AnnotationStore()\n        self.unsure_migrated_annotation_store = AnnotationStore()"
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_mapping_from_annotation",
      "name": "_get_mapping_from_annotation",
      "qname": "package_parser.processing.migration._migrate.Migration._get_mapping_from_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_mapping_from_annotation/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._get_mapping_from_annotation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_mapping_from_annotation/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration._migrate.Migration._get_mapping_from_annotation.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mapping_from_annotation(\n        self, annotation: AbstractAnnotation\n    ) -> Optional[Mapping]:\n        for mapping in self.mappings:\n            for element in mapping.get_apiv1_elements():\n                if (\n                    not isinstance(element, (Attribute, Result))\n                    and element.id == annotation.target\n                ):\n                    return mapping\n        return None"
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_mappings_for_table",
      "name": "_get_mappings_for_table",
      "qname": "package_parser.processing.migration._migrate.Migration._get_mappings_for_table",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_mappings_for_table/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._get_mappings_for_table.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mappings_for_table(self) -> list[str]:\n        table_rows: list[str] = []\n        for mapping in self.mappings:\n\n            def print_api_element(\n                api_element: Union[Attribute, Class, Function, Parameter, Result]\n            ) -> str:\n                if isinstance(api_element, Result):\n                    return api_element.name\n                if isinstance(api_element, Attribute):\n                    return str(api_element.class_id) + \"/\" + api_element.name\n                return api_element.id\n\n            apiv1_elements = \", \".join(\n                [\n                    print_api_element(api_element)\n                    for api_element in mapping.get_apiv1_elements()\n                ]\n            )\n            apiv2_elements = \", \".join(\n                [\n                    print_api_element(api_element)\n                    for api_element in mapping.get_apiv2_elements()\n                ]\n            )\n            apiv1_elements = \"`\" + apiv1_elements + \"`\"\n            apiv2_elements = \"`\" + apiv2_elements + \"`\"\n            table_rows.append(\n                f\"{mapping.similarity:.4}|{apiv1_elements}|{apiv2_elements}|\"\n            )\n        return table_rows"
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string",
      "name": "_get_not_mapped_api_elements_as_string",
      "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_as_string",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_as_string.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string/api",
          "name": "api",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_as_string.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_as_string/print_for_apiv2",
          "name": "print_for_apiv2",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_as_string.print_for_apiv2",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_not_mapped_api_elements_as_string(\n        self, api: API, print_for_apiv2: bool = False\n    ) -> list[str]:\n        not_mapped_api_elements: list[str] = []\n\n        def is_included(\n            api_element: Union[Attribute, Class, Function, Parameter, Result]\n        ) -> bool:\n            if not print_for_apiv2:\n                for mapping in self.mappings:\n                    for element in mapping.get_apiv1_elements():\n                        if isinstance(api_element, Attribute) and isinstance(\n                            element, Attribute\n                        ):\n                            if element.name == api_element.name and isinstance(\n                                element.types, type(api_element.types)\n                            ):\n                                return True\n                        if isinstance(api_element, Result) and isinstance(\n                            element, Result\n                        ):\n                            if (\n                                element.name == api_element.name\n                                and element.docstring == api_element.docstring\n                            ):\n                                return True\n                        if not isinstance(\n                            api_element, (Attribute, Result)\n                        ) and not isinstance(element, (Attribute, Result)):\n                            if element.id == api_element.id:\n                                return True\n                return False\n            for mapping in self.mappings:\n                for element in mapping.get_apiv2_elements():\n                    if isinstance(api_element, Attribute) and isinstance(\n                        element, Attribute\n                    ):\n                        if element.name == api_element.name and isinstance(\n                            element.types, type(api_element.types)\n                        ):\n                            return True\n                    if isinstance(api_element, Result) and isinstance(element, Result):\n                        if (\n                            element.name == api_element.name\n                            and element.docstring == api_element.docstring\n                        ):\n                            return True\n                    if not isinstance(\n                        api_element, (Attribute, Result)\n                    ) and not isinstance(element, (Attribute, Result)):\n                        if element.id == api_element.id:\n                            return True\n            return False\n\n        for class_ in api.classes.values():\n            if not is_included(class_):\n                not_mapped_api_elements.append(class_.id)\n        for function in api.functions.values():\n            if not is_included(function):\n                not_mapped_api_elements.append(function.id)\n        for parameter in api.parameters().values():\n            if not is_included(parameter):\n                not_mapped_api_elements.append(parameter.id)\n        for attribute, class_ in [\n            (attribute, class_)\n            for class_ in api.classes.values()\n            for attribute in class_.instance_attributes\n        ]:\n            if not is_included(attribute):\n                not_mapped_api_elements.append(class_.id + \"/\" + attribute.name)\n        for result, function in [\n            (result, function)\n            for function in api.functions.values()\n            for result in function.results\n        ]:\n            if not is_included(result):\n                not_mapped_api_elements.append(function.id + \"/\" + result.name)\n        return not_mapped_api_elements"
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table",
      "name": "_get_not_mapped_api_elements_for_table",
      "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_for_table",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_for_table.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_for_table.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_get_not_mapped_api_elements_for_table/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration._migrate.Migration._get_not_mapped_api_elements_for_table.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_not_mapped_api_elements_for_table(\n        self, apiv1: API, apiv2: API\n    ) -> list[str]:\n        not_mapped_api_elements: list[str] = []\n        not_mapped_apiv1_elements = self._get_not_mapped_api_elements_as_string(apiv1)\n        for element_id in not_mapped_apiv1_elements:\n            not_mapped_api_elements.append(f\"-|`{element_id}`||\")\n        not_mapped_apiv2_elements = self._get_not_mapped_api_elements_as_string(\n            apiv2, print_for_apiv2=True\n        )\n        for element_id in not_mapped_apiv2_elements:\n            not_mapped_api_elements.append(f\"-||`{element_id}`|\")\n        return not_mapped_api_elements"
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration/_handle_duplicates",
      "name": "_handle_duplicates",
      "qname": "package_parser.processing.migration._migrate.Migration._handle_duplicates",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/_handle_duplicates/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration._handle_duplicates.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _handle_duplicates(self) -> None:\n        for annotation_type in [\n            \"boundaryAnnotations\",\n            \"calledAfterAnnotations\",\n            \"descriptionAnnotations\",\n            \"enumAnnotations\",\n            \"expertAnnotations\",\n            \"groupAnnotations\",\n            \"moveAnnotations\",\n            \"pureAnnotations\",\n            \"removeAnnotations\",\n            \"renameAnnotations\",\n            \"todoAnnotations\",\n            \"valueAnnotations\",\n        ]:\n            migrated_annotations = [\n                annotation\n                for annotation_store in [\n                    self.migrated_annotation_store,\n                    self.unsure_migrated_annotation_store,\n                ]\n                for annotation in getattr(annotation_store, annotation_type)\n            ]\n            duplicates_dict: dict[str, list[AbstractAnnotation]] = {}\n            for duplicated_annotations in migrated_annotations:\n                if duplicated_annotations.target in duplicates_dict:\n                    duplicates_dict[duplicated_annotations.target].append(\n                        duplicated_annotations\n                    )\n                    continue\n                for annotation in migrated_annotations:\n                    if (\n                        duplicated_annotations is annotation\n                        or annotation.target in duplicates_dict\n                    ):\n                        continue\n                    if (\n                        isinstance(annotation, type(duplicated_annotations))\n                        and annotation.target == duplicated_annotations.target\n                    ):\n                        duplicates = duplicates_dict.get(annotation.target, [])\n                        duplicates.append(annotation)\n                        duplicates.append(duplicated_annotations)\n                        duplicates_dict[duplicated_annotations.target] = duplicates\n                        break\n\n            for duplicates in duplicates_dict.values():\n                if len(duplicates) > 1:\n                    duplicates = sorted(\n                        duplicates, key=lambda annotation: annotation.reviewResult.name\n                    )\n                    different_values = set()\n                    first_annotation_and_value: Optional[\n                        tuple[AbstractAnnotation, str]\n                    ] = None\n                    for annotation in duplicates:\n                        annotation_dict = annotation.to_json()\n                        for key in [\n                            \"target\",\n                            \"authors\",\n                            \"reviewers\",\n                            \"comment\",\n                            \"reviewResult\",\n                        ]:\n                            del annotation_dict[key]\n                        annotation_value = str(annotation_dict)\n                        if first_annotation_and_value is None:\n                            first_annotation_and_value = annotation, annotation_value\n                        different_values.add(annotation_value)\n\n                    if first_annotation_and_value is not None:\n                        first_annotation, first_value = first_annotation_and_value\n                        if len(different_values) > 1:\n                            different_values.remove(first_value)\n                            comment = (\n                                \"Conflicting Attribute during migration: \"\n                                + \", \".join(sorted(different_values))\n                            )\n                            first_annotation.comment = (\n                                \"\\n\".join([comment, first_annotation.comment])\n                                if len(first_annotation.comment) > 0\n                                else comment\n                            )\n                            first_annotation.reviewResult = EnumReviewResult.UNSURE\n                        for annotation_store in [\n                            self.migrated_annotation_store,\n                            self.unsure_migrated_annotation_store,\n                        ]:\n                            for annotation in duplicates:\n                                if annotation is first_annotation:\n                                    continue\n                                annotations: list[AbstractAnnotation] = getattr(\n                                    annotation_store, annotation_type\n                                )\n                                if annotation in annotations:\n                                    annotations.remove(annotation)"
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity",
      "name": "add_annotations_based_on_similarity",
      "qname": "package_parser.processing.migration._migrate.Migration.add_annotations_based_on_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration.add_annotations_based_on_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration._migrate.Migration.add_annotations_based_on_similarity.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/add_annotations_based_on_similarity/similarity",
          "name": "similarity",
          "qname": "package_parser.processing.migration._migrate.Migration.add_annotations_based_on_similarity.similarity",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_annotations_based_on_similarity(\n        self, annotation: AbstractAnnotation, similarity: float\n    ) -> None:\n        if similarity >= self.reliable_similarity:\n            self.migrated_annotation_store.add_annotation(annotation)\n        elif similarity >= self.unsure_similarity:\n            annotation.reviewResult = EnumReviewResult.UNSURE\n            self.migrated_annotation_store.add_annotation(annotation)\n        else:\n            self.unsure_migrated_annotation_store.add_annotation(annotation)"
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration/migrate_annotations",
      "name": "migrate_annotations",
      "qname": "package_parser.processing.migration._migrate.Migration.migrate_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/migrate_annotations/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration.migrate_annotations.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def migrate_annotations(self) -> None:\n        for boundary_annotation in self.annotationsv1.boundaryAnnotations:\n            mapping = self._get_mapping_from_annotation(boundary_annotation)\n            if mapping is not None:\n                for annotation in migrate_boundary_annotation(\n                    boundary_annotation, mapping\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for called_after_annotation in self.annotationsv1.calledAfterAnnotations:\n            mapping = self._get_mapping_from_annotation(called_after_annotation)\n            if mapping is not None:\n                for annotation in migrate_called_after_annotation(\n                    called_after_annotation, mapping, self.mappings\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for description_annotation in self.annotationsv1.descriptionAnnotations:\n            mapping = self._get_mapping_from_annotation(description_annotation)\n            if mapping is not None:\n                for annotation in migrate_description_annotation(\n                    description_annotation, mapping\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for enum_annotation in self.annotationsv1.enumAnnotations:\n            mapping = self._get_mapping_from_annotation(enum_annotation)\n            if mapping is not None:\n                for annotation in migrate_enum_annotation(enum_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for expert_annotation in self.annotationsv1.expertAnnotations:\n            mapping = self._get_mapping_from_annotation(expert_annotation)\n            if mapping is not None:\n                for annotation in migrate_expert_annotation(expert_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for group_annotation in self.annotationsv1.groupAnnotations:\n            mapping = self._get_mapping_from_annotation(group_annotation)\n            if mapping is not None:\n                for annotation in migrate_group_annotation(\n                    group_annotation, mapping, self.mappings\n                ):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for move_annotation in self.annotationsv1.moveAnnotations:\n            mapping = self._get_mapping_from_annotation(move_annotation)\n            if mapping is not None:\n                for annotation in migrate_move_annotation(move_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for rename_annotation in self.annotationsv1.renameAnnotations:\n            mapping = self._get_mapping_from_annotation(rename_annotation)\n            if mapping is not None:\n                for annotation in migrate_rename_annotation(rename_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for remove_annotation in self.annotationsv1.removeAnnotations:\n            mapping = self._get_mapping_from_annotation(remove_annotation)\n            if mapping is not None:\n                for annotation in migrate_remove_annotation(remove_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for todo_annotation in self.annotationsv1.todoAnnotations:\n            mapping = self._get_mapping_from_annotation(todo_annotation)\n            if mapping is not None:\n                for annotation in migrate_todo_annotation(todo_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n\n        for value_annotation in self.annotationsv1.valueAnnotations:\n            mapping = self._get_mapping_from_annotation(value_annotation)\n            if mapping is not None:\n                for annotation in migrate_value_annotation(value_annotation, mapping):\n                    self.add_annotations_based_on_similarity(\n                        annotation, mapping.get_similarity()\n                    )\n        self._handle_duplicates()"
    },
    {
      "id": "package-parser/package_parser.processing.migration._migrate/Migration/print",
      "name": "print",
      "qname": "package_parser.processing.migration._migrate.Migration.print",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/print/self",
          "name": "self",
          "qname": "package_parser.processing.migration._migrate.Migration.print.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/print/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration._migrate.Migration.print.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration._migrate/Migration/print/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration._migrate.Migration.print.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print(self, apiv1: API, apiv2: API) -> None:\n        print(\n            \"**Similarity**|**APIV1**|**APIV2**|**comment**\\n:-----:|:-----:|:-----:|:----:|\"\n        )\n        table_body = self._get_mappings_for_table()\n        table_body.extend(self._get_not_mapped_api_elements_for_table(apiv1, apiv2))\n        table_body.sort(\n            key=lambda row: max(len(cell.split(\"/\")) for cell in row.split(\"|\")[:-1])\n        )\n        print(\"\\n\".join(table_body))"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element",
      "name": "get_annotated_api_element",
      "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element/api_element_list",
          "name": "api_element_list",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element.api_element_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_annotated_api_element(\n    annotation: AbstractAnnotation,\n    api_element_list: List[Union[Attribute, Class, Function, Parameter, Result]],\n) -> Optional[Union[Class, Function, Parameter]]:\n    for element in api_element_list:\n        if (\n            isinstance(element, (Class, Function, Parameter))\n            and element.id == annotation.target\n        ):\n            return element\n    return None"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element_by_type",
      "name": "get_annotated_api_element_by_type",
      "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element_by_type",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element_by_type/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element_by_type.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element_by_type/api_element_list",
          "name": "api_element_list",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element_by_type.api_element_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_annotated_api_element/get_annotated_api_element_by_type/api_type",
          "name": "api_type",
          "qname": "package_parser.processing.migration.annotations._get_annotated_api_element.get_annotated_api_element_by_type.api_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_annotated_api_element_by_type(\n    annotation: AbstractAnnotation,\n    api_element_list: List[Union[Attribute, Class, Function, Parameter, Result]],\n    api_type: type[API_ELEMENTS],\n) -> Optional[API_ELEMENTS]:\n    for element in api_element_list:\n        if isinstance(element, api_type) and element.id == annotation.target:\n            return element\n    return None"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._get_migration_text/_get_further_information",
      "name": "_get_further_information",
      "qname": "package_parser.processing.migration.annotations._get_migration_text._get_further_information",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_migration_text/_get_further_information/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._get_migration_text._get_further_information.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_further_information(annotation: AbstractAnnotation) -> str:\n    if isinstance(\n        annotation,\n        (CompleteAnnotation, ExpertAnnotation, PureAnnotation, RemoveAnnotation),\n    ):\n        return \"\"\n    if isinstance(annotation, BoundaryAnnotation):\n        return \" with the interval '\" + str(annotation.interval.to_json()) + \"'\"\n    if isinstance(annotation, CalledAfterAnnotation):\n        return (\n            \" with the method '\"\n            + annotation.calledAfterName\n            + \"' that should be called before\"\n        )\n    if isinstance(annotation, DescriptionAnnotation):\n        return \" with the new description '\" + annotation.newDescription + \"'\"\n    if isinstance(annotation, EnumAnnotation):\n        return (\n            \" with the new enum '\"\n            + annotation.enumName\n            + \" (\"\n            + \", \".join(\n                map(\n                    lambda enum_pair: enum_pair.stringValue\n                    + \", \"\n                    + enum_pair.instanceName,\n                    annotation.pairs,\n                )\n            )\n            + \")'\"\n        )\n    if isinstance(annotation, GroupAnnotation):\n        return (\n            \" with the group name '\"\n            + annotation.groupName\n            + \"' and the grouped parameters: '\"\n            + \", \".join(annotation.parameters)\n            + \"'\"\n        )\n    if isinstance(annotation, MoveAnnotation):\n        return \" with the destination: '\" + annotation.destination + \"'\"\n    if isinstance(annotation, RenameAnnotation):\n        return \" with the new name '\" + annotation.newName + \"'\"\n    if isinstance(annotation, TodoAnnotation):\n        return \" with the todo '\" + annotation.newTodo + \"'\"\n    if isinstance(annotation, ValueAnnotation):\n        value = \" with the variant '\" + annotation.variant.value\n        if isinstance(annotation, (ConstantAnnotation, OptionalAnnotation)):\n            value += (\n                \"' and the default Value '\"\n                + str(annotation.defaultValue)\n                + \" ( type: \"\n                + str(annotation.defaultValueType.value)\n                + \" )\"\n            )\n        value += \"'\"\n        return value\n    return \" with the data '\" + str(annotation.to_json()) + \"'\""
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._get_migration_text/_list_api_elements",
      "name": "_list_api_elements",
      "qname": "package_parser.processing.migration.annotations._get_migration_text._list_api_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_migration_text/_list_api_elements/api_elements",
          "name": "api_elements",
          "qname": "package_parser.processing.migration.annotations._get_migration_text._list_api_elements.api_elements",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _list_api_elements(\n    api_elements: Sequence[Attribute | Class | Function | Parameter | Result],\n) -> str:\n    return \", \".join(\n        map(\n            lambda api_element: api_element.id\n            if hasattr(api_element, \"id\")\n            else api_element.name,\n            api_elements,\n        )\n    )"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text",
      "name": "get_migration_text",
      "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text/for_todo_annotation",
          "name": "for_todo_annotation",
          "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text.for_todo_annotation",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._get_migration_text/get_migration_text/additional_information",
          "name": "additional_information",
          "qname": "package_parser.processing.migration.annotations._get_migration_text.get_migration_text.additional_information",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_migration_text(\n    annotation: AbstractAnnotation,\n    mapping: Mapping,\n    for_todo_annotation: bool = False,\n    additional_information: Any = None,\n) -> str:\n    class_name = str(annotation.__class__.__name__)\n    if class_name.endswith(\"Annotation\"):\n        class_name = class_name[:-10]\n    if issubclass(type(annotation), ValueAnnotation):\n        class_name = \"Value\"\n    migrate_text = (\n        \"The @\" + class_name + \" Annotation\" + _get_further_information(annotation)\n    )\n    migrate_text += (\n        \" from the previous version was at '\"\n        + annotation.target\n        + \"' and the possible alternatives in the new version of the api are: \"\n        + _list_api_elements(mapping.get_apiv2_elements())\n    )\n    if additional_information is not None and isinstance(additional_information, list):\n        functions = [\n            function\n            for function in additional_information\n            if isinstance(function, Function)\n        ]\n        if len(functions) > 0:\n            migrate_text += (\n                \" and the possible replacements (\" + _list_api_elements(functions) + \")\"\n            )\n\n        parameters = [\n            parameter\n            for parameter in additional_information\n            if isinstance(parameter, Parameter)\n        ]\n        if len(parameters) > 0:\n            migrate_text += (\n                \" and the possible replacements (\"\n                + _list_api_elements(parameters)\n                + \")\"\n            )\n    migration_text = migrate_text\n    if for_todo_annotation:\n        return migration_text\n    if len(annotation.comment) == 0:\n        return migration_text\n    return annotation.comment + \"\\n\" + migration_text"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/_contains_number_and_is_discrete",
      "name": "_contains_number_and_is_discrete",
      "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation._contains_number_and_is_discrete",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/_contains_number_and_is_discrete/type_",
          "name": "type_",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation._contains_number_and_is_discrete.type_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _contains_number_and_is_discrete(\n    type_: Optional[AbstractType],\n) -> Tuple[bool, bool]:\n    if type_ is None:\n        return False, False\n    if isinstance(type_, NamedType):\n        return type_.name in (\"int\", \"float\"), type_.name == \"int\"\n    if isinstance(type_, UnionType):\n        for element in type_.types:\n            is_number, is_discrete = _contains_number_and_is_discrete(element)\n            if is_number:\n                return is_number, is_discrete\n    return False, False"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_boundary_annotation",
      "name": "migrate_boundary_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_boundary_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_boundary_annotation/boundary_annotation",
          "name": "boundary_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_boundary_annotation.boundary_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_boundary_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_boundary_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_boundary_annotation(\n    boundary_annotation: BoundaryAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    boundary_annotation = deepcopy(boundary_annotation)\n    authors = boundary_annotation.authors\n    authors.append(migration_author)\n    boundary_annotation.authors = authors\n\n    annotated_apiv1_element = get_annotated_api_element(\n        boundary_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None or not isinstance(\n        annotated_apiv1_element, Parameter\n    ):\n        return []\n\n    if isinstance(mapping, (OneToOneMapping, ManyToOneMapping)):\n        parameter = mapping.get_apiv2_elements()[0]\n        if isinstance(parameter, (Attribute, Result)):\n            return []\n        if isinstance(parameter, Parameter):\n            (\n                parameter_expects_number,\n                parameter_type_is_discrete,\n            ) = _contains_number_and_is_discrete(parameter.type)\n            if parameter.type is None and annotated_apiv1_element.type is not None:\n                boundary_annotation.reviewResult = EnumReviewResult.UNSURE\n                boundary_annotation.comment = get_migration_text(\n                    boundary_annotation, mapping\n                )\n                boundary_annotation.target = parameter.id\n                return [boundary_annotation]\n            if parameter_expects_number or (\n                parameter.type is None and annotated_apiv1_element.type is None\n            ):\n                if (\n                    parameter_type_is_discrete\n                    != boundary_annotation.interval.isDiscrete\n                ) and not (\n                    parameter.type is None and annotated_apiv1_element.type is None\n                ):\n                    boundary_annotation.reviewResult = EnumReviewResult.UNSURE\n                    boundary_annotation.comment = get_migration_text(\n                        boundary_annotation, mapping\n                    )\n                    if parameter_expects_number:\n                        boundary_annotation.interval = (\n                            migrate_interval_to_fit_parameter_type(\n                                boundary_annotation.interval, parameter_type_is_discrete\n                            )\n                        )\n                boundary_annotation.target = parameter.id\n                return [boundary_annotation]\n        return [\n            TodoAnnotation(\n                parameter.id,\n                authors,\n                boundary_annotation.reviewers,\n                boundary_annotation.comment,\n                EnumReviewResult.NONE,\n                get_migration_text(\n                    boundary_annotation, mapping, for_todo_annotation=True\n                ),\n            )\n        ]\n    migrated_annotations: list[AbstractAnnotation] = []\n    if isinstance(mapping, (OneToManyMapping, ManyToManyMapping)):\n        for parameter in mapping.get_apiv2_elements():\n            if isinstance(parameter, Parameter):\n                is_number, is_discrete = _contains_number_and_is_discrete(\n                    parameter.type\n                )\n                if (\n                    parameter.type is not None\n                    and is_number\n                    and is_discrete == boundary_annotation.interval.isDiscrete\n                ) or (parameter.type is None and annotated_apiv1_element.type is None):\n                    migrated_annotations.append(\n                        BoundaryAnnotation(\n                            parameter.id,\n                            authors,\n                            boundary_annotation.reviewers,\n                            boundary_annotation.comment,\n                            EnumReviewResult.NONE,\n                            boundary_annotation.interval,\n                        )\n                    )\n                elif parameter.type is not None and is_number:\n                    migrated_annotations.append(\n                        BoundaryAnnotation(\n                            parameter.id,\n                            authors,\n                            boundary_annotation.reviewers,\n                            get_migration_text(boundary_annotation, mapping),\n                            EnumReviewResult.UNSURE,\n                            migrate_interval_to_fit_parameter_type(\n                                boundary_annotation.interval,\n                                is_discrete,\n                            ),\n                        )\n                    )\n                elif parameter.type is None:\n                    migrated_annotations.append(\n                        BoundaryAnnotation(\n                            parameter.id,\n                            authors,\n                            boundary_annotation.reviewers,\n                            get_migration_text(boundary_annotation, mapping),\n                            EnumReviewResult.UNSURE,\n                            boundary_annotation.interval,\n                        )\n                    )\n                continue\n            if not isinstance(parameter, (Attribute, Result)):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        parameter.id,\n                        authors,\n                        boundary_annotation.reviewers,\n                        boundary_annotation.comment,\n                        EnumReviewResult.NONE,\n                        get_migration_text(\n                            boundary_annotation, mapping, for_todo_annotation=True\n                        ),\n                    )\n                )\n    return migrated_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_interval_to_fit_parameter_type",
      "name": "migrate_interval_to_fit_parameter_type",
      "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_interval_to_fit_parameter_type",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_interval_to_fit_parameter_type/intervalv1",
          "name": "intervalv1",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_interval_to_fit_parameter_type.intervalv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_boundary_annotation/migrate_interval_to_fit_parameter_type/is_discrete",
          "name": "is_discrete",
          "qname": "package_parser.processing.migration.annotations._migrate_boundary_annotation.migrate_interval_to_fit_parameter_type.is_discrete",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_interval_to_fit_parameter_type(\n    intervalv1: Interval, is_discrete: bool\n) -> Interval:\n    intervalv2 = deepcopy(intervalv1)\n    if intervalv2.isDiscrete == is_discrete:\n        return intervalv2\n    if is_discrete:\n        intervalv2.isDiscrete = True\n        if intervalv1.upperLimitType in (0, 1):\n            intervalv2.upperIntervalLimit = int(intervalv1.upperIntervalLimit)\n            intervalv2.upperLimitType = 1\n            if intervalv2.upperIntervalLimit == intervalv1.upperIntervalLimit:\n                intervalv2.upperLimitType = intervalv1.upperLimitType\n        if intervalv1.lowerLimitType in (0, 1):\n            intervalv2.lowerIntervalLimit = int(intervalv1.lowerIntervalLimit)\n            intervalv2.lowerLimitType = 1\n            if intervalv2.lowerIntervalLimit == intervalv1.lowerIntervalLimit:\n                intervalv2.lowerLimitType = intervalv1.lowerLimitType\n            else:\n                intervalv2.lowerIntervalLimit += 1\n    else:\n        intervalv2.isDiscrete = False\n        if intervalv1.upperLimitType in (0, 1):\n            intervalv2.upperIntervalLimit = float(intervalv1.upperIntervalLimit)\n        if intervalv1.lowerLimitType in (0, 1):\n            intervalv2.lowerIntervalLimit = float(intervalv1.lowerIntervalLimit)\n    return intervalv2"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/_get_function_called_before_replacements",
      "name": "_get_function_called_before_replacements",
      "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation._get_function_called_before_replacements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/_get_function_called_before_replacements/called_after_annotation",
          "name": "called_after_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation._get_function_called_before_replacements.called_after_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/_get_function_called_before_replacements/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation._get_function_called_before_replacements.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/_get_function_called_before_replacements/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation._get_function_called_before_replacements.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_function_called_before_replacements(\n    called_after_annotation: CalledAfterAnnotation,\n    mappings: list[Mapping],\n    functionv2: Function,\n) -> list[Function]:\n    called_before_idv1 = (\n        \"/\".join(called_after_annotation.target.split(\"/\")[:-1])\n        + \"/\"\n        + called_after_annotation.calledAfterName\n    )\n    called_before_idv2_prefix = \"/\".join(functionv2.id.split(\"/\")[:-1]) + \"/\"\n    functions_in_same_class: list[Function] = []\n    for mapping in mappings:\n        found_mapped_function_in_same_class = False\n        for element in mapping.get_apiv1_elements():\n            if isinstance(element, Function) and called_before_idv1 == element.id:\n                found_mapped_function_in_same_class = True\n                break\n\n        if found_mapped_function_in_same_class:\n            for replacement in mapping.get_apiv2_elements():\n                if isinstance(replacement, Function) and replacement.id.startswith(\n                    called_before_idv2_prefix\n                ):\n                    functions_in_same_class.append(replacement)\n            break\n    return functions_in_same_class"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/migrate_called_after_annotation",
      "name": "migrate_called_after_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation.migrate_called_after_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/migrate_called_after_annotation/called_after_annotation",
          "name": "called_after_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation.migrate_called_after_annotation.called_after_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/migrate_called_after_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation.migrate_called_after_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_called_after_annotation/migrate_called_after_annotation/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.annotations._migrate_called_after_annotation.migrate_called_after_annotation.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_called_after_annotation(\n    called_after_annotation: CalledAfterAnnotation,\n    mapping: Mapping,\n    mappings: list[Mapping],\n) -> list[AbstractAnnotation]:\n    called_after_annotation = deepcopy(called_after_annotation)\n    authors = called_after_annotation.authors\n    authors.append(migration_author)\n    called_after_annotation.authors = authors\n\n    migrated_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if not isinstance(element, Function):\n            if not isinstance(element, (Attribute, Result)):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        element.id,\n                        authors,\n                        called_after_annotation.reviewers,\n                        called_after_annotation.comment,\n                        EnumReviewResult.NONE,\n                        get_migration_text(\n                            called_after_annotation, mapping, for_todo_annotation=True\n                        ),\n                    )\n                )\n            continue\n\n        called_before_functions = _get_function_called_before_replacements(\n            called_after_annotation, mappings, element\n        )\n        if len(called_before_functions) == 0:\n            migrated_annotations.append(\n                CalledAfterAnnotation(\n                    element.id,\n                    authors,\n                    called_after_annotation.reviewers,\n                    get_migration_text(\n                        called_after_annotation,\n                        mapping,\n                        additional_information=called_before_functions,\n                    ),\n                    EnumReviewResult.UNSURE,\n                    called_after_annotation.calledAfterName,\n                )\n            )\n        elif (\n            len(called_before_functions) == 1 and called_before_functions[0] != element\n        ):\n            migrated_annotations.append(\n                CalledAfterAnnotation(\n                    element.id,\n                    authors,\n                    called_after_annotation.reviewers,\n                    called_after_annotation.comment,\n                    called_after_annotation.reviewResult,\n                    called_before_functions[0].name,\n                )\n            )\n        else:\n            migrated_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    called_after_annotation.reviewers,\n                    called_after_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        called_after_annotation,\n                        mapping,\n                        for_todo_annotation=True,\n                        additional_information=called_before_functions,\n                    ),\n                )\n            )\n    return migrated_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_description_annotation/migrate_description_annotation",
      "name": "migrate_description_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_description_annotation.migrate_description_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_description_annotation/migrate_description_annotation/description_annotation",
          "name": "description_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_description_annotation.migrate_description_annotation.description_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_description_annotation/migrate_description_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_description_annotation.migrate_description_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_description_annotation(\n    description_annotation: DescriptionAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    description_annotation = deepcopy(description_annotation)\n    authors = description_annotation.authors\n    authors.append(migration_author)\n    description_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        description_annotation.target = element.id\n        return [description_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        description_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    description_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if isinstance(element, type(annotated_apiv1_element)) and not isinstance(\n            element, (Attribute, Result)\n        ):\n            description_annotations.append(\n                DescriptionAnnotation(\n                    element.id,\n                    authors,\n                    description_annotation.reviewers,\n                    description_annotation.comment,\n                    EnumReviewResult.NONE,\n                    newDescription=description_annotation.newDescription,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            description_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    description_annotation.reviewers,\n                    description_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        description_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return description_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_contains_string",
      "name": "_contains_string",
      "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._contains_string",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_contains_string/type_",
          "name": "type_",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._contains_string.type_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _contains_string(type_: AbstractType) -> bool:\n    if isinstance(type_, NamedType):\n        return type_.name == \"str\"\n    if isinstance(type_, UnionType):\n        for element in type_.types:\n            if _contains_string(element):\n                return True\n    return False"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_default_value_is_in_instance_values_or_is_empty",
      "name": "_default_value_is_in_instance_values_or_is_empty",
      "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._default_value_is_in_instance_values_or_is_empty",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_default_value_is_in_instance_values_or_is_empty/default_value",
          "name": "default_value",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._default_value_is_in_instance_values_or_is_empty.default_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/_default_value_is_in_instance_values_or_is_empty/pairs",
          "name": "pairs",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation._default_value_is_in_instance_values_or_is_empty.pairs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _default_value_is_in_instance_values_or_is_empty(\n    default_value: Optional[str], pairs: List[EnumPair]\n) -> bool:\n    return (\n        default_value is None\n        or default_value in map(lambda pair: pair.stringValue, pairs)\n        or len(default_value) == 0\n    )"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/migrate_enum_annotation",
      "name": "migrate_enum_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation.migrate_enum_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/migrate_enum_annotation/enum_annotation",
          "name": "enum_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation.migrate_enum_annotation.enum_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_enum_annotation/migrate_enum_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_enum_annotation.migrate_enum_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_enum_annotation(\n    enum_annotation: EnumAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    enum_annotation = deepcopy(enum_annotation)\n    authors = enum_annotation.authors\n    authors.append(migration_author)\n    enum_annotation.authors = authors\n\n    annotated_apiv1_element = get_annotated_api_element(\n        enum_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None or not isinstance(\n        annotated_apiv1_element, Parameter\n    ):\n        return []\n\n    if isinstance(mapping, (OneToOneMapping, ManyToOneMapping)):\n        parameter = mapping.get_apiv2_elements()[0]\n        if isinstance(parameter, (Attribute, Result)):\n            return []\n        if isinstance(parameter, Parameter):\n            if (\n                parameter.type is not None\n                and _contains_string(parameter.type)\n                and _default_value_is_in_instance_values_or_is_empty(\n                    parameter.default_value, enum_annotation.pairs\n                )\n            ) or (parameter.type is None and annotated_apiv1_element.type is None):\n                enum_annotation.target = parameter.id\n                return [enum_annotation]\n            if isinstance(parameter.type, NamedType):\n                # assuming api has been chanced to an enum type:\n                # do not migrate annotation\n                return []\n            enum_annotation.reviewResult = EnumReviewResult.UNSURE\n            enum_annotation.comment = get_migration_text(enum_annotation, mapping)\n            enum_annotation.target = parameter.id\n            return [enum_annotation]\n        return [\n            TodoAnnotation(\n                parameter.id,\n                authors,\n                enum_annotation.reviewers,\n                enum_annotation.comment,\n                EnumReviewResult.NONE,\n                get_migration_text(enum_annotation, mapping, for_todo_annotation=True),\n            )\n        ]\n\n    migrated_annotations: list[AbstractAnnotation] = []\n    if isinstance(mapping, (OneToManyMapping, ManyToManyMapping)):\n        for parameter in mapping.get_apiv2_elements():\n            if isinstance(parameter, Parameter):\n                if (\n                    parameter.type is not None\n                    and _contains_string(parameter.type)\n                    and _default_value_is_in_instance_values_or_is_empty(\n                        parameter.default_value, enum_annotation.pairs\n                    )\n                ) or (parameter.type is None and annotated_apiv1_element.type is None):\n                    migrated_annotations.append(\n                        EnumAnnotation(\n                            parameter.id,\n                            authors,\n                            enum_annotation.reviewers,\n                            enum_annotation.comment,\n                            EnumReviewResult.NONE,\n                            enum_annotation.enumName,\n                            enum_annotation.pairs,\n                        )\n                    )\n                    continue\n                if isinstance(parameter.type, NamedType):\n                    continue\n                migrated_annotations.append(\n                    EnumAnnotation(\n                        parameter.id,\n                        authors,\n                        enum_annotation.reviewers,\n                        get_migration_text(enum_annotation, mapping),\n                        EnumReviewResult.UNSURE,\n                        enum_annotation.enumName,\n                        enum_annotation.pairs,\n                    )\n                )\n            elif not isinstance(parameter, (Attribute, Result)):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        parameter.id,\n                        authors,\n                        enum_annotation.reviewers,\n                        enum_annotation.comment,\n                        EnumReviewResult.NONE,\n                        get_migration_text(\n                            enum_annotation, mapping, for_todo_annotation=True\n                        ),\n                    )\n                )\n    return migrated_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_expert_annotation/migrate_expert_annotation",
      "name": "migrate_expert_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_expert_annotation.migrate_expert_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_expert_annotation/migrate_expert_annotation/expert_annotation",
          "name": "expert_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_expert_annotation.migrate_expert_annotation.expert_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_expert_annotation/migrate_expert_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_expert_annotation.migrate_expert_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_expert_annotation(\n    expert_annotation: ExpertAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    expert_annotation = deepcopy(expert_annotation)\n    authors = expert_annotation.authors\n    authors.append(migration_author)\n    expert_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        expert_annotation.target = element.id\n        return [expert_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        expert_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    expert_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if isinstance(element, type(annotated_apiv1_element)) and not isinstance(\n            element, (Attribute, Result)\n        ):\n            expert_annotations.append(\n                ExpertAnnotation(\n                    element.id,\n                    authors,\n                    expert_annotation.reviewers,\n                    expert_annotation.comment,\n                    EnumReviewResult.NONE,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            expert_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    expert_annotation.reviewers,\n                    expert_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        expert_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return expert_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_group_annotation/_get_mappings_for_grouped_parameters",
      "name": "_get_mappings_for_grouped_parameters",
      "qname": "package_parser.processing.migration.annotations._migrate_group_annotation._get_mappings_for_grouped_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_group_annotation/_get_mappings_for_grouped_parameters/group_annotation",
          "name": "group_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation._get_mappings_for_grouped_parameters.group_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_group_annotation/_get_mappings_for_grouped_parameters/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation._get_mappings_for_grouped_parameters.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_group_annotation/_get_mappings_for_grouped_parameters/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation._get_mappings_for_grouped_parameters.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_mappings_for_grouped_parameters(\n    group_annotation: GroupAnnotation, mappings: list[Mapping], functionv2: Function\n) -> list[list[Parameter]]:\n    parameter_ids = [\n        group_annotation.target + \"/\" + parameter_name\n        for parameter_name in group_annotation.parameters\n    ]\n\n    matched_parameters: list[list[Parameter]] = []\n    for parameter_id in parameter_ids:\n        for mapping in mappings:\n            for parameterv1 in mapping.get_apiv1_elements():\n                if (\n                    isinstance(parameterv1, Parameter)\n                    and parameterv1.id == parameter_id\n                ):\n                    mapped_parameters: list[Parameter] = []\n                    for parameterv2 in mapping.get_apiv2_elements():\n                        if isinstance(\n                            parameterv2, Parameter\n                        ) and parameterv2.id.startswith(functionv2.id + \"/\"):\n                            mapped_parameters.append(parameterv2)\n                    matched_parameters.append(mapped_parameters)\n                    break\n    return matched_parameters"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_group_annotation/migrate_group_annotation",
      "name": "migrate_group_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_group_annotation.migrate_group_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_group_annotation/migrate_group_annotation/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation.migrate_group_annotation.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_group_annotation/migrate_group_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation.migrate_group_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_group_annotation/migrate_group_annotation/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.annotations._migrate_group_annotation.migrate_group_annotation.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_group_annotation(\n    annotation: GroupAnnotation, mapping: Mapping, mappings: list[Mapping]\n) -> list[AbstractAnnotation]:\n    group_annotation = deepcopy(annotation)\n    authors = group_annotation.authors\n    authors.append(migration_author)\n    group_annotation.authors = authors\n\n    migrated_annotations: list[AbstractAnnotation] = []\n\n    for functionv2 in mapping.get_apiv2_elements():\n        if isinstance(functionv2, (Attribute, Result)):\n            continue\n        if not isinstance(functionv2, Function):\n            migrated_annotations.append(\n                TodoAnnotation(\n                    target=functionv2.id,\n                    authors=authors,\n                    reviewers=group_annotation.reviewers,\n                    comment=group_annotation.comment,\n                    reviewResult=EnumReviewResult.NONE,\n                    newTodo=get_migration_text(\n                        group_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n        else:\n            parameter_replacements = _get_mappings_for_grouped_parameters(\n                group_annotation, mappings, functionv2\n            )\n            grouped_parameters: list[Parameter] = []\n            name_modifier = \"\"\n\n            for parameter_list in parameter_replacements:\n                if len(parameter_list) == 0:\n                    name_modifier = \"0\" + name_modifier\n                else:\n                    grouped_parameters.extend(parameter_list)\n                    if len(parameter_list) == 1:\n                        name_modifier = \"1\" + name_modifier\n                    else:\n                        name_modifier = \"0\" + name_modifier\n\n            remove_duplicates_and_preserve_order = [\n                i\n                for n, i in enumerate(grouped_parameters)\n                if i not in grouped_parameters[:n]\n            ]\n            grouped_parameters = remove_duplicates_and_preserve_order\n\n            if len(grouped_parameters) < 2 < len(group_annotation.parameters):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        target=functionv2.id,\n                        authors=authors,\n                        reviewers=group_annotation.reviewers,\n                        comment=group_annotation.comment,\n                        reviewResult=EnumReviewResult.NONE,\n                        newTodo=get_migration_text(\n                            group_annotation,\n                            mapping,\n                            for_todo_annotation=True,\n                            additional_information=grouped_parameters,\n                        ),\n                    )\n                )\n                continue\n\n            if len(grouped_parameters) != len(group_annotation.parameters):\n                group_name = group_annotation.groupName + str(\n                    int(name_modifier, base=2)\n                )\n                migrated_annotations.append(\n                    GroupAnnotation(\n                        target=functionv2.id,\n                        authors=authors,\n                        reviewers=group_annotation.reviewers,\n                        comment=get_migration_text(\n                            group_annotation,\n                            mapping,\n                            additional_information=grouped_parameters,\n                        ),\n                        reviewResult=EnumReviewResult.UNSURE,\n                        groupName=group_name,\n                        parameters=[parameter.name for parameter in grouped_parameters],\n                    )\n                )\n            else:\n                migrated_annotations.append(\n                    GroupAnnotation(\n                        target=functionv2.id,\n                        authors=authors,\n                        reviewers=group_annotation.reviewers,\n                        comment=group_annotation.comment,\n                        reviewResult=EnumReviewResult.NONE,\n                        groupName=group_annotation.groupName,\n                        parameters=[parameter.name for parameter in grouped_parameters],\n                    )\n                )\n\n    return migrated_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_move_annotation/is_moveable",
      "name": "is_moveable",
      "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.is_moveable",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_move_annotation/is_moveable/element",
          "name": "element",
          "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.is_moveable.element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def is_moveable(element: Attribute | Class | Function | Parameter | Result) -> bool:\n    if isinstance(element, (Attribute, Result)):\n        return False\n    if isinstance(element, Function):\n        # check for global function\n        element_parents = element.id.split(\"/\")\n        return len(element_parents) == 3\n    return isinstance(element, Class)"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_move_annotation/migrate_move_annotation",
      "name": "migrate_move_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.migrate_move_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_move_annotation/migrate_move_annotation/move_annotation",
          "name": "move_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.migrate_move_annotation.move_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_move_annotation/migrate_move_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_move_annotation.migrate_move_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_move_annotation(\n    move_annotation: MoveAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    move_annotation = deepcopy(move_annotation)\n    authors = move_annotation.authors\n    authors.append(migration_author)\n    move_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        if not is_moveable(element):\n            return [\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    move_annotation.reviewers,\n                    move_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        move_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            ]\n        move_annotation.target = element.id\n        return [move_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        move_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    move_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if (\n            isinstance(element, type(annotated_apiv1_element))\n            and is_moveable(element)\n            and not isinstance(element, (Attribute, Result))\n        ):\n            move_annotations.append(\n                MoveAnnotation(\n                    element.id,\n                    authors,\n                    move_annotation.reviewers,\n                    move_annotation.comment,\n                    EnumReviewResult.NONE,\n                    move_annotation.destination,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            move_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    move_annotation.reviewers,\n                    move_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        move_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return move_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/is_removeable",
      "name": "is_removeable",
      "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.is_removeable",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/is_removeable/element",
          "name": "element",
          "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.is_removeable.element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def is_removeable(element: Attribute | Class | Function | Parameter | Result) -> bool:\n    return isinstance(element, (Class, Function))"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/migrate_remove_annotation",
      "name": "migrate_remove_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.migrate_remove_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/migrate_remove_annotation/remove_annotation",
          "name": "remove_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.migrate_remove_annotation.remove_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_remove_annotation/migrate_remove_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_remove_annotation.migrate_remove_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_remove_annotation(\n    remove_annotation: RemoveAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    remove_annotation = deepcopy(remove_annotation)\n    authors = remove_annotation.authors\n    authors.append(migration_author)\n    remove_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        if not is_removeable(element):\n            return [\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    remove_annotation.reviewers,\n                    remove_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        remove_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            ]\n        remove_annotation.target = element.id\n        return [remove_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        remove_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    remove_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if (\n            isinstance(element, type(annotated_apiv1_element))\n            and is_removeable(element)\n            and not isinstance(element, (Attribute, Result))\n        ):\n            remove_annotations.append(\n                RemoveAnnotation(\n                    element.id,\n                    authors,\n                    remove_annotation.reviewers,\n                    remove_annotation.comment,\n                    EnumReviewResult.NONE,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            remove_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    remove_annotation.reviewers,\n                    remove_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        remove_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return remove_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_rename_annotation/migrate_rename_annotation",
      "name": "migrate_rename_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_rename_annotation.migrate_rename_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_rename_annotation/migrate_rename_annotation/rename_annotation",
          "name": "rename_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_rename_annotation.migrate_rename_annotation.rename_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_rename_annotation/migrate_rename_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_rename_annotation.migrate_rename_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_rename_annotation(\n    rename_annotation: RenameAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    rename_annotation = deepcopy(rename_annotation)\n    new_name = rename_annotation.newName\n    authors = rename_annotation.authors\n    authors.append(migration_author)\n    rename_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        rename_annotation.target = element.id\n        return [rename_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        rename_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if isinstance(element, type(annotated_apiv1_element)) and not isinstance(\n            element, (Attribute, Result)\n        ):\n            if element.name not in (\n                new_name,\n                rename_annotation.target.split(\".\")[-1],\n            ):\n                annotations.append(\n                    RenameAnnotation(\n                        element.id,\n                        authors,\n                        rename_annotation.reviewers,\n                        get_migration_text(rename_annotation, mapping),\n                        EnumReviewResult.UNSURE,\n                        rename_annotation.newName,\n                    )\n                )\n            else:\n                annotations.append(\n                    RenameAnnotation(\n                        element.id,\n                        authors,\n                        rename_annotation.reviewers,\n                        rename_annotation.comment,\n                        EnumReviewResult.NONE,\n                        rename_annotation.newName,\n                    )\n                )\n        elif not isinstance(element, (Attribute, Result)):\n            annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    rename_annotation.reviewers,\n                    rename_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        rename_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_todo_annotation/migrate_todo_annotation",
      "name": "migrate_todo_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_todo_annotation.migrate_todo_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_todo_annotation/migrate_todo_annotation/todo_annotation",
          "name": "todo_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_todo_annotation.migrate_todo_annotation.todo_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_todo_annotation/migrate_todo_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_todo_annotation.migrate_todo_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_todo_annotation(\n    todo_annotation: TodoAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    todo_annotation = deepcopy(todo_annotation)\n    authors = todo_annotation.authors\n    authors.append(migration_author)\n    todo_annotation.authors = authors\n\n    if isinstance(mapping, (ManyToOneMapping, OneToOneMapping)):\n        element = mapping.get_apiv2_elements()[0]\n        if isinstance(element, (Attribute, Result)):\n            return []\n        todo_annotation.target = element.id\n        return [todo_annotation]\n\n    annotated_apiv1_element = get_annotated_api_element(\n        todo_annotation, mapping.get_apiv1_elements()\n    )\n    if annotated_apiv1_element is None:\n        return []\n\n    todo_annotations: list[AbstractAnnotation] = []\n    for element in mapping.get_apiv2_elements():\n        if isinstance(element, type(annotated_apiv1_element)) and not isinstance(\n            element, (Attribute, Result)\n        ):\n            todo_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    todo_annotation.reviewers,\n                    todo_annotation.comment,\n                    EnumReviewResult.NONE,\n                    todo_annotation.newTodo,\n                )\n            )\n        elif not isinstance(element, (Attribute, Result)):\n            todo_annotations.append(\n                TodoAnnotation(\n                    element.id,\n                    authors,\n                    todo_annotation.reviewers,\n                    todo_annotation.comment,\n                    EnumReviewResult.NONE,\n                    get_migration_text(\n                        todo_annotation, mapping, for_todo_annotation=True\n                    ),\n                )\n            )\n    return todo_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_type",
      "name": "_have_same_type",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_type",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_type/typev1",
          "name": "typev1",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_type.typev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_type/typev2",
          "name": "typev2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_type.typev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _have_same_type(\n    typev1: Optional[AbstractType],\n    typev2: Optional[AbstractType],\n) -> bool:\n    if typev2 is None and typev1 is None:\n        return True\n    if typev2 is None or typev1 is None:\n        return False\n    if isinstance(typev2, NamedType):\n        if typev2.name in (\"int\", \"interger\") or typev2.name.startswith(\"int \"):\n            types = [typev1]\n            if isinstance(typev1, UnionType):\n                types = typev1.types\n            for element in types:\n                if isinstance(element, NamedType) and (\n                    element.name in (\"int\", \"integer\")\n                    or element.name.startswith(\"int \")\n                ):\n                    return True\n        elif typev2.name == \"float\" or typev2.name.startswith(\"float \"):\n            types = [typev1]\n            if isinstance(typev1, UnionType):\n                types = typev1.types\n            for element in types:\n                if isinstance(element, NamedType) and (\n                    element.name == \"float\" or element.name.startswith(\"float \")\n                ):\n                    return True\n        elif typev2.name in (\"bool\", \"boolean\"):\n            types = [typev1]\n            if isinstance(typev1, UnionType):\n                types = typev1.types\n            for element in types:\n                if isinstance(element, NamedType) and (\n                    element.name in (\"bool\", \"boolean\")\n                ):\n                    return True\n        elif typev2.name in (\"str\", \"string\"):\n            types = [typev1]\n            if isinstance(typev1, UnionType):\n                types = typev1.types\n            for element in types:\n                if isinstance(element, NamedType) and (\n                    element.name in (\"str\", \"string\")\n                ):\n                    return True\n    elif isinstance(typev2, UnionType):\n        for element in typev2.types:\n            if _have_same_type(typev1, element):\n                return True\n    return False"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_value",
      "name": "_have_same_value",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_value",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_value/parameterv1_default_value",
          "name": "parameterv1_default_value",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_value.parameterv1_default_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/_have_same_value/parameterv2_default_value",
          "name": "parameterv2_default_value",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation._have_same_value.parameterv2_default_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _have_same_value(\n    parameterv1_default_value: Optional[str], parameterv2_default_value: Optional[str]\n) -> bool:\n    if parameterv1_default_value is None and parameterv2_default_value is None:\n        return True\n    if parameterv1_default_value is None or parameterv2_default_value is None:\n        return False\n    if parameterv1_default_value == \"None\" and parameterv2_default_value == \"None\":\n        return True\n    try:\n        intv1_value = int(parameterv1_default_value)\n        intv2_value = int(parameterv2_default_value)\n        return intv1_value == intv2_value\n    except ValueError:\n        try:\n            floatv1_value = float(parameterv1_default_value)\n            floatv2_value = float(parameterv2_default_value)\n            return floatv1_value == floatv2_value\n        except ValueError:\n            try:\n                int(parameterv1_default_value)\n                float(parameterv2_default_value)\n                return False\n            except ValueError:\n                try:\n                    int(parameterv2_default_value)\n                    float(parameterv1_default_value)\n                    return False\n                except ValueError:\n                    pass\n    if parameterv1_default_value in (\n        \"True\",\n        \"False\",\n    ) and parameterv2_default_value in (\"True\", \"False\"):\n        return bool(parameterv1_default_value) == bool(parameterv2_default_value)\n    valuev1_is_in_quotation_marks = (\n        parameterv1_default_value.startswith(\"'\")\n        and parameterv1_default_value.endswith(\"'\")\n    ) or (\n        parameterv1_default_value.startswith('\"')\n        and parameterv1_default_value.endswith('\"')\n    )\n    valuev2_is_in_quotation_marks = (\n        parameterv2_default_value.startswith(\"'\")\n        and parameterv2_default_value.endswith(\"'\")\n    ) or (\n        parameterv2_default_value.startswith('\"')\n        and parameterv2_default_value.endswith('\"')\n    )\n    if valuev1_is_in_quotation_marks and valuev2_is_in_quotation_marks:\n        return parameterv1_default_value[1:-1] == parameterv2_default_value[1:-1]\n    return False"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_constant_annotation",
      "name": "migrate_constant_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_constant_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_constant_annotation/constant_annotation",
          "name": "constant_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_constant_annotation.constant_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_constant_annotation/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_constant_annotation.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_constant_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_constant_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_constant_annotation(\n    constant_annotation: ConstantAnnotation, parameterv2: Parameter, mapping: Mapping\n) -> Optional[ConstantAnnotation]:\n    parameterv1 = get_annotated_api_element_by_type(\n        constant_annotation, mapping.get_apiv1_elements(), Parameter\n    )\n    if parameterv1 is None:\n        return None\n    if not _have_same_type(parameterv1.type, parameterv2.type):\n        return None\n    if not _have_same_value(parameterv1.default_value, parameterv2.default_value):\n        return ConstantAnnotation(\n            parameterv2.id,\n            constant_annotation.authors,\n            constant_annotation.reviewers,\n            get_migration_text(constant_annotation, mapping),\n            EnumReviewResult.UNSURE,\n            constant_annotation.defaultValueType,\n            constant_annotation.defaultValue,\n        )\n    return ConstantAnnotation(\n        parameterv2.id,\n        constant_annotation.authors,\n        constant_annotation.reviewers,\n        constant_annotation.comment,\n        EnumReviewResult.NONE,\n        constant_annotation.defaultValueType,\n        constant_annotation.defaultValue,\n    )"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_omitted_annotation",
      "name": "migrate_omitted_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_omitted_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_omitted_annotation/omitted_annotation",
          "name": "omitted_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_omitted_annotation.omitted_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_omitted_annotation/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_omitted_annotation.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_omitted_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_omitted_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_omitted_annotation(\n    omitted_annotation: OmittedAnnotation, parameterv2: Parameter, mapping: Mapping\n) -> Optional[OmittedAnnotation]:\n    parameterv1 = get_annotated_api_element_by_type(\n        omitted_annotation, mapping.get_apiv1_elements(), Parameter\n    )\n    if parameterv1 is None:\n        return None\n    if _have_same_type(parameterv1.type, parameterv2.type) and _have_same_value(\n        parameterv1.default_value, parameterv2.default_value\n    ):\n        return OmittedAnnotation(\n            parameterv2.id,\n            omitted_annotation.authors,\n            omitted_annotation.reviewers,\n            omitted_annotation.comment,\n            EnumReviewResult.NONE,\n        )\n    if _have_same_type(parameterv1.type, parameterv2.type) and not _have_same_value(\n        parameterv1.default_value, parameterv2.default_value\n    ):\n        return OmittedAnnotation(\n            parameterv2.id,\n            omitted_annotation.authors,\n            omitted_annotation.reviewers,\n            get_migration_text(omitted_annotation, mapping),\n            EnumReviewResult.UNSURE,\n        )\n\n    return None"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_optional_annotation",
      "name": "migrate_optional_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_optional_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_optional_annotation/optional_annotation",
          "name": "optional_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_optional_annotation.optional_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_optional_annotation/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_optional_annotation.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_optional_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_optional_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_optional_annotation(\n    optional_annotation: OptionalAnnotation, parameterv2: Parameter, mapping: Mapping\n) -> Optional[OptionalAnnotation]:\n    parameterv1 = get_annotated_api_element_by_type(\n        optional_annotation, mapping.get_apiv1_elements(), Parameter\n    )\n    if parameterv1 is None:\n        return None\n    if _have_same_type(parameterv1.type, parameterv2.type) and _have_same_value(\n        parameterv1.default_value, parameterv2.default_value\n    ):\n        return OptionalAnnotation(\n            parameterv2.id,\n            optional_annotation.authors,\n            optional_annotation.reviewers,\n            optional_annotation.comment,\n            EnumReviewResult.NONE,\n            optional_annotation.defaultValueType,\n            optional_annotation.defaultValue,\n        )\n    have_implicit_same_value = False\n    if parameterv1.default_value is not None and parameterv2.default_value is not None:\n        try:\n            have_implicit_same_value = float(parameterv1.default_value) == float(\n                parameterv2.default_value\n            )\n        except ValueError:\n            pass\n    if (\n        _have_same_type(parameterv1.type, parameterv2.type)\n        or (\n            (parameterv1.default_value is None)\n            is not (parameterv2.default_value is None)\n        )\n        or have_implicit_same_value\n    ):\n        return OptionalAnnotation(\n            parameterv2.id,\n            optional_annotation.authors,\n            optional_annotation.reviewers,\n            get_migration_text(optional_annotation, mapping),\n            EnumReviewResult.UNSURE,\n            optional_annotation.defaultValueType,\n            optional_annotation.defaultValue,\n        )\n\n    return None"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_required_annotation",
      "name": "migrate_required_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_required_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_required_annotation/required_annotation",
          "name": "required_annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_required_annotation.required_annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_required_annotation/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_required_annotation.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_required_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_required_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_required_annotation(\n    required_annotation: RequiredAnnotation, parameterv2: Parameter, mapping: Mapping\n) -> Optional[RequiredAnnotation]:\n    parameterv1 = get_annotated_api_element_by_type(\n        required_annotation, mapping.get_apiv1_elements(), Parameter\n    )\n    if parameterv1 is None:\n        return None\n    if _have_same_type(parameterv1.type, parameterv2.type) and (\n        (\n            parameterv1.default_value is not None\n            and parameterv2.default_value is not None\n        )\n        or (parameterv1.default_value is None and parameterv2.default_value is None)\n    ):\n        return RequiredAnnotation(\n            parameterv2.id,\n            required_annotation.authors,\n            required_annotation.reviewers,\n            required_annotation.comment,\n            EnumReviewResult.NONE,\n        )\n    return None"
    },
    {
      "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_value_annotation",
      "name": "migrate_value_annotation",
      "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_value_annotation",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_value_annotation/annotation",
          "name": "annotation",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_value_annotation.annotation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.annotations._migrate_value_annotation/migrate_value_annotation/mapping",
          "name": "mapping",
          "qname": "package_parser.processing.migration.annotations._migrate_value_annotation.migrate_value_annotation.mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def migrate_value_annotation(\n    annotation: ValueAnnotation, mapping: Mapping\n) -> list[AbstractAnnotation]:\n    value_annotation = deepcopy(annotation)\n    authors = value_annotation.authors\n    authors.append(migration_author)\n    value_annotation.authors = authors\n\n    if isinstance(mapping, (OneToOneMapping, ManyToOneMapping)):\n        parameter = mapping.get_apiv2_elements()[0]\n        if isinstance(parameter, (Attribute, Result)):\n            return []\n        if isinstance(parameter, Parameter):\n            if isinstance(value_annotation, ConstantAnnotation):\n                migrated_constant_annotation = migrate_constant_annotation(\n                    value_annotation, parameter, mapping\n                )\n                if migrated_constant_annotation is not None:\n                    return [migrated_constant_annotation]\n            if isinstance(value_annotation, OmittedAnnotation):\n                migrated_omitted_annotation = migrate_omitted_annotation(\n                    value_annotation, parameter, mapping\n                )\n                if migrated_omitted_annotation is not None:\n                    return [migrated_omitted_annotation]\n            if isinstance(value_annotation, OptionalAnnotation):\n                migrated_optional_annotation = migrate_optional_annotation(\n                    value_annotation, parameter, mapping\n                )\n                if migrated_optional_annotation is not None:\n                    return [migrated_optional_annotation]\n            if isinstance(value_annotation, RequiredAnnotation):\n                migrated_required_annotation = migrate_required_annotation(\n                    value_annotation, parameter, mapping\n                )\n                if migrated_required_annotation is not None:\n                    return [migrated_required_annotation]\n        return [\n            TodoAnnotation(\n                parameter.id,\n                authors,\n                value_annotation.reviewers,\n                value_annotation.comment,\n                EnumReviewResult.NONE,\n                get_migration_text(value_annotation, mapping),\n            )\n        ]\n    migrated_annotations: list[AbstractAnnotation] = []\n    if isinstance(mapping, (OneToManyMapping, ManyToManyMapping)):\n        for parameter in mapping.get_apiv2_elements():\n            if isinstance(parameter, (Result, Attribute)):\n                continue\n            if isinstance(parameter, Parameter):\n                if isinstance(value_annotation, ConstantAnnotation):\n                    migrated_constant_annotation = migrate_constant_annotation(\n                        value_annotation, parameter, mapping\n                    )\n                    if migrated_constant_annotation is not None:\n                        migrated_annotations.append(migrated_constant_annotation)\n                        continue\n                elif isinstance(value_annotation, OmittedAnnotation):\n                    migrated_omitted_annotation = migrate_omitted_annotation(\n                        value_annotation, parameter, mapping\n                    )\n                    if migrated_omitted_annotation is not None:\n                        migrated_annotations.append(migrated_omitted_annotation)\n                        continue\n                elif isinstance(value_annotation, OptionalAnnotation):\n                    migrated_optional_annotation = migrate_optional_annotation(\n                        value_annotation, parameter, mapping\n                    )\n                    if migrated_optional_annotation is not None:\n                        migrated_annotations.append(migrated_optional_annotation)\n                        continue\n                elif isinstance(value_annotation, RequiredAnnotation):\n                    migrated_required_annotation = migrate_required_annotation(\n                        value_annotation, parameter, mapping\n                    )\n                    if migrated_required_annotation is not None:\n                        migrated_annotations.append(migrated_required_annotation)\n                        continue\n            if not isinstance(parameter, (Attribute, Result)):\n                migrated_annotations.append(\n                    TodoAnnotation(\n                        parameter.id,\n                        authors,\n                        value_annotation.reviewers,\n                        value_annotation.comment,\n                        EnumReviewResult.NONE,\n                        get_migration_text(value_annotation, mapping),\n                    )\n                )\n    return migrated_annotations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/differ",
          "name": "differ",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/threshold_of_similarity_for_creation_of_mappings",
          "name": "threshold_of_similarity_for_creation_of_mappings",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.threshold_of_similarity_for_creation_of_mappings",
          "default_value": "0.5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/__init__/threshold_of_similarity_between_mappings",
          "name": "threshold_of_similarity_between_mappings",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.__init__.threshold_of_similarity_between_mappings",
          "default_value": "0.05",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        apiv1: API,\n        apiv2: API,\n        differ: AbstractDiffer,\n        threshold_of_similarity_for_creation_of_mappings: float = 0.5,\n        threshold_of_similarity_between_mappings: float = 0.05,\n    ) -> None:\n        self.apiv1 = apiv1\n        self.apiv2 = apiv2\n        self.differ = differ\n        self.threshold_of_similarity_for_creation_of_mappings = (\n            threshold_of_similarity_for_creation_of_mappings\n        )\n        self.threshold_of_similarity_between_mappings = (\n            threshold_of_similarity_between_mappings\n        )"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements",
      "name": "_get_mappings_for_api_elements",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements/api_elementv1_list",
          "name": "api_elementv1_list",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements.api_elementv1_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements/api_elementv2_list",
          "name": "api_elementv2_list",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements.api_elementv2_list",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_get_mappings_for_api_elements/compute_similarity",
          "name": "compute_similarity",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._get_mappings_for_api_elements.compute_similarity",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mappings_for_api_elements(\n        self,\n        api_elementv1_list: List[API_ELEMENTS],\n        api_elementv2_list: List[API_ELEMENTS],\n        compute_similarity: Callable[[API_ELEMENTS, API_ELEMENTS], float],\n    ) -> list[Mapping]:\n        element_mappings: list[Mapping] = []\n        for api_elementv1 in api_elementv1_list:\n            mapping_for_class_1: list[Mapping] = []\n            for api_elementv2 in api_elementv2_list:\n                similarity = compute_similarity(api_elementv1, api_elementv2)\n                if similarity >= self.threshold_of_similarity_for_creation_of_mappings:\n                    mapping_for_class_1.append(\n                        OneToOneMapping(similarity, api_elementv1, api_elementv2)\n                    )\n            mapping_for_class_1.sort(key=Mapping.get_similarity, reverse=True)\n            new_mapping = self._merge_similar_mappings(mapping_for_class_1)\n            if new_mapping is not None:\n                self._merge_mappings_with_same_elements(new_mapping, element_mappings)\n        return element_mappings"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements",
      "name": "_merge_mappings_with_same_elements",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_mappings_with_same_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_mappings_with_same_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements/mapping_to_be_appended",
          "name": "mapping_to_be_appended",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_mappings_with_same_elements.mapping_to_be_appended",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_mappings_with_same_elements/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_mappings_with_same_elements.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This method prevents that an element in a mapping appears multiple times in a list of mappings\nby merging the affected mappings and include the result in the list. If there is no such element,\nthe mapping will be included without any merge.\n\n:param mapping_to_be_appended: the mapping that should be included in mappings\n:param mappings: the list, in which mapping_to_be_appended should be appended",
      "docstring": "This method prevents that an element in a mapping appears multiple times in a list of mappings\nby merging the affected mappings and include the result in the list. If there is no such element,\nthe mapping will be included without any merge.\n\n:param mapping_to_be_appended: the mapping that should be included in mappings\n:param mappings: the list, in which mapping_to_be_appended should be appended",
      "code": "    def _merge_mappings_with_same_elements(\n        self, mapping_to_be_appended: Mapping, mappings: list[Mapping]\n    ) -> None:\n        \"\"\"\n        This method prevents that an element in a mapping appears multiple times in a list of mappings\n        by merging the affected mappings and include the result in the list. If there is no such element,\n        the mapping will be included without any merge.\n\n        :param mapping_to_be_appended: the mapping that should be included in mappings\n        :param mappings: the list, in which mapping_to_be_appended should be appended\n        \"\"\"\n        duplicated: list[Mapping] = []\n        for mapping in mappings:\n            duplicated_element = False\n            for element in mapping.get_apiv2_elements():\n                for element_2 in mapping_to_be_appended.get_apiv2_elements():\n                    if element == element_2:\n                        duplicated_element = True\n                        break\n            if duplicated_element:\n                duplicated.append(mapping)\n\n        if len(duplicated) == 0:\n            mappings.append(mapping_to_be_appended)\n            return\n\n        for conflicted_mapping in duplicated:\n            mapping_to_be_appended = merge_mappings(\n                mapping_to_be_appended, conflicted_mapping\n            )\n            mappings.remove(conflicted_mapping)\n\n        mappings.append(mapping_to_be_appended)"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_similar_mappings",
      "name": "_merge_similar_mappings",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_similar_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_similar_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_similar_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/_merge_similar_mappings/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping._merge_similar_mappings.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\nfrom this apiv1 element to apiv2 elements by merging the first and second elements recursively,\nif the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n:param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n:return: the first element of the sorted list that could be a result of merged similar mappings",
      "docstring": "Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\nfrom this apiv1 element to apiv2 elements by merging the first and second elements recursively,\nif the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n:param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n:return: the first element of the sorted list that could be a result of merged similar mappings",
      "code": "    def _merge_similar_mappings(self, mappings: List[Mapping]) -> Optional[Mapping]:\n        \"\"\"\n        Given a list of OneToOne(Many)Mappings which apiv1 element is the same, this method returns the best mapping\n        from this apiv1 element to apiv2 elements by merging the first and second elements recursively,\n        if the difference in similarity is smaller than THRESHOLD_OF_SIMILARITY_BETWEEN_MAPPINGS.\n\n        :param mappings: mappings sorted by decreasing similarity, which apiv1 element is the same\n        :return: the first element of the sorted list that could be a result of merged similar mappings\n        \"\"\"\n        if len(mappings) == 0:\n            return None\n        if len(mappings) == 1:\n            return mappings[0]\n        if (\n            mappings[0].similarity - mappings[1].similarity\n            < self.threshold_of_similarity_between_mappings\n        ):\n            mappings[0] = merge_mappings(mappings[0], mappings[1])\n            mappings.pop(1)\n            return self._merge_similar_mappings(mappings)\n        return mappings[0]"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/map_api",
      "name": "map_api",
      "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.map_api",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._api_mapping/APIMapping/map_api/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._api_mapping.APIMapping.map_api.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def map_api(self) -> List[Mapping]:\n        mappings: List[Mapping] = []\n        previous_mappings = self.differ.get_related_mappings()\n        if previous_mappings is not None:\n            for mapping in previous_mappings:\n                new_mapping = None\n                if isinstance(\n                    mapping.get_apiv1_elements()[0], Attribute\n                ) and isinstance(mapping.get_apiv2_elements()[0], Attribute):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Attribute)\n                        ],\n                        self.differ.compute_attribute_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Class) and isinstance(\n                    mapping.get_apiv2_elements()[0], Class\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Class)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Class)\n                        ],\n                        self.differ.compute_class_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Function\n                ) and isinstance(mapping.get_apiv2_elements()[0], Function):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Function)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Function)\n                        ],\n                        self.differ.compute_function_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(\n                    mapping.get_apiv1_elements()[0], Parameter\n                ) and isinstance(mapping.get_apiv2_elements()[0], Parameter):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Parameter)\n                        ],\n                        self.differ.compute_parameter_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                elif isinstance(mapping.get_apiv1_elements()[0], Result) and isinstance(\n                    mapping.get_apiv2_elements()[0], Result\n                ):\n                    new_mapping = self._get_mappings_for_api_elements(\n                        [\n                            element\n                            for element in mapping.get_apiv1_elements()\n                            if isinstance(element, Result)\n                        ],\n                        [\n                            element\n                            for element in mapping.get_apiv2_elements()\n                            if isinstance(element, Result)\n                        ],\n                        self.differ.compute_result_similarity,\n                    )\n                    mappings.extend(new_mapping)\n                if new_mapping is not None:\n                    self.differ.notify_new_mapping(new_mapping)\n        else:\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.classes.values()),\n                    list(self.apiv2.classes.values()),\n                    self.differ.compute_class_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.functions.values()),\n                    list(self.apiv2.functions.values()),\n                    self.differ.compute_function_similarity,\n                )\n            )\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    list(self.apiv1.parameters().values()),\n                    list(self.apiv2.parameters().values()),\n                    self.differ.compute_parameter_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        attribute\n                        for class_ in self.apiv1.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    [\n                        attribute\n                        for class_ in self.apiv2.classes.values()\n                        for attribute in class_.instance_attributes\n                    ],\n                    self.differ.compute_attribute_similarity,\n                )\n            )\n\n            mappings.extend(\n                self._get_mappings_for_api_elements(\n                    [\n                        result\n                        for function in self.apiv1.functions.values()\n                        for result in function.results\n                    ],\n                    [\n                        result\n                        for function in self.apiv2.functions.values()\n                        for result in function.results\n                    ],\n                    self.differ.compute_result_similarity,\n                )\n            )\n\n        mappings.sort(key=Mapping.get_similarity, reverse=True)\n        return mappings"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity",
      "name": "compute_attribute_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_attribute_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_attribute_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity/attributev1",
          "name": "attributev1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_attribute_similarity.attributev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_attribute_similarity/attributev2",
          "name": "attributev2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_attribute_similarity.attributev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_attribute_similarity(\n        self,\n        attributev1: Attribute,\n        attributev2: Attribute,\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity",
      "name": "compute_class_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_class_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_class_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity/classv1",
          "name": "classv1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_class_similarity.classv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_class_similarity/classv2",
          "name": "classv2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_class_similarity.classv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between classes from apiv1 and apiv2.\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between classes from apiv1 and apiv2.\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2.\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity",
      "name": "compute_function_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_function_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_function_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity/functionv1",
          "name": "functionv1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_function_similarity.functionv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_function_similarity/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_function_similarity.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity",
      "name": "compute_parameter_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_parameter_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_parameter_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity/parameterv1",
          "name": "parameterv1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_parameter_similarity.parameterv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_parameter_similarity/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_parameter_similarity.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity",
      "name": "compute_result_similarity",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_result_similarity",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_result_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity/resultv1",
          "name": "resultv1",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_result_similarity.resultv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/compute_result_similarity/resultv2",
          "name": "resultv2",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.compute_result_similarity.resultv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between results from apiv1 and apiv2.\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between results from apiv1 and apiv2.\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    @abstractmethod\n    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2.\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\""
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_additional_mappings",
      "name": "get_additional_mappings",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.get_additional_mappings",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_additional_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.get_additional_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This method allows the differ to add further mappings from previous differs\n:return: additional mappings that should be included in the result of the differentiation",
      "docstring": "This method allows the differ to add further mappings from previous differs\n:return: additional mappings that should be included in the result of the differentiation",
      "code": "    @abstractmethod\n    def get_additional_mappings(self) -> list[Mapping]:\n        \"\"\"\n        This method allows the differ to add further mappings from previous differs\n        :return: additional mappings that should be included in the result of the differentiation\n        \"\"\""
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_related_mappings",
      "name": "get_related_mappings",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.get_related_mappings",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/get_related_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.get_related_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Indicates whether all api elements should be compared with each other\nor just the ones that are mapped to each other.\n:return: a list of Mappings if only previously mapped api elements should be mapped to each other or else None.",
      "docstring": "Indicates whether all api elements should be compared with each other\nor just the ones that are mapped to each other.\n:return: a list of Mappings if only previously mapped api elements should be mapped to each other or else None.",
      "code": "    @abstractmethod\n    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        \"\"\"\n        Indicates whether all api elements should be compared with each other\n        or just the ones that are mapped to each other.\n        :return: a list of Mappings if only previously mapped api elements should be mapped to each other or else None.\n        \"\"\""
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/notify_new_mapping",
      "name": "notify_new_mapping",
      "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.notify_new_mapping",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/notify_new_mapping/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.notify_new_mapping.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/AbstractDiffer/notify_new_mapping/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._differ.AbstractDiffer.notify_new_mapping.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "If previous mappings returns None, the differ will be notified about a new mapping.\nThereby the differ can calculate the similarity with more information.\n:param mappings: a list of mappings new appended mappings.",
      "docstring": "If previous mappings returns None, the differ will be notified about a new mapping.\nThereby the differ can calculate the similarity with more information.\n:param mappings: a list of mappings new appended mappings.",
      "code": "    @abstractmethod\n    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        \"\"\"\n        If previous mappings returns None, the differ will be notified about a new mapping.\n        Thereby the differ can calculate the similarity with more information.\n        :param mappings: a list of mappings new appended mappings.\n        \"\"\""
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/previous_base_differ",
          "name": "previous_base_differ",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.previous_base_differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/previous_mappings",
          "name": "previous_mappings",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.previous_mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        previous_base_differ: Optional[AbstractDiffer],\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        distance_between_implicit_and_explicit = 0.3\n        distance_between_vararg_and_normal = 0.3\n        distance_between_position_and_named = 0.3\n        distance_between_both_to_one = 0.15\n        distance_between_one_to_both = 0.15\n        self.assigned_by_look_up_similarity = {\n            ParameterAssignment.IMPLICIT: {\n                ParameterAssignment.IMPLICIT: 1.0,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_implicit_and_explicit,\n            },\n            ParameterAssignment.NAMED_VARARG: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.NAMED_VARARG: 1.0,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0 - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n            },\n            ParameterAssignment.POSITIONAL_VARARG: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_vararg_and_normal,\n            },\n            ParameterAssignment.POSITION_OR_NAME: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_both_to_one,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_both_to_one,\n                ParameterAssignment.POSITION_OR_NAME: 1.0,\n                ParameterAssignment.NAME_ONLY: 1.0 - distance_between_both_to_one,\n                ParameterAssignment.POSITION_ONLY: 1.0 - distance_between_both_to_one,\n            },\n            ParameterAssignment.NAME_ONLY: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0,\n                ParameterAssignment.POSITION_ONLY: 1.0\n                - distance_between_position_and_named,\n            },\n            ParameterAssignment.POSITION_ONLY: {\n                ParameterAssignment.IMPLICIT: 1.0\n                - distance_between_implicit_and_explicit,\n                ParameterAssignment.NAMED_VARARG: 1.0\n                - distance_between_vararg_and_normal\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITIONAL_VARARG: 1.0\n                - distance_between_vararg_and_normal,\n                ParameterAssignment.POSITION_OR_NAME: 1.0\n                - distance_between_one_to_both,\n                ParameterAssignment.NAME_ONLY: 1.0\n                - distance_between_position_and_named,\n                ParameterAssignment.POSITION_ONLY: 1.0,\n            },\n        }"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity",
      "name": "_compute_assignment_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_assignment_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_assignment_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity/assigned_byv1",
          "name": "assigned_byv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_assignment_similarity.assigned_byv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_assignment_similarity/assigned_byv2",
          "name": "assigned_byv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_assignment_similarity.assigned_byv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_assignment_similarity(\n        self, assigned_byv1: ParameterAssignment, assigned_byv2: ParameterAssignment\n    ) -> float:\n        return self.assigned_by_look_up_similarity[assigned_byv1][assigned_byv2]"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity",
      "name": "_compute_code_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_code_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_code_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity/codev1",
          "name": "codev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_code_similarity.codev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_code_similarity/codev2",
          "name": "codev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_code_similarity.codev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_code_similarity(self, codev1: str, codev2: str) -> float:\n        splitv1 = codev1.split(\"\\n\")\n        splitv2 = codev2.split(\"\\n\")\n        diff_code = distance(splitv1, splitv2) / max(len(splitv1), len(splitv2), 1)\n        return 1 - diff_code"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity",
      "name": "_compute_default_value_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_default_value_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_default_value_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity/default_valuev1",
          "name": "default_valuev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_default_value_similarity.default_valuev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_default_value_similarity/default_valuev2",
          "name": "default_valuev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_default_value_similarity.default_valuev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_default_value_similarity(\n        self, default_valuev1: Optional[str], default_valuev2: Optional[str]\n    ) -> float:\n        if default_valuev1 is None and default_valuev2 is None:\n            return -1.0\n        if default_valuev1 is None or default_valuev2 is None:\n            return 0.0\n        if default_valuev1 == \"None\" and default_valuev2 == \"None\":\n            return 1.0\n        try:\n            intv1_value = int(default_valuev1)\n            intv2_value = int(default_valuev2)\n            if intv1_value == intv2_value:\n                return 1.0\n            return 0.5\n        except ValueError:\n            try:\n                floatv1_value = float(default_valuev1)\n                floatv2_value = float(default_valuev2)\n                if floatv1_value == floatv2_value:\n                    return 1.0\n            except ValueError:\n                try:\n                    if float(int(default_valuev1)) == float(default_valuev2):\n                        return 0.75\n                except ValueError:\n                    try:\n                        if float(int(default_valuev2)) == float(default_valuev1):\n                            return 0.75\n                    except ValueError:\n                        pass\n        if default_valuev1 in (\n            \"True\",\n            \"False\",\n        ) and default_valuev2 in (\"True\", \"False\"):\n            if bool(default_valuev1) == bool(default_valuev2):\n                return 1.0\n            return 0.5\n        valuev1_is_in_quotation_marks = (\n            default_valuev1.startswith(\"'\") and default_valuev1.endswith(\"'\")\n        ) or (default_valuev1.startswith('\"') and default_valuev1.endswith('\"'))\n        valuev2_is_in_quotation_marks = (\n            default_valuev2.startswith(\"'\") and default_valuev2.endswith(\"'\")\n        ) or (default_valuev2.startswith('\"') and default_valuev2.endswith('\"'))\n        if valuev1_is_in_quotation_marks and valuev2_is_in_quotation_marks:\n            if default_valuev1[1:-1] == default_valuev2[1:-1]:\n                return 1.0\n            return 0.5\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity",
      "name": "_compute_documentation_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_documentation_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_documentation_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity/documentationv1",
          "name": "documentationv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_documentation_similarity.documentationv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_documentation_similarity/documentationv2",
          "name": "documentationv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_documentation_similarity.documentationv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_documentation_similarity(\n        self,\n        documentationv1: Union[\n            ClassDocumentation, FunctionDocumentation, ParameterDocumentation\n        ],\n        documentationv2: Union[\n            ClassDocumentation, FunctionDocumentation, ParameterDocumentation\n        ],\n    ) -> float:\n        if len(documentationv1.description) == len(documentationv2.description) == 0:\n            return -1.0\n        descriptionv1 = re.split(\"[\\n ]\", documentationv1.description)\n        descriptionv2 = re.split(\"[\\n ]\", documentationv2.description)\n\n        documentation_similarity = distance(descriptionv1, descriptionv2) / max(\n            len(descriptionv1), len(descriptionv2), 1\n        )\n        return 1 - documentation_similarity"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity",
      "name": "_compute_id_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_id_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_id_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity/idv1",
          "name": "idv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_id_similarity.idv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_id_similarity/idv2",
          "name": "idv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_id_similarity.idv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_id_similarity(self, idv1: str, idv2: str) -> float:\n        module_pathv1 = idv1.split(\"/\")[1].split(\".\")\n        additional_module_pathv1 = idv1.split(\"/\")[2:-1]\n        if len(additional_module_pathv1) > 0:\n            module_pathv1.extend(additional_module_pathv1)\n        module_pathv2 = idv2.split(\"/\")[1].split(\".\")\n        additional_module_pathv2 = idv2.split(\"/\")[2:-1]\n        if len(additional_module_pathv2) > 0:\n            module_pathv2.extend(additional_module_pathv2)\n\n        def cost_function(iteration: int, max_iteration: int) -> float:\n            return (max_iteration - iteration + 1) / max_iteration\n\n        total_costs, max_iterations = distance_elements_with_cost_function(\n            module_pathv1, module_pathv2, cost_function\n        )\n        return 1 - (total_costs / (sum(range(1, max_iterations + 1)) / max_iterations))"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity",
      "name": "_compute_name_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_name_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_name_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity/namev1",
          "name": "namev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_name_similarity.namev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_name_similarity/namev2",
          "name": "namev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_name_similarity.namev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_name_similarity(self, namev1: str, namev2: str) -> float:\n        name_similarity = distance(namev1, namev2) / max(len(namev1), len(namev2), 1)\n        return 1 - name_similarity"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity",
      "name": "_compute_type_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_type_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_type_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity/typev1",
          "name": "typev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_type_similarity.typev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_compute_type_similarity/typev2",
          "name": "typev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._compute_type_similarity.typev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _compute_type_similarity(\n        self, typev1: Optional[AbstractType], typev2: Optional[AbstractType]\n    ) -> float:\n        if typev1 is None:\n            if typev2 is None:\n                return 1\n            return 0\n        if typev2 is None:\n            return 0\n\n        type_listv1 = self._create_list_from_type(typev1)\n        type_listv2 = self._create_list_from_type(typev2)\n        diff_elements = distance(type_listv1, type_listv2) / max(\n            len(type_listv1), len(type_listv2), 1\n        )\n        return 1 - diff_elements"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_create_list_from_type",
      "name": "_create_list_from_type",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._create_list_from_type",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_create_list_from_type/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._create_list_from_type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/_create_list_from_type/abstract_type",
          "name": "abstract_type",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer._create_list_from_type.abstract_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _create_list_from_type(\n        self, abstract_type: Optional[AbstractType]\n    ) -> Sequence[Optional[AbstractType]]:\n        if abstract_type is not None and isinstance(abstract_type, UnionType):\n            return abstract_type.types\n        return [abstract_type]"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity",
      "name": "compute_attribute_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_attribute_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_attribute_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity/attributev1",
          "name": "attributev1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_attribute_similarity.attributev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_attribute_similarity/attributev2",
          "name": "attributev2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_attribute_similarity.attributev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between attributes from apiv1 and apiv2 with the respect to their name and type.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between attributes from apiv1 and apiv2 with the respect to their name and type.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_attribute_similarity(\n        self,\n        attributev1: Attribute,\n        attributev2: Attribute,\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2 with the respect to their name and type.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        name_similarity = self._compute_name_similarity(\n            attributev1.name, attributev2.name\n        )\n        type_listv1 = self._create_list_from_type(attributev1.types)\n        type_listv2 = self._create_list_from_type(attributev2.types)\n        type_similarity = distance(type_listv1, type_listv2) / max(\n            len(type_listv1), len(type_listv2), 1\n        )\n        type_similarity = 1 - type_similarity\n        return (name_similarity + type_similarity) / 2"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity",
      "name": "compute_class_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_class_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_class_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity/classv1",
          "name": "classv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_class_similarity.classv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_class_similarity/classv2",
          "name": "classv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_class_similarity.classv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between classes from apiv1 and apiv2 with the respect to their name, id, code, and attributes.\n:param classv1: attribute from apiv1\n:param classv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between classes from apiv1 and apiv2 with the respect to their name, id, code, and attributes.\n:param classv1: attribute from apiv1\n:param classv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2 with the respect to their name, id, code, and attributes.\n        :param classv1: attribute from apiv1\n        :param classv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        normalize_similarity = 6\n\n        code_similarity = self._compute_code_similarity(\n            classv1.get_formatted_code(), classv2.get_formatted_code()\n        )\n        name_similarity = self._compute_name_similarity(classv1.name, classv2.name)\n\n        attributes_similarity = distance(\n            classv1.instance_attributes, classv2.instance_attributes\n        )\n        attributes_similarity = attributes_similarity / (\n            max(len(classv1.instance_attributes), len(classv2.instance_attributes), 1)\n        )\n        attributes_similarity = 1 - attributes_similarity\n\n        function_similarity = distance(\n            classv1.methods,\n            classv2.methods,\n        ) / max(len(classv1.methods), len(classv2.methods), 1)\n        function_similarity = 1 - function_similarity\n\n        id_similarity = self._compute_id_similarity(classv1.id, classv2.id)\n\n        documentation_similarity = self._compute_documentation_similarity(\n            classv1.documentation, classv2.documentation\n        )\n        if documentation_similarity < 0:\n            documentation_similarity = 0\n            normalize_similarity -= 1\n\n        return (\n            name_similarity\n            + attributes_similarity\n            + function_similarity\n            + code_similarity\n            + id_similarity\n            + documentation_similarity\n        ) / normalize_similarity"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity",
      "name": "compute_function_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_function_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_function_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity/functionv1",
          "name": "functionv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_function_similarity.functionv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_function_similarity/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_function_similarity.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between functions from apiv1 and apiv2 with the respect to their code, name, id, and parameters.\n:param functionv1: attribute from apiv1\n:param functionv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between functions from apiv1 and apiv2 with the respect to their code, name, id, and parameters.\n:param functionv1: attribute from apiv1\n:param functionv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2 with the respect to their code, name, id, and parameters.\n        :param functionv1: attribute from apiv1\n        :param functionv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        if (\n            functionv1.id in self.previous_function_similarity\n            and functionv2.id in self.previous_function_similarity[functionv1.id]\n        ):\n            return self.previous_function_similarity[functionv1.id][functionv2.id]\n\n        normalize_similarity = 5\n\n        code_similarity = self._compute_code_similarity(\n            functionv1.get_formatted_code(), functionv2.get_formatted_code()\n        )\n        name_similarity = self._compute_name_similarity(\n            functionv1.name, functionv2.name\n        )\n\n        parameter_similarity = distance(\n            functionv1.parameters,\n            functionv2.parameters,\n        ) / max(len(functionv1.parameters), len(functionv2.parameters), 1)\n        parameter_similarity = 1 - parameter_similarity\n\n        id_similarity = self._compute_id_similarity(functionv1.id, functionv2.id)\n\n        documentation_similarity = self._compute_documentation_similarity(\n            functionv1.documentation, functionv2.documentation\n        )\n        if documentation_similarity < 0:\n            documentation_similarity = 0\n            normalize_similarity -= 1\n\n        result = (\n            code_similarity\n            + name_similarity\n            + parameter_similarity\n            + id_similarity\n            + documentation_similarity\n        ) / normalize_similarity\n        if functionv1.id not in self.previous_function_similarity:\n            self.previous_function_similarity[functionv1.id] = {}\n        self.previous_function_similarity[functionv1.id][functionv2.id] = result\n        return result"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity",
      "name": "compute_parameter_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_parameter_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_parameter_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity/parameterv1",
          "name": "parameterv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_parameter_similarity.parameterv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_parameter_similarity/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_parameter_similarity.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between parameters from apiv1 and apiv2 with the respect to their name, type, assignment, default value, documentation, and id.\n:param parameterv1: attribute from apiv1\n:param parameterv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between parameters from apiv1 and apiv2 with the respect to their name, type, assignment, default value, documentation, and id.\n:param parameterv1: attribute from apiv1\n:param parameterv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2 with the respect to their name, type, assignment, default value, documentation, and id.\n        :param parameterv1: attribute from apiv1\n        :param parameterv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        if (\n            parameterv1.id in self.previous_parameter_similarity\n            and parameterv2.id in self.previous_parameter_similarity[parameterv1.id]\n        ):\n            return self.previous_parameter_similarity[parameterv1.id][parameterv2.id]\n\n        normalize_similarity = 6\n        parameter_name_similarity = self._compute_name_similarity(\n            parameterv1.name, parameterv2.name\n        )\n        parameter_type_similarity = self._compute_type_similarity(\n            parameterv1.type, parameterv2.type\n        )\n        parameter_assignment_similarity = self._compute_assignment_similarity(\n            parameterv1.assigned_by, parameterv2.assigned_by\n        )\n        if parameter_assignment_similarity < 0:\n            parameter_assignment_similarity = 0\n            normalize_similarity -= 1\n        parameter_default_value_similarity = self._compute_default_value_similarity(\n            parameterv1.default_value, parameterv2.default_value\n        )\n        if parameter_default_value_similarity < 0:\n            parameter_default_value_similarity = 0\n            normalize_similarity -= 1\n        parameter_documentation_similarity = self._compute_documentation_similarity(\n            parameterv1.documentation, parameterv2.documentation\n        )\n        if parameter_documentation_similarity < 0:\n            parameter_documentation_similarity = 0\n            normalize_similarity -= 1\n\n        id_similarity = self._compute_id_similarity(parameterv1.id, parameterv2.id)\n\n        result = (\n            parameter_name_similarity\n            + parameter_type_similarity\n            + parameter_assignment_similarity\n            + parameter_default_value_similarity\n            + parameter_documentation_similarity\n            + id_similarity\n        ) / normalize_similarity\n        if parameterv1.id not in self.previous_parameter_similarity:\n            self.previous_parameter_similarity[parameterv1.id] = {}\n        self.previous_parameter_similarity[parameterv1.id][parameterv2.id] = result\n        return result"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity",
      "name": "compute_result_similarity",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_result_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_result_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity/resultv1",
          "name": "resultv1",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_result_similarity.resultv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/compute_result_similarity/resultv2",
          "name": "resultv2",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.compute_result_similarity.resultv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between results from apiv1 and apiv2 with the respect to their name.\n:param resultv1: attribute from apiv1\n:param resultv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "docstring": "Computes similarity between results from apiv1 and apiv2 with the respect to their name.\n:param resultv1: attribute from apiv1\n:param resultv2: attribute from apiv2\n:return: value between 0 and 1, where 1 means that the elements are equal",
      "code": "    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2 with the respect to their name.\n        :param resultv1: attribute from apiv1\n        :param resultv2: attribute from apiv2\n        :return: value between 0 and 1, where 1 means that the elements are equal\n        \"\"\"\n        return self._compute_name_similarity(resultv1.name, resultv2.name)"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_additional_mappings",
      "name": "get_additional_mappings",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.get_additional_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_additional_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.get_additional_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_additional_mappings(self) -> list[Mapping]:\n        return []"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_related_mappings",
      "name": "get_related_mappings",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.get_related_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/get_related_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.get_related_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        return None"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/notify_new_mapping",
      "name": "notify_new_mapping",
      "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.notify_new_mapping",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/notify_new_mapping/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.notify_new_mapping.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/SimpleDiffer/notify_new_mapping/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._differ.SimpleDiffer.notify_new_mapping.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        return"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function",
      "name": "distance_elements_with_cost_function",
      "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/listv1",
          "name": "listv1",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.listv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/listv2",
          "name": "listv2",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.listv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/cost_function",
          "name": "cost_function",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.cost_function",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/are_similar",
          "name": "are_similar",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.are_similar",
          "default_value": "lambda x, y: x == y",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._differ/distance_elements_with_cost_function/iteration",
          "name": "iteration",
          "qname": "package_parser.processing.migration.model._differ.distance_elements_with_cost_function.iteration",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def distance_elements_with_cost_function(\n    listv1: list[X],\n    listv2: list[X],\n    cost_function: Callable[[int, int], float],\n    are_similar: Callable[[X, X], bool] = lambda x, y: x == y,\n    iteration: int = 1,\n) -> Tuple[float, int]:\n    if len(listv1) == 0 and len(listv2) == 0:\n        return 0.0, iteration - 1\n    if len(listv1) == 0:\n        total_costs = 0.0\n        max_iterations = iteration + len(listv2)\n        for i in range(0, len(listv2)):\n            total_costs += cost_function(iteration + i, max_iterations)\n        return total_costs, max_iterations\n    if len(listv2) == 0:\n        total_costs = 0.0\n        max_iterations = iteration + len(listv1)\n        for i in range(0, len(listv1)):\n            total_costs += cost_function(iteration + i, max_iterations)\n        return total_costs, max_iterations\n    if are_similar(listv1[0], listv2[0]):\n        total_costs, max_iterations = distance_elements_with_cost_function(\n            listv1[1:], listv2[1:], cost_function, are_similar, iteration + 1\n        )\n        return total_costs, max_iterations\n    recursive_results = [\n        distance_elements_with_cost_function(\n            listv1[1:], listv2, cost_function, are_similar, iteration + 1\n        ),\n        distance_elements_with_cost_function(\n            listv1, listv2[1:], cost_function, are_similar, iteration + 1\n        ),\n        distance_elements_with_cost_function(\n            listv1[1:], listv2[1:], cost_function, are_similar, iteration + 1\n        ),\n    ]\n    total_costs, max_iterations = sorted(\n        recursive_results, key=lambda tuple_: tuple_[0]\n    )[0]\n    total_costs += cost_function(iteration, max_iterations)\n    return total_costs, max_iterations"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/previous_base_differ",
          "name": "previous_base_differ",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.previous_base_differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/previous_mappings",
          "name": "previous_mappings",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.previous_mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/__init__/boost_value",
          "name": "boost_value",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.__init__.boost_value",
          "default_value": "0.15",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        previous_base_differ: AbstractDiffer,\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n        boost_value: float = 0.15,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        self.differ = previous_base_differ\n        self.boost_value = boost_value\n        self.inheritance = {}\n        self.new_mappings = []\n        for class_v2 in self.apiv2.classes.values():\n            additional_v1_elements = []\n            for mapping in previous_mappings:\n                if isinstance(mapping.get_apiv2_elements()[0], Class):\n                    is_inheritance_mapping = class_v2.id in map(\n                        lambda class_: class_.id if isinstance(class_, Class) else \"\",\n                        mapping.get_apiv2_elements(),\n                    )\n                    if not is_inheritance_mapping:\n                        for inheritance_class_v2 in mapping.get_apiv2_elements():\n                            if isinstance(inheritance_class_v2, Class):\n                                if (\n                                    inheritance_class_v2.name in class_v2.superclasses\n                                    or class_v2.name\n                                    in inheritance_class_v2.superclasses\n                                ):\n                                    is_inheritance_mapping = True\n                                    break\n                    if is_inheritance_mapping:\n                        for class_v1 in mapping.get_apiv1_elements():\n                            if isinstance(class_v1, Class):\n                                additional_v1_elements.append(class_v1.id)\n            if len(additional_v1_elements) > 0:\n                self.inheritance[class_v2.id] = additional_v1_elements"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements",
      "name": "_get_not_mapped_api_elements",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements/mapped_apiv1_elements",
          "name": "mapped_apiv1_elements",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements.mapped_apiv1_elements",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements/mapped_apiv2_elements",
          "name": "mapped_apiv2_elements",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements.mapped_apiv2_elements",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/_get_not_mapped_api_elements/get_api_element",
          "name": "get_api_element",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer._get_not_mapped_api_elements.get_api_element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_not_mapped_api_elements(\n        self,\n        mapped_apiv1_elements: list[api_element],\n        mapped_apiv2_elements: list[api_element],\n        get_api_element: Callable[[API], list[api_element]],\n    ) -> Optional[Mapping]:\n        not_mapped_v1_elements = []\n        for api_elementv1 in get_api_element(self.apiv1):\n            if api_elementv1 not in mapped_apiv1_elements:\n                not_mapped_v1_elements.append(api_elementv1)\n        not_mapped_v2_elements = []\n        for api_elementv2 in get_api_element(self.apiv2):\n            if api_elementv2 not in mapped_apiv2_elements:\n                not_mapped_v2_elements.append(api_elementv2)\n        if len(not_mapped_v1_elements) > 0 and len(not_mapped_v2_elements) > 0:\n            return ManyToManyMapping(\n                -1.0, not_mapped_v1_elements, not_mapped_v2_elements\n            )\n        return None"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity",
      "name": "compute_attribute_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_attribute_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_attribute_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity/attributev1",
          "name": "attributev1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_attribute_similarity.attributev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_attribute_similarity/attributev2",
          "name": "attributev2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_attribute_similarity.attributev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: if the parent of the attributes are mapped onto each other\n or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.",
      "docstring": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: if the parent of the attributes are mapped onto each other\n or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.",
      "code": "    def compute_attribute_similarity(\n        self, attributev1: Attribute, attributev2: Attribute\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: if the parent of the attributes are mapped onto each other\n         or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if (\n            attributev2.class_id in self.inheritance\n            and attributev1.class_id in self.inheritance[attributev2.class_id]\n        ):\n            return (\n                self.differ.compute_attribute_similarity(attributev1, attributev2)\n                * (1 - self.boost_value)\n            ) + self.boost_value\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity",
      "name": "compute_class_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_class_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_class_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity/classv1",
          "name": "classv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_class_similarity.classv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_class_similarity/classv2",
          "name": "classv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_class_similarity.classv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between classes from apiv1 and apiv2\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: if the classes are mapped onto each other or onto a super- or subclass,\nthe normalized similarity of the previous differ plus boost_value, or else 0.",
      "docstring": "Computes similarity between classes from apiv1 and apiv2\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: if the classes are mapped onto each other or onto a super- or subclass,\nthe normalized similarity of the previous differ plus boost_value, or else 0.",
      "code": "    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: if the classes are mapped onto each other or onto a super- or subclass,\n        the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if classv2.id in self.inheritance:\n            for mapping in self.previous_mappings:\n                for elementv2 in mapping.get_apiv2_elements():\n                    if isinstance(elementv2, Class):\n                        if elementv2.id in self.inheritance[classv2.id]:\n                            return (\n                                self.differ.compute_class_similarity(classv1, classv2)\n                                * (1 - self.boost_value)\n                            ) + self.boost_value\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity",
      "name": "compute_function_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_function_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_function_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity/functionv1",
          "name": "functionv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_function_similarity.functionv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_function_similarity/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_function_similarity.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: if functions are not global functions and its parent are mapped onto each other\n or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.",
      "docstring": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: if functions are not global functions and its parent are mapped onto each other\n or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.",
      "code": "    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: if functions are not global functions and its parent are mapped onto each other\n         or onto a super- or subclass, the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        functionv1_is_global = len(functionv1.id.split(\"/\")) == 3\n        functionv2_is_global = len(functionv2.id.split(\"/\")) == 3\n        if functionv1_is_global or functionv2_is_global:\n            return 0.0\n        class_id_functionv1 = \"/\".join(functionv1.id.split(\"/\")[:-1])\n        class_id_functionv2 = \"/\".join(functionv2.id.split(\"/\")[:-1])\n        if (\n            class_id_functionv2 in self.inheritance\n            and class_id_functionv1 in self.inheritance[class_id_functionv2]\n        ):\n            base_similarity = self.differ.compute_function_similarity(\n                functionv1, functionv2\n            )\n            return (base_similarity * (1 - self.boost_value)) + self.boost_value\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity",
      "name": "compute_parameter_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_parameter_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_parameter_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity/parameterv1",
          "name": "parameterv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_parameter_similarity.parameterv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_parameter_similarity/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_parameter_similarity.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: if their parents are mapped together, the normalized similarity of the previous differ plus boost_value,\nor else 0.",
      "docstring": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: if their parents are mapped together, the normalized similarity of the previous differ plus boost_value,\nor else 0.",
      "code": "    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: if their parents are mapped together, the normalized similarity of the previous differ plus boost_value,\n        or else 0.\n        \"\"\"\n        parameterv2_id_splitted = parameterv2.id.split(\"/\")\n        if \"/\".join(parameterv2_id_splitted[:-2]) in self.inheritance:\n            functionv1_id = \"/\".join(parameterv1.id.split(\"/\")[:-1])\n            for mapping in self.new_mappings:\n                for functionv1 in mapping.get_apiv1_elements():\n                    if (\n                        isinstance(functionv1, Function)\n                        and functionv1_id == functionv1.id\n                    ):\n                        for functionv2 in mapping.get_apiv2_elements():\n                            if (\n                                isinstance(functionv2, Function)\n                                and \"/\".join(parameterv2_id_splitted[:-1])\n                                == functionv2.id\n                            ):\n                                return (\n                                    self.differ.compute_parameter_similarity(\n                                        parameterv1, parameterv2\n                                    )\n                                    * (1 - self.boost_value)\n                                ) + self.boost_value\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity",
      "name": "compute_result_similarity",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_result_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_result_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity/resultv1",
          "name": "resultv1",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_result_similarity.resultv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/compute_result_similarity/resultv2",
          "name": "resultv2",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.compute_result_similarity.resultv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between results from apiv1 and apiv2\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: if their parents are mapped together,\nthe normalized similarity of the previous differ plus boost_value, or else 0.",
      "docstring": "Computes similarity between results from apiv1 and apiv2\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: if their parents are mapped together,\nthe normalized similarity of the previous differ plus boost_value, or else 0.",
      "code": "    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: if their parents are mapped together,\n        the normalized similarity of the previous differ plus boost_value, or else 0.\n        \"\"\"\n        if (\n            resultv2.function_id is not None\n            and \"/\".join(resultv2.function_id.split(\"/\")[:-1]) in self.inheritance\n        ):\n            for mapping in self.new_mappings:\n                for functionv1 in mapping.get_apiv1_elements():\n                    if (\n                        isinstance(functionv1, Function)\n                        and resultv1.function_id == functionv1.id\n                    ):\n                        for functionv2 in mapping.get_apiv2_elements():\n                            if (\n                                isinstance(functionv2, Function)\n                                and resultv2.function_id == functionv2.id\n                            ):\n                                return (\n                                    self.differ.compute_result_similarity(\n                                        resultv1, resultv2\n                                    )\n                                    * (1 - self.boost_value)\n                                ) + self.boost_value\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_additional_mappings",
      "name": "get_additional_mappings",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.get_additional_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_additional_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.get_additional_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_additional_mappings(self) -> list[Mapping]:\n        return self.previous_mappings"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_related_mappings",
      "name": "get_related_mappings",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.get_related_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/get_related_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.get_related_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Indicates whether all api elements should be compared with each other\nor just the ones that are mapped to each other.\n:return: a list of Mappings by type whose elements are not already mapped",
      "docstring": "Indicates whether all api elements should be compared with each other\nor just the ones that are mapped to each other.\n:return: a list of Mappings by type whose elements are not already mapped",
      "code": "    def get_related_mappings(self) -> Optional[list[Mapping]]:\n        \"\"\"\n        Indicates whether all api elements should be compared with each other\n        or just the ones that are mapped to each other.\n        :return: a list of Mappings by type whose elements are not already mapped\n        \"\"\"\n        related_mappings = []\n        mapped_apiv1_elements = [\n            element\n            for mapping in self.previous_mappings\n            for element in mapping.get_apiv1_elements()\n        ]\n        mapped_apiv2_elements = [\n            element\n            for mapping in self.previous_mappings\n            for element in mapping.get_apiv2_elements()\n        ]\n        for get_api_element in [\n            lambda api: api.classes.values(),\n            lambda api: api.functions.values(),\n            lambda api: api.attributes().values(),\n            lambda api: api.parameters().values(),\n            lambda api: api.results().values(),\n        ]:\n            not_mapped_elements_mapping = self._get_not_mapped_api_elements(\n                mapped_apiv1_elements, mapped_apiv2_elements, get_api_element\n            )\n            if not_mapped_elements_mapping is not None:\n                related_mappings.append(not_mapped_elements_mapping)\n        return related_mappings"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/notify_new_mapping",
      "name": "notify_new_mapping",
      "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.notify_new_mapping",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/notify_new_mapping/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.notify_new_mapping.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._inheritance_differ/InheritanceDiffer/notify_new_mapping/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._inheritance_differ.InheritanceDiffer.notify_new_mapping.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        self.new_mappings.extend(mappings)"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping.get_apiv1_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv1_elements(self) -> list[api_element]:\n        return self.apiv1_elements"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping.get_apiv2_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToManyMapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.ManyToManyMapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv2_elements(self) -> list[api_element]:\n        return self.apiv2_elements"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping.get_apiv1_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv1_elements(self) -> list[api_element]:\n        return self.apiv1_elements"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping.get_apiv2_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/ManyToOneMapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.ManyToOneMapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv2_elements(self) -> list[api_element]:\n        return [self.apiv2_element]"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.Mapping.get_apiv1_elements",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.Mapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def get_apiv1_elements(self) -> list[api_element]:\n        pass"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.Mapping.get_apiv2_elements",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/Mapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.Mapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def get_apiv2_elements(self) -> list[api_element]:\n        pass"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/Mapping/get_similarity",
      "name": "get_similarity",
      "qname": "package_parser.processing.migration.model._mapping.Mapping.get_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/Mapping/get_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.Mapping.get_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_similarity(self) -> float:\n        return self.similarity"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping.get_apiv1_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv1_elements(self) -> list[api_element]:\n        return [self.apiv1_element]"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping.get_apiv2_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/OneToManyMapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.OneToManyMapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv2_elements(self) -> list[api_element]:\n        return self.apiv2_elements"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv1_elements",
      "name": "get_apiv1_elements",
      "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping.get_apiv1_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv1_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping.get_apiv1_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv1_elements(self) -> list[api_element]:\n        return [self.apiv1_element]"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv2_elements",
      "name": "get_apiv2_elements",
      "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping.get_apiv2_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/OneToOneMapping/get_apiv2_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._mapping.OneToOneMapping.get_apiv2_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_apiv2_elements(self) -> list[api_element]:\n        return [self.apiv2_element]"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/merge_api_elements_and_remove_duplicates",
      "name": "merge_api_elements_and_remove_duplicates",
      "qname": "package_parser.processing.migration.model._mapping.merge_api_elements_and_remove_duplicates",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/merge_api_elements_and_remove_duplicates/list_a",
          "name": "list_a",
          "qname": "package_parser.processing.migration.model._mapping.merge_api_elements_and_remove_duplicates.list_a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/merge_api_elements_and_remove_duplicates/list_b",
          "name": "list_b",
          "qname": "package_parser.processing.migration.model._mapping.merge_api_elements_and_remove_duplicates.list_b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def merge_api_elements_and_remove_duplicates(\n    list_a: list[api_element], list_b: list[api_element]\n) -> list[api_element]:\n    api_elements: list[api_element] = []\n    api_elements.extend(list_a)\n    api_elements.extend(list_b)\n    id_list: list[str] = []\n    merged_list: list[api_element] = []\n    for element in api_elements:\n        element_id = \"\"\n        if isinstance(element, (Class, Function, Parameter)):\n            element_id = element.id\n        elif isinstance(element, Attribute):\n            element_id = str(element.class_id) + \"/\" + element.name\n        elif isinstance(element, Result):\n            element_id = str(element.function_id) + \"/\" + element.name\n        if len(element_id) > 0 and element_id not in id_list:\n            merged_list.append(element)\n            id_list.append(element_id)\n    return merged_list"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._mapping/merge_mappings",
      "name": "merge_mappings",
      "qname": "package_parser.processing.migration.model._mapping.merge_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/merge_mappings/mapping_a",
          "name": "mapping_a",
          "qname": "package_parser.processing.migration.model._mapping.merge_mappings.mapping_a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._mapping/merge_mappings/mapping_b",
          "name": "mapping_b",
          "qname": "package_parser.processing.migration.model._mapping.merge_mappings.mapping_b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def merge_mappings(mapping_a: Mapping, mapping_b: Mapping) -> Mapping:\n    similarity = (mapping_a.similarity + mapping_b.similarity) / 2\n    codomain = merge_api_elements_and_remove_duplicates(\n        mapping_a.get_apiv2_elements(), mapping_b.get_apiv2_elements()\n    )\n    domain: list[api_element] = merge_api_elements_and_remove_duplicates(\n        mapping_a.get_apiv1_elements(), mapping_b.get_apiv1_elements()\n    )\n    if len(domain) == 1 and len(codomain) == 1:\n        return OneToOneMapping(similarity, domain[0], codomain[0])\n    if len(domain) == 1:\n        return OneToManyMapping(similarity, domain[0], codomain)\n    if len(codomain) == 1:\n        return ManyToOneMapping(similarity, domain, codomain[0])\n    return ManyToManyMapping(similarity, domain, codomain)"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/previous_base_differ",
          "name": "previous_base_differ",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.previous_base_differ",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/previous_mappings",
          "name": "previous_mappings",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.previous_mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/apiv1",
          "name": "apiv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.apiv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/__init__/apiv2",
          "name": "apiv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.__init__.apiv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        previous_base_differ: AbstractDiffer,\n        previous_mappings: list[Mapping],\n        apiv1: API,\n        apiv2: API,\n    ) -> None:\n        super().__init__(previous_base_differ, previous_mappings, apiv1, apiv2)\n        self.differ = previous_base_differ\n        self.new_mappings = []"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other",
      "name": "_api_elements_are_mapped_to_each_other",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._api_elements_are_mapped_to_each_other",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._api_elements_are_mapped_to_each_other.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other/api_elementv1",
          "name": "api_elementv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._api_elements_are_mapped_to_each_other.api_elementv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_api_elements_are_mapped_to_each_other/api_elementv2",
          "name": "api_elementv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._api_elements_are_mapped_to_each_other.api_elementv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _api_elements_are_mapped_to_each_other(\n        self,\n        api_elementv1: DEPENDENT_API_ELEMENTS,\n        api_elementv2: DEPENDENT_API_ELEMENTS,\n    ) -> bool:\n        (\n            relevant_apiv1_mappings,\n            relevant_apiv2_mappings,\n        ) = self._get_mapping_for_elements(api_elementv1, api_elementv2)\n        relevant_apiv2_mappings_include_functionv1 = (\n            len(\n                [\n                    parent\n                    for mapping in relevant_apiv2_mappings\n                    for parent in mapping.get_apiv1_elements()\n                    if self._is_parent(parent, api_elementv1)\n                ]\n            )\n            == 1\n        )\n        relevant_apiv2_mappings_include_functionv2 = (\n            len(\n                [\n                    parent\n                    for mapping in relevant_apiv1_mappings\n                    for parent in mapping.get_apiv2_elements()\n                    if self._is_parent(parent, api_elementv2)\n                ]\n            )\n            == 1\n        )\n        return (\n            relevant_apiv2_mappings_include_functionv1\n            and relevant_apiv2_mappings_include_functionv2\n        )"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements",
      "name": "_get_mapping_for_elements",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._get_mapping_for_elements",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._get_mapping_for_elements.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements/apiv1_element",
          "name": "apiv1_element",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._get_mapping_for_elements.apiv1_element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_get_mapping_for_elements/apiv2_element",
          "name": "apiv2_element",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._get_mapping_for_elements.apiv2_element",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _get_mapping_for_elements(\n        self,\n        apiv1_element: DEPENDENT_API_ELEMENTS,\n        apiv2_element: DEPENDENT_API_ELEMENTS,\n    ) -> tuple[list[Mapping], list[Mapping]]:\n        mapping_for_apiv1_elements = []\n        mapping_for_apiv2_elements = []\n        for mapping in self.new_mappings:\n            if isinstance(mapping.get_apiv1_elements()[0], (Class, Function)):\n                for element in mapping.get_apiv1_elements():\n                    if self._is_parent(element, apiv1_element):\n                        mapping_for_apiv1_elements.append(mapping)\n                for element in mapping.get_apiv2_elements():\n                    if self._is_parent(element, apiv2_element):\n                        mapping_for_apiv2_elements.append(mapping)\n        return mapping_for_apiv1_elements, mapping_for_apiv2_elements"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent",
      "name": "_is_parent",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._is_parent",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._is_parent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent/possible_parent",
          "name": "possible_parent",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._is_parent.possible_parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/_is_parent/child",
          "name": "child",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer._is_parent.child",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def _is_parent(\n        self,\n        possible_parent: Union[Class, Function, Attribute, Parameter, Result],\n        child: DEPENDENT_API_ELEMENTS,\n    ) -> bool:\n        if isinstance(child, Attribute) and isinstance(possible_parent, Class):\n            return child.class_id == possible_parent.id\n        if isinstance(child, Result) and isinstance(possible_parent, Function):\n            return child.function_id == possible_parent.id\n        if isinstance(child, Parameter) and isinstance(possible_parent, Function):\n            return \"/\".join(child.id.split(\"/\")[:-1]) == possible_parent.id\n        if isinstance(child, Function) and isinstance(possible_parent, Class):\n            return \"/\".join(child.id.split(\"/\")[:-1]) == possible_parent.id\n        return False"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity",
      "name": "compute_attribute_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_attribute_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_attribute_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity/attributev1",
          "name": "attributev1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_attribute_similarity.attributev1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_attribute_similarity/attributev2",
          "name": "attributev2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_attribute_similarity.attributev2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between attributes from apiv1 and apiv2.\n:param attributev1: attribute from apiv1\n:param attributev2: attribute from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_attribute_similarity(\n        self, attributev1: Attribute, attributev2: Attribute\n    ) -> float:\n        \"\"\"\n        Computes similarity between attributes from apiv1 and apiv2.\n        :param attributev1: attribute from apiv1\n        :param attributev2: attribute from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(attributev1, attributev2):\n            return self.differ.compute_attribute_similarity(attributev1, attributev2)\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity",
      "name": "compute_class_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_class_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_class_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity/classv1",
          "name": "classv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_class_similarity.classv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_class_similarity/classv2",
          "name": "classv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_class_similarity.classv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between classes from apiv1 and apiv2\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: if the classes are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between classes from apiv1 and apiv2\n:param classv1: class from apiv1\n:param classv2: class from apiv2\n:return: if the classes are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_class_similarity(self, classv1: Class, classv2: Class) -> float:\n        \"\"\"\n        Computes similarity between classes from apiv1 and apiv2\n        :param classv1: class from apiv1\n        :param classv2: class from apiv2\n        :return: if the classes are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        for mapping in self.previous_mappings:\n            if (\n                classv1 in mapping.get_apiv1_elements()\n                and classv2 in mapping.get_apiv2_elements()\n            ):\n                return self.differ.compute_class_similarity(classv1, classv2)\n        return 0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity",
      "name": "compute_function_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_function_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_function_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity/functionv1",
          "name": "functionv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_function_similarity.functionv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_function_similarity/functionv2",
          "name": "functionv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_function_similarity.functionv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between functions from apiv1 and apiv2.\n:param functionv1: function from apiv1\n:param functionv2: function from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_function_similarity(\n        self, functionv1: Function, functionv2: Function\n    ) -> float:\n        \"\"\"\n        Computes similarity between functions from apiv1 and apiv2.\n        :param functionv1: function from apiv1\n        :param functionv2: function from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        is_global_functionv1 = len(functionv1.id.split(\"/\")) == 3\n        is_global_functionv2 = len(functionv2.id.split(\"/\")) == 3\n        if is_global_functionv1 and is_global_functionv2:\n            for mapping in self.previous_mappings:\n                if (\n                    functionv1 in mapping.get_apiv1_elements()\n                    and functionv2 in mapping.get_apiv2_elements()\n                ):\n                    return self.differ.compute_function_similarity(\n                        functionv1, functionv2\n                    )\n        elif (\n            not is_global_functionv1 and not is_global_functionv2\n        ) and self._api_elements_are_mapped_to_each_other(functionv1, functionv2):\n            return self.differ.compute_function_similarity(functionv1, functionv2)\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity",
      "name": "compute_parameter_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_parameter_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_parameter_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity/parameterv1",
          "name": "parameterv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_parameter_similarity.parameterv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_parameter_similarity/parameterv2",
          "name": "parameterv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_parameter_similarity.parameterv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between parameters from apiv1 and apiv2.\n:param parameterv1: parameter from apiv1\n:param parameterv2: parameter from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_parameter_similarity(\n        self, parameterv1: Parameter, parameterv2: Parameter\n    ) -> float:\n        \"\"\"\n        Computes similarity between parameters from apiv1 and apiv2.\n        :param parameterv1: parameter from apiv1\n        :param parameterv2: parameter from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(parameterv1, parameterv2):\n            return self.differ.compute_parameter_similarity(parameterv1, parameterv2)\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity",
      "name": "compute_result_similarity",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_result_similarity",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_result_similarity.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity/resultv1",
          "name": "resultv1",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_result_similarity.resultv1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/compute_result_similarity/resultv2",
          "name": "resultv2",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.compute_result_similarity.resultv2",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Computes similarity between results from apiv1 and apiv2.\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "docstring": "Computes similarity between results from apiv1 and apiv2.\n:param resultv1: result from apiv1\n:param resultv2: result from apiv2\n:return: if their parents are mapped together, the similarity of the previous differ, or else 0.",
      "code": "    def compute_result_similarity(self, resultv1: Result, resultv2: Result) -> float:\n        \"\"\"\n        Computes similarity between results from apiv1 and apiv2.\n        :param resultv1: result from apiv1\n        :param resultv2: result from apiv2\n        :return: if their parents are mapped together, the similarity of the previous differ, or else 0.\n        \"\"\"\n        if self._api_elements_are_mapped_to_each_other(resultv1, resultv2):\n            return self.differ.compute_result_similarity(resultv1, resultv2)\n        return 0.0"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_additional_mappings",
      "name": "get_additional_mappings",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.get_additional_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_additional_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.get_additional_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_additional_mappings(self) -> list[Mapping]:\n        return []"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_related_mappings",
      "name": "get_related_mappings",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.get_related_mappings",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/get_related_mappings/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.get_related_mappings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_related_mappings(\n        self,\n    ) -> Optional[list[Mapping]]:\n        sort_order = {\n            Class: 0,\n            Attribute: 1,\n            Function: 2,\n            Parameter: 3,\n            Result: 4,\n        }\n        return sorted(\n            self.previous_mappings,\n            key=lambda mapping: sort_order[type(mapping.get_apiv1_elements()[0])],\n        )"
    },
    {
      "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/notify_new_mapping",
      "name": "notify_new_mapping",
      "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.notify_new_mapping",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/notify_new_mapping/self",
          "name": "self",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.notify_new_mapping.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.migration.model._strict_differ/StrictDiffer/notify_new_mapping/mappings",
          "name": "mappings",
          "qname": "package_parser.processing.migration.model._strict_differ.StrictDiffer.notify_new_mapping.mappings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def notify_new_mapping(self, mappings: list[Mapping]) -> None:\n        self.new_mappings.extend(mappings)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter",
      "name": "__enter",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[0]\n        if method is not None:\n            method(node)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks",
      "name": "__get_callbacks",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __get_callbacks(self, node: astroid.NodeNG) -> _EnterAndLeaveFunctions:\n        klass = node.__class__\n        methods = self._cache.get(klass)\n\n        if methods is None:\n            handler = self._handler\n            class_name = klass.__name__.lower()\n            enter_method = getattr(\n                handler, f\"enter_{class_name}\", getattr(handler, \"enter_default\", None)\n            )\n            leave_method = getattr(\n                handler, f\"leave_{class_name}\", getattr(handler, \"leave_default\", None)\n            )\n            self._cache[klass] = (enter_method, leave_method)\n        else:\n            enter_method, leave_method = methods\n\n        return enter_method, leave_method"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__",
      "name": "__init__",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__/handler",
          "name": "handler",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__.handler",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "docstring": "",
      "code": "    def __init__(self, handler: Any) -> None:\n        self._handler = handler\n        self._cache: dict[Type, _EnterAndLeaveFunctions] = {}"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave",
      "name": "__leave",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __leave(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[1]\n        if method is not None:\n            method(node)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk",
      "name": "__walk",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/visited_nodes",
          "name": "visited_nodes",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.visited_nodes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __walk(self, node: astroid.NodeNG, visited_nodes: set[astroid.NodeNG]) -> None:\n        if node in visited_nodes:\n            raise AssertionError(\"Node visited twice\")\n        visited_nodes.add(node)\n\n        self.__enter(node)\n        for child_node in node.get_children():\n            self.__walk(child_node, visited_nodes)\n        self.__leave(node)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk",
      "name": "walk",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.walk",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.walk.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.walk.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def walk(self, node: astroid.NodeNG) -> None:\n        self.__walk(node, set())"
    },
    {
      "id": "package-parser/package_parser.utils._files/__read_lines",
      "name": "__read_lines",
      "qname": "package_parser.utils._files.__read_lines",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/__read_lines/f",
          "name": "f",
          "qname": "package_parser.utils._files.__read_lines.f",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __read_lines(f: TextIO) -> list[str]:\n    return [it.strip() for it in f.readlines() if it != \"\"]"
    },
    {
      "id": "package-parser/package_parser.utils._files/__write_lines",
      "name": "__write_lines",
      "qname": "package_parser.utils._files.__write_lines",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/__write_lines/f",
          "name": "f",
          "qname": "package_parser.utils._files.__write_lines.f",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._files/__write_lines/lines",
          "name": "lines",
          "qname": "package_parser.utils._files.__write_lines.lines",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __write_lines(f: TextIO, lines: list[str]) -> None:\n    f.writelines(f\"{it}\\n\" for it in lines)"
    },
    {
      "id": "package-parser/package_parser.utils._files/ensure_file_exists",
      "name": "ensure_file_exists",
      "qname": "package_parser.utils._files.ensure_file_exists",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/ensure_file_exists/file",
          "name": "file",
          "qname": "package_parser.utils._files.ensure_file_exists.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Creates a file and all parent directories if they don't exist already.\n\n:param file: The file path.",
      "docstring": "Creates a file and all parent directories if they don't exist already.\n\n:param file: The file path.",
      "code": "def ensure_file_exists(file: Path) -> None:\n    \"\"\"\n    Creates a file and all parent directories if they don't exist already.\n\n    :param file: The file path.\n    \"\"\"\n\n    file.parent.mkdir(parents=True, exist_ok=True)\n    file.touch(exist_ok=True)"
    },
    {
      "id": "package-parser/package_parser.utils._files/initialize_and_read_exclude_file",
      "name": "initialize_and_read_exclude_file",
      "qname": "package_parser.utils._files.initialize_and_read_exclude_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/initialize_and_read_exclude_file/exclude_file",
          "name": "exclude_file",
          "qname": "package_parser.utils._files.initialize_and_read_exclude_file.exclude_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def initialize_and_read_exclude_file(exclude_file: Path) -> list[str]:\n    exclude_file.parent.mkdir(parents=True, exist_ok=True)\n    try:\n        with exclude_file.open(\"r\") as f:\n            return __read_lines(f)\n    except FileNotFoundError:\n        return []"
    },
    {
      "id": "package-parser/package_parser.utils._files/list_files",
      "name": "list_files",
      "qname": "package_parser.utils._files.list_files",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/list_files/root_dir",
          "name": "root_dir",
          "qname": "package_parser.utils._files.list_files.root_dir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._files/list_files/extension",
          "name": "extension",
          "qname": "package_parser.utils._files.list_files.extension",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": ":param root_dir: The directory containing the files.\n:param extension: The extension the files should have.\n:return: A list with absolute paths to the files.",
      "docstring": ":param root_dir: The directory containing the files.\n:param extension: The extension the files should have.\n:return: A list with absolute paths to the files.",
      "code": "def list_files(root_dir: Path, extension: str = \"\") -> list[str]:\n    \"\"\"\n    :param root_dir: The directory containing the files.\n    :param extension: The extension the files should have.\n    :return: A list with absolute paths to the files.\n    \"\"\"\n\n    result: list[str] = []\n\n    for root, _, files in os.walk(root_dir):\n        for filename in files:\n            if filename.endswith(extension):\n                result.append(str(os.path.join(root, filename)))\n\n    return result"
    },
    {
      "id": "package-parser/package_parser.utils._names/declaration_qname_to_name",
      "name": "declaration_qname_to_name",
      "qname": "package_parser.utils._names.declaration_qname_to_name",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._names/declaration_qname_to_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.utils._names.declaration_qname_to_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def declaration_qname_to_name(qualified_name: str) -> str:\n    return qualified_name.split(\".\")[-1]"
    },
    {
      "id": "package-parser/package_parser.utils._names/parent_id",
      "name": "parent_id",
      "qname": "package_parser.utils._names.parent_id",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._names/parent_id/id_",
          "name": "id_",
          "qname": "package_parser.utils._names.parent_id.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def parent_id(id_: str) -> str:\n    return \"/\".join(id_.split(\"/\")[:-1])"
    },
    {
      "id": "package-parser/package_parser.utils._names/parent_qualified_name",
      "name": "parent_qualified_name",
      "qname": "package_parser.utils._names.parent_qualified_name",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._names/parent_qualified_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.utils._names.parent_qualified_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def parent_qualified_name(qualified_name: str) -> str:\n    return \".\".join(qualified_name.split(\".\")[:-1])"
    },
    {
      "id": "package-parser/package_parser.utils._parsing/parse_python_code",
      "name": "parse_python_code",
      "qname": "package_parser.utils._parsing.parse_python_code",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/code",
          "name": "code",
          "qname": "package_parser.utils._parsing.parse_python_code.code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/module_name",
          "name": "module_name",
          "qname": "package_parser.utils._parsing.parse_python_code.module_name",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/path",
          "name": "path",
          "qname": "package_parser.utils._parsing.parse_python_code.path",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/ast_builder",
          "name": "ast_builder",
          "qname": "package_parser.utils._parsing.parse_python_code.ast_builder",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Parses a source string in order to obtain an astroid AST from it\n\n:param str code: The code for the module.\n:param str module_name: The name for the module, if any\n:param str path: The path for the module\n:param ast_builder: The Astroid builder to use",
      "docstring": "Parses a source string in order to obtain an astroid AST from it\n\n:param str code: The code for the module.\n:param str module_name: The name for the module, if any\n:param str path: The path for the module\n:param ast_builder: The Astroid builder to use",
      "code": "def parse_python_code(\n    code: str,\n    module_name: str = \"\",\n    path: str = None,\n    ast_builder: AstroidBuilder = None,\n) -> astroid.Module:\n    \"\"\"Parses a source string in order to obtain an astroid AST from it\n\n    :param str code: The code for the module.\n    :param str module_name: The name for the module, if any\n    :param str path: The path for the module\n    :param ast_builder: The Astroid builder to use\n    \"\"\"\n\n    if ast_builder is None:\n        ast_builder = AstroidBuilder()\n\n    code = textwrap.dedent(code)\n    return ast_builder.string_build(code, modname=module_name, path=path)"
    },
    {
      "id": "package-parser/package_parser.utils._strings/pluralize",
      "name": "pluralize",
      "qname": "package_parser.utils._strings.pluralize",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._strings/pluralize/count",
          "name": "count",
          "qname": "package_parser.utils._strings.pluralize.count",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._strings/pluralize/word",
          "name": "word",
          "qname": "package_parser.utils._strings.pluralize.word",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def pluralize(count: int, word: str) -> str:\n    if count == 1:\n        return f\"{count} {word}\"\n    else:\n        return f\"{count} {word}s\""
    }
  ]
}