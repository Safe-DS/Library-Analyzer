{
  "schemaVersion": 1,
  "distribution": "",
  "package": "package-parser",
  "version": "",
  "modules": [],
  "classes": [
    {
      "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder",
      "name": "CustomEncoder",
      "qname": "package_parser.cli._json_encoder.CustomEncoder",
      "decorators": [],
      "superclasses": [
        "JSONEncoder"
      ],
      "methods": [
        "package-parser/package_parser.cli._json_encoder/CustomEncoder/default"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class CustomEncoder(JSONEncoder):\n    def default(self, o: Any) -> Any:\n        if isinstance(o, set):\n            return list(o)\n        return super().default(o)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AbstractAnnotation",
      "name": "AbstractAnnotation",
      "qname": "package_parser.model.annotations._annotations.AbstractAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/AbstractAnnotation/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AbstractAnnotation:\n    target: str\n    authors: list[str]\n    reviewers: list[str]\n\n    def to_json(self) -> dict:\n        return asdict(self)",
      "instance_attributes": [
        {
          "name": "target",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "authors",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "reviewers",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore",
      "name": "AnnotationStore",
      "qname": "package_parser.model.annotations._annotations.AnnotationStore",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/AnnotationStore/__init__",
        "package-parser/package_parser.model.annotations._annotations/AnnotationStore/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AnnotationStore:\n    boundaries: list[BoundaryAnnotation]\n    constants: list[ConstantAnnotation]\n    enums: list[EnumAnnotation]\n    optionals: list[OptionalAnnotation]\n    removes: list[RemoveAnnotation]\n    requireds: list[RequiredAnnotation]\n\n    def __init__(self):\n        self.constants = []\n        self.removes = []\n        self.requireds = []\n        self.optionals = []\n        self.boundaries = []\n        self.enums = []\n\n    def to_json(self) -> dict:\n        return {\n            \"constants\": {\n                annotation.target: annotation.to_json() for annotation in self.constants\n            },\n            \"removes\": {\n                annotation.target: annotation.to_json() for annotation in self.removes\n            },\n            \"requireds\": {\n                annotation.target: annotation.to_json() for annotation in self.requireds\n            },\n            \"optionals\": {\n                annotation.target: annotation.to_json() for annotation in self.optionals\n            },\n            \"boundaries\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.boundaries\n            },\n            \"enums\": {\n                annotation.target: annotation.to_json() for annotation in self.enums\n            },\n        }",
      "instance_attributes": [
        {
          "name": "constants",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "removes",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "requireds",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "optionals",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "boundaries",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "enums",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/BoundaryAnnotation",
      "name": "BoundaryAnnotation",
      "qname": "package_parser.model.annotations._annotations.BoundaryAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class BoundaryAnnotation(AbstractAnnotation):\n    interval: Interval",
      "instance_attributes": [
        {
          "name": "interval",
          "types": {
            "kind": "NamedType",
            "name": "Interval"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/ConstantAnnotation",
      "name": "ConstantAnnotation",
      "qname": "package_parser.model.annotations._annotations.ConstantAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConstantAnnotation(AbstractAnnotation):\n    defaultType: str\n    defaultValue: Any",
      "instance_attributes": [
        {
          "name": "defaultType",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "defaultValue",
          "types": null
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/EnumAnnotation",
      "name": "EnumAnnotation",
      "qname": "package_parser.model.annotations._annotations.EnumAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class EnumAnnotation(AbstractAnnotation):\n    enumName: str\n    pairs: list[EnumPair]",
      "instance_attributes": [
        {
          "name": "enumName",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "pairs",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/EnumPair",
      "name": "EnumPair",
      "qname": "package_parser.model.annotations._annotations.EnumPair",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/EnumPair/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class EnumPair:\n    stringValue: str\n    instanceName: str\n\n    def to_json(self) -> dict:\n        return asdict(self)",
      "instance_attributes": [
        {
          "name": "stringValue",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "instanceName",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/Interval",
      "name": "Interval",
      "qname": "package_parser.model.annotations._annotations.Interval",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/Interval/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Interval:\n    isDiscrete: bool\n    lowerIntervalLimit: int\n    lowerLimitType: int\n    upperIntervalLimit: int\n    upperLimitType: int\n\n    def to_json(self) -> dict:\n        return asdict(self)",
      "instance_attributes": [
        {
          "name": "isDiscrete",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "lowerIntervalLimit",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "lowerLimitType",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "upperIntervalLimit",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "upperLimitType",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/OptionalAnnotation",
      "name": "OptionalAnnotation",
      "qname": "package_parser.model.annotations._annotations.OptionalAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class OptionalAnnotation(AbstractAnnotation):\n    defaultType: str\n    defaultValue: Any",
      "instance_attributes": [
        {
          "name": "defaultType",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "defaultValue",
          "types": null
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo",
      "name": "ParameterInfo",
      "qname": "package_parser.model.annotations._annotations.ParameterInfo",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterInfo:\n    type: ParameterType\n    value: str\n    value_type: str\n\n    def __init__(self, parameter_type, value=\"\", value_type=\"\"):\n        self.type = parameter_type\n        self.value = value\n        self.value_type = value_type",
      "instance_attributes": [
        {
          "name": "type",
          "types": null
        },
        {
          "name": "value",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "value_type",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/ParameterType",
      "name": "ParameterType",
      "qname": "package_parser.model.annotations._annotations.ParameterType",
      "decorators": [],
      "superclasses": [
        "Enum"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterType(Enum):\n    Constant = 0\n    Optional = 1\n    Required = 2\n    Unused = 3",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/RemoveAnnotation",
      "name": "RemoveAnnotation",
      "qname": "package_parser.model.annotations._annotations.RemoveAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RemoveAnnotation(AbstractAnnotation):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/RequiredAnnotation",
      "name": "RequiredAnnotation",
      "qname": "package_parser.model.annotations._annotations.RequiredAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RequiredAnnotation(AbstractAnnotation):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore",
      "name": "UsageCountStore",
      "qname": "package_parser.model.usages._usages.UsageCountStore",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.usages._usages/UsageCountStore/from_json",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/__init__",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/__eq__",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/__hash__",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_class",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_function",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_parameter",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/init_value",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/n_class_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/n_function_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/n_parameter_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/most_common_parameter_values",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/merge_other_into_self",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Counts how often classes, functions, parameters, and parameter values are used.",
      "docstring": "Counts how often classes, functions, parameters, and parameter values are used.",
      "code": "class UsageCountStore:\n    \"\"\"Counts how often classes, functions, parameters, and parameter values are used.\"\"\"\n\n    @staticmethod\n    def from_json(json: Any) -> UsageCountStore:\n        \"\"\"Creates an instance of this class from a dictionary.\"\"\"\n\n        result = UsageCountStore()\n\n        # Revive class counts\n        class_counts = json[\"class_counts\"]\n        for class_id, count in class_counts.items():\n            result.add_class_usages(class_id, count)\n\n        # Revive function counts\n        function_counts = json[\"function_counts\"]\n        for function_id, count in function_counts.items():\n            result.add_function_usages(function_id, count)\n\n        # Revive parameter counts\n        parameter_counts = json[\"parameter_counts\"]\n        for parameter_id, count in parameter_counts.items():\n            result.add_parameter_usages(parameter_id, count)\n\n        # Revive value counts\n        value_counts = json[\"value_counts\"]\n        for parameter_id, values in value_counts.items():\n            for value, count in values.items():\n                result.add_value_usages(parameter_id, value, count)\n\n        return result\n\n    def __init__(self) -> None:\n        self.class_usages: Counter[ClassId] = Counter()\n        self.function_usages: Counter[FunctionId] = Counter()\n        self.parameter_usages: Counter[ParameterId] = Counter()\n        self.value_usages: dict[ParameterId, Counter[StringifiedValue]] = {}\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, UsageCountStore):\n            return (\n                self.class_usages == other.class_usages\n                and self.function_usages == other.function_usages\n                and self.parameter_usages == other.parameter_usages\n                and self.value_usages == other.value_usages\n            )\n\n        return False\n\n    def __hash__(self) -> int:\n        return hash(tuple(sorted(self.__dict__.items())))\n\n    def add_class_usages(self, class_id: ClassId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the class with the given name by the given count.\"\"\"\n\n        self.class_usages[class_id] += count\n\n    def remove_class(self, class_id: ClassId) -> None:\n        \"\"\"Removes all usages of classes with the given name and usages of their methods.\"\"\"\n\n        if class_id in self.class_usages:\n            del self.class_usages[class_id]\n\n        for function_id in list(self.function_usages.keys()):\n            if function_id.startswith(class_id):\n                self.remove_function(function_id)\n\n    def add_function_usages(self, function_id: FunctionId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the function with the given name by the given count.\"\"\"\n\n        self.function_usages[function_id] += count\n\n    def remove_function(self, function_id: FunctionId) -> None:\n        \"\"\"Removes all usages of functions with the given name and usages of their parameters.\"\"\"\n\n        if function_id in self.function_usages:\n            del self.function_usages[function_id]\n\n        for parameter_id in list(self.parameter_usages.keys()):\n            if parameter_id.startswith(function_id):\n                self.remove_parameter(parameter_id)\n\n    def add_parameter_usages(self, parameter_id: ParameterId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the parameter with the given name by the given count.\"\"\"\n\n        self.parameter_usages[parameter_id] += count\n\n    def remove_parameter(self, parameter_id: ParameterId) -> None:\n        \"\"\"Removes all parameter and value usages of parameters with the given name.\"\"\"\n\n        if parameter_id in self.parameter_usages:\n            del self.parameter_usages[parameter_id]\n\n        if parameter_id in self.value_usages:\n            del self.value_usages[parameter_id]\n\n    def add_value_usages(\n        self, parameter_id: ParameterId, value: StringifiedValue, count: int = 1\n    ) -> None:\n        \"\"\"Increases the usage count of the given value for the parameter with the given name by the given count.\"\"\"\n\n        self.init_value(parameter_id)\n        self.value_usages[parameter_id][value] += count\n\n    def init_value(self, parameter_id: ParameterId) -> None:\n        \"\"\"Ensures the dictionary for the value counts has the given parameter name as a key.\"\"\"\n\n        if parameter_id not in self.value_usages:\n            self.value_usages[parameter_id] = Counter()\n\n    def n_class_usages(self, class_id: ClassId) -> int:\n        \"\"\"Returns how often the class is used, i.e. how often any of its methods are called.\"\"\"\n\n        return self.class_usages[class_id]\n\n    def n_function_usages(self, function_id: FunctionId) -> int:\n        \"\"\"Returns how often the function is called.\"\"\"\n\n        return self.function_usages[function_id]\n\n    def n_parameter_usages(self, parameter_id: ParameterId) -> int:\n        \"\"\"Returns how often the parameter is set.\"\"\"\n\n        return self.parameter_usages[parameter_id]\n\n    def n_value_usages(self, parameter_id: ParameterId, value: str) -> int:\n        \"\"\"Returns how often the parameter with the given name is set to the given value.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return self.value_usages[parameter_id][value]\n\n        return 0\n\n    def most_common_parameter_values(self, parameter_id: ParameterId) -> list[str]:\n        \"\"\"Returns all values that have been set for the parameter with the given name sorted by their count in descending order.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return [\n                value\n                for value, count in self.value_usages[parameter_id].most_common()\n                if count > 0\n            ]\n\n        return []\n\n    def merge_other_into_self(\n        self, other_usage_store: UsageCountStore\n    ) -> UsageCountStore:\n        \"\"\"\n        Merges the other usage store into this one **in-place** and returns this store.\n\n        :param other_usage_store: The usage store to merge into this one.\n        :return: This usage store.\n        \"\"\"\n\n        # Merge class usages\n        self.class_usages += other_usage_store.class_usages\n\n        # Merge function usages\n        self.function_usages += other_usage_store.function_usages\n\n        # Merge parameter usages\n        self.parameter_usages += other_usage_store.parameter_usages\n\n        # Merge value usages\n        for parameter_id, value_usages in other_usage_store.value_usages.items():\n            self.init_value(parameter_id)\n            self.value_usages[parameter_id] += value_usages\n\n        return self\n\n    def to_json(self) -> Any:\n        \"\"\"Converts this class to a dictionary, which can later be serialized as JSON.\"\"\"\n\n        return {\n            \"class_counts\": {\n                class_id: usage_count\n                for class_id, usage_count in self.class_usages.most_common()\n            },\n            \"function_counts\": {\n                function_id: usage_count\n                for function_id, usage_count in self.function_usages.most_common()\n            },\n            \"parameter_counts\": {\n                parameter_id: usage_count\n                for parameter_id, usage_count in self.parameter_usages.most_common()\n            },\n            \"value_counts\": {\n                parameter_id: {\n                    value: usage_count for value, usage_count in values.most_common()\n                }\n                for parameter_id, values in self.value_usages.items()\n            },\n        }",
      "instance_attributes": [
        {
          "name": "class_usages",
          "types": {
            "kind": "NamedType",
            "name": "Counter[ClassId]"
          }
        },
        {
          "name": "function_usages",
          "types": {
            "kind": "NamedType",
            "name": "Counter[FunctionId]"
          }
        },
        {
          "name": "parameter_usages",
          "types": {
            "kind": "NamedType",
            "name": "Counter[ParameterId]"
          }
        },
        {
          "name": "value_usages",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder",
      "name": "_UsageFinder",
      "qname": "package_parser.processing.usages._ast_visitor._UsageFinder",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__",
        "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class _UsageFinder:\n    def __init__(self, package_name: str) -> None:\n        self.package_name: str = package_name\n        self.usages: UsageCountStore = UsageCountStore()\n\n    def enter_call(self, node: astroid.Call):\n        called_tuple = _analyze_declaration_called_by(node, self.package_name)\n        if called_tuple is None:\n            return\n        called, function_id, parameters, n_implicit_parameters = called_tuple\n\n        bound_parameters = _bound_parameters(\n            parameters, CallSite.from_call(node), n_implicit_parameters\n        )\n        if bound_parameters is None:\n            return\n\n        # Add class usage\n        if (\n            isinstance(called, (astroid.BoundMethod, astroid.UnboundMethod))\n            or isinstance(called, astroid.FunctionDef)\n            and called.is_method()\n        ):\n            self.usages.add_class_usages(parent_id(function_id))\n\n        # Add function usage\n        self.usages.add_function_usages(function_id)\n\n        # Add parameter & value usage\n        for parameter_name, value in bound_parameters.items():\n            parameter_id = f\"{function_id}/{parameter_name}\"\n            self.usages.add_parameter_usages(parameter_id)\n\n            value = _stringify_value(value)\n            self.usages.add_value_usages(parameter_id, value)",
      "instance_attributes": [
        {
          "name": "package_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "usages",
          "types": {
            "kind": "NamedType",
            "name": "UsageCountStore"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker",
      "name": "ASTWalker",
      "qname": "package_parser.utils._ASTWalker.ASTWalker",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "docstring": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "code": "class ASTWalker:\n    \"\"\"A walker visiting a tree in preorder, calling on the handler:\n\n    * enter_<class_name> on entering a node, where class name is the class of\n    the node in lower case.\n\n    * leave_<class_name> on leaving a node, where class name is the class of\n    the node in lower case.\n    \"\"\"\n\n    def __init__(self, handler: Any) -> None:\n        self._handler = handler\n        self._cache: dict[Type, _EnterAndLeaveFunctions] = {}\n\n    def walk(self, node: astroid.NodeNG) -> None:\n        self.__walk(node, set())\n\n    def __walk(self, node: astroid.NodeNG, visited_nodes: set[astroid.NodeNG]) -> None:\n        if node in visited_nodes:\n            raise AssertionError(\"Node visited twice\")\n        visited_nodes.add(node)\n\n        self.__enter(node)\n        for child_node in node.get_children():\n            self.__walk(child_node, visited_nodes)\n        self.__leave(node)\n\n    def __enter(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[0]\n        if method is not None:\n            method(node)\n\n    def __leave(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[1]\n        if method is not None:\n            method(node)\n\n    def __get_callbacks(self, node: astroid.NodeNG) -> _EnterAndLeaveFunctions:\n        klass = node.__class__\n        methods = self._cache.get(klass)\n\n        if methods is None:\n            handler = self._handler\n            class_name = klass.__name__.lower()\n            enter_method = getattr(\n                handler, f\"enter_{class_name}\", getattr(handler, \"enter_default\", None)\n            )\n            leave_method = getattr(\n                handler, f\"leave_{class_name}\", getattr(handler, \"leave_default\", None)\n            )\n            self._cache[klass] = (enter_method, leave_method)\n        else:\n            enter_method, leave_method = methods\n\n        return enter_method, leave_method",
      "instance_attributes": [
        {
          "name": "_handler",
          "types": {
            "kind": "NamedType",
            "name": "Any"
          }
        },
        {
          "name": "_cache",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    }
  ],
  "functions": [
    {
      "id": "package-parser/package_parser.cli._cli/_add_all_subparser",
      "name": "_add_all_subparser",
      "qname": "package_parser.cli._cli._add_all_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_all_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_all_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_all_subparser(subparsers: _SubParsersAction) -> None:\n    all_parser = subparsers.add_parser(\n        _ALL_COMMAND,\n        help=\"Run api and usages command in parallel and then run annotations command.\",\n    )\n    all_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package.\",\n        type=str,\n        required=True,\n    )\n    all_parser.add_argument(\n        \"-s\",\n        \"--src\",\n        help=\"Directory containing the Python code of the package. If this is omitted, we try to locate the package \"\n        \"with the given name in the current Python interpreter.\",\n        type=Path,\n        required=False,\n        default=None,\n    )\n    all_parser.add_argument(\n        \"-c\",\n        \"--client\",\n        help=\"Directory containing Python code that uses the package.\",\n        type=Path,\n        required=True,\n    )\n    all_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )\n    all_parser.add_argument(\n        \"--processes\",\n        help=\"How many processes should be spawned during processing.\",\n        type=int,\n        required=False,\n        default=4,\n    )\n    all_parser.add_argument(\n        \"--batchsize\",\n        help=\"How many files to process in one go. Higher values lead to higher memory usage but better performance.\",\n        type=int,\n        required=False,\n        default=100,\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_annotations_subparser",
      "name": "_add_annotations_subparser",
      "qname": "package_parser.cli._cli._add_annotations_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_annotations_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_annotations_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_annotations_subparser(subparsers) -> None:\n    generate_parser = subparsers.add_parser(\n        _ANNOTATIONS_COMMAND, help=\"Generate Annotations automatically.\"\n    )\n    generate_parser.add_argument(\n        \"-a\",\n        \"--api\",\n        help=\"File created by the 'api' command.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-u\",\n        \"--usages\",\n        help=\"File created by the 'usages' command that contains usage counts.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_api_subparser",
      "name": "_add_api_subparser",
      "qname": "package_parser.cli._cli._add_api_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_api_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_api_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_api_subparser(subparsers: _SubParsersAction) -> None:\n    api_parser = subparsers.add_parser(_API_COMMAND, help=\"List the API of a package.\")\n    api_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package.\",\n        type=str,\n        required=True,\n    )\n    api_parser.add_argument(\n        \"-s\",\n        \"--src\",\n        help=\"Directory containing the Python code of the package. If this is omitted, we try to locate the package \"\n        \"with the given name in the current Python interpreter.\",\n        type=Path,\n        required=False,\n        default=None,\n    )\n    api_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_usages_subparser",
      "name": "_add_usages_subparser",
      "qname": "package_parser.cli._cli._add_usages_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_usages_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_usages_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_usages_subparser(subparsers: _SubParsersAction) -> None:\n    usages_parser = subparsers.add_parser(\n        _USAGES_COMMAND, help=\"Find usages of API elements.\"\n    )\n    usages_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package. It must be installed in the current interpreter.\",\n        type=str,\n        required=True,\n    )\n    usages_parser.add_argument(\n        \"-c\",\n        \"--client\",\n        help=\"Directory containing Python code that uses the package.\",\n        type=Path,\n        required=True,\n    )\n    usages_parser.add_argument(\n        \"--processes\",\n        help=\"How many processes should be spawned during processing.\",\n        type=int,\n        required=False,\n        default=4,\n    ),\n    usages_parser.add_argument(\n        \"--batchsize\",\n        help=\"How many files to process in one go. Higher values lead to higher memory usage but better performance.\",\n        type=int,\n        required=False,\n        default=100,\n    )\n    usages_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_get_args",
      "name": "_get_args",
      "qname": "package_parser.cli._cli._get_args",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(description=\"Analyze Python code.\")\n    parser.add_argument(\n        \"-v\", \"--verbose\", help=\"show info messages\", action=\"store_true\"\n    )\n\n    # Commands\n    subparsers = parser.add_subparsers(dest=\"command\")\n    _add_api_subparser(subparsers)\n    _add_usages_subparser(subparsers)\n    _add_annotations_subparser(subparsers)\n    _add_all_subparser(subparsers)\n\n    return parser.parse_args()"
    },
    {
      "id": "package-parser/package_parser.cli._cli/cli",
      "name": "cli",
      "qname": "package_parser.cli._cli.cli",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def cli() -> None:\n    args = _get_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.INFO)\n\n    if args.command == _API_COMMAND:\n        _run_api_command(args.package, args.src, args.out)\n    elif args.command == _USAGES_COMMAND:\n        _run_usages_command(\n            args.package, args.client, args.out, args.processes, args.batchsize\n        )\n    elif args.command == _ANNOTATIONS_COMMAND:\n        _run_annotations(args.api, args.usages, args.out)\n    elif args.command == _ALL_COMMAND:\n        _run_all_command(\n            args.package,\n            args.src,\n            args.client,\n            args.out,\n            args.processes,\n            args.batchsize,\n        )"
    },
    {
      "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder/default",
      "name": "default",
      "qname": "package_parser.cli._json_encoder.CustomEncoder.default",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder/default/self",
          "name": "self",
          "qname": "package_parser.cli._json_encoder.CustomEncoder.default.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder/default/o",
          "name": "o",
          "qname": "package_parser.cli._json_encoder.CustomEncoder.default.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def default(self, o: Any) -> Any:\n        if isinstance(o, set):\n            return list(o)\n        return super().default(o)"
    },
    {
      "id": "package-parser/package_parser.cli._run_all/_run_all_command",
      "name": "_run_all_command",
      "qname": "package_parser.cli._run_all._run_all_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_all._run_all_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/src_dir_path",
          "name": "src_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.src_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/client_dir_path",
          "name": "client_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.client_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/n_processes",
          "name": "n_processes",
          "qname": "package_parser.cli._run_all._run_all_command.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/batch_size",
          "name": "batch_size",
          "qname": "package_parser.cli._run_all._run_all_command.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_all_command(\n    package: str,\n    src_dir_path: Path,\n    client_dir_path: Path,\n    out_dir_path: Path,\n    n_processes: int,\n    batch_size: int,\n) -> None:\n    out_file_annotations = out_dir_path.joinpath(\"annotations.json\")\n    results = _run_in_parallel(\n        partial(_run_api_command, package, src_dir_path, out_dir_path),\n        partial(\n            _run_usages_command,\n            package,\n            client_dir_path,\n            out_dir_path,\n            n_processes,\n            batch_size,\n        ),\n    )\n    _run_annotations(results[_API_KEY], results[_USAGES_KEY], out_file_annotations)"
    },
    {
      "id": "package-parser/package_parser.cli._run_all/_run_in_parallel",
      "name": "_run_in_parallel",
      "qname": "package_parser.cli._run_all._run_in_parallel",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_all/_run_in_parallel/fns",
          "name": "fns",
          "qname": "package_parser.cli._run_all._run_in_parallel.fns",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_in_parallel(*fns) -> dict:\n    manager = multiprocessing.Manager()\n    return_dict: dict[str, str] = manager.dict()\n    proc = []\n    for fn in fns:\n        p = multiprocessing.Process(target=fn, args=(return_dict,))\n        proc.append(p)\n        p.start()\n\n    for p in proc:\n        p.join()\n\n    return return_dict"
    },
    {
      "id": "package-parser/package_parser.cli._run_annotations/_read_api_file",
      "name": "_read_api_file",
      "qname": "package_parser.cli._run_annotations._read_api_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_annotations/_read_api_file/api_file_path",
          "name": "api_file_path",
          "qname": "package_parser.cli._run_annotations._read_api_file.api_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_api_file(api_file_path: Path) -> API:\n    with open(api_file_path) as api_file:\n        api_json = json.load(api_file)\n\n    return API.from_json(api_json)"
    },
    {
      "id": "package-parser/package_parser.cli._run_annotations/_read_usages_file",
      "name": "_read_usages_file",
      "qname": "package_parser.cli._run_annotations._read_usages_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_annotations/_read_usages_file/usages_file_path",
          "name": "usages_file_path",
          "qname": "package_parser.cli._run_annotations._read_usages_file.usages_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_usages_file(usages_file_path: Path) -> UsageCountStore:\n    with open(usages_file_path) as usages_file:\n        usages_json = json.load(usages_file)\n\n    return UsageCountStore.from_json(usages_json)"
    },
    {
      "id": "package-parser/package_parser.cli._run_annotations/_run_annotations",
      "name": "_run_annotations",
      "qname": "package_parser.cli._run_annotations._run_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_annotations/_run_annotations/api_file_path",
          "name": "api_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.api_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_annotations/_run_annotations/usages_file_path",
          "name": "usages_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.usages_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_annotations/_run_annotations/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\nAnnotations that are generated are: remove, constant, required, optional, enum and boundary.\n:param api_file_path: API file Path\n:param usages_file_path: UsageStore file Path\n:param annotations_file_path: Output file Path",
      "docstring": "Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\nAnnotations that are generated are: remove, constant, required, optional, enum and boundary.\n:param api_file_path: API file Path\n:param usages_file_path: UsageStore file Path\n:param annotations_file_path: Output file Path",
      "code": "def _run_annotations(\n    api_file_path: Path, usages_file_path: Path, annotations_file_path: Path\n) -> None:\n    \"\"\"\n    Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\n    Annotations that are generated are: remove, constant, required, optional, enum and boundary.\n    :param api_file_path: API file Path\n    :param usages_file_path: UsageStore file Path\n    :param annotations_file_path: Output file Path\n    \"\"\"\n\n    api = _read_api_file(api_file_path)\n    usages = _read_usages_file(usages_file_path)\n    annotations = generate_annotations(api, usages)\n    _write_annotations_file(annotations, annotations_file_path)"
    },
    {
      "id": "package-parser/package_parser.cli._run_annotations/_write_annotations_file",
      "name": "_write_annotations_file",
      "qname": "package_parser.cli._run_annotations._write_annotations_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_annotations/_write_annotations_file/annotations",
          "name": "annotations",
          "qname": "package_parser.cli._run_annotations._write_annotations_file.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_annotations/_write_annotations_file/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._run_annotations._write_annotations_file.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_annotations_file(\n    annotations: AnnotationStore, annotations_file_path: Path\n) -> None:\n    ensure_file_exists(annotations_file_path)\n    with annotations_file_path.open(\"w\") as f:\n        json.dump(annotations.to_json(), f, indent=2)"
    },
    {
      "id": "package-parser/package_parser.cli._run_api/_run_api_command",
      "name": "_run_api_command",
      "qname": "package_parser.cli._run_api._run_api_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_api._run_api_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/src_dir_path",
          "name": "src_dir_path",
          "qname": "package_parser.cli._run_api._run_api_command.src_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_api._run_api_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/result_dict",
          "name": "result_dict",
          "qname": "package_parser.cli._run_api._run_api_command.result_dict",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_api_command(\n    package: str,\n    src_dir_path: Path,\n    out_dir_path: Path,\n    result_dict: Optional[dict] = None,\n) -> None:\n    api = get_api(package, src_dir_path)\n    api_dependencies = get_dependencies(api)\n\n    api_file_path = _write_api_file(api, out_dir_path)\n    _write_api_dependency_file(api, api_dependencies, out_dir_path)\n\n    if result_dict is not None:\n        result_dict[_API_KEY] = api_file_path"
    },
    {
      "id": "package-parser/package_parser.cli._run_api/_write_api_dependency_file",
      "name": "_write_api_dependency_file",
      "qname": "package_parser.cli._run_api._write_api_dependency_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_dependency_file/api",
          "name": "api",
          "qname": "package_parser.cli._run_api._write_api_dependency_file.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_dependency_file/api_dependencies",
          "name": "api_dependencies",
          "qname": "package_parser.cli._run_api._write_api_dependency_file.api_dependencies",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_dependency_file/out",
          "name": "out",
          "qname": "package_parser.cli._run_api._write_api_dependency_file.out",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_api_dependency_file(api: API, api_dependencies, out):\n    out_file_api_dependencies = out.joinpath(f\"{api.package}__api_dependencies.json\")\n    ensure_file_exists(out_file_api_dependencies)\n    with out_file_api_dependencies.open(\"w\") as f:\n        json.dump(api_dependencies.to_json(), f, indent=2, cls=CustomEncoder)"
    },
    {
      "id": "package-parser/package_parser.cli._run_api/_write_api_file",
      "name": "_write_api_file",
      "qname": "package_parser.cli._run_api._write_api_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_file/api",
          "name": "api",
          "qname": "package_parser.cli._run_api._write_api_file.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_file/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_api._write_api_file.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_api_file(api: API, out_dir_path: Path) -> Path:\n    out_file_api = out_dir_path.joinpath(f\"{api.package}__api.json\")\n    ensure_file_exists(out_file_api)\n    with out_file_api.open(\"w\") as f:\n        json.dump(api.to_json(), f, indent=2, cls=CustomEncoder)\n    return out_file_api"
    },
    {
      "id": "package-parser/package_parser.cli._run_usages/_run_usages_command",
      "name": "_run_usages_command",
      "qname": "package_parser.cli._run_usages._run_usages_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_usages._run_usages_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/client_dir_path",
          "name": "client_dir_path",
          "qname": "package_parser.cli._run_usages._run_usages_command.client_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_usages._run_usages_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/n_processes",
          "name": "n_processes",
          "qname": "package_parser.cli._run_usages._run_usages_command.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/batch_size",
          "name": "batch_size",
          "qname": "package_parser.cli._run_usages._run_usages_command.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/result_dict",
          "name": "result_dict",
          "qname": "package_parser.cli._run_usages._run_usages_command.result_dict",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_usages_command(\n    package: str,\n    client_dir_path: Path,\n    out_dir_path: Path,\n    n_processes: int,\n    batch_size: int,\n    result_dict: Optional[dict] = None,\n) -> None:\n    usages = find_usages(package, client_dir_path, n_processes, batch_size)\n\n    out_file_usage_count = out_dir_path.joinpath(f\"{package}__usage_counts.json\")\n    ensure_file_exists(out_file_usage_count)\n    with out_file_usage_count.open(\"w\") as f:\n        json.dump(usages.to_json(), f, indent=2)\n\n    if result_dict is not None:\n        result_dict[_USAGES_KEY] = out_file_usage_count"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AbstractAnnotation/to_json",
      "name": "to_json",
      "qname": "package_parser.model.annotations._annotations.AbstractAnnotation.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/AbstractAnnotation/to_json/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.AbstractAnnotation.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return asdict(self)"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore/__init__",
      "name": "__init__",
      "qname": "package_parser.model.annotations._annotations.AnnotationStore.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore/__init__/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.AnnotationStore.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self):\n        self.constants = []\n        self.removes = []\n        self.requireds = []\n        self.optionals = []\n        self.boundaries = []\n        self.enums = []"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore/to_json",
      "name": "to_json",
      "qname": "package_parser.model.annotations._annotations.AnnotationStore.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore/to_json/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.AnnotationStore.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"constants\": {\n                annotation.target: annotation.to_json() for annotation in self.constants\n            },\n            \"removes\": {\n                annotation.target: annotation.to_json() for annotation in self.removes\n            },\n            \"requireds\": {\n                annotation.target: annotation.to_json() for annotation in self.requireds\n            },\n            \"optionals\": {\n                annotation.target: annotation.to_json() for annotation in self.optionals\n            },\n            \"boundaries\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.boundaries\n            },\n            \"enums\": {\n                annotation.target: annotation.to_json() for annotation in self.enums\n            },\n        }"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/EnumPair/to_json",
      "name": "to_json",
      "qname": "package_parser.model.annotations._annotations.EnumPair.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/EnumPair/to_json/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.EnumPair.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return asdict(self)"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/Interval/to_json",
      "name": "to_json",
      "qname": "package_parser.model.annotations._annotations.Interval.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/Interval/to_json/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.Interval.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return asdict(self)"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__",
      "name": "__init__",
      "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__/parameter_type",
          "name": "parameter_type",
          "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__.parameter_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__/value",
          "name": "value",
          "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__.value",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__/value_type",
          "name": "value_type",
          "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__.value_type",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, parameter_type, value=\"\", value_type=\"\"):\n        self.type = parameter_type\n        self.value = value\n        self.value_type = value_type"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__eq__",
      "name": "__eq__",
      "qname": "package_parser.model.usages._usages.UsageCountStore.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__eq__/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__eq__/other",
          "name": "other",
          "qname": "package_parser.model.usages._usages.UsageCountStore.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: object) -> bool:\n        if isinstance(other, UsageCountStore):\n            return (\n                self.class_usages == other.class_usages\n                and self.function_usages == other.function_usages\n                and self.parameter_usages == other.parameter_usages\n                and self.value_usages == other.value_usages\n            )\n\n        return False"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__hash__",
      "name": "__hash__",
      "qname": "package_parser.model.usages._usages.UsageCountStore.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__hash__/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(tuple(sorted(self.__dict__.items())))"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__init__",
      "name": "__init__",
      "qname": "package_parser.model.usages._usages.UsageCountStore.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__init__/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Counts how often classes, functions, parameters, and parameter values are used.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self.class_usages: Counter[ClassId] = Counter()\n        self.function_usages: Counter[FunctionId] = Counter()\n        self.parameter_usages: Counter[ParameterId] = Counter()\n        self.value_usages: dict[ParameterId, Counter[StringifiedValue]] = {}"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages",
      "name": "add_class_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.add_class_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_class_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages/class_id",
          "name": "class_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_class_usages.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages/count",
          "name": "count",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_class_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the class with the given name by the given count.",
      "docstring": "Increases the usage count of the class with the given name by the given count.",
      "code": "    def add_class_usages(self, class_id: ClassId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the class with the given name by the given count.\"\"\"\n\n        self.class_usages[class_id] += count"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages",
      "name": "add_function_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.add_function_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_function_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages/function_id",
          "name": "function_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_function_usages.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages/count",
          "name": "count",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_function_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the function with the given name by the given count.",
      "docstring": "Increases the usage count of the function with the given name by the given count.",
      "code": "    def add_function_usages(self, function_id: FunctionId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the function with the given name by the given count.\"\"\"\n\n        self.function_usages[function_id] += count"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages",
      "name": "add_parameter_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.add_parameter_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_parameter_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_parameter_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages/count",
          "name": "count",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_parameter_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the parameter with the given name by the given count.",
      "docstring": "Increases the usage count of the parameter with the given name by the given count.",
      "code": "    def add_parameter_usages(self, parameter_id: ParameterId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the parameter with the given name by the given count.\"\"\"\n\n        self.parameter_usages[parameter_id] += count"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages",
      "name": "add_value_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages/value",
          "name": "value",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages/count",
          "name": "count",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the given value for the parameter with the given name by the given count.",
      "docstring": "Increases the usage count of the given value for the parameter with the given name by the given count.",
      "code": "    def add_value_usages(\n        self, parameter_id: ParameterId, value: StringifiedValue, count: int = 1\n    ) -> None:\n        \"\"\"Increases the usage count of the given value for the parameter with the given name by the given count.\"\"\"\n\n        self.init_value(parameter_id)\n        self.value_usages[parameter_id][value] += count"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/from_json",
      "name": "from_json",
      "qname": "package_parser.model.usages._usages.UsageCountStore.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/from_json/json",
          "name": "json",
          "qname": "package_parser.model.usages._usages.UsageCountStore.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Creates an instance of this class from a dictionary.",
      "docstring": "Creates an instance of this class from a dictionary.",
      "code": "    @staticmethod\n    def from_json(json: Any) -> UsageCountStore:\n        \"\"\"Creates an instance of this class from a dictionary.\"\"\"\n\n        result = UsageCountStore()\n\n        # Revive class counts\n        class_counts = json[\"class_counts\"]\n        for class_id, count in class_counts.items():\n            result.add_class_usages(class_id, count)\n\n        # Revive function counts\n        function_counts = json[\"function_counts\"]\n        for function_id, count in function_counts.items():\n            result.add_function_usages(function_id, count)\n\n        # Revive parameter counts\n        parameter_counts = json[\"parameter_counts\"]\n        for parameter_id, count in parameter_counts.items():\n            result.add_parameter_usages(parameter_id, count)\n\n        # Revive value counts\n        value_counts = json[\"value_counts\"]\n        for parameter_id, values in value_counts.items():\n            for value, count in values.items():\n                result.add_value_usages(parameter_id, value, count)\n\n        return result"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/init_value",
      "name": "init_value",
      "qname": "package_parser.model.usages._usages.UsageCountStore.init_value",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/init_value/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.init_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/init_value/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.init_value.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Ensures the dictionary for the value counts has the given parameter name as a key.",
      "docstring": "Ensures the dictionary for the value counts has the given parameter name as a key.",
      "code": "    def init_value(self, parameter_id: ParameterId) -> None:\n        \"\"\"Ensures the dictionary for the value counts has the given parameter name as a key.\"\"\"\n\n        if parameter_id not in self.value_usages:\n            self.value_usages[parameter_id] = Counter()"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/merge_other_into_self",
      "name": "merge_other_into_self",
      "qname": "package_parser.model.usages._usages.UsageCountStore.merge_other_into_self",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/merge_other_into_self/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.merge_other_into_self.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/merge_other_into_self/other_usage_store",
          "name": "other_usage_store",
          "qname": "package_parser.model.usages._usages.UsageCountStore.merge_other_into_self.other_usage_store",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Merges the other usage store into this one **in-place** and returns this store.\n\n:param other_usage_store: The usage store to merge into this one.\n:return: This usage store.",
      "docstring": "Merges the other usage store into this one **in-place** and returns this store.\n\n:param other_usage_store: The usage store to merge into this one.\n:return: This usage store.",
      "code": "    def merge_other_into_self(\n        self, other_usage_store: UsageCountStore\n    ) -> UsageCountStore:\n        \"\"\"\n        Merges the other usage store into this one **in-place** and returns this store.\n\n        :param other_usage_store: The usage store to merge into this one.\n        :return: This usage store.\n        \"\"\"\n\n        # Merge class usages\n        self.class_usages += other_usage_store.class_usages\n\n        # Merge function usages\n        self.function_usages += other_usage_store.function_usages\n\n        # Merge parameter usages\n        self.parameter_usages += other_usage_store.parameter_usages\n\n        # Merge value usages\n        for parameter_id, value_usages in other_usage_store.value_usages.items():\n            self.init_value(parameter_id)\n            self.value_usages[parameter_id] += value_usages\n\n        return self"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/most_common_parameter_values",
      "name": "most_common_parameter_values",
      "qname": "package_parser.model.usages._usages.UsageCountStore.most_common_parameter_values",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/most_common_parameter_values/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.most_common_parameter_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/most_common_parameter_values/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.most_common_parameter_values.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns all values that have been set for the parameter with the given name sorted by their count in descending order.",
      "docstring": "Returns all values that have been set for the parameter with the given name sorted by their count in descending order.",
      "code": "    def most_common_parameter_values(self, parameter_id: ParameterId) -> list[str]:\n        \"\"\"Returns all values that have been set for the parameter with the given name sorted by their count in descending order.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return [\n                value\n                for value, count in self.value_usages[parameter_id].most_common()\n                if count > 0\n            ]\n\n        return []"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_class_usages",
      "name": "n_class_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.n_class_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_class_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_class_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_class_usages/class_id",
          "name": "class_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_class_usages.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the class is used, i.e. how often any of its methods are called.",
      "docstring": "Returns how often the class is used, i.e. how often any of its methods are called.",
      "code": "    def n_class_usages(self, class_id: ClassId) -> int:\n        \"\"\"Returns how often the class is used, i.e. how often any of its methods are called.\"\"\"\n\n        return self.class_usages[class_id]"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_function_usages",
      "name": "n_function_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.n_function_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_function_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_function_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_function_usages/function_id",
          "name": "function_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_function_usages.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the function is called.",
      "docstring": "Returns how often the function is called.",
      "code": "    def n_function_usages(self, function_id: FunctionId) -> int:\n        \"\"\"Returns how often the function is called.\"\"\"\n\n        return self.function_usages[function_id]"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_parameter_usages",
      "name": "n_parameter_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.n_parameter_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_parameter_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_parameter_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_parameter_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_parameter_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the parameter is set.",
      "docstring": "Returns how often the parameter is set.",
      "code": "    def n_parameter_usages(self, parameter_id: ParameterId) -> int:\n        \"\"\"Returns how often the parameter is set.\"\"\"\n\n        return self.parameter_usages[parameter_id]"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages",
      "name": "n_value_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.n_value_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_value_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_value_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages/value",
          "name": "value",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_value_usages.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the parameter with the given name is set to the given value.",
      "docstring": "Returns how often the parameter with the given name is set to the given value.",
      "code": "    def n_value_usages(self, parameter_id: ParameterId, value: str) -> int:\n        \"\"\"Returns how often the parameter with the given name is set to the given value.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return self.value_usages[parameter_id][value]\n\n        return 0"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_class",
      "name": "remove_class",
      "qname": "package_parser.model.usages._usages.UsageCountStore.remove_class",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_class/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_class/class_id",
          "name": "class_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_class.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Removes all usages of classes with the given name and usages of their methods.",
      "docstring": "Removes all usages of classes with the given name and usages of their methods.",
      "code": "    def remove_class(self, class_id: ClassId) -> None:\n        \"\"\"Removes all usages of classes with the given name and usages of their methods.\"\"\"\n\n        if class_id in self.class_usages:\n            del self.class_usages[class_id]\n\n        for function_id in list(self.function_usages.keys()):\n            if function_id.startswith(class_id):\n                self.remove_function(function_id)"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_function",
      "name": "remove_function",
      "qname": "package_parser.model.usages._usages.UsageCountStore.remove_function",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_function/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_function/function_id",
          "name": "function_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_function.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Removes all usages of functions with the given name and usages of their parameters.",
      "docstring": "Removes all usages of functions with the given name and usages of their parameters.",
      "code": "    def remove_function(self, function_id: FunctionId) -> None:\n        \"\"\"Removes all usages of functions with the given name and usages of their parameters.\"\"\"\n\n        if function_id in self.function_usages:\n            del self.function_usages[function_id]\n\n        for parameter_id in list(self.parameter_usages.keys()):\n            if parameter_id.startswith(function_id):\n                self.remove_parameter(parameter_id)"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_parameter",
      "name": "remove_parameter",
      "qname": "package_parser.model.usages._usages.UsageCountStore.remove_parameter",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_parameter/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_parameter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_parameter/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_parameter.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Removes all parameter and value usages of parameters with the given name.",
      "docstring": "Removes all parameter and value usages of parameters with the given name.",
      "code": "    def remove_parameter(self, parameter_id: ParameterId) -> None:\n        \"\"\"Removes all parameter and value usages of parameters with the given name.\"\"\"\n\n        if parameter_id in self.parameter_usages:\n            del self.parameter_usages[parameter_id]\n\n        if parameter_id in self.value_usages:\n            del self.value_usages[parameter_id]"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/to_json",
      "name": "to_json",
      "qname": "package_parser.model.usages._usages.UsageCountStore.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/to_json/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Converts this class to a dictionary, which can later be serialized as JSON.",
      "docstring": "Converts this class to a dictionary, which can later be serialized as JSON.",
      "code": "    def to_json(self) -> Any:\n        \"\"\"Converts this class to a dictionary, which can later be serialized as JSON.\"\"\"\n\n        return {\n            \"class_counts\": {\n                class_id: usage_count\n                for class_id, usage_count in self.class_usages.most_common()\n            },\n            \"function_counts\": {\n                function_id: usage_count\n                for function_id, usage_count in self.function_usages.most_common()\n            },\n            \"parameter_counts\": {\n                parameter_id: usage_count\n                for parameter_id, usage_count in self.parameter_usages.most_common()\n            },\n            \"value_counts\": {\n                parameter_id: {\n                    value: usage_count for value, usage_count in values.most_common()\n                }\n                for parameter_id, values in self.value_usages.items()\n            },\n        }"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.__init__.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, package_name: str) -> None:\n        self.package_name: str = package_name\n        self.usages: UsageCountStore = UsageCountStore()"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call",
      "name": "enter_call",
      "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.enter_call",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call/self",
          "name": "self",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.enter_call.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call/node",
          "name": "node",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.enter_call.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_call(self, node: astroid.Call):\n        called_tuple = _analyze_declaration_called_by(node, self.package_name)\n        if called_tuple is None:\n            return\n        called, function_id, parameters, n_implicit_parameters = called_tuple\n\n        bound_parameters = _bound_parameters(\n            parameters, CallSite.from_call(node), n_implicit_parameters\n        )\n        if bound_parameters is None:\n            return\n\n        # Add class usage\n        if (\n            isinstance(called, (astroid.BoundMethod, astroid.UnboundMethod))\n            or isinstance(called, astroid.FunctionDef)\n            and called.is_method()\n        ):\n            self.usages.add_class_usages(parent_id(function_id))\n\n        # Add function usage\n        self.usages.add_function_usages(function_id)\n\n        # Add parameter & value usage\n        for parameter_name, value in bound_parameters.items():\n            parameter_id = f\"{function_id}/{parameter_name}\"\n            self.usages.add_parameter_usages(parameter_id)\n\n            value = _stringify_value(value)\n            self.usages.add_value_usages(parameter_id, value)"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/__called_constructor",
      "name": "__called_constructor",
      "qname": "package_parser.processing.usages._ast_visitor.__called_constructor",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/__called_constructor/class_def",
          "name": "class_def",
          "qname": "package_parser.processing.usages._ast_visitor.__called_constructor.class_def",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __called_constructor(class_def: astroid.ClassDef) -> Optional[astroid.FunctionDef]:\n    try:\n        # Use last __init__\n        constructor = class_def.local_attr(\"__init__\")[-1]\n    except astroid.NotFoundError:\n        return None\n\n    if isinstance(constructor, astroid.FunctionDef):\n        return constructor\n    else:\n        return None"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name",
      "name": "__is_relevant_qualified_name",
      "qname": "package_parser.processing.usages._ast_visitor.__is_relevant_qualified_name",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor.__is_relevant_qualified_name.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.processing.usages._ast_visitor.__is_relevant_qualified_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __is_relevant_qualified_name(package_name: str, qualified_name: str) -> bool:\n    return qualified_name.startswith(package_name)"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/__n_implicit_parameters",
      "name": "__n_implicit_parameters",
      "qname": "package_parser.processing.usages._ast_visitor.__n_implicit_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/__n_implicit_parameters/called",
          "name": "called",
          "qname": "package_parser.processing.usages._ast_visitor.__n_implicit_parameters.called",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __n_implicit_parameters(called: astroid.NodeNG) -> int:\n    return called.implicit_parameters() if hasattr(called, \"implicit_parameters\") else 0"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by",
      "name": "_analyze_declaration_called_by",
      "qname": "package_parser.processing.usages._ast_visitor._analyze_declaration_called_by",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by/node",
          "name": "node",
          "qname": "package_parser.processing.usages._ast_visitor._analyze_declaration_called_by.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._analyze_declaration_called_by.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns None if the called declaration could not be determined or if it is not relevant for us. Otherwise, it\nreturns a tuple with the form (called, qualified_name, parameters, n_implicit_parameters).",
      "docstring": "Returns None if the called declaration could not be determined or if it is not relevant for us. Otherwise, it\nreturns a tuple with the form (called, qualified_name, parameters, n_implicit_parameters).",
      "code": "def _analyze_declaration_called_by(\n    node: astroid.Call, package_name: str\n) -> Optional[tuple[astroid.NodeNG, str, astroid.Arguments, int]]:\n    \"\"\"\n    Returns None if the called declaration could not be determined or if it is not relevant for us. Otherwise, it\n    returns a tuple with the form (called, qualified_name, parameters, n_implicit_parameters).\n    \"\"\"\n\n    called = safe_infer(node.func)\n    if called is None or not __is_relevant_qualified_name(package_name, called.qname()):\n        return None\n\n    n_implicit_parameters = __n_implicit_parameters(called)\n\n    if isinstance(called, astroid.ClassDef):\n        called = __called_constructor(called)\n        if called is None:\n            return None\n\n    if isinstance(\n        called, (astroid.BoundMethod, astroid.UnboundMethod, astroid.FunctionDef)\n    ):\n        return called, _id(package_name, called), called.args, n_implicit_parameters\n    else:\n        return None"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_bound_parameters",
      "name": "_bound_parameters",
      "qname": "package_parser.processing.usages._ast_visitor._bound_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_bound_parameters/parameters",
          "name": "parameters",
          "qname": "package_parser.processing.usages._ast_visitor._bound_parameters.parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_bound_parameters/arguments",
          "name": "arguments",
          "qname": "package_parser.processing.usages._ast_visitor._bound_parameters.arguments",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_bound_parameters/n_implicit_parameters",
          "name": "n_implicit_parameters",
          "qname": "package_parser.processing.usages._ast_visitor._bound_parameters.n_implicit_parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _bound_parameters(\n    parameters: astroid.Arguments, arguments: CallSite, n_implicit_parameters: int\n) -> Optional[dict[str, astroid.NodeNG]]:\n    # Improper call\n    if (\n        parameters.args is None\n        or arguments.has_invalid_arguments()\n        or arguments.has_invalid_keywords()\n    ):\n        return None\n\n    result: dict[str, astroid.NodeNG] = arguments.keyword_arguments.copy()\n\n    positional_parameter_names = [\n        it.name for it in (parameters.posonlyargs + parameters.args)\n    ][n_implicit_parameters:]\n\n    for index, arg in enumerate(arguments.positional_arguments):\n        if index >= len(positional_parameter_names):\n            break\n\n        result[positional_parameter_names[index]] = arg\n\n    return result"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_id",
      "name": "_id",
      "qname": "package_parser.processing.usages._ast_visitor._id",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_id/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._id.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_id/called",
          "name": "called",
          "qname": "package_parser.processing.usages._ast_visitor._id.called",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _id(\n    package_name: str, called: Union[astroid.UnboundMethod, astroid.FunctionDef]\n) -> str:\n    path = _path(package_name, called)\n\n    decorators: Optional[astroid.Decorators] = called.decorators\n    if decorators is not None:\n        decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n    else:\n        decorator_names = []\n\n    def is_getter() -> bool:\n        return \"property\" in decorator_names\n\n    def is_setter() -> bool:\n        for decorator in decorator_names:\n            if re.search(r\"^[^.]*.setter$\", decorator):\n                return True\n\n        return False\n\n    def is_deleter() -> bool:\n        for decorator in decorator_names:\n            if re.search(r\"^[^.]*.deleter$\", decorator):\n                return True\n\n        return False\n\n    result = \"/\".join(path)\n\n    if is_getter():\n        result += \"@getter\"\n    elif is_setter():\n        result += \"@setter\"\n    elif is_deleter():\n        result += \"@deleter\"\n\n    return result"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_path",
      "name": "_path",
      "qname": "package_parser.processing.usages._ast_visitor._path",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_path/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._path.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_path/current",
          "name": "current",
          "qname": "package_parser.processing.usages._ast_visitor._path.current",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _path(package_name: str, current: astroid.NodeNG) -> list[str]:\n    if current is None:\n        return []\n\n    if isinstance(current, astroid.Module):\n        return [package_name, current.name]\n    elif hasattr(current, \"name\"):\n        return _path(package_name, current.parent) + [current.name]\n    else:\n        return _path(package_name, current.parent)"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_stringify_value",
      "name": "_stringify_value",
      "qname": "package_parser.processing.usages._ast_visitor._stringify_value",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_stringify_value/value",
          "name": "value",
          "qname": "package_parser.processing.usages._ast_visitor._stringify_value.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _stringify_value(value: astroid.NodeNG):\n    return value.as_string()"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file",
      "name": "__is_relevant_python_file",
      "qname": "package_parser.processing.usages._find_usages.__is_relevant_python_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages.__is_relevant_python_file.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file/source_code",
          "name": "source_code",
          "qname": "package_parser.processing.usages._find_usages.__is_relevant_python_file.source_code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __is_relevant_python_file(package_name: str, source_code: str) -> bool:\n    return package_name in source_code"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch",
      "name": "_find_usages_in_batch",
      "qname": "package_parser.processing.usages._find_usages._find_usages_in_batch",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_batch.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch/python_files",
          "name": "python_files",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_batch.python_files",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _find_usages_in_batch(\n    package_name: str, python_files: list[str]\n) -> UsageCountStore:\n    ast_builder = AstroidBuilder()\n    usage_finder = _UsageFinder(package_name)\n    ast_walker = ASTWalker(usage_finder)\n\n    for python_file in python_files:\n        _find_usages_in_single_file(package_name, python_file, ast_builder, ast_walker)\n\n    return usage_finder.usages"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file",
      "name": "_find_usages_in_single_file",
      "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/python_file",
          "name": "python_file",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.python_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/ast_builder",
          "name": "ast_builder",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.ast_builder",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/ast_walker",
          "name": "ast_walker",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.ast_walker",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _find_usages_in_single_file(\n    package_name: str,\n    python_file: str,\n    ast_builder: AstroidBuilder,\n    ast_walker: ASTWalker,\n) -> None:\n    logging.info(f\"Working on {python_file}\")\n\n    # noinspection PyBroadException\n    try:\n        with open(python_file, \"r\", encoding=\"UTF-8\") as f:\n            source = f.read()\n\n        if __is_relevant_python_file(package_name, source):\n            module = parse_python_code(source, ast_builder=ast_builder)\n            ast_walker.walk(module)\n        else:\n            logging.info(f\"Skipping {python_file} (irrelevant file)\")\n\n    except UnicodeError:\n        logging.warning(f\"Skipping {python_file} (broken encoding)\")\n    except astroid.exceptions.AstroidSyntaxError:\n        logging.warning(f\"Skipping {python_file} (invalid syntax)\")\n    except RecursionError:\n        logging.warning(f\"Skipping {python_file} (infinite recursion)\")\n    except Exception as e:\n        logging.error(f\"Skipping {python_file} (unknown error: {e})\")"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/_initializer",
      "name": "_initializer",
      "qname": "package_parser.processing.usages._find_usages._initializer",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_initializer/log_level",
          "name": "log_level",
          "qname": "package_parser.processing.usages._find_usages._initializer.log_level",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Ignore CTRL+C in the worker process.",
      "docstring": "Ignore CTRL+C in the worker process.",
      "code": "def _initializer(log_level: int) -> None:\n    \"\"\"\n    Ignore CTRL+C in the worker process.\n    \"\"\"\n\n    logging.basicConfig(level=log_level)\n    signal.signal(signal.SIGINT, signal.SIG_IGN)"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/_split_into_batches",
      "name": "_split_into_batches",
      "qname": "package_parser.processing.usages._find_usages._split_into_batches",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_split_into_batches/list_",
          "name": "list_",
          "qname": "package_parser.processing.usages._find_usages._split_into_batches.list_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_split_into_batches/batch_size",
          "name": "batch_size",
          "qname": "package_parser.processing.usages._find_usages._split_into_batches.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Splits a list into batches of size batch_size.",
      "docstring": "Splits a list into batches of size batch_size.",
      "code": "def _split_into_batches(list_: list[T], batch_size: int) -> list[list[T]]:\n    \"\"\"\n    Splits a list into batches of size batch_size.\n    \"\"\"\n\n    batches = []\n    batch = []\n\n    for python_file in list_:\n        batch.append(python_file)\n        if len(batch) >= batch_size:\n            batches.append(batch)\n            batch = []\n\n    if len(batch) > 0:\n        batches.append(batch)\n\n    return batches"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/find_usages",
      "name": "find_usages",
      "qname": "package_parser.processing.usages._find_usages.find_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/find_usages/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages.find_usages.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/find_usages/src_dir",
          "name": "src_dir",
          "qname": "package_parser.processing.usages._find_usages.find_usages.src_dir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/find_usages/n_processes",
          "name": "n_processes",
          "qname": "package_parser.processing.usages._find_usages.find_usages.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/find_usages/batch_size",
          "name": "batch_size",
          "qname": "package_parser.processing.usages._find_usages.find_usages.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def find_usages(\n    package_name: str, src_dir: Path, n_processes: int, batch_size: int\n) -> UsageCountStore:\n    python_files = list_files(src_dir, \".py\")\n    python_file_batches = _split_into_batches(python_files, batch_size)\n\n    aggregated_counts = UsageCountStore()\n\n    for batch_index in range(0, len(python_file_batches), n_processes):\n        python_file_batches_slice = python_file_batches[\n            batch_index : batch_index + n_processes\n        ]\n        n_process_to_spawn = min(n_processes, len(python_file_batches_slice))\n\n        with Pool(\n            processes=n_process_to_spawn,\n            initializer=_initializer,\n            initargs=[logging.root.level],\n        ) as pool:\n            batch_counts = pool.starmap(\n                _find_usages_in_batch,\n                [[package_name, it] for it in python_file_batches_slice],\n            )\n\n            for batch_count in batch_counts:\n                aggregated_counts.merge_other_into_self(batch_count)\n\n    return aggregated_counts"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter",
      "name": "__enter",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[0]\n        if method is not None:\n            method(node)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks",
      "name": "__get_callbacks",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __get_callbacks(self, node: astroid.NodeNG) -> _EnterAndLeaveFunctions:\n        klass = node.__class__\n        methods = self._cache.get(klass)\n\n        if methods is None:\n            handler = self._handler\n            class_name = klass.__name__.lower()\n            enter_method = getattr(\n                handler, f\"enter_{class_name}\", getattr(handler, \"enter_default\", None)\n            )\n            leave_method = getattr(\n                handler, f\"leave_{class_name}\", getattr(handler, \"leave_default\", None)\n            )\n            self._cache[klass] = (enter_method, leave_method)\n        else:\n            enter_method, leave_method = methods\n\n        return enter_method, leave_method"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__",
      "name": "__init__",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__/handler",
          "name": "handler",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__.handler",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "docstring": "",
      "code": "    def __init__(self, handler: Any) -> None:\n        self._handler = handler\n        self._cache: dict[Type, _EnterAndLeaveFunctions] = {}"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave",
      "name": "__leave",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __leave(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[1]\n        if method is not None:\n            method(node)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk",
      "name": "__walk",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/visited_nodes",
          "name": "visited_nodes",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.visited_nodes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __walk(self, node: astroid.NodeNG, visited_nodes: set[astroid.NodeNG]) -> None:\n        if node in visited_nodes:\n            raise AssertionError(\"Node visited twice\")\n        visited_nodes.add(node)\n\n        self.__enter(node)\n        for child_node in node.get_children():\n            self.__walk(child_node, visited_nodes)\n        self.__leave(node)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk",
      "name": "walk",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.walk",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.walk.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.walk.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def walk(self, node: astroid.NodeNG) -> None:\n        self.__walk(node, set())"
    },
    {
      "id": "package-parser/package_parser.utils._files/__read_lines",
      "name": "__read_lines",
      "qname": "package_parser.utils._files.__read_lines",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/__read_lines/f",
          "name": "f",
          "qname": "package_parser.utils._files.__read_lines.f",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __read_lines(f: TextIO) -> list[str]:\n    return [it.strip() for it in f.readlines() if it != \"\"]"
    },
    {
      "id": "package-parser/package_parser.utils._files/__write_lines",
      "name": "__write_lines",
      "qname": "package_parser.utils._files.__write_lines",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/__write_lines/f",
          "name": "f",
          "qname": "package_parser.utils._files.__write_lines.f",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._files/__write_lines/lines",
          "name": "lines",
          "qname": "package_parser.utils._files.__write_lines.lines",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __write_lines(f: TextIO, lines: list[str]) -> None:\n    f.writelines(f\"{it}\\n\" for it in lines)"
    },
    {
      "id": "package-parser/package_parser.utils._files/ensure_file_exists",
      "name": "ensure_file_exists",
      "qname": "package_parser.utils._files.ensure_file_exists",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/ensure_file_exists/file",
          "name": "file",
          "qname": "package_parser.utils._files.ensure_file_exists.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Creates a file and all parent directories if they don't exist already.\n\n:param file: The file path.",
      "docstring": "Creates a file and all parent directories if they don't exist already.\n\n:param file: The file path.",
      "code": "def ensure_file_exists(file: Path) -> None:\n    \"\"\"\n    Creates a file and all parent directories if they don't exist already.\n\n    :param file: The file path.\n    \"\"\"\n\n    file.parent.mkdir(parents=True, exist_ok=True)\n    file.touch(exist_ok=True)"
    },
    {
      "id": "package-parser/package_parser.utils._files/initialize_and_read_exclude_file",
      "name": "initialize_and_read_exclude_file",
      "qname": "package_parser.utils._files.initialize_and_read_exclude_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/initialize_and_read_exclude_file/exclude_file",
          "name": "exclude_file",
          "qname": "package_parser.utils._files.initialize_and_read_exclude_file.exclude_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def initialize_and_read_exclude_file(exclude_file: Path) -> list[str]:\n    exclude_file.parent.mkdir(parents=True, exist_ok=True)\n    try:\n        with exclude_file.open(\"r\") as f:\n            return __read_lines(f)\n    except FileNotFoundError:\n        return []"
    },
    {
      "id": "package-parser/package_parser.utils._files/list_files",
      "name": "list_files",
      "qname": "package_parser.utils._files.list_files",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/list_files/root_dir",
          "name": "root_dir",
          "qname": "package_parser.utils._files.list_files.root_dir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._files/list_files/extension",
          "name": "extension",
          "qname": "package_parser.utils._files.list_files.extension",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": ":param root_dir: The directory containing the files.\n:param extension: The extension the files should have.\n:return: A list with absolute paths to the files.",
      "docstring": ":param root_dir: The directory containing the files.\n:param extension: The extension the files should have.\n:return: A list with absolute paths to the files.",
      "code": "def list_files(root_dir: Path, extension: str = \"\") -> list[str]:\n    \"\"\"\n    :param root_dir: The directory containing the files.\n    :param extension: The extension the files should have.\n    :return: A list with absolute paths to the files.\n    \"\"\"\n\n    result: list[str] = []\n\n    for root, _, files in os.walk(root_dir):\n        for filename in files:\n            if filename.endswith(extension):\n                result.append(str(os.path.join(root, filename)))\n\n    return result"
    },
    {
      "id": "package-parser/package_parser.utils._names/declaration_qname_to_name",
      "name": "declaration_qname_to_name",
      "qname": "package_parser.utils._names.declaration_qname_to_name",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._names/declaration_qname_to_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.utils._names.declaration_qname_to_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def declaration_qname_to_name(qualified_name: str) -> str:\n    return qualified_name.split(\".\")[-1]"
    },
    {
      "id": "package-parser/package_parser.utils._names/parent_id",
      "name": "parent_id",
      "qname": "package_parser.utils._names.parent_id",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._names/parent_id/id_",
          "name": "id_",
          "qname": "package_parser.utils._names.parent_id.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def parent_id(id_: str) -> str:\n    return \"/\".join(id_.split(\"/\")[:-1])"
    },
    {
      "id": "package-parser/package_parser.utils._names/parent_qualified_name",
      "name": "parent_qualified_name",
      "qname": "package_parser.utils._names.parent_qualified_name",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._names/parent_qualified_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.utils._names.parent_qualified_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def parent_qualified_name(qualified_name: str) -> str:\n    return \".\".join(qualified_name.split(\".\")[:-1])"
    },
    {
      "id": "package-parser/package_parser.utils._parsing/parse_python_code",
      "name": "parse_python_code",
      "qname": "package_parser.utils._parsing.parse_python_code",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/code",
          "name": "code",
          "qname": "package_parser.utils._parsing.parse_python_code.code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/module_name",
          "name": "module_name",
          "qname": "package_parser.utils._parsing.parse_python_code.module_name",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/path",
          "name": "path",
          "qname": "package_parser.utils._parsing.parse_python_code.path",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/ast_builder",
          "name": "ast_builder",
          "qname": "package_parser.utils._parsing.parse_python_code.ast_builder",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Parses a source string in order to obtain an astroid AST from it\n\n:param str code: The code for the module.\n:param str module_name: The name for the module, if any\n:param str path: The path for the module\n:param ast_builder: The Astroid builder to use",
      "docstring": "Parses a source string in order to obtain an astroid AST from it\n\n:param str code: The code for the module.\n:param str module_name: The name for the module, if any\n:param str path: The path for the module\n:param ast_builder: The Astroid builder to use",
      "code": "def parse_python_code(\n    code: str,\n    module_name: str = \"\",\n    path: str = None,\n    ast_builder: AstroidBuilder = None,\n) -> astroid.Module:\n    \"\"\"Parses a source string in order to obtain an astroid AST from it\n\n    :param str code: The code for the module.\n    :param str module_name: The name for the module, if any\n    :param str path: The path for the module\n    :param ast_builder: The Astroid builder to use\n    \"\"\"\n\n    if ast_builder is None:\n        ast_builder = AstroidBuilder()\n\n    code = textwrap.dedent(code)\n    return ast_builder.string_build(code, modname=module_name, path=path)"
    }
  ]
}