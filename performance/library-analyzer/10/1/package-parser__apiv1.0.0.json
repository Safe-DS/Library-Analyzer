{
  "schemaVersion": 1,
  "distribution": "",
  "package": "package-parser",
  "version": "",
  "modules": [],
  "classes": [
    {
      "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder",
      "name": "CustomEncoder",
      "qname": "package_parser.cli._json_encoder.CustomEncoder",
      "decorators": [],
      "superclasses": [
        "JSONEncoder"
      ],
      "methods": [
        "package-parser/package_parser.cli._json_encoder/CustomEncoder/default"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class CustomEncoder(JSONEncoder):\n    def default(self, o: Any) -> Any:\n        if isinstance(o, set):\n            return list(o)\n        return super().default(o)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AbstractAnnotation",
      "name": "AbstractAnnotation",
      "qname": "package_parser.model.annotations._annotations.AbstractAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/AbstractAnnotation/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AbstractAnnotation:\n    target: str\n    authors: list[str]\n    reviewers: list[str]\n\n    def to_json(self) -> dict:\n        return asdict(self)",
      "instance_attributes": [
        {
          "name": "target",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "authors",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "reviewers",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore",
      "name": "AnnotationStore",
      "qname": "package_parser.model.annotations._annotations.AnnotationStore",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/AnnotationStore/__init__",
        "package-parser/package_parser.model.annotations._annotations/AnnotationStore/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AnnotationStore:\n    boundaries: list[BoundaryAnnotation]\n    constants: list[ConstantAnnotation]\n    enums: list[EnumAnnotation]\n    optionals: list[OptionalAnnotation]\n    removes: list[RemoveAnnotation]\n    requireds: list[RequiredAnnotation]\n\n    def __init__(self):\n        self.constants = []\n        self.removes = []\n        self.requireds = []\n        self.optionals = []\n        self.boundaries = []\n        self.enums = []\n\n    def to_json(self) -> dict:\n        return {\n            \"constants\": {\n                annotation.target: annotation.to_json() for annotation in self.constants\n            },\n            \"removes\": {\n                annotation.target: annotation.to_json() for annotation in self.removes\n            },\n            \"requireds\": {\n                annotation.target: annotation.to_json() for annotation in self.requireds\n            },\n            \"optionals\": {\n                annotation.target: annotation.to_json() for annotation in self.optionals\n            },\n            \"boundaries\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.boundaries\n            },\n            \"enums\": {\n                annotation.target: annotation.to_json() for annotation in self.enums\n            },\n        }",
      "instance_attributes": [
        {
          "name": "constants",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "removes",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "requireds",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "optionals",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "boundaries",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "enums",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/BoundaryAnnotation",
      "name": "BoundaryAnnotation",
      "qname": "package_parser.model.annotations._annotations.BoundaryAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class BoundaryAnnotation(AbstractAnnotation):\n    interval: Interval",
      "instance_attributes": [
        {
          "name": "interval",
          "types": {
            "kind": "NamedType",
            "name": "Interval"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/ConstantAnnotation",
      "name": "ConstantAnnotation",
      "qname": "package_parser.model.annotations._annotations.ConstantAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConstantAnnotation(AbstractAnnotation):\n    defaultType: str\n    defaultValue: Any",
      "instance_attributes": [
        {
          "name": "defaultType",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "defaultValue",
          "types": null
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/EnumAnnotation",
      "name": "EnumAnnotation",
      "qname": "package_parser.model.annotations._annotations.EnumAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class EnumAnnotation(AbstractAnnotation):\n    enumName: str\n    pairs: list[EnumPair]",
      "instance_attributes": [
        {
          "name": "enumName",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "pairs",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/EnumPair",
      "name": "EnumPair",
      "qname": "package_parser.model.annotations._annotations.EnumPair",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/EnumPair/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class EnumPair:\n    stringValue: str\n    instanceName: str\n\n    def to_json(self) -> dict:\n        return asdict(self)",
      "instance_attributes": [
        {
          "name": "stringValue",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "instanceName",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/Interval",
      "name": "Interval",
      "qname": "package_parser.model.annotations._annotations.Interval",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/Interval/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Interval:\n    isDiscrete: bool\n    lowerIntervalLimit: int\n    lowerLimitType: int\n    upperIntervalLimit: int\n    upperLimitType: int\n\n    def to_json(self) -> dict:\n        return asdict(self)",
      "instance_attributes": [
        {
          "name": "isDiscrete",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "lowerIntervalLimit",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "lowerLimitType",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "upperIntervalLimit",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "upperLimitType",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/OptionalAnnotation",
      "name": "OptionalAnnotation",
      "qname": "package_parser.model.annotations._annotations.OptionalAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class OptionalAnnotation(AbstractAnnotation):\n    defaultType: str\n    defaultValue: Any",
      "instance_attributes": [
        {
          "name": "defaultType",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "defaultValue",
          "types": null
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo",
      "name": "ParameterInfo",
      "qname": "package_parser.model.annotations._annotations.ParameterInfo",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterInfo:\n    type: ParameterType\n    value: str\n    value_type: str\n\n    def __init__(self, parameter_type, value=\"\", value_type=\"\"):\n        self.type = parameter_type\n        self.value = value\n        self.value_type = value_type",
      "instance_attributes": [
        {
          "name": "type",
          "types": null
        },
        {
          "name": "value",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "value_type",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/ParameterType",
      "name": "ParameterType",
      "qname": "package_parser.model.annotations._annotations.ParameterType",
      "decorators": [],
      "superclasses": [
        "Enum"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterType(Enum):\n    Constant = 0\n    Optional = 1\n    Required = 2\n    Unused = 3",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/RemoveAnnotation",
      "name": "RemoveAnnotation",
      "qname": "package_parser.model.annotations._annotations.RemoveAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RemoveAnnotation(AbstractAnnotation):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/RequiredAnnotation",
      "name": "RequiredAnnotation",
      "qname": "package_parser.model.annotations._annotations.RequiredAnnotation",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractAnnotation"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RequiredAnnotation(AbstractAnnotation):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._api/API",
      "name": "API",
      "qname": "package_parser.model.api._api.API",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/API/from_json",
        "package-parser/package_parser.model.api._api/API/__init__",
        "package-parser/package_parser.model.api._api/API/add_module",
        "package-parser/package_parser.model.api._api/API/add_class",
        "package-parser/package_parser.model.api._api/API/add_function",
        "package-parser/package_parser.model.api._api/API/is_public_class",
        "package-parser/package_parser.model.api._api/API/is_public_function",
        "package-parser/package_parser.model.api._api/API/class_count",
        "package-parser/package_parser.model.api._api/API/public_class_count",
        "package-parser/package_parser.model.api._api/API/function_count",
        "package-parser/package_parser.model.api._api/API/public_function_count",
        "package-parser/package_parser.model.api._api/API/parameter_count",
        "package-parser/package_parser.model.api._api/API/public_parameter_count",
        "package-parser/package_parser.model.api._api/API/parameters",
        "package-parser/package_parser.model.api._api/API/get_default_value",
        "package-parser/package_parser.model.api._api/API/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class API:\n    @staticmethod\n    def from_json(json: Any) -> API:\n        result = API(json[\"distribution\"], json[\"package\"], json[\"version\"])\n\n        for module_json in json.get(\"modules\", []):\n            result.add_module(Module.from_json(module_json))\n\n        for class_json in json.get(\"classes\", []):\n            result.add_class(Class.from_json(class_json))\n\n        for function_json in json.get(\"functions\", []):\n            result.add_function(Function.from_json(function_json))\n\n        return result\n\n    def __init__(self, distribution: str, package: str, version: str) -> None:\n        self.distribution: str = distribution\n        self.package: str = package\n        self.version: str = version\n        self.modules: dict[str, Module] = dict()\n        self.classes: dict[str, Class] = dict()\n        self.functions: dict[str, Function] = dict()\n\n    def add_module(self, module: Module) -> None:\n        self.modules[module.id] = module\n\n    def add_class(self, class_: Class) -> None:\n        self.classes[class_.id] = class_\n\n    def add_function(self, function: Function) -> None:\n        self.functions[function.id] = function\n\n    def is_public_class(self, class_id: str) -> bool:\n        return class_id in self.classes and self.classes[class_id].is_public\n\n    def is_public_function(self, function_id: str) -> bool:\n        return function_id in self.functions and self.functions[function_id].is_public\n\n    def class_count(self) -> int:\n        return len(self.classes)\n\n    def public_class_count(self) -> int:\n        return len([it for it in self.classes.values() if it.is_public])\n\n    def function_count(self) -> int:\n        return len(self.functions)\n\n    def public_function_count(self) -> int:\n        return len([it for it in self.functions.values() if it.is_public])\n\n    def parameter_count(self) -> int:\n        return len(self.parameters())\n\n    def public_parameter_count(self) -> int:\n        return len([it for it in self.parameters().values() if it.is_public])\n\n    def parameters(self) -> dict[str, Parameter]:\n        result: dict[str, Parameter] = {}\n\n        for function in self.functions.values():\n            for parameter in function.parameters:\n                parameter_id = f\"{function.id}/{parameter.name}\"\n                result[parameter_id] = parameter\n\n        return result\n\n    def get_default_value(self, parameter_id: str) -> Optional[str]:\n        function_id = parent_id(parameter_id)\n\n        if function_id not in self.functions:\n            return None\n\n        for parameter in self.functions[function_id].parameters:\n            if parameter.id == parameter_id:\n                return parameter.default_value\n\n        return None\n\n    def to_json(self) -> Any:\n        return {\n            \"distribution\": self.distribution,\n            \"package\": self.package,\n            \"version\": self.version,\n            \"modules\": [\n                module.to_json()\n                for module in sorted(self.modules.values(), key=lambda it: it.id)\n            ],\n            \"classes\": [\n                class_.to_json()\n                for class_ in sorted(self.classes.values(), key=lambda it: it.id)\n            ],\n            \"functions\": [\n                function.to_json()\n                for function in sorted(self.functions.values(), key=lambda it: it.id)\n            ],\n        }",
      "instance_attributes": [
        {
          "name": "distribution",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "package",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "version",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "modules",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "classes",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "functions",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._api/Class",
      "name": "Class",
      "qname": "package_parser.model.api._api.Class",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/Class/from_json",
        "package-parser/package_parser.model.api._api/Class/__init__",
        "package-parser/package_parser.model.api._api/Class/name@getter",
        "package-parser/package_parser.model.api._api/Class/add_method",
        "package-parser/package_parser.model.api._api/Class/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Class:\n    @staticmethod\n    def from_json(json: Any) -> Class:\n        result = Class(\n            json[\"id\"],\n            json[\"qname\"],\n            json.get(\"decorators\", []),\n            json.get(\"superclasses\", []),\n            json.get(\"is_public\", True),\n            json.get(\"reexported_by\", []),\n            json.get(\"description\", \"\"),\n            json.get(\"docstring\", \"\"),\n        )\n\n        for method_id in json[\"methods\"]:\n            result.add_method(method_id)\n\n        return result\n\n    def __init__(\n        self,\n        id_: str,\n        qname: str,\n        decorators: list[str],\n        superclasses: list[str],\n        is_public: bool,\n        reexported_by: list[str],\n        description: str,\n        docstring: str,\n    ) -> None:\n        self.id: str = id_\n        self.qname: str = qname\n        self.decorators: list[str] = decorators\n        self.superclasses: list[str] = superclasses\n        self.methods: list[str] = []\n        self.is_public: bool = is_public\n        self.reexported_by: list[str] = reexported_by\n        self.description: str = description\n        self.docstring: str = docstring\n\n    @property\n    def name(self) -> str:\n        return self.qname.split(\".\")[-1]\n\n    def add_method(self, method_id: str) -> None:\n        self.methods.append(method_id)\n\n    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"decorators\": self.decorators,\n            \"superclasses\": self.superclasses,\n            \"methods\": self.methods,\n            \"is_public\": self.is_public,\n            \"reexported_by\": self.reexported_by,\n            \"description\": self.description,\n            \"docstring\": self.docstring,\n        }",
      "instance_attributes": [
        {
          "name": "id",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "qname",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "decorators",
          "types": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        },
        {
          "name": "superclasses",
          "types": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        },
        {
          "name": "methods",
          "types": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        },
        {
          "name": "is_public",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "reexported_by",
          "types": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        },
        {
          "name": "description",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "docstring",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._api/FromImport",
      "name": "FromImport",
      "qname": "package_parser.model.api._api.FromImport",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/FromImport/from_json",
        "package-parser/package_parser.model.api._api/FromImport/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FromImport:\n    module_name: str\n    declaration_name: str\n    alias: Optional[str]\n\n    @staticmethod\n    def from_json(json: Any) -> FromImport:\n        return FromImport(json[\"module\"], json[\"declaration\"], json[\"alias\"])\n\n    def to_json(self) -> Any:\n        return {\n            \"module\": self.module_name,\n            \"declaration\": self.declaration_name,\n            \"alias\": self.alias,\n        }",
      "instance_attributes": [
        {
          "name": "module_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "declaration_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "alias",
          "types": null
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._api/Function",
      "name": "Function",
      "qname": "package_parser.model.api._api.Function",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/Function/from_json",
        "package-parser/package_parser.model.api._api/Function/name@getter",
        "package-parser/package_parser.model.api._api/Function/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Function:\n    id: str\n    qname: str\n    decorators: list[str]\n    parameters: list[Parameter]\n    results: list[Result]\n    is_public: bool\n    reexported_by: list[str]\n    description: str\n    docstring: str\n\n    @staticmethod\n    def from_json(json: Any) -> Function:\n        return Function(\n            json[\"id\"],\n            json[\"qname\"],\n            json.get(\"decorators\", []),\n            [\n                Parameter.from_json(parameter_json)\n                for parameter_json in json.get(\"parameters\", [])\n            ],\n            [Result.from_json(result_json) for result_json in json.get(\"results\", [])],\n            json.get(\"is_public\", True),\n            json.get(\"reexported_by\", []),\n            json.get(\"description\", \"\"),\n            json.get(\"docstring\", \"\"),\n        )\n\n    @property\n    def name(self) -> str:\n        return self.qname.split(\".\")[-1]\n\n    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"decorators\": self.decorators,\n            \"parameters\": [parameter.to_json() for parameter in self.parameters],\n            \"results\": [result.to_json() for result in self.results],\n            \"is_public\": self.is_public,\n            \"reexported_by\": self.reexported_by,\n            \"description\": self.description,\n            \"docstring\": self.docstring,\n        }",
      "instance_attributes": [
        {
          "name": "id",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "qname",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "decorators",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "parameters",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "results",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "is_public",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "reexported_by",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "description",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "docstring",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._api/Import",
      "name": "Import",
      "qname": "package_parser.model.api._api.Import",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/Import/from_json",
        "package-parser/package_parser.model.api._api/Import/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Import:\n    module_name: str\n    alias: Optional[str]\n\n    @staticmethod\n    def from_json(json: Any) -> Import:\n        return Import(json[\"module\"], json[\"alias\"])\n\n    def to_json(self) -> Any:\n        return {\"module\": self.module_name, \"alias\": self.alias}",
      "instance_attributes": [
        {
          "name": "module_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "alias",
          "types": null
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._api/Module",
      "name": "Module",
      "qname": "package_parser.model.api._api.Module",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/Module/from_json",
        "package-parser/package_parser.model.api._api/Module/__init__",
        "package-parser/package_parser.model.api._api/Module/add_class",
        "package-parser/package_parser.model.api._api/Module/add_function",
        "package-parser/package_parser.model.api._api/Module/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Module:\n    @staticmethod\n    def from_json(json: Any) -> Module:\n        result = Module(\n            json[\"id\"],\n            json[\"name\"],\n            [Import.from_json(import_json) for import_json in json.get(\"imports\", [])],\n            [\n                FromImport.from_json(from_import_json)\n                for from_import_json in json.get(\"from_imports\", [])\n            ],\n        )\n\n        for class_id in json.get(\"classes\", []):\n            result.add_class(class_id)\n\n        for function_id in json.get(\"functions\", []):\n            result.add_function(function_id)\n\n        return result\n\n    def __init__(\n        self, id_: str, name: str, imports: list[Import], from_imports: list[FromImport]\n    ):\n        self.id: str = id_\n        self.name: str = name\n        self.imports: list[Import] = imports\n        self.from_imports: list[FromImport] = from_imports\n        self.classes: list[str] = []\n        self.functions: list[str] = []\n\n    def add_class(self, class_id: str) -> None:\n        self.classes.append(class_id)\n\n    def add_function(self, function_id: str) -> None:\n        self.functions.append(function_id)\n\n    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"imports\": [import_.to_json() for import_ in self.imports],\n            \"from_imports\": [\n                from_import.to_json() for from_import in self.from_imports\n            ],\n            \"classes\": self.classes,\n            \"functions\": self.functions,\n        }",
      "instance_attributes": [
        {
          "name": "id",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "imports",
          "types": {
            "kind": "NamedType",
            "name": "list[Import]"
          }
        },
        {
          "name": "from_imports",
          "types": {
            "kind": "NamedType",
            "name": "list[FromImport]"
          }
        },
        {
          "name": "classes",
          "types": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        },
        {
          "name": "functions",
          "types": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._api/Parameter",
      "name": "Parameter",
      "qname": "package_parser.model.api._api.Parameter",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/Parameter/from_json",
        "package-parser/package_parser.model.api._api/Parameter/__init__",
        "package-parser/package_parser.model.api._api/Parameter/is_optional",
        "package-parser/package_parser.model.api._api/Parameter/is_required",
        "package-parser/package_parser.model.api._api/Parameter/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Parameter:\n    @staticmethod\n    def from_json(json: Any):\n        return Parameter(\n            json[\"id\"],\n            json[\"name\"],\n            json[\"qname\"],\n            json.get(\"default_value\", None),\n            ParameterAssignment[json.get(\"assigned_by\", \"POSITION_OR_NAME\")],\n            json.get(\"is_public\", True),\n            ParameterAndResultDocstring.from_json(json.get(\"docstring\", {})),\n        )\n\n    def __init__(\n        self,\n        id_: str,\n        name: str,\n        qname: str,\n        default_value: Optional[str],\n        assigned_by: ParameterAssignment,\n        is_public: bool,\n        docstring: ParameterAndResultDocstring,\n    ) -> None:\n        self.id: str = id_\n        self.name: str = name\n        self.qname: str = qname\n        self.default_value: Optional[str] = default_value\n        self.assigned_by: ParameterAssignment = assigned_by\n        self.is_public: bool = is_public\n        self.docstring = docstring\n        self.type: Type = Type(docstring)\n\n    def is_optional(self) -> bool:\n        return self.default_value is not None\n\n    def is_required(self) -> bool:\n        return self.default_value is None\n\n    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"default_value\": self.default_value,\n            \"assigned_by\": self.assigned_by.name,\n            \"is_public\": self.is_public,\n            \"docstring\": self.docstring.to_json(),\n            \"type\": self.type.to_json(),\n        }",
      "instance_attributes": [
        {
          "name": "id",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "qname",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "default_value",
          "types": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "NoneType"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        {
          "name": "assigned_by",
          "types": {
            "kind": "NamedType",
            "name": "ParameterAssignment"
          }
        },
        {
          "name": "is_public",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "docstring",
          "types": {
            "kind": "NamedType",
            "name": "ParameterAndResultDocstring"
          }
        },
        {
          "name": "type",
          "types": {
            "kind": "NamedType",
            "name": "Type"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._api/ParameterAndResultDocstring",
      "name": "ParameterAndResultDocstring",
      "qname": "package_parser.model.api._api.ParameterAndResultDocstring",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/ParameterAndResultDocstring/from_json",
        "package-parser/package_parser.model.api._api/ParameterAndResultDocstring/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterAndResultDocstring:\n    type: str\n    description: str\n\n    @staticmethod\n    def from_json(json: Any):\n        return ParameterAndResultDocstring(\n            json.get(\"type\", \"\"),\n            json.get(\"description\", \"\"),\n        )\n\n    def to_json(self) -> Any:\n        return {\"type\": self.type, \"description\": self.description}",
      "instance_attributes": [
        {
          "name": "type",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "description",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._api/ParameterAssignment",
      "name": "ParameterAssignment",
      "qname": "package_parser.model.api._api.ParameterAssignment",
      "decorators": [],
      "superclasses": [
        "Enum"
      ],
      "methods": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterAssignment(Enum):\n    IMPLICIT = \"IMPLICIT\"\n    POSITION_ONLY = \"POSITION_ONLY\"\n    POSITION_OR_NAME = \"POSITION_OR_NAME\"\n    NAME_ONLY = \"NAME_ONLY\"",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._api/Result",
      "name": "Result",
      "qname": "package_parser.model.api._api.Result",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/Result/from_json",
        "package-parser/package_parser.model.api._api/Result/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Result:\n    name: str\n    docstring: ParameterAndResultDocstring\n\n    @staticmethod\n    def from_json(json: Any) -> Result:\n        return Result(\n            json[\"name\"],\n            ParameterAndResultDocstring.from_json(json.get(\"docstring\", {})),\n        )\n\n    def to_json(self) -> Any:\n        return {\"name\": self.name, \"docstring\": self.docstring.to_json()}",
      "instance_attributes": [
        {
          "name": "name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "docstring",
          "types": {
            "kind": "NamedType",
            "name": "ParameterAndResultDocstring"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._api/Type",
      "name": "Type",
      "qname": "package_parser.model.api._api.Type",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._api/Type/__init__",
        "package-parser/package_parser.model.api._api/Type/create_type",
        "package-parser/package_parser.model.api._api/Type/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Type:\n    def __init__(\n        self,\n        typestring: ParameterAndResultDocstring,\n    ) -> None:\n        self.type: Optional[AbstractType] = Type.create_type(typestring)\n\n    @classmethod\n    def create_type(\n        cls, docstring: ParameterAndResultDocstring\n    ) -> Optional[AbstractType]:\n        type_string = docstring.type\n        types: list[AbstractType] = list()\n\n        # Collapse whitespaces\n        type_string = re.sub(r\"\\s+\", \" \", type_string)\n\n        # Get boundary from description\n        boundary = BoundaryType.from_string(docstring.description)\n        if boundary is not None:\n            types.append(boundary)\n\n        # Find all enums and remove them from doc_string\n        enum_array_matches = re.findall(r\"\\{.*?}\", type_string)\n        type_string = re.sub(r\"\\{.*?}\", \" \", type_string)\n        for enum in enum_array_matches:\n            enum_type = EnumType.from_string(enum)\n            if enum_type is not None:\n                types.append(enum_type)\n\n        # Remove default value from doc_string\n        type_string = re.sub(\"default=.*\", \" \", type_string)\n\n        # Create a list with all values and types\n        # \") or (\" must be replaced by a very unlikely string (\"&%&\") so that it is not removed when filtering out.\n        # The string will be replaced by \") or (\" again after filtering out.\n        type_string = re.sub(r\"\\) or \\(\", \"&%&\", type_string)\n        type_string = re.sub(r\" ?, ?or \", \", \", type_string)\n        type_string = re.sub(r\" or \", \", \", type_string)\n        type_string = re.sub(\"&%&\", \") or (\", type_string)\n\n        brackets = 0\n        build_string = \"\"\n        for c in type_string:\n            if c == \"(\":\n                brackets += 1\n            elif c == \")\":\n                brackets -= 1\n\n            if brackets > 0:\n                build_string += c\n                continue\n\n            if brackets == 0 and c != \",\":\n                build_string += c\n            elif brackets == 0 and c == \",\":\n                # remove leading and trailing whitespaces\n                build_string = build_string.strip()\n                if build_string != \"\":\n                    named = NamedType.from_string(build_string)\n                    types.append(named)\n                    build_string = \"\"\n\n        build_string = build_string.strip()\n\n        # Append the last remaining entry\n        if build_string != \"\":\n            named = NamedType.from_string(build_string)\n            types.append(named)\n\n        if len(types) == 1:\n            return types[0]\n        elif len(types) == 0:\n            return None\n        else:\n            return UnionType(types)\n\n    def to_json(self) -> dict[str, Any]:\n        if self.type is None:\n            return {}\n        else:\n            return self.type.to_json()",
      "instance_attributes": [
        {
          "name": "type",
          "types": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "NoneType"
              },
              {
                "kind": "NamedType",
                "name": "AbstractType"
              }
            ]
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/APIDependencies",
      "name": "APIDependencies",
      "qname": "package_parser.model.api._parameter_dependencies.APIDependencies",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/APIDependencies/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class APIDependencies:\n    dependencies: Dict\n\n    def to_json(self) -> Dict:\n        return {\n            function_name: {\n                parameter_name: [dependency.to_json() for dependency in dependencies]\n                for parameter_name, dependencies in parameter_name.items()\n            }\n            for function_name, parameter_name in self.dependencies.items()\n        }",
      "instance_attributes": [
        {
          "name": "dependencies",
          "types": {
            "kind": "NamedType",
            "name": "Dict"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/Action",
      "name": "Action",
      "qname": "package_parser.model.api._parameter_dependencies.Action",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/Action/from_json",
        "package-parser/package_parser.model.api._parameter_dependencies/Action/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Action:\n    action: str\n\n    @classmethod\n    def from_json(cls, json: Any):\n        return cls(json[\"action\"])\n\n    def to_json(self) -> Dict:\n        return {\"action\": self.action}",
      "instance_attributes": [
        {
          "name": "action",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/Condition",
      "name": "Condition",
      "qname": "package_parser.model.api._parameter_dependencies.Condition",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/Condition/from_json",
        "package-parser/package_parser.model.api._parameter_dependencies/Condition/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Condition:\n    condition: str\n\n    @classmethod\n    def from_json(cls, json: Any):\n        return cls(json[\"condition\"])\n\n    def to_json(self) -> Dict:\n        return {\"condition\": self.condition}",
      "instance_attributes": [
        {
          "name": "condition",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/Dependency",
      "name": "Dependency",
      "qname": "package_parser.model.api._parameter_dependencies.Dependency",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/Dependency/from_json",
        "package-parser/package_parser.model.api._parameter_dependencies/Dependency/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Dependency:\n    hasDependentParameter: Parameter\n    isDependingOn: Parameter\n    hasCondition: Condition\n    hasAction: Action\n\n    @classmethod\n    def from_json(cls, json: Any):\n        return cls(\n            Parameter.from_json(json[\"hasDependentParameter\"]),\n            Parameter.from_json(json[\"isDependingOn\"]),\n            Condition.from_json(json[\"hasCondition\"]),\n            Action.from_json(json[\"hasAction\"]),\n        )\n\n    def to_json(self) -> dict:\n        return {\n            \"hasDependentParameter\": self.hasDependentParameter.to_json(),\n            \"isDependingOn\": self.isDependingOn.to_json(),\n            \"hasCondition\": self.hasCondition.to_json(),\n            \"hasAction\": self.hasAction.to_json(),\n        }",
      "instance_attributes": [
        {
          "name": "hasDependentParameter",
          "types": {
            "kind": "NamedType",
            "name": "Parameter"
          }
        },
        {
          "name": "isDependingOn",
          "types": {
            "kind": "NamedType",
            "name": "Parameter"
          }
        },
        {
          "name": "hasCondition",
          "types": {
            "kind": "NamedType",
            "name": "Condition"
          }
        },
        {
          "name": "hasAction",
          "types": {
            "kind": "NamedType",
            "name": "Action"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterHasValue",
      "name": "ParameterHasValue",
      "qname": "package_parser.model.api._parameter_dependencies.ParameterHasValue",
      "decorators": [],
      "superclasses": [
        "StaticCondition"
      ],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/ParameterHasValue/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterHasValue(StaticCondition):\n    def __init__(self, condition: str) -> None:\n        super().__init__(condition)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIgnored",
      "name": "ParameterIsIgnored",
      "qname": "package_parser.model.api._parameter_dependencies.ParameterIsIgnored",
      "decorators": [],
      "superclasses": [
        "StaticAction"
      ],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIgnored/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterIsIgnored(StaticAction):\n    def __init__(self, action: str) -> None:\n        super().__init__(action)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIllegal",
      "name": "ParameterIsIllegal",
      "qname": "package_parser.model.api._parameter_dependencies.ParameterIsIllegal",
      "decorators": [],
      "superclasses": [
        "StaticAction"
      ],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIllegal/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterIsIllegal(StaticAction):\n    def __init__(self, action: str) -> None:\n        super().__init__(action)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsNone",
      "name": "ParameterIsNone",
      "qname": "package_parser.model.api._parameter_dependencies.ParameterIsNone",
      "decorators": [],
      "superclasses": [
        "StaticCondition"
      ],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsNone/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ParameterIsNone(StaticCondition):\n    def __init__(self, condition: str) -> None:\n        super().__init__(condition)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/RuntimeAction",
      "name": "RuntimeAction",
      "qname": "package_parser.model.api._parameter_dependencies.RuntimeAction",
      "decorators": [],
      "superclasses": [
        "Action"
      ],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/RuntimeAction/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RuntimeAction(Action):\n    def __init__(self, action: str) -> None:\n        super().__init__(action)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/RuntimeCondition",
      "name": "RuntimeCondition",
      "qname": "package_parser.model.api._parameter_dependencies.RuntimeCondition",
      "decorators": [],
      "superclasses": [
        "Condition"
      ],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/RuntimeCondition/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RuntimeCondition(Condition):\n    def __init__(self, condition: str) -> None:\n        super().__init__(condition)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/StaticAction",
      "name": "StaticAction",
      "qname": "package_parser.model.api._parameter_dependencies.StaticAction",
      "decorators": [],
      "superclasses": [
        "Action"
      ],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/StaticAction/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class StaticAction(Action):\n    def __init__(self, action: str) -> None:\n        super().__init__(action)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/StaticCondition",
      "name": "StaticCondition",
      "qname": "package_parser.model.api._parameter_dependencies.StaticCondition",
      "decorators": [],
      "superclasses": [
        "Condition"
      ],
      "methods": [
        "package-parser/package_parser.model.api._parameter_dependencies/StaticCondition/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class StaticCondition(Condition):\n    def __init__(self, condition: str) -> None:\n        super().__init__(condition)",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._types/AbstractType",
      "name": "AbstractType",
      "qname": "package_parser.model.api._types.AbstractType",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.api._types/AbstractType/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AbstractType(metaclass=ABCMeta):\n    @abstractmethod\n    def to_json(self):\n        pass",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.model.api._types/BoundaryType",
      "name": "BoundaryType",
      "qname": "package_parser.model.api._types.BoundaryType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractType"
      ],
      "methods": [
        "package-parser/package_parser.model.api._types/BoundaryType/_is_inclusive",
        "package-parser/package_parser.model.api._types/BoundaryType/from_string",
        "package-parser/package_parser.model.api._types/BoundaryType/__eq__",
        "package-parser/package_parser.model.api._types/BoundaryType/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class BoundaryType(AbstractType):\n    NEGATIVE_INFINITY: ClassVar = \"NegativeInfinity\"\n    INFINITY: ClassVar = \"Infinity\"\n\n    base_type: str\n    min: Union[float, int]\n    max: Union[float, int, str]\n    min_inclusive: bool\n    max_inclusive: bool\n\n    @classmethod\n    def _is_inclusive(cls, bracket: str) -> bool:\n        if bracket == \"(\" or bracket == \")\":\n            return False\n        elif bracket == \"[\" or bracket == \"]\":\n            return True\n        else:\n            raise Exception(f\"{bracket} is not one of []()\")\n\n    @classmethod\n    def from_string(cls, string: str) -> Optional[BoundaryType]:\n        pattern = r\"\"\"(?P<base_type>float|int)?[ ]  # optional base type of either float or int\n                    (in|of)[ ](the[ ])?(range|interval)[ ](of[ ])?  # 'in' or 'of', optional 'the', 'range' or 'interval', optional 'of'\n                    `?(?P<min_bracket>[\\[(])(?P<min>[-+]?\\d+(.\\d*)?|negative_infinity),[ ]  # left side of the range\n                    (?P<max>[-+]?\\d+(.\\d*)?|infinity)(?P<max_bracket>[\\])])`?\"\"\"  # right side of the range\n        match = re.search(pattern, string, re.VERBOSE)\n\n        if match is not None:\n            base_type = match.group(\"base_type\")\n            if base_type is None:\n                base_type = \"float\"\n            base_type = eval(base_type)\n\n            min_value = match.group(\"min\")\n            if min_value != \"negative_infinity\":\n                min_value = base_type(min_value)\n            else:\n                min_value = BoundaryType.NEGATIVE_INFINITY\n\n            max_value = match.group(\"max\")\n            if max_value != \"infinity\":\n                max_value = base_type(max_value)\n            else:\n                max_value = BoundaryType.INFINITY\n\n            min_bracket = match.group(\"min_bracket\")\n            max_bracket = match.group(\"max_bracket\")\n            min_inclusive = BoundaryType._is_inclusive(min_bracket)\n            max_inclusive = BoundaryType._is_inclusive(max_bracket)\n\n            return BoundaryType(\n                base_type.__name__, min_value, max_value, min_inclusive, max_inclusive\n            )\n\n        return None\n\n    def __eq__(self, __o: object) -> bool:\n        if isinstance(__o, BoundaryType):\n            eq = (\n                self.base_type == __o.base_type\n                and self.min == __o.min\n                and self.min_inclusive == __o.min_inclusive\n                and self.max == __o.max\n            )\n            if eq:\n                if self.max == BoundaryType.INFINITY:\n                    return True\n                else:\n                    return self.max_inclusive == __o.max_inclusive\n            else:\n                return False\n        else:\n            return False\n\n    def to_json(self) -> dict[str, Any]:\n        return {\n            \"kind\": self.__class__.__name__,\n            \"base_type\": self.base_type,\n            \"min\": self.min,\n            \"max\": self.max,\n            \"min_inclusive\": self.min_inclusive,\n            \"max_inclusive\": self.max_inclusive,\n        }",
      "instance_attributes": [
        {
          "name": "base_type",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "min",
          "types": null
        },
        {
          "name": "max",
          "types": null
        },
        {
          "name": "min_inclusive",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "max_inclusive",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._types/EnumType",
      "name": "EnumType",
      "qname": "package_parser.model.api._types.EnumType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractType"
      ],
      "methods": [
        "package-parser/package_parser.model.api._types/EnumType/from_string",
        "package-parser/package_parser.model.api._types/EnumType/update",
        "package-parser/package_parser.model.api._types/EnumType/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class EnumType(AbstractType):\n    values: set[str] = field(default_factory=set)\n\n    @classmethod\n    def from_string(cls, string: str) -> Optional[EnumType]:\n        def remove_backslash(e: str):\n            e = e.replace(r\"\\\"\", '\"')\n            e = e.replace(r\"\\'\", \"'\")\n            return e\n\n        enum_match = re.search(r\"{(.*?)}\", string)\n        if enum_match:\n            quotes = \"'\\\"\"\n            values = set()\n            enum_str = enum_match.group(1)\n            value = \"\"\n            inside_value = False\n            curr_quote = None\n            for i, char in enumerate(enum_str):\n                if char in quotes and (i == 0 or (i > 0 and enum_str[i - 1] != \"\\\\\")):\n                    if inside_value == False:\n                        inside_value = True\n                        curr_quote = char\n                    elif inside_value == True:\n                        if curr_quote == char:\n                            inside_value = False\n                            curr_quote = None\n                            values.add(remove_backslash(value))\n                            value = \"\"\n                        else:\n                            value += char\n                elif inside_value:\n                    value += char\n\n            return EnumType(values)\n\n        return None\n\n    def update(self, enum: EnumType):\n        self.values.update(enum.values)\n\n    def to_json(self) -> dict[str, Any]:\n        return {\"kind\": self.__class__.__name__, \"values\": self.values}",
      "instance_attributes": [
        {
          "name": "values",
          "types": {
            "kind": "NamedType",
            "name": "set"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._types/NamedType",
      "name": "NamedType",
      "qname": "package_parser.model.api._types.NamedType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractType"
      ],
      "methods": [
        "package-parser/package_parser.model.api._types/NamedType/from_string",
        "package-parser/package_parser.model.api._types/NamedType/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NamedType(AbstractType):\n    name: str\n\n    @classmethod\n    def from_string(cls, string: str) -> NamedType:\n        return NamedType(string)\n\n    def to_json(self) -> dict[str, str]:\n        return {\"kind\": self.__class__.__name__, \"name\": self.name}",
      "instance_attributes": [
        {
          "name": "name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.api._types/UnionType",
      "name": "UnionType",
      "qname": "package_parser.model.api._types.UnionType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "AbstractType"
      ],
      "methods": [
        "package-parser/package_parser.model.api._types/UnionType/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class UnionType(AbstractType):\n    types: list[AbstractType]\n\n    def to_json(self) -> dict[str, Any]:\n        type_list = []\n        for t in self.types:\n            type_list.append(t.to_json())\n\n        return {\"kind\": self.__class__.__name__, \"types\": type_list}",
      "instance_attributes": [
        {
          "name": "types",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore",
      "name": "UsageCountStore",
      "qname": "package_parser.model.usages._usages.UsageCountStore",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.model.usages._usages/UsageCountStore/from_json",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/__init__",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/__eq__",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/__hash__",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_class",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_function",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_parameter",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/init_value",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/n_class_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/n_function_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/n_parameter_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/most_common_parameter_values",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/merge_other_into_self",
        "package-parser/package_parser.model.usages._usages/UsageCountStore/to_json"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Counts how often classes, functions, parameters, and parameter values are used.",
      "docstring": "Counts how often classes, functions, parameters, and parameter values are used.",
      "code": "class UsageCountStore:\n    \"\"\"Counts how often classes, functions, parameters, and parameter values are used.\"\"\"\n\n    @staticmethod\n    def from_json(json: Any) -> UsageCountStore:\n        \"\"\"Creates an instance of this class from a dictionary.\"\"\"\n\n        result = UsageCountStore()\n\n        # Revive class counts\n        class_counts = json[\"class_counts\"]\n        for class_id, count in class_counts.items():\n            result.add_class_usages(class_id, count)\n\n        # Revive function counts\n        function_counts = json[\"function_counts\"]\n        for function_id, count in function_counts.items():\n            result.add_function_usages(function_id, count)\n\n        # Revive parameter counts\n        parameter_counts = json[\"parameter_counts\"]\n        for parameter_id, count in parameter_counts.items():\n            result.add_parameter_usages(parameter_id, count)\n\n        # Revive value counts\n        value_counts = json[\"value_counts\"]\n        for parameter_id, values in value_counts.items():\n            for value, count in values.items():\n                result.add_value_usages(parameter_id, value, count)\n\n        return result\n\n    def __init__(self) -> None:\n        self.class_usages: Counter[ClassId] = Counter()\n        self.function_usages: Counter[FunctionId] = Counter()\n        self.parameter_usages: Counter[ParameterId] = Counter()\n        self.value_usages: dict[ParameterId, Counter[StringifiedValue]] = {}\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, UsageCountStore):\n            return (\n                self.class_usages == other.class_usages\n                and self.function_usages == other.function_usages\n                and self.parameter_usages == other.parameter_usages\n                and self.value_usages == other.value_usages\n            )\n\n        return False\n\n    def __hash__(self) -> int:\n        return hash(tuple(sorted(self.__dict__.items())))\n\n    def add_class_usages(self, class_id: ClassId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the class with the given name by the given count.\"\"\"\n\n        self.class_usages[class_id] += count\n\n    def remove_class(self, class_id: ClassId) -> None:\n        \"\"\"Removes all usages of classes with the given name and usages of their methods.\"\"\"\n\n        if class_id in self.class_usages:\n            del self.class_usages[class_id]\n\n        for function_id in list(self.function_usages.keys()):\n            if function_id.startswith(class_id):\n                self.remove_function(function_id)\n\n    def add_function_usages(self, function_id: FunctionId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the function with the given name by the given count.\"\"\"\n\n        self.function_usages[function_id] += count\n\n    def remove_function(self, function_id: FunctionId) -> None:\n        \"\"\"Removes all usages of functions with the given name and usages of their parameters.\"\"\"\n\n        if function_id in self.function_usages:\n            del self.function_usages[function_id]\n\n        for parameter_id in list(self.parameter_usages.keys()):\n            if parameter_id.startswith(function_id):\n                self.remove_parameter(parameter_id)\n\n    def add_parameter_usages(self, parameter_id: ParameterId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the parameter with the given name by the given count.\"\"\"\n\n        self.parameter_usages[parameter_id] += count\n\n    def remove_parameter(self, parameter_id: ParameterId) -> None:\n        \"\"\"Removes all parameter and value usages of parameters with the given name.\"\"\"\n\n        if parameter_id in self.parameter_usages:\n            del self.parameter_usages[parameter_id]\n\n        if parameter_id in self.value_usages:\n            del self.value_usages[parameter_id]\n\n    def add_value_usages(\n        self, parameter_id: ParameterId, value: StringifiedValue, count: int = 1\n    ) -> None:\n        \"\"\"Increases the usage count of the given value for the parameter with the given name by the given count.\"\"\"\n\n        self.init_value(parameter_id)\n        self.value_usages[parameter_id][value] += count\n\n    def init_value(self, parameter_id: ParameterId) -> None:\n        \"\"\"Ensures the dictionary for the value counts has the given parameter name as a key.\"\"\"\n\n        if parameter_id not in self.value_usages:\n            self.value_usages[parameter_id] = Counter()\n\n    def n_class_usages(self, class_id: ClassId) -> int:\n        \"\"\"Returns how often the class is used, i.e. how often any of its methods are called.\"\"\"\n\n        return self.class_usages[class_id]\n\n    def n_function_usages(self, function_id: FunctionId) -> int:\n        \"\"\"Returns how often the function is called.\"\"\"\n\n        return self.function_usages[function_id]\n\n    def n_parameter_usages(self, parameter_id: ParameterId) -> int:\n        \"\"\"Returns how often the parameter is set.\"\"\"\n\n        return self.parameter_usages[parameter_id]\n\n    def n_value_usages(self, parameter_id: ParameterId, value: str) -> int:\n        \"\"\"Returns how often the parameter with the given name is set to the given value.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return self.value_usages[parameter_id][value]\n\n        return 0\n\n    def most_common_parameter_values(self, parameter_id: ParameterId) -> list[str]:\n        \"\"\"Returns all values that have been set for the parameter with the given name sorted by their count in descending order.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return [\n                value\n                for value, count in self.value_usages[parameter_id].most_common()\n                if count > 0\n            ]\n\n        return []\n\n    def merge_other_into_self(\n        self, other_usage_store: UsageCountStore\n    ) -> UsageCountStore:\n        \"\"\"\n        Merges the other usage store into this one **in-place** and returns this store.\n\n        :param other_usage_store: The usage store to merge into this one.\n        :return: This usage store.\n        \"\"\"\n\n        # Merge class usages\n        self.class_usages += other_usage_store.class_usages\n\n        # Merge function usages\n        self.function_usages += other_usage_store.function_usages\n\n        # Merge parameter usages\n        self.parameter_usages += other_usage_store.parameter_usages\n\n        # Merge value usages\n        for parameter_id, value_usages in other_usage_store.value_usages.items():\n            self.init_value(parameter_id)\n            self.value_usages[parameter_id] += value_usages\n\n        return self\n\n    def to_json(self) -> Any:\n        \"\"\"Converts this class to a dictionary, which can later be serialized as JSON.\"\"\"\n\n        return {\n            \"class_counts\": {\n                class_id: usage_count\n                for class_id, usage_count in self.class_usages.most_common()\n            },\n            \"function_counts\": {\n                function_id: usage_count\n                for function_id, usage_count in self.function_usages.most_common()\n            },\n            \"parameter_counts\": {\n                parameter_id: usage_count\n                for parameter_id, usage_count in self.parameter_usages.most_common()\n            },\n            \"value_counts\": {\n                parameter_id: {\n                    value: usage_count for value, usage_count in values.most_common()\n                }\n                for parameter_id, values in self.value_usages.items()\n            },\n        }",
      "instance_attributes": [
        {
          "name": "class_usages",
          "types": {
            "kind": "NamedType",
            "name": "Counter[ClassId]"
          }
        },
        {
          "name": "function_usages",
          "types": {
            "kind": "NamedType",
            "name": "Counter[FunctionId]"
          }
        },
        {
          "name": "parameter_usages",
          "types": {
            "kind": "NamedType",
            "name": "Counter[ParameterId]"
          }
        },
        {
          "name": "value_usages",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor",
      "name": "_AstVisitor",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__init__",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_id",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_module",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_module",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_classdef",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_classdef",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_functiondef",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_functiondef",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__description",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__function_parameters",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__parameter_default",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__parameter_docstring",
        "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class _AstVisitor:\n    def __init__(self, api: API) -> None:\n        self.reexported: dict[str, list[str]] = {}\n        self.api: API = api\n        self.__declaration_stack: list[Union[Module, Class, Function]] = []\n\n    def __get_id(self, name: str) -> str:\n        segments = [self.api.package]\n        segments += [it.name for it in self.__declaration_stack]\n        segments += [name]\n\n        return \"/\".join(segments)\n\n    def __get_function_id(self, name: str, decorators: list[str]) -> str:\n        def is_getter() -> bool:\n            return \"property\" in decorators\n\n        def is_setter() -> bool:\n            for decorator in decorators:\n                if re.search(r\"^[^.]*.setter$\", decorator):\n                    return True\n\n            return False\n\n        def is_deleter() -> bool:\n            for decorator in decorators:\n                if re.search(r\"^[^.]*.deleter$\", decorator):\n                    return True\n\n            return False\n\n        result = self.__get_id(name)\n\n        if is_getter():\n            result += \"@getter\"\n        elif is_setter():\n            result += \"@setter\"\n        elif is_deleter():\n            result += \"@deleter\"\n\n        return result\n\n    def enter_module(self, module_node: astroid.Module):\n        imports: list[Import] = []\n        from_imports: list[FromImport] = []\n        visited_global_nodes: set[astroid.NodeNG] = set()\n        id_ = f\"{self.api.package}/{module_node.qname()}\"\n\n        for _, global_node_list in module_node.globals.items():\n            global_node = global_node_list[0]\n\n            # For some reason from-imports get visited as often as there are imported names, leading to duplicates\n            if global_node in visited_global_nodes:\n                continue\n            visited_global_nodes.add(global_node)\n\n            # import X as Y\n            if isinstance(global_node, astroid.Import):\n                for (name, alias) in global_node.names:\n                    imports.append(Import(name, alias))\n\n            # from X import a as b\n            if isinstance(global_node, astroid.ImportFrom):\n                base_import_path = module_node.relative_to_absolute_name(\n                    global_node.modname, global_node.level\n                )\n\n                for (name, alias) in global_node.names:\n                    from_imports.append(FromImport(base_import_path, name, alias))\n\n                # Find re-exported declarations in __init__.py files\n                if _is_init_file(module_node.file) and is_public_module(\n                    module_node.qname()\n                ):\n                    for declaration, _ in global_node.names:\n                        context = InferenceContext()\n                        context.lookupname = declaration\n                        node = safe_infer(global_node, context)\n\n                        if node is None:\n                            logging.warning(\n                                f\"Could not resolve 'from {global_node.modname} import {declaration}\"\n                            )\n                            continue\n\n                        reexported_name = node.qname()\n\n                        if reexported_name.startswith(module_node.name):\n                            if reexported_name not in self.reexported:\n                                self.reexported[reexported_name] = []\n                            self.reexported[reexported_name].append(id_)\n\n        # Remember module, so we can later add classes and global functions\n        module = Module(\n            id_,\n            module_node.qname(),\n            imports,\n            from_imports,\n        )\n        self.__declaration_stack.append(module)\n\n    def leave_module(self, _: astroid.Module) -> None:\n        module = self.__declaration_stack.pop()\n        if not isinstance(module, Module):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        self.api.add_module(module)\n\n    def enter_classdef(self, class_node: astroid.ClassDef) -> None:\n        qname = class_node.qname()\n\n        decorators: Optional[astroid.Decorators] = class_node.decorators\n        if decorators is not None:\n            decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n        else:\n            decorator_names = []\n\n        numpydoc = NumpyDocString(inspect.cleandoc(class_node.doc or \"\"))\n\n        # Remember class, so we can later add methods\n        class_ = Class(\n            self.__get_id(class_node.name),\n            qname,\n            decorator_names,\n            class_node.basenames,\n            self.is_public(class_node.name, qname),\n            self.reexported.get(qname, []),\n            _AstVisitor.__description(numpydoc),\n            class_node.doc,\n        )\n        self.__declaration_stack.append(class_)\n\n    def leave_classdef(self, _: astroid.ClassDef) -> None:\n        class_ = self.__declaration_stack.pop()\n        if not isinstance(class_, Class):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        if len(self.__declaration_stack) > 0:\n            parent = self.__declaration_stack[-1]\n\n            # Ignore nested classes for now\n            if isinstance(parent, Module):\n                self.api.add_class(class_)\n                parent.add_class(class_.id)\n\n    def enter_functiondef(self, function_node: astroid.FunctionDef) -> None:\n        qname = function_node.qname()\n\n        decorators: Optional[astroid.Decorators] = function_node.decorators\n        if decorators is not None:\n            decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n        else:\n            decorator_names = []\n\n        numpydoc = NumpyDocString(inspect.cleandoc(function_node.doc or \"\"))\n        is_public = self.is_public(function_node.name, qname)\n\n        function = Function(\n            self.__get_function_id(function_node.name, decorator_names),\n            qname,\n            decorator_names,\n            self.__function_parameters(\n                function_node, is_public, qname, self.__get_id(function_node.name)\n            ),\n            [],  # TODO: results\n            is_public,\n            self.reexported.get(qname, []),\n            _AstVisitor.__description(numpydoc),\n            function_node.doc,\n        )\n        self.__declaration_stack.append(function)\n\n    def leave_functiondef(self, _: astroid.FunctionDef) -> None:\n        function = self.__declaration_stack.pop()\n        if not isinstance(function, Function):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        if len(self.__declaration_stack) > 0:\n            parent = self.__declaration_stack[-1]\n\n            # Ignore nested functions for now\n            if isinstance(parent, Module):\n                self.api.add_function(function)\n                parent.add_function(function.id)\n            elif isinstance(parent, Class):\n                self.api.add_function(function)\n                parent.add_method(function.id)\n\n    @staticmethod\n    def __description(numpydoc: NumpyDocString) -> str:\n        has_summary = \"Summary\" in numpydoc and len(numpydoc[\"Summary\"]) > 0\n        has_extended_summary = (\n            \"Extended Summary\" in numpydoc and len(numpydoc[\"Extended Summary\"]) > 0\n        )\n\n        result = \"\"\n        if has_summary:\n            result += \"\\n\".join(numpydoc[\"Summary\"])\n        if has_summary and has_extended_summary:\n            result += \"\\n\\n\"\n        if has_extended_summary:\n            result += \"\\n\".join(numpydoc[\"Extended Summary\"])\n        return result\n\n    @staticmethod\n    def __function_parameters(\n        node: astroid.FunctionDef,\n        function_is_public: bool,\n        function_qname: str,\n        function_id: str,\n    ) -> list[Parameter]:\n        parameters = node.args\n        n_implicit_parameters = node.implicit_parameters()\n\n        # For constructors (__init__ functions) the parameters are described on the class\n        if node.name == \"__init__\" and isinstance(node.parent, astroid.ClassDef):\n            docstring = node.parent.doc\n        else:\n            docstring = node.doc\n        function_numpydoc = NumpyDocString(inspect.cleandoc(docstring or \"\"))\n\n        # Arguments that can be specified positionally only ( f(1) works but not f(x=1) )\n        result = [\n            Parameter(\n                id_=function_id + \"/\" + it.name,\n                name=it.name,\n                qname=function_qname + \".\" + it.name,\n                default_value=None,\n                assigned_by=ParameterAssignment.POSITION_ONLY,\n                is_public=function_is_public,\n                docstring=_AstVisitor.__parameter_docstring(function_numpydoc, it.name),\n            )\n            for it in parameters.posonlyargs\n        ]\n\n        # Arguments that can be specified positionally or by name ( f(1) and f(x=1) both work )\n        result += [\n            Parameter(\n                function_id + \"/\" + it.name,\n                it.name,\n                function_qname + \".\" + it.name,\n                _AstVisitor.__parameter_default(\n                    parameters.defaults,\n                    index - len(parameters.args) + len(parameters.defaults),\n                ),\n                ParameterAssignment.POSITION_OR_NAME,\n                function_is_public,\n                _AstVisitor.__parameter_docstring(function_numpydoc, it.name),\n            )\n            for index, it in enumerate(parameters.args)\n        ]\n\n        # Arguments that can be specified by name only ( f(x=1) works but not f(1) )\n        result += [\n            Parameter(\n                function_id + \"/\" + it.name,\n                it.name,\n                function_qname + \".\" + it.name,\n                _AstVisitor.__parameter_default(\n                    parameters.kw_defaults,\n                    index - len(parameters.kwonlyargs) + len(parameters.kw_defaults),\n                ),\n                ParameterAssignment.NAME_ONLY,\n                function_is_public,\n                _AstVisitor.__parameter_docstring(function_numpydoc, it.name),\n            )\n            for index, it in enumerate(parameters.kwonlyargs)\n        ]\n\n        implicit_parameters = result[:n_implicit_parameters]\n        for implicit_parameter in implicit_parameters:\n            implicit_parameter.assigned_by = ParameterAssignment.IMPLICIT\n\n        return result\n\n    @staticmethod\n    def __parameter_default(\n        defaults: list[astroid.NodeNG], default_index: int\n    ) -> Optional[str]:\n        if 0 <= default_index < len(defaults):\n            default = defaults[default_index]\n            if default is None:\n                return None\n            return default.as_string()\n        else:\n            return None\n\n    @staticmethod\n    def __parameter_docstring(\n        function_numpydoc: NumpyDocString, parameter_name: str\n    ) -> ParameterAndResultDocstring:\n        parameters_numpydoc = function_numpydoc[\"Parameters\"]\n        candidate_parameters_numpydoc = [\n            it for it in parameters_numpydoc if it.name == parameter_name\n        ]\n\n        if len(candidate_parameters_numpydoc) > 0:\n            last_parameter_numpydoc = candidate_parameters_numpydoc[-1]\n            return ParameterAndResultDocstring(\n                last_parameter_numpydoc.type, \"\\n\".join(last_parameter_numpydoc.desc)\n            )\n\n        return ParameterAndResultDocstring(\"\", \"\")\n\n    def is_public(self, name: str, qualified_name: str) -> bool:\n        if name.startswith(\"_\") and not name.endswith(\"__\"):\n            return False\n\n        if qualified_name in self.reexported:\n            return True\n\n        # Containing class is re-exported (always false if the current API element is not a method)\n        if (\n            isinstance(self.__declaration_stack[-1], Class)\n            and parent_qualified_name(qualified_name) in self.reexported\n        ):\n            return True\n\n        # The slicing is necessary so __init__ functions are not excluded (already handled in the first condition).\n        return all(not it.startswith(\"_\") for it in qualified_name.split(\".\")[:-1])",
      "instance_attributes": [
        {
          "name": "reexported",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "api",
          "types": {
            "kind": "NamedType",
            "name": "API"
          }
        },
        {
          "name": "__declaration_stack",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor",
      "name": "DependencyExtractor",
      "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Functions to extract each type of pattern in _dependency_patterns",
      "docstring": "Functions to extract each type of pattern in _dependency_patterns",
      "code": "class DependencyExtractor:\n    \"\"\"\n    Functions to extract each type of pattern in _dependency_patterns\n    \"\"\"\n\n    @staticmethod\n    def extract_pattern_parameter_adverbial_clause(\n        dependent_param: Parameter,\n        func_parameters: List[Parameter],\n        match: Tuple,\n        param_docstring: Doc,\n    ) -> Union[Dependency, None]:\n        is_depending_on_param_index = match[1][2]\n        is_depending_on_param_name = param_docstring[is_depending_on_param_index].text\n        is_depending_on_param = next(\n            filter(\n                lambda param: param.name == is_depending_on_param_name, func_parameters\n            ),\n            None,\n        )\n        if is_depending_on_param is None:\n            # Likely not a correct dependency match\n            return None\n\n        condition_token = param_docstring[match[1][1]]\n        condition = extract_condition(condition_token)\n\n        action_token = param_docstring[match[1][0]]\n        action = extract_action(action_token, condition_token)\n\n        return Dependency(\n            hasDependentParameter=dependent_param,\n            isDependingOn=is_depending_on_param,\n            hasCondition=condition,\n            hasAction=action,\n        )",
      "instance_attributes": []
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder",
      "name": "_UsageFinder",
      "qname": "package_parser.processing.usages._ast_visitor._UsageFinder",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__",
        "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class _UsageFinder:\n    def __init__(self, package_name: str) -> None:\n        self.package_name: str = package_name\n        self.usages: UsageCountStore = UsageCountStore()\n\n    def enter_call(self, node: astroid.Call):\n        called_tuple = _analyze_declaration_called_by(node, self.package_name)\n        if called_tuple is None:\n            return\n        called, function_id, parameters, n_implicit_parameters = called_tuple\n\n        bound_parameters = _bound_parameters(\n            parameters, CallSite.from_call(node), n_implicit_parameters\n        )\n        if bound_parameters is None:\n            return\n\n        # Add class usage\n        if (\n            isinstance(called, (astroid.BoundMethod, astroid.UnboundMethod))\n            or isinstance(called, astroid.FunctionDef)\n            and called.is_method()\n        ):\n            self.usages.add_class_usages(parent_id(function_id))\n\n        # Add function usage\n        self.usages.add_function_usages(function_id)\n\n        # Add parameter & value usage\n        for parameter_name, value in bound_parameters.items():\n            parameter_id = f\"{function_id}/{parameter_name}\"\n            self.usages.add_parameter_usages(parameter_id)\n\n            value = _stringify_value(value)\n            self.usages.add_value_usages(parameter_id, value)",
      "instance_attributes": [
        {
          "name": "package_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "usages",
          "types": {
            "kind": "NamedType",
            "name": "UsageCountStore"
          }
        }
      ]
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker",
      "name": "ASTWalker",
      "qname": "package_parser.utils._ASTWalker.ASTWalker",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave",
        "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "docstring": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "code": "class ASTWalker:\n    \"\"\"A walker visiting a tree in preorder, calling on the handler:\n\n    * enter_<class_name> on entering a node, where class name is the class of\n    the node in lower case.\n\n    * leave_<class_name> on leaving a node, where class name is the class of\n    the node in lower case.\n    \"\"\"\n\n    def __init__(self, handler: Any) -> None:\n        self._handler = handler\n        self._cache: dict[Type, _EnterAndLeaveFunctions] = {}\n\n    def walk(self, node: astroid.NodeNG) -> None:\n        self.__walk(node, set())\n\n    def __walk(self, node: astroid.NodeNG, visited_nodes: set[astroid.NodeNG]) -> None:\n        if node in visited_nodes:\n            raise AssertionError(\"Node visited twice\")\n        visited_nodes.add(node)\n\n        self.__enter(node)\n        for child_node in node.get_children():\n            self.__walk(child_node, visited_nodes)\n        self.__leave(node)\n\n    def __enter(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[0]\n        if method is not None:\n            method(node)\n\n    def __leave(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[1]\n        if method is not None:\n            method(node)\n\n    def __get_callbacks(self, node: astroid.NodeNG) -> _EnterAndLeaveFunctions:\n        klass = node.__class__\n        methods = self._cache.get(klass)\n\n        if methods is None:\n            handler = self._handler\n            class_name = klass.__name__.lower()\n            enter_method = getattr(\n                handler, f\"enter_{class_name}\", getattr(handler, \"enter_default\", None)\n            )\n            leave_method = getattr(\n                handler, f\"leave_{class_name}\", getattr(handler, \"leave_default\", None)\n            )\n            self._cache[klass] = (enter_method, leave_method)\n        else:\n            enter_method, leave_method = methods\n\n        return enter_method, leave_method",
      "instance_attributes": [
        {
          "name": "_handler",
          "types": {
            "kind": "NamedType",
            "name": "Any"
          }
        },
        {
          "name": "_cache",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    }
  ],
  "functions": [
    {
      "id": "package-parser/package_parser.cli._cli/_add_all_subparser",
      "name": "_add_all_subparser",
      "qname": "package_parser.cli._cli._add_all_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_all_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_all_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_all_subparser(subparsers: _SubParsersAction) -> None:\n    all_parser = subparsers.add_parser(\n        _ALL_COMMAND,\n        help=\"Run api and usages command in parallel and then run annotations command.\",\n    )\n    all_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package.\",\n        type=str,\n        required=True,\n    )\n    all_parser.add_argument(\n        \"-s\",\n        \"--src\",\n        help=\"Directory containing the Python code of the package. If this is omitted, we try to locate the package \"\n        \"with the given name in the current Python interpreter.\",\n        type=Path,\n        required=False,\n        default=None,\n    )\n    all_parser.add_argument(\n        \"-c\",\n        \"--client\",\n        help=\"Directory containing Python code that uses the package.\",\n        type=Path,\n        required=True,\n    )\n    all_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )\n    all_parser.add_argument(\n        \"--processes\",\n        help=\"How many processes should be spawned during processing.\",\n        type=int,\n        required=False,\n        default=4,\n    )\n    all_parser.add_argument(\n        \"--batchsize\",\n        help=\"How many files to process in one go. Higher values lead to higher memory usage but better performance.\",\n        type=int,\n        required=False,\n        default=100,\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_annotations_subparser",
      "name": "_add_annotations_subparser",
      "qname": "package_parser.cli._cli._add_annotations_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_annotations_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_annotations_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_annotations_subparser(subparsers) -> None:\n    generate_parser = subparsers.add_parser(\n        _ANNOTATIONS_COMMAND, help=\"Generate Annotations automatically.\"\n    )\n    generate_parser.add_argument(\n        \"-a\",\n        \"--api\",\n        help=\"File created by the 'api' command.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-u\",\n        \"--usages\",\n        help=\"File created by the 'usages' command that contains usage counts.\",\n        type=Path,\n        required=True,\n    )\n    generate_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_api_subparser",
      "name": "_add_api_subparser",
      "qname": "package_parser.cli._cli._add_api_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_api_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_api_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_api_subparser(subparsers: _SubParsersAction) -> None:\n    api_parser = subparsers.add_parser(_API_COMMAND, help=\"List the API of a package.\")\n    api_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package.\",\n        type=str,\n        required=True,\n    )\n    api_parser.add_argument(\n        \"-s\",\n        \"--src\",\n        help=\"Directory containing the Python code of the package. If this is omitted, we try to locate the package \"\n        \"with the given name in the current Python interpreter.\",\n        type=Path,\n        required=False,\n        default=None,\n    )\n    api_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_add_usages_subparser",
      "name": "_add_usages_subparser",
      "qname": "package_parser.cli._cli._add_usages_subparser",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._cli/_add_usages_subparser/subparsers",
          "name": "subparsers",
          "qname": "package_parser.cli._cli._add_usages_subparser.subparsers",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _add_usages_subparser(subparsers: _SubParsersAction) -> None:\n    usages_parser = subparsers.add_parser(\n        _USAGES_COMMAND, help=\"Find usages of API elements.\"\n    )\n    usages_parser.add_argument(\n        \"-p\",\n        \"--package\",\n        help=\"The name of the package. It must be installed in the current interpreter.\",\n        type=str,\n        required=True,\n    )\n    usages_parser.add_argument(\n        \"-c\",\n        \"--client\",\n        help=\"Directory containing Python code that uses the package.\",\n        type=Path,\n        required=True,\n    )\n    usages_parser.add_argument(\n        \"--processes\",\n        help=\"How many processes should be spawned during processing.\",\n        type=int,\n        required=False,\n        default=4,\n    ),\n    usages_parser.add_argument(\n        \"--batchsize\",\n        help=\"How many files to process in one go. Higher values lead to higher memory usage but better performance.\",\n        type=int,\n        required=False,\n        default=100,\n    )\n    usages_parser.add_argument(\n        \"-o\", \"--out\", help=\"Output directory.\", type=Path, required=True\n    )"
    },
    {
      "id": "package-parser/package_parser.cli._cli/_get_args",
      "name": "_get_args",
      "qname": "package_parser.cli._cli._get_args",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _get_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(description=\"Analyze Python code.\")\n    parser.add_argument(\n        \"-v\", \"--verbose\", help=\"show info messages\", action=\"store_true\"\n    )\n\n    # Commands\n    subparsers = parser.add_subparsers(dest=\"command\")\n    _add_api_subparser(subparsers)\n    _add_usages_subparser(subparsers)\n    _add_annotations_subparser(subparsers)\n    _add_all_subparser(subparsers)\n\n    return parser.parse_args()"
    },
    {
      "id": "package-parser/package_parser.cli._cli/cli",
      "name": "cli",
      "qname": "package_parser.cli._cli.cli",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def cli() -> None:\n    args = _get_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.INFO)\n\n    if args.command == _API_COMMAND:\n        _run_api_command(args.package, args.src, args.out)\n    elif args.command == _USAGES_COMMAND:\n        _run_usages_command(\n            args.package, args.client, args.out, args.processes, args.batchsize\n        )\n    elif args.command == _ANNOTATIONS_COMMAND:\n        _run_annotations(args.api, args.usages, args.out)\n    elif args.command == _ALL_COMMAND:\n        _run_all_command(\n            args.package,\n            args.src,\n            args.client,\n            args.out,\n            args.processes,\n            args.batchsize,\n        )"
    },
    {
      "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder/default",
      "name": "default",
      "qname": "package_parser.cli._json_encoder.CustomEncoder.default",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder/default/self",
          "name": "self",
          "qname": "package_parser.cli._json_encoder.CustomEncoder.default.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._json_encoder/CustomEncoder/default/o",
          "name": "o",
          "qname": "package_parser.cli._json_encoder.CustomEncoder.default.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def default(self, o: Any) -> Any:\n        if isinstance(o, set):\n            return list(o)\n        return super().default(o)"
    },
    {
      "id": "package-parser/package_parser.cli._run_all/_run_all_command",
      "name": "_run_all_command",
      "qname": "package_parser.cli._run_all._run_all_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_all._run_all_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/src_dir_path",
          "name": "src_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.src_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/client_dir_path",
          "name": "client_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.client_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_all._run_all_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/n_processes",
          "name": "n_processes",
          "qname": "package_parser.cli._run_all._run_all_command.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_all/_run_all_command/batch_size",
          "name": "batch_size",
          "qname": "package_parser.cli._run_all._run_all_command.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_all_command(\n    package: str,\n    src_dir_path: Path,\n    client_dir_path: Path,\n    out_dir_path: Path,\n    n_processes: int,\n    batch_size: int,\n) -> None:\n    out_file_annotations = out_dir_path.joinpath(\"annotations.json\")\n    results = _run_in_parallel(\n        partial(_run_api_command, package, src_dir_path, out_dir_path),\n        partial(\n            _run_usages_command,\n            package,\n            client_dir_path,\n            out_dir_path,\n            n_processes,\n            batch_size,\n        ),\n    )\n    _run_annotations(results[_API_KEY], results[_USAGES_KEY], out_file_annotations)"
    },
    {
      "id": "package-parser/package_parser.cli._run_all/_run_in_parallel",
      "name": "_run_in_parallel",
      "qname": "package_parser.cli._run_all._run_in_parallel",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_all/_run_in_parallel/fns",
          "name": "fns",
          "qname": "package_parser.cli._run_all._run_in_parallel.fns",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_in_parallel(*fns) -> dict:\n    manager = multiprocessing.Manager()\n    return_dict: dict[str, str] = manager.dict()\n    proc = []\n    for fn in fns:\n        p = multiprocessing.Process(target=fn, args=(return_dict,))\n        proc.append(p)\n        p.start()\n\n    for p in proc:\n        p.join()\n\n    return return_dict"
    },
    {
      "id": "package-parser/package_parser.cli._run_annotations/_read_api_file",
      "name": "_read_api_file",
      "qname": "package_parser.cli._run_annotations._read_api_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_annotations/_read_api_file/api_file_path",
          "name": "api_file_path",
          "qname": "package_parser.cli._run_annotations._read_api_file.api_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_api_file(api_file_path: Path) -> API:\n    with open(api_file_path) as api_file:\n        api_json = json.load(api_file)\n\n    return API.from_json(api_json)"
    },
    {
      "id": "package-parser/package_parser.cli._run_annotations/_read_usages_file",
      "name": "_read_usages_file",
      "qname": "package_parser.cli._run_annotations._read_usages_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_annotations/_read_usages_file/usages_file_path",
          "name": "usages_file_path",
          "qname": "package_parser.cli._run_annotations._read_usages_file.usages_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _read_usages_file(usages_file_path: Path) -> UsageCountStore:\n    with open(usages_file_path) as usages_file:\n        usages_json = json.load(usages_file)\n\n    return UsageCountStore.from_json(usages_json)"
    },
    {
      "id": "package-parser/package_parser.cli._run_annotations/_run_annotations",
      "name": "_run_annotations",
      "qname": "package_parser.cli._run_annotations._run_annotations",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_annotations/_run_annotations/api_file_path",
          "name": "api_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.api_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_annotations/_run_annotations/usages_file_path",
          "name": "usages_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.usages_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_annotations/_run_annotations/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._run_annotations._run_annotations.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\nAnnotations that are generated are: remove, constant, required, optional, enum and boundary.\n:param api_file_path: API file Path\n:param usages_file_path: UsageStore file Path\n:param annotations_file_path: Output file Path",
      "docstring": "Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\nAnnotations that are generated are: remove, constant, required, optional, enum and boundary.\n:param api_file_path: API file Path\n:param usages_file_path: UsageStore file Path\n:param annotations_file_path: Output file Path",
      "code": "def _run_annotations(\n    api_file_path: Path, usages_file_path: Path, annotations_file_path: Path\n) -> None:\n    \"\"\"\n    Generates an annotation file from the given API and UsageStore files, and writes it to the given output file.\n    Annotations that are generated are: remove, constant, required, optional, enum and boundary.\n    :param api_file_path: API file Path\n    :param usages_file_path: UsageStore file Path\n    :param annotations_file_path: Output file Path\n    \"\"\"\n\n    api = _read_api_file(api_file_path)\n    usages = _read_usages_file(usages_file_path)\n    annotations = generate_annotations(api, usages)\n    _write_annotations_file(annotations, annotations_file_path)"
    },
    {
      "id": "package-parser/package_parser.cli._run_annotations/_write_annotations_file",
      "name": "_write_annotations_file",
      "qname": "package_parser.cli._run_annotations._write_annotations_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_annotations/_write_annotations_file/annotations",
          "name": "annotations",
          "qname": "package_parser.cli._run_annotations._write_annotations_file.annotations",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_annotations/_write_annotations_file/annotations_file_path",
          "name": "annotations_file_path",
          "qname": "package_parser.cli._run_annotations._write_annotations_file.annotations_file_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_annotations_file(\n    annotations: AnnotationStore, annotations_file_path: Path\n) -> None:\n    ensure_file_exists(annotations_file_path)\n    with annotations_file_path.open(\"w\") as f:\n        json.dump(annotations.to_json(), f, indent=2)"
    },
    {
      "id": "package-parser/package_parser.cli._run_api/_run_api_command",
      "name": "_run_api_command",
      "qname": "package_parser.cli._run_api._run_api_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_api._run_api_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/src_dir_path",
          "name": "src_dir_path",
          "qname": "package_parser.cli._run_api._run_api_command.src_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_api._run_api_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_run_api_command/result_dict",
          "name": "result_dict",
          "qname": "package_parser.cli._run_api._run_api_command.result_dict",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_api_command(\n    package: str,\n    src_dir_path: Path,\n    out_dir_path: Path,\n    result_dict: Optional[dict] = None,\n) -> None:\n    api = get_api(package, src_dir_path)\n    api_dependencies = get_dependencies(api)\n\n    api_file_path = _write_api_file(api, out_dir_path)\n    _write_api_dependency_file(api, api_dependencies, out_dir_path)\n\n    if result_dict is not None:\n        result_dict[_API_KEY] = api_file_path"
    },
    {
      "id": "package-parser/package_parser.cli._run_api/_write_api_dependency_file",
      "name": "_write_api_dependency_file",
      "qname": "package_parser.cli._run_api._write_api_dependency_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_dependency_file/api",
          "name": "api",
          "qname": "package_parser.cli._run_api._write_api_dependency_file.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_dependency_file/api_dependencies",
          "name": "api_dependencies",
          "qname": "package_parser.cli._run_api._write_api_dependency_file.api_dependencies",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_dependency_file/out",
          "name": "out",
          "qname": "package_parser.cli._run_api._write_api_dependency_file.out",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_api_dependency_file(api: API, api_dependencies, out):\n    out_file_api_dependencies = out.joinpath(f\"{api.package}__api_dependencies.json\")\n    ensure_file_exists(out_file_api_dependencies)\n    with out_file_api_dependencies.open(\"w\") as f:\n        json.dump(api_dependencies.to_json(), f, indent=2, cls=CustomEncoder)"
    },
    {
      "id": "package-parser/package_parser.cli._run_api/_write_api_file",
      "name": "_write_api_file",
      "qname": "package_parser.cli._run_api._write_api_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_file/api",
          "name": "api",
          "qname": "package_parser.cli._run_api._write_api_file.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_api/_write_api_file/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_api._write_api_file.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _write_api_file(api: API, out_dir_path: Path) -> Path:\n    out_file_api = out_dir_path.joinpath(f\"{api.package}__api.json\")\n    ensure_file_exists(out_file_api)\n    with out_file_api.open(\"w\") as f:\n        json.dump(api.to_json(), f, indent=2, cls=CustomEncoder)\n    return out_file_api"
    },
    {
      "id": "package-parser/package_parser.cli._run_usages/_run_usages_command",
      "name": "_run_usages_command",
      "qname": "package_parser.cli._run_usages._run_usages_command",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/package",
          "name": "package",
          "qname": "package_parser.cli._run_usages._run_usages_command.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/client_dir_path",
          "name": "client_dir_path",
          "qname": "package_parser.cli._run_usages._run_usages_command.client_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/out_dir_path",
          "name": "out_dir_path",
          "qname": "package_parser.cli._run_usages._run_usages_command.out_dir_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/n_processes",
          "name": "n_processes",
          "qname": "package_parser.cli._run_usages._run_usages_command.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/batch_size",
          "name": "batch_size",
          "qname": "package_parser.cli._run_usages._run_usages_command.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.cli._run_usages/_run_usages_command/result_dict",
          "name": "result_dict",
          "qname": "package_parser.cli._run_usages._run_usages_command.result_dict",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _run_usages_command(\n    package: str,\n    client_dir_path: Path,\n    out_dir_path: Path,\n    n_processes: int,\n    batch_size: int,\n    result_dict: Optional[dict] = None,\n) -> None:\n    usages = find_usages(package, client_dir_path, n_processes, batch_size)\n\n    out_file_usage_count = out_dir_path.joinpath(f\"{package}__usage_counts.json\")\n    ensure_file_exists(out_file_usage_count)\n    with out_file_usage_count.open(\"w\") as f:\n        json.dump(usages.to_json(), f, indent=2)\n\n    if result_dict is not None:\n        result_dict[_USAGES_KEY] = out_file_usage_count"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AbstractAnnotation/to_json",
      "name": "to_json",
      "qname": "package_parser.model.annotations._annotations.AbstractAnnotation.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/AbstractAnnotation/to_json/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.AbstractAnnotation.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return asdict(self)"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore/__init__",
      "name": "__init__",
      "qname": "package_parser.model.annotations._annotations.AnnotationStore.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore/__init__/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.AnnotationStore.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self):\n        self.constants = []\n        self.removes = []\n        self.requireds = []\n        self.optionals = []\n        self.boundaries = []\n        self.enums = []"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore/to_json",
      "name": "to_json",
      "qname": "package_parser.model.annotations._annotations.AnnotationStore.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/AnnotationStore/to_json/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.AnnotationStore.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"constants\": {\n                annotation.target: annotation.to_json() for annotation in self.constants\n            },\n            \"removes\": {\n                annotation.target: annotation.to_json() for annotation in self.removes\n            },\n            \"requireds\": {\n                annotation.target: annotation.to_json() for annotation in self.requireds\n            },\n            \"optionals\": {\n                annotation.target: annotation.to_json() for annotation in self.optionals\n            },\n            \"boundaries\": {\n                annotation.target: annotation.to_json()\n                for annotation in self.boundaries\n            },\n            \"enums\": {\n                annotation.target: annotation.to_json() for annotation in self.enums\n            },\n        }"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/EnumPair/to_json",
      "name": "to_json",
      "qname": "package_parser.model.annotations._annotations.EnumPair.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/EnumPair/to_json/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.EnumPair.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return asdict(self)"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/Interval/to_json",
      "name": "to_json",
      "qname": "package_parser.model.annotations._annotations.Interval.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/Interval/to_json/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.Interval.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return asdict(self)"
    },
    {
      "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__",
      "name": "__init__",
      "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__/self",
          "name": "self",
          "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__/parameter_type",
          "name": "parameter_type",
          "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__.parameter_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__/value",
          "name": "value",
          "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__.value",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.annotations._annotations/ParameterInfo/__init__/value_type",
          "name": "value_type",
          "qname": "package_parser.model.annotations._annotations.ParameterInfo.__init__.value_type",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, parameter_type, value=\"\", value_type=\"\"):\n        self.type = parameter_type\n        self.value = value\n        self.value_type = value_type"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._api.API.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/API/__init__/distribution",
          "name": "distribution",
          "qname": "package_parser.model.api._api.API.__init__.distribution",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/API/__init__/package",
          "name": "package",
          "qname": "package_parser.model.api._api.API.__init__.package",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/API/__init__/version",
          "name": "version",
          "qname": "package_parser.model.api._api.API.__init__.version",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, distribution: str, package: str, version: str) -> None:\n        self.distribution: str = distribution\n        self.package: str = package\n        self.version: str = version\n        self.modules: dict[str, Module] = dict()\n        self.classes: dict[str, Class] = dict()\n        self.functions: dict[str, Function] = dict()"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/add_class",
      "name": "add_class",
      "qname": "package_parser.model.api._api.API.add_class",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/add_class/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.add_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/API/add_class/class_",
          "name": "class_",
          "qname": "package_parser.model.api._api.API.add_class.class_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_class(self, class_: Class) -> None:\n        self.classes[class_.id] = class_"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/add_function",
      "name": "add_function",
      "qname": "package_parser.model.api._api.API.add_function",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/add_function/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.add_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/API/add_function/function",
          "name": "function",
          "qname": "package_parser.model.api._api.API.add_function.function",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_function(self, function: Function) -> None:\n        self.functions[function.id] = function"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/add_module",
      "name": "add_module",
      "qname": "package_parser.model.api._api.API.add_module",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/add_module/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.add_module.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/API/add_module/module",
          "name": "module",
          "qname": "package_parser.model.api._api.API.add_module.module",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_module(self, module: Module) -> None:\n        self.modules[module.id] = module"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/class_count",
      "name": "class_count",
      "qname": "package_parser.model.api._api.API.class_count",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/class_count/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.class_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def class_count(self) -> int:\n        return len(self.classes)"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._api.API.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._api.API.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> API:\n        result = API(json[\"distribution\"], json[\"package\"], json[\"version\"])\n\n        for module_json in json.get(\"modules\", []):\n            result.add_module(Module.from_json(module_json))\n\n        for class_json in json.get(\"classes\", []):\n            result.add_class(Class.from_json(class_json))\n\n        for function_json in json.get(\"functions\", []):\n            result.add_function(Function.from_json(function_json))\n\n        return result"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/function_count",
      "name": "function_count",
      "qname": "package_parser.model.api._api.API.function_count",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/function_count/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.function_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def function_count(self) -> int:\n        return len(self.functions)"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/get_default_value",
      "name": "get_default_value",
      "qname": "package_parser.model.api._api.API.get_default_value",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/get_default_value/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.get_default_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/API/get_default_value/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.api._api.API.get_default_value.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_value(self, parameter_id: str) -> Optional[str]:\n        function_id = parent_id(parameter_id)\n\n        if function_id not in self.functions:\n            return None\n\n        for parameter in self.functions[function_id].parameters:\n            if parameter.id == parameter_id:\n                return parameter.default_value\n\n        return None"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/is_public_class",
      "name": "is_public_class",
      "qname": "package_parser.model.api._api.API.is_public_class",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/is_public_class/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.is_public_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/API/is_public_class/class_id",
          "name": "class_id",
          "qname": "package_parser.model.api._api.API.is_public_class.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_public_class(self, class_id: str) -> bool:\n        return class_id in self.classes and self.classes[class_id].is_public"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/is_public_function",
      "name": "is_public_function",
      "qname": "package_parser.model.api._api.API.is_public_function",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/is_public_function/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.is_public_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/API/is_public_function/function_id",
          "name": "function_id",
          "qname": "package_parser.model.api._api.API.is_public_function.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_public_function(self, function_id: str) -> bool:\n        return function_id in self.functions and self.functions[function_id].is_public"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/parameter_count",
      "name": "parameter_count",
      "qname": "package_parser.model.api._api.API.parameter_count",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/parameter_count/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.parameter_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def parameter_count(self) -> int:\n        return len(self.parameters())"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/parameters",
      "name": "parameters",
      "qname": "package_parser.model.api._api.API.parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/parameters/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.parameters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def parameters(self) -> dict[str, Parameter]:\n        result: dict[str, Parameter] = {}\n\n        for function in self.functions.values():\n            for parameter in function.parameters:\n                parameter_id = f\"{function.id}/{parameter.name}\"\n                result[parameter_id] = parameter\n\n        return result"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/public_class_count",
      "name": "public_class_count",
      "qname": "package_parser.model.api._api.API.public_class_count",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/public_class_count/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.public_class_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def public_class_count(self) -> int:\n        return len([it for it in self.classes.values() if it.is_public])"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/public_function_count",
      "name": "public_function_count",
      "qname": "package_parser.model.api._api.API.public_function_count",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/public_function_count/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.public_function_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def public_function_count(self) -> int:\n        return len([it for it in self.functions.values() if it.is_public])"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/public_parameter_count",
      "name": "public_parameter_count",
      "qname": "package_parser.model.api._api.API.public_parameter_count",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/public_parameter_count/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.public_parameter_count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def public_parameter_count(self) -> int:\n        return len([it for it in self.parameters().values() if it.is_public])"
    },
    {
      "id": "package-parser/package_parser.model.api._api/API/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.API.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/API/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.API.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"distribution\": self.distribution,\n            \"package\": self.package,\n            \"version\": self.version,\n            \"modules\": [\n                module.to_json()\n                for module in sorted(self.modules.values(), key=lambda it: it.id)\n            ],\n            \"classes\": [\n                class_.to_json()\n                for class_ in sorted(self.classes.values(), key=lambda it: it.id)\n            ],\n            \"functions\": [\n                function.to_json()\n                for function in sorted(self.functions.values(), key=lambda it: it.id)\n            ],\n        }"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Class/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._api.Class.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Class/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Class.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Class/__init__/id_",
          "name": "id_",
          "qname": "package_parser.model.api._api.Class.__init__.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Class/__init__/qname",
          "name": "qname",
          "qname": "package_parser.model.api._api.Class.__init__.qname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Class/__init__/decorators",
          "name": "decorators",
          "qname": "package_parser.model.api._api.Class.__init__.decorators",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Class/__init__/superclasses",
          "name": "superclasses",
          "qname": "package_parser.model.api._api.Class.__init__.superclasses",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Class/__init__/is_public",
          "name": "is_public",
          "qname": "package_parser.model.api._api.Class.__init__.is_public",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Class/__init__/reexported_by",
          "name": "reexported_by",
          "qname": "package_parser.model.api._api.Class.__init__.reexported_by",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Class/__init__/description",
          "name": "description",
          "qname": "package_parser.model.api._api.Class.__init__.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Class/__init__/docstring",
          "name": "docstring",
          "qname": "package_parser.model.api._api.Class.__init__.docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        id_: str,\n        qname: str,\n        decorators: list[str],\n        superclasses: list[str],\n        is_public: bool,\n        reexported_by: list[str],\n        description: str,\n        docstring: str,\n    ) -> None:\n        self.id: str = id_\n        self.qname: str = qname\n        self.decorators: list[str] = decorators\n        self.superclasses: list[str] = superclasses\n        self.methods: list[str] = []\n        self.is_public: bool = is_public\n        self.reexported_by: list[str] = reexported_by\n        self.description: str = description\n        self.docstring: str = docstring"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Class/add_method",
      "name": "add_method",
      "qname": "package_parser.model.api._api.Class.add_method",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Class/add_method/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Class.add_method.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Class/add_method/method_id",
          "name": "method_id",
          "qname": "package_parser.model.api._api.Class.add_method.method_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_method(self, method_id: str) -> None:\n        self.methods.append(method_id)"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Class/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._api.Class.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Class/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._api.Class.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Class:\n        result = Class(\n            json[\"id\"],\n            json[\"qname\"],\n            json.get(\"decorators\", []),\n            json.get(\"superclasses\", []),\n            json.get(\"is_public\", True),\n            json.get(\"reexported_by\", []),\n            json.get(\"description\", \"\"),\n            json.get(\"docstring\", \"\"),\n        )\n\n        for method_id in json[\"methods\"]:\n            result.add_method(method_id)\n\n        return result"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Class/name@getter",
      "name": "name",
      "qname": "package_parser.model.api._api.Class.name",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Class/name@getter/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Class.name.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def name(self) -> str:\n        return self.qname.split(\".\")[-1]"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Class/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.Class.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Class/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Class.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"decorators\": self.decorators,\n            \"superclasses\": self.superclasses,\n            \"methods\": self.methods,\n            \"is_public\": self.is_public,\n            \"reexported_by\": self.reexported_by,\n            \"description\": self.description,\n            \"docstring\": self.docstring,\n        }"
    },
    {
      "id": "package-parser/package_parser.model.api._api/FromImport/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._api.FromImport.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/FromImport/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._api.FromImport.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> FromImport:\n        return FromImport(json[\"module\"], json[\"declaration\"], json[\"alias\"])"
    },
    {
      "id": "package-parser/package_parser.model.api._api/FromImport/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.FromImport.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/FromImport/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.FromImport.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"module\": self.module_name,\n            \"declaration\": self.declaration_name,\n            \"alias\": self.alias,\n        }"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Function/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._api.Function.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Function/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._api.Function.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Function:\n        return Function(\n            json[\"id\"],\n            json[\"qname\"],\n            json.get(\"decorators\", []),\n            [\n                Parameter.from_json(parameter_json)\n                for parameter_json in json.get(\"parameters\", [])\n            ],\n            [Result.from_json(result_json) for result_json in json.get(\"results\", [])],\n            json.get(\"is_public\", True),\n            json.get(\"reexported_by\", []),\n            json.get(\"description\", \"\"),\n            json.get(\"docstring\", \"\"),\n        )"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Function/name@getter",
      "name": "name",
      "qname": "package_parser.model.api._api.Function.name",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Function/name@getter/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Function.name.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def name(self) -> str:\n        return self.qname.split(\".\")[-1]"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Function/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.Function.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Function/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Function.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"decorators\": self.decorators,\n            \"parameters\": [parameter.to_json() for parameter in self.parameters],\n            \"results\": [result.to_json() for result in self.results],\n            \"is_public\": self.is_public,\n            \"reexported_by\": self.reexported_by,\n            \"description\": self.description,\n            \"docstring\": self.docstring,\n        }"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Import/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._api.Import.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Import/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._api.Import.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Import:\n        return Import(json[\"module\"], json[\"alias\"])"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Import/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.Import.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Import/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Import.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\"module\": self.module_name, \"alias\": self.alias}"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Module/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._api.Module.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Module/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Module.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Module/__init__/id_",
          "name": "id_",
          "qname": "package_parser.model.api._api.Module.__init__.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Module/__init__/name",
          "name": "name",
          "qname": "package_parser.model.api._api.Module.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Module/__init__/imports",
          "name": "imports",
          "qname": "package_parser.model.api._api.Module.__init__.imports",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Module/__init__/from_imports",
          "name": "from_imports",
          "qname": "package_parser.model.api._api.Module.__init__.from_imports",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self, id_: str, name: str, imports: list[Import], from_imports: list[FromImport]\n    ):\n        self.id: str = id_\n        self.name: str = name\n        self.imports: list[Import] = imports\n        self.from_imports: list[FromImport] = from_imports\n        self.classes: list[str] = []\n        self.functions: list[str] = []"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Module/add_class",
      "name": "add_class",
      "qname": "package_parser.model.api._api.Module.add_class",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Module/add_class/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Module.add_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Module/add_class/class_id",
          "name": "class_id",
          "qname": "package_parser.model.api._api.Module.add_class.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_class(self, class_id: str) -> None:\n        self.classes.append(class_id)"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Module/add_function",
      "name": "add_function",
      "qname": "package_parser.model.api._api.Module.add_function",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Module/add_function/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Module.add_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Module/add_function/function_id",
          "name": "function_id",
          "qname": "package_parser.model.api._api.Module.add_function.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_function(self, function_id: str) -> None:\n        self.functions.append(function_id)"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Module/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._api.Module.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Module/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._api.Module.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Module:\n        result = Module(\n            json[\"id\"],\n            json[\"name\"],\n            [Import.from_json(import_json) for import_json in json.get(\"imports\", [])],\n            [\n                FromImport.from_json(from_import_json)\n                for from_import_json in json.get(\"from_imports\", [])\n            ],\n        )\n\n        for class_id in json.get(\"classes\", []):\n            result.add_class(class_id)\n\n        for function_id in json.get(\"functions\", []):\n            result.add_function(function_id)\n\n        return result"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Module/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.Module.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Module/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Module.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"imports\": [import_.to_json() for import_ in self.imports],\n            \"from_imports\": [\n                from_import.to_json() for from_import in self.from_imports\n            ],\n            \"classes\": self.classes,\n            \"functions\": self.functions,\n        }"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Parameter/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._api.Parameter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Parameter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/__init__/id_",
          "name": "id_",
          "qname": "package_parser.model.api._api.Parameter.__init__.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/__init__/name",
          "name": "name",
          "qname": "package_parser.model.api._api.Parameter.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/__init__/qname",
          "name": "qname",
          "qname": "package_parser.model.api._api.Parameter.__init__.qname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/__init__/default_value",
          "name": "default_value",
          "qname": "package_parser.model.api._api.Parameter.__init__.default_value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/__init__/assigned_by",
          "name": "assigned_by",
          "qname": "package_parser.model.api._api.Parameter.__init__.assigned_by",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/__init__/is_public",
          "name": "is_public",
          "qname": "package_parser.model.api._api.Parameter.__init__.is_public",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/__init__/docstring",
          "name": "docstring",
          "qname": "package_parser.model.api._api.Parameter.__init__.docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        id_: str,\n        name: str,\n        qname: str,\n        default_value: Optional[str],\n        assigned_by: ParameterAssignment,\n        is_public: bool,\n        docstring: ParameterAndResultDocstring,\n    ) -> None:\n        self.id: str = id_\n        self.name: str = name\n        self.qname: str = qname\n        self.default_value: Optional[str] = default_value\n        self.assigned_by: ParameterAssignment = assigned_by\n        self.is_public: bool = is_public\n        self.docstring = docstring\n        self.type: Type = Type(docstring)"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Parameter/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._api.Parameter.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._api.Parameter.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any):\n        return Parameter(\n            json[\"id\"],\n            json[\"name\"],\n            json[\"qname\"],\n            json.get(\"default_value\", None),\n            ParameterAssignment[json.get(\"assigned_by\", \"POSITION_OR_NAME\")],\n            json.get(\"is_public\", True),\n            ParameterAndResultDocstring.from_json(json.get(\"docstring\", {})),\n        )"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Parameter/is_optional",
      "name": "is_optional",
      "qname": "package_parser.model.api._api.Parameter.is_optional",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/is_optional/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Parameter.is_optional.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_optional(self) -> bool:\n        return self.default_value is not None"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Parameter/is_required",
      "name": "is_required",
      "qname": "package_parser.model.api._api.Parameter.is_required",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/is_required/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Parameter.is_required.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_required(self) -> bool:\n        return self.default_value is None"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Parameter/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.Parameter.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Parameter/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Parameter.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"qname\": self.qname,\n            \"default_value\": self.default_value,\n            \"assigned_by\": self.assigned_by.name,\n            \"is_public\": self.is_public,\n            \"docstring\": self.docstring.to_json(),\n            \"type\": self.type.to_json(),\n        }"
    },
    {
      "id": "package-parser/package_parser.model.api._api/ParameterAndResultDocstring/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._api.ParameterAndResultDocstring.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/ParameterAndResultDocstring/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._api.ParameterAndResultDocstring.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any):\n        return ParameterAndResultDocstring(\n            json.get(\"type\", \"\"),\n            json.get(\"description\", \"\"),\n        )"
    },
    {
      "id": "package-parser/package_parser.model.api._api/ParameterAndResultDocstring/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.ParameterAndResultDocstring.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/ParameterAndResultDocstring/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.ParameterAndResultDocstring.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\"type\": self.type, \"description\": self.description}"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Result/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._api.Result.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Result/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._api.Result.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def from_json(json: Any) -> Result:\n        return Result(\n            json[\"name\"],\n            ParameterAndResultDocstring.from_json(json.get(\"docstring\", {})),\n        )"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Result/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.Result.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Result/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Result.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Any:\n        return {\"name\": self.name, \"docstring\": self.docstring.to_json()}"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Type/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._api.Type.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Type/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Type.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Type/__init__/typestring",
          "name": "typestring",
          "qname": "package_parser.model.api._api.Type.__init__.typestring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        typestring: ParameterAndResultDocstring,\n    ) -> None:\n        self.type: Optional[AbstractType] = Type.create_type(typestring)"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Type/create_type",
      "name": "create_type",
      "qname": "package_parser.model.api._api.Type.create_type",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Type/create_type/cls",
          "name": "cls",
          "qname": "package_parser.model.api._api.Type.create_type.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._api/Type/create_type/docstring",
          "name": "docstring",
          "qname": "package_parser.model.api._api.Type.create_type.docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def create_type(\n        cls, docstring: ParameterAndResultDocstring\n    ) -> Optional[AbstractType]:\n        type_string = docstring.type\n        types: list[AbstractType] = list()\n\n        # Collapse whitespaces\n        type_string = re.sub(r\"\\s+\", \" \", type_string)\n\n        # Get boundary from description\n        boundary = BoundaryType.from_string(docstring.description)\n        if boundary is not None:\n            types.append(boundary)\n\n        # Find all enums and remove them from doc_string\n        enum_array_matches = re.findall(r\"\\{.*?}\", type_string)\n        type_string = re.sub(r\"\\{.*?}\", \" \", type_string)\n        for enum in enum_array_matches:\n            enum_type = EnumType.from_string(enum)\n            if enum_type is not None:\n                types.append(enum_type)\n\n        # Remove default value from doc_string\n        type_string = re.sub(\"default=.*\", \" \", type_string)\n\n        # Create a list with all values and types\n        # \") or (\" must be replaced by a very unlikely string (\"&%&\") so that it is not removed when filtering out.\n        # The string will be replaced by \") or (\" again after filtering out.\n        type_string = re.sub(r\"\\) or \\(\", \"&%&\", type_string)\n        type_string = re.sub(r\" ?, ?or \", \", \", type_string)\n        type_string = re.sub(r\" or \", \", \", type_string)\n        type_string = re.sub(\"&%&\", \") or (\", type_string)\n\n        brackets = 0\n        build_string = \"\"\n        for c in type_string:\n            if c == \"(\":\n                brackets += 1\n            elif c == \")\":\n                brackets -= 1\n\n            if brackets > 0:\n                build_string += c\n                continue\n\n            if brackets == 0 and c != \",\":\n                build_string += c\n            elif brackets == 0 and c == \",\":\n                # remove leading and trailing whitespaces\n                build_string = build_string.strip()\n                if build_string != \"\":\n                    named = NamedType.from_string(build_string)\n                    types.append(named)\n                    build_string = \"\"\n\n        build_string = build_string.strip()\n\n        # Append the last remaining entry\n        if build_string != \"\":\n            named = NamedType.from_string(build_string)\n            types.append(named)\n\n        if len(types) == 1:\n            return types[0]\n        elif len(types) == 0:\n            return None\n        else:\n            return UnionType(types)"
    },
    {
      "id": "package-parser/package_parser.model.api._api/Type/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._api.Type.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._api/Type/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._api.Type.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, Any]:\n        if self.type is None:\n            return {}\n        else:\n            return self.type.to_json()"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/APIDependencies/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._parameter_dependencies.APIDependencies.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/APIDependencies/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.APIDependencies.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Dict:\n        return {\n            function_name: {\n                parameter_name: [dependency.to_json() for dependency in dependencies]\n                for parameter_name, dependencies in parameter_name.items()\n            }\n            for function_name, parameter_name in self.dependencies.items()\n        }"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/Action/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._parameter_dependencies.Action.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/Action/from_json/cls",
          "name": "cls",
          "qname": "package_parser.model.api._parameter_dependencies.Action.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/Action/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._parameter_dependencies.Action.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any):\n        return cls(json[\"action\"])"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/Action/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._parameter_dependencies.Action.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/Action/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.Action.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Dict:\n        return {\"action\": self.action}"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/Condition/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._parameter_dependencies.Condition.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/Condition/from_json/cls",
          "name": "cls",
          "qname": "package_parser.model.api._parameter_dependencies.Condition.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/Condition/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._parameter_dependencies.Condition.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any):\n        return cls(json[\"condition\"])"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/Condition/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._parameter_dependencies.Condition.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/Condition/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.Condition.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> Dict:\n        return {\"condition\": self.condition}"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/Dependency/from_json",
      "name": "from_json",
      "qname": "package_parser.model.api._parameter_dependencies.Dependency.from_json",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/Dependency/from_json/cls",
          "name": "cls",
          "qname": "package_parser.model.api._parameter_dependencies.Dependency.from_json.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/Dependency/from_json/json",
          "name": "json",
          "qname": "package_parser.model.api._parameter_dependencies.Dependency.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_json(cls, json: Any):\n        return cls(\n            Parameter.from_json(json[\"hasDependentParameter\"]),\n            Parameter.from_json(json[\"isDependingOn\"]),\n            Condition.from_json(json[\"hasCondition\"]),\n            Action.from_json(json[\"hasAction\"]),\n        )"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/Dependency/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._parameter_dependencies.Dependency.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/Dependency/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.Dependency.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict:\n        return {\n            \"hasDependentParameter\": self.hasDependentParameter.to_json(),\n            \"isDependingOn\": self.isDependingOn.to_json(),\n            \"hasCondition\": self.hasCondition.to_json(),\n            \"hasAction\": self.hasAction.to_json(),\n        }"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterHasValue/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._parameter_dependencies.ParameterHasValue.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterHasValue/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.ParameterHasValue.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterHasValue/__init__/condition",
          "name": "condition",
          "qname": "package_parser.model.api._parameter_dependencies.ParameterHasValue.__init__.condition",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, condition: str) -> None:\n        super().__init__(condition)"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIgnored/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._parameter_dependencies.ParameterIsIgnored.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIgnored/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.ParameterIsIgnored.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIgnored/__init__/action",
          "name": "action",
          "qname": "package_parser.model.api._parameter_dependencies.ParameterIsIgnored.__init__.action",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, action: str) -> None:\n        super().__init__(action)"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIllegal/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._parameter_dependencies.ParameterIsIllegal.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIllegal/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.ParameterIsIllegal.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsIllegal/__init__/action",
          "name": "action",
          "qname": "package_parser.model.api._parameter_dependencies.ParameterIsIllegal.__init__.action",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, action: str) -> None:\n        super().__init__(action)"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsNone/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._parameter_dependencies.ParameterIsNone.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsNone/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.ParameterIsNone.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/ParameterIsNone/__init__/condition",
          "name": "condition",
          "qname": "package_parser.model.api._parameter_dependencies.ParameterIsNone.__init__.condition",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, condition: str) -> None:\n        super().__init__(condition)"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/RuntimeAction/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._parameter_dependencies.RuntimeAction.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/RuntimeAction/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.RuntimeAction.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/RuntimeAction/__init__/action",
          "name": "action",
          "qname": "package_parser.model.api._parameter_dependencies.RuntimeAction.__init__.action",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, action: str) -> None:\n        super().__init__(action)"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/RuntimeCondition/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._parameter_dependencies.RuntimeCondition.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/RuntimeCondition/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.RuntimeCondition.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/RuntimeCondition/__init__/condition",
          "name": "condition",
          "qname": "package_parser.model.api._parameter_dependencies.RuntimeCondition.__init__.condition",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, condition: str) -> None:\n        super().__init__(condition)"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/StaticAction/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._parameter_dependencies.StaticAction.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/StaticAction/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.StaticAction.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/StaticAction/__init__/action",
          "name": "action",
          "qname": "package_parser.model.api._parameter_dependencies.StaticAction.__init__.action",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, action: str) -> None:\n        super().__init__(action)"
    },
    {
      "id": "package-parser/package_parser.model.api._parameter_dependencies/StaticCondition/__init__",
      "name": "__init__",
      "qname": "package_parser.model.api._parameter_dependencies.StaticCondition.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/StaticCondition/__init__/self",
          "name": "self",
          "qname": "package_parser.model.api._parameter_dependencies.StaticCondition.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._parameter_dependencies/StaticCondition/__init__/condition",
          "name": "condition",
          "qname": "package_parser.model.api._parameter_dependencies.StaticCondition.__init__.condition",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, condition: str) -> None:\n        super().__init__(condition)"
    },
    {
      "id": "package-parser/package_parser.model.api._types/AbstractType/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._types.AbstractType.to_json",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/AbstractType/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._types.AbstractType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def to_json(self):\n        pass"
    },
    {
      "id": "package-parser/package_parser.model.api._types/BoundaryType/__eq__",
      "name": "__eq__",
      "qname": "package_parser.model.api._types.BoundaryType.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/BoundaryType/__eq__/self",
          "name": "self",
          "qname": "package_parser.model.api._types.BoundaryType.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._types/BoundaryType/__eq__/__o",
          "name": "__o",
          "qname": "package_parser.model.api._types.BoundaryType.__eq__.__o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, __o: object) -> bool:\n        if isinstance(__o, BoundaryType):\n            eq = (\n                self.base_type == __o.base_type\n                and self.min == __o.min\n                and self.min_inclusive == __o.min_inclusive\n                and self.max == __o.max\n            )\n            if eq:\n                if self.max == BoundaryType.INFINITY:\n                    return True\n                else:\n                    return self.max_inclusive == __o.max_inclusive\n            else:\n                return False\n        else:\n            return False"
    },
    {
      "id": "package-parser/package_parser.model.api._types/BoundaryType/_is_inclusive",
      "name": "_is_inclusive",
      "qname": "package_parser.model.api._types.BoundaryType._is_inclusive",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/BoundaryType/_is_inclusive/cls",
          "name": "cls",
          "qname": "package_parser.model.api._types.BoundaryType._is_inclusive.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._types/BoundaryType/_is_inclusive/bracket",
          "name": "bracket",
          "qname": "package_parser.model.api._types.BoundaryType._is_inclusive.bracket",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def _is_inclusive(cls, bracket: str) -> bool:\n        if bracket == \"(\" or bracket == \")\":\n            return False\n        elif bracket == \"[\" or bracket == \"]\":\n            return True\n        else:\n            raise Exception(f\"{bracket} is not one of []()\")"
    },
    {
      "id": "package-parser/package_parser.model.api._types/BoundaryType/from_string",
      "name": "from_string",
      "qname": "package_parser.model.api._types.BoundaryType.from_string",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/BoundaryType/from_string/cls",
          "name": "cls",
          "qname": "package_parser.model.api._types.BoundaryType.from_string.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._types/BoundaryType/from_string/string",
          "name": "string",
          "qname": "package_parser.model.api._types.BoundaryType.from_string.string",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_string(cls, string: str) -> Optional[BoundaryType]:\n        pattern = r\"\"\"(?P<base_type>float|int)?[ ]  # optional base type of either float or int\n                    (in|of)[ ](the[ ])?(range|interval)[ ](of[ ])?  # 'in' or 'of', optional 'the', 'range' or 'interval', optional 'of'\n                    `?(?P<min_bracket>[\\[(])(?P<min>[-+]?\\d+(.\\d*)?|negative_infinity),[ ]  # left side of the range\n                    (?P<max>[-+]?\\d+(.\\d*)?|infinity)(?P<max_bracket>[\\])])`?\"\"\"  # right side of the range\n        match = re.search(pattern, string, re.VERBOSE)\n\n        if match is not None:\n            base_type = match.group(\"base_type\")\n            if base_type is None:\n                base_type = \"float\"\n            base_type = eval(base_type)\n\n            min_value = match.group(\"min\")\n            if min_value != \"negative_infinity\":\n                min_value = base_type(min_value)\n            else:\n                min_value = BoundaryType.NEGATIVE_INFINITY\n\n            max_value = match.group(\"max\")\n            if max_value != \"infinity\":\n                max_value = base_type(max_value)\n            else:\n                max_value = BoundaryType.INFINITY\n\n            min_bracket = match.group(\"min_bracket\")\n            max_bracket = match.group(\"max_bracket\")\n            min_inclusive = BoundaryType._is_inclusive(min_bracket)\n            max_inclusive = BoundaryType._is_inclusive(max_bracket)\n\n            return BoundaryType(\n                base_type.__name__, min_value, max_value, min_inclusive, max_inclusive\n            )\n\n        return None"
    },
    {
      "id": "package-parser/package_parser.model.api._types/BoundaryType/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._types.BoundaryType.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/BoundaryType/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._types.BoundaryType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, Any]:\n        return {\n            \"kind\": self.__class__.__name__,\n            \"base_type\": self.base_type,\n            \"min\": self.min,\n            \"max\": self.max,\n            \"min_inclusive\": self.min_inclusive,\n            \"max_inclusive\": self.max_inclusive,\n        }"
    },
    {
      "id": "package-parser/package_parser.model.api._types/EnumType/from_string",
      "name": "from_string",
      "qname": "package_parser.model.api._types.EnumType.from_string",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/EnumType/from_string/cls",
          "name": "cls",
          "qname": "package_parser.model.api._types.EnumType.from_string.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._types/EnumType/from_string/string",
          "name": "string",
          "qname": "package_parser.model.api._types.EnumType.from_string.string",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_string(cls, string: str) -> Optional[EnumType]:\n        def remove_backslash(e: str):\n            e = e.replace(r\"\\\"\", '\"')\n            e = e.replace(r\"\\'\", \"'\")\n            return e\n\n        enum_match = re.search(r\"{(.*?)}\", string)\n        if enum_match:\n            quotes = \"'\\\"\"\n            values = set()\n            enum_str = enum_match.group(1)\n            value = \"\"\n            inside_value = False\n            curr_quote = None\n            for i, char in enumerate(enum_str):\n                if char in quotes and (i == 0 or (i > 0 and enum_str[i - 1] != \"\\\\\")):\n                    if inside_value == False:\n                        inside_value = True\n                        curr_quote = char\n                    elif inside_value == True:\n                        if curr_quote == char:\n                            inside_value = False\n                            curr_quote = None\n                            values.add(remove_backslash(value))\n                            value = \"\"\n                        else:\n                            value += char\n                elif inside_value:\n                    value += char\n\n            return EnumType(values)\n\n        return None"
    },
    {
      "id": "package-parser/package_parser.model.api._types/EnumType/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._types.EnumType.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/EnumType/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._types.EnumType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, Any]:\n        return {\"kind\": self.__class__.__name__, \"values\": self.values}"
    },
    {
      "id": "package-parser/package_parser.model.api._types/EnumType/update",
      "name": "update",
      "qname": "package_parser.model.api._types.EnumType.update",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/EnumType/update/self",
          "name": "self",
          "qname": "package_parser.model.api._types.EnumType.update.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._types/EnumType/update/enum",
          "name": "enum",
          "qname": "package_parser.model.api._types.EnumType.update.enum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def update(self, enum: EnumType):\n        self.values.update(enum.values)"
    },
    {
      "id": "package-parser/package_parser.model.api._types/NamedType/from_string",
      "name": "from_string",
      "qname": "package_parser.model.api._types.NamedType.from_string",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/NamedType/from_string/cls",
          "name": "cls",
          "qname": "package_parser.model.api._types.NamedType.from_string.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.api._types/NamedType/from_string/string",
          "name": "string",
          "qname": "package_parser.model.api._types.NamedType.from_string.string",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def from_string(cls, string: str) -> NamedType:\n        return NamedType(string)"
    },
    {
      "id": "package-parser/package_parser.model.api._types/NamedType/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._types.NamedType.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/NamedType/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._types.NamedType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, str]:\n        return {\"kind\": self.__class__.__name__, \"name\": self.name}"
    },
    {
      "id": "package-parser/package_parser.model.api._types/UnionType/to_json",
      "name": "to_json",
      "qname": "package_parser.model.api._types.UnionType.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.api._types/UnionType/to_json/self",
          "name": "self",
          "qname": "package_parser.model.api._types.UnionType.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def to_json(self) -> dict[str, Any]:\n        type_list = []\n        for t in self.types:\n            type_list.append(t.to_json())\n\n        return {\"kind\": self.__class__.__name__, \"types\": type_list}"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__eq__",
      "name": "__eq__",
      "qname": "package_parser.model.usages._usages.UsageCountStore.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__eq__/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__eq__/other",
          "name": "other",
          "qname": "package_parser.model.usages._usages.UsageCountStore.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: object) -> bool:\n        if isinstance(other, UsageCountStore):\n            return (\n                self.class_usages == other.class_usages\n                and self.function_usages == other.function_usages\n                and self.parameter_usages == other.parameter_usages\n                and self.value_usages == other.value_usages\n            )\n\n        return False"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__hash__",
      "name": "__hash__",
      "qname": "package_parser.model.usages._usages.UsageCountStore.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__hash__/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(tuple(sorted(self.__dict__.items())))"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__init__",
      "name": "__init__",
      "qname": "package_parser.model.usages._usages.UsageCountStore.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/__init__/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Counts how often classes, functions, parameters, and parameter values are used.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self.class_usages: Counter[ClassId] = Counter()\n        self.function_usages: Counter[FunctionId] = Counter()\n        self.parameter_usages: Counter[ParameterId] = Counter()\n        self.value_usages: dict[ParameterId, Counter[StringifiedValue]] = {}"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages",
      "name": "add_class_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.add_class_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_class_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages/class_id",
          "name": "class_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_class_usages.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_class_usages/count",
          "name": "count",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_class_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the class with the given name by the given count.",
      "docstring": "Increases the usage count of the class with the given name by the given count.",
      "code": "    def add_class_usages(self, class_id: ClassId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the class with the given name by the given count.\"\"\"\n\n        self.class_usages[class_id] += count"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages",
      "name": "add_function_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.add_function_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_function_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages/function_id",
          "name": "function_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_function_usages.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_function_usages/count",
          "name": "count",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_function_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the function with the given name by the given count.",
      "docstring": "Increases the usage count of the function with the given name by the given count.",
      "code": "    def add_function_usages(self, function_id: FunctionId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the function with the given name by the given count.\"\"\"\n\n        self.function_usages[function_id] += count"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages",
      "name": "add_parameter_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.add_parameter_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_parameter_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_parameter_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_parameter_usages/count",
          "name": "count",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_parameter_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the parameter with the given name by the given count.",
      "docstring": "Increases the usage count of the parameter with the given name by the given count.",
      "code": "    def add_parameter_usages(self, parameter_id: ParameterId, count: int = 1) -> None:\n        \"\"\"Increases the usage count of the parameter with the given name by the given count.\"\"\"\n\n        self.parameter_usages[parameter_id] += count"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages",
      "name": "add_value_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages/value",
          "name": "value",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/add_value_usages/count",
          "name": "count",
          "qname": "package_parser.model.usages._usages.UsageCountStore.add_value_usages.count",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Increases the usage count of the given value for the parameter with the given name by the given count.",
      "docstring": "Increases the usage count of the given value for the parameter with the given name by the given count.",
      "code": "    def add_value_usages(\n        self, parameter_id: ParameterId, value: StringifiedValue, count: int = 1\n    ) -> None:\n        \"\"\"Increases the usage count of the given value for the parameter with the given name by the given count.\"\"\"\n\n        self.init_value(parameter_id)\n        self.value_usages[parameter_id][value] += count"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/from_json",
      "name": "from_json",
      "qname": "package_parser.model.usages._usages.UsageCountStore.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/from_json/json",
          "name": "json",
          "qname": "package_parser.model.usages._usages.UsageCountStore.from_json.json",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Creates an instance of this class from a dictionary.",
      "docstring": "Creates an instance of this class from a dictionary.",
      "code": "    @staticmethod\n    def from_json(json: Any) -> UsageCountStore:\n        \"\"\"Creates an instance of this class from a dictionary.\"\"\"\n\n        result = UsageCountStore()\n\n        # Revive class counts\n        class_counts = json[\"class_counts\"]\n        for class_id, count in class_counts.items():\n            result.add_class_usages(class_id, count)\n\n        # Revive function counts\n        function_counts = json[\"function_counts\"]\n        for function_id, count in function_counts.items():\n            result.add_function_usages(function_id, count)\n\n        # Revive parameter counts\n        parameter_counts = json[\"parameter_counts\"]\n        for parameter_id, count in parameter_counts.items():\n            result.add_parameter_usages(parameter_id, count)\n\n        # Revive value counts\n        value_counts = json[\"value_counts\"]\n        for parameter_id, values in value_counts.items():\n            for value, count in values.items():\n                result.add_value_usages(parameter_id, value, count)\n\n        return result"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/init_value",
      "name": "init_value",
      "qname": "package_parser.model.usages._usages.UsageCountStore.init_value",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/init_value/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.init_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/init_value/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.init_value.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Ensures the dictionary for the value counts has the given parameter name as a key.",
      "docstring": "Ensures the dictionary for the value counts has the given parameter name as a key.",
      "code": "    def init_value(self, parameter_id: ParameterId) -> None:\n        \"\"\"Ensures the dictionary for the value counts has the given parameter name as a key.\"\"\"\n\n        if parameter_id not in self.value_usages:\n            self.value_usages[parameter_id] = Counter()"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/merge_other_into_self",
      "name": "merge_other_into_self",
      "qname": "package_parser.model.usages._usages.UsageCountStore.merge_other_into_self",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/merge_other_into_self/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.merge_other_into_self.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/merge_other_into_self/other_usage_store",
          "name": "other_usage_store",
          "qname": "package_parser.model.usages._usages.UsageCountStore.merge_other_into_self.other_usage_store",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Merges the other usage store into this one **in-place** and returns this store.\n\n:param other_usage_store: The usage store to merge into this one.\n:return: This usage store.",
      "docstring": "Merges the other usage store into this one **in-place** and returns this store.\n\n:param other_usage_store: The usage store to merge into this one.\n:return: This usage store.",
      "code": "    def merge_other_into_self(\n        self, other_usage_store: UsageCountStore\n    ) -> UsageCountStore:\n        \"\"\"\n        Merges the other usage store into this one **in-place** and returns this store.\n\n        :param other_usage_store: The usage store to merge into this one.\n        :return: This usage store.\n        \"\"\"\n\n        # Merge class usages\n        self.class_usages += other_usage_store.class_usages\n\n        # Merge function usages\n        self.function_usages += other_usage_store.function_usages\n\n        # Merge parameter usages\n        self.parameter_usages += other_usage_store.parameter_usages\n\n        # Merge value usages\n        for parameter_id, value_usages in other_usage_store.value_usages.items():\n            self.init_value(parameter_id)\n            self.value_usages[parameter_id] += value_usages\n\n        return self"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/most_common_parameter_values",
      "name": "most_common_parameter_values",
      "qname": "package_parser.model.usages._usages.UsageCountStore.most_common_parameter_values",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/most_common_parameter_values/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.most_common_parameter_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/most_common_parameter_values/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.most_common_parameter_values.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns all values that have been set for the parameter with the given name sorted by their count in descending order.",
      "docstring": "Returns all values that have been set for the parameter with the given name sorted by their count in descending order.",
      "code": "    def most_common_parameter_values(self, parameter_id: ParameterId) -> list[str]:\n        \"\"\"Returns all values that have been set for the parameter with the given name sorted by their count in descending order.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return [\n                value\n                for value, count in self.value_usages[parameter_id].most_common()\n                if count > 0\n            ]\n\n        return []"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_class_usages",
      "name": "n_class_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.n_class_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_class_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_class_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_class_usages/class_id",
          "name": "class_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_class_usages.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the class is used, i.e. how often any of its methods are called.",
      "docstring": "Returns how often the class is used, i.e. how often any of its methods are called.",
      "code": "    def n_class_usages(self, class_id: ClassId) -> int:\n        \"\"\"Returns how often the class is used, i.e. how often any of its methods are called.\"\"\"\n\n        return self.class_usages[class_id]"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_function_usages",
      "name": "n_function_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.n_function_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_function_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_function_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_function_usages/function_id",
          "name": "function_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_function_usages.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the function is called.",
      "docstring": "Returns how often the function is called.",
      "code": "    def n_function_usages(self, function_id: FunctionId) -> int:\n        \"\"\"Returns how often the function is called.\"\"\"\n\n        return self.function_usages[function_id]"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_parameter_usages",
      "name": "n_parameter_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.n_parameter_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_parameter_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_parameter_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_parameter_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_parameter_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the parameter is set.",
      "docstring": "Returns how often the parameter is set.",
      "code": "    def n_parameter_usages(self, parameter_id: ParameterId) -> int:\n        \"\"\"Returns how often the parameter is set.\"\"\"\n\n        return self.parameter_usages[parameter_id]"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages",
      "name": "n_value_usages",
      "qname": "package_parser.model.usages._usages.UsageCountStore.n_value_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_value_usages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_value_usages.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/n_value_usages/value",
          "name": "value",
          "qname": "package_parser.model.usages._usages.UsageCountStore.n_value_usages.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns how often the parameter with the given name is set to the given value.",
      "docstring": "Returns how often the parameter with the given name is set to the given value.",
      "code": "    def n_value_usages(self, parameter_id: ParameterId, value: str) -> int:\n        \"\"\"Returns how often the parameter with the given name is set to the given value.\"\"\"\n\n        if parameter_id in self.value_usages:\n            return self.value_usages[parameter_id][value]\n\n        return 0"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_class",
      "name": "remove_class",
      "qname": "package_parser.model.usages._usages.UsageCountStore.remove_class",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_class/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_class/class_id",
          "name": "class_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_class.class_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Removes all usages of classes with the given name and usages of their methods.",
      "docstring": "Removes all usages of classes with the given name and usages of their methods.",
      "code": "    def remove_class(self, class_id: ClassId) -> None:\n        \"\"\"Removes all usages of classes with the given name and usages of their methods.\"\"\"\n\n        if class_id in self.class_usages:\n            del self.class_usages[class_id]\n\n        for function_id in list(self.function_usages.keys()):\n            if function_id.startswith(class_id):\n                self.remove_function(function_id)"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_function",
      "name": "remove_function",
      "qname": "package_parser.model.usages._usages.UsageCountStore.remove_function",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_function/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_function/function_id",
          "name": "function_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_function.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Removes all usages of functions with the given name and usages of their parameters.",
      "docstring": "Removes all usages of functions with the given name and usages of their parameters.",
      "code": "    def remove_function(self, function_id: FunctionId) -> None:\n        \"\"\"Removes all usages of functions with the given name and usages of their parameters.\"\"\"\n\n        if function_id in self.function_usages:\n            del self.function_usages[function_id]\n\n        for parameter_id in list(self.parameter_usages.keys()):\n            if parameter_id.startswith(function_id):\n                self.remove_parameter(parameter_id)"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_parameter",
      "name": "remove_parameter",
      "qname": "package_parser.model.usages._usages.UsageCountStore.remove_parameter",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_parameter/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_parameter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/remove_parameter/parameter_id",
          "name": "parameter_id",
          "qname": "package_parser.model.usages._usages.UsageCountStore.remove_parameter.parameter_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Removes all parameter and value usages of parameters with the given name.",
      "docstring": "Removes all parameter and value usages of parameters with the given name.",
      "code": "    def remove_parameter(self, parameter_id: ParameterId) -> None:\n        \"\"\"Removes all parameter and value usages of parameters with the given name.\"\"\"\n\n        if parameter_id in self.parameter_usages:\n            del self.parameter_usages[parameter_id]\n\n        if parameter_id in self.value_usages:\n            del self.value_usages[parameter_id]"
    },
    {
      "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/to_json",
      "name": "to_json",
      "qname": "package_parser.model.usages._usages.UsageCountStore.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.model.usages._usages/UsageCountStore/to_json/self",
          "name": "self",
          "qname": "package_parser.model.usages._usages.UsageCountStore.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Converts this class to a dictionary, which can later be serialized as JSON.",
      "docstring": "Converts this class to a dictionary, which can later be serialized as JSON.",
      "code": "    def to_json(self) -> Any:\n        \"\"\"Converts this class to a dictionary, which can later be serialized as JSON.\"\"\"\n\n        return {\n            \"class_counts\": {\n                class_id: usage_count\n                for class_id, usage_count in self.class_usages.most_common()\n            },\n            \"function_counts\": {\n                function_id: usage_count\n                for function_id, usage_count in self.function_usages.most_common()\n            },\n            \"parameter_counts\": {\n                parameter_id: usage_count\n                for parameter_id, usage_count in self.parameter_usages.most_common()\n            },\n            \"value_counts\": {\n                parameter_id: {\n                    value: usage_count for value, usage_count in values.most_common()\n                }\n                for parameter_id, values in self.value_usages.items()\n            },\n        }"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__description",
      "name": "__description",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__description",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__description/numpydoc",
          "name": "numpydoc",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__description.numpydoc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def __description(numpydoc: NumpyDocString) -> str:\n        has_summary = \"Summary\" in numpydoc and len(numpydoc[\"Summary\"]) > 0\n        has_extended_summary = (\n            \"Extended Summary\" in numpydoc and len(numpydoc[\"Extended Summary\"]) > 0\n        )\n\n        result = \"\"\n        if has_summary:\n            result += \"\\n\".join(numpydoc[\"Summary\"])\n        if has_summary and has_extended_summary:\n            result += \"\\n\\n\"\n        if has_extended_summary:\n            result += \"\\n\".join(numpydoc[\"Extended Summary\"])\n        return result"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__function_parameters",
      "name": "__function_parameters",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__function_parameters",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__function_parameters/node",
          "name": "node",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__function_parameters.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__function_parameters/function_is_public",
          "name": "function_is_public",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__function_parameters.function_is_public",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__function_parameters/function_qname",
          "name": "function_qname",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__function_parameters.function_qname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__function_parameters/function_id",
          "name": "function_id",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__function_parameters.function_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def __function_parameters(\n        node: astroid.FunctionDef,\n        function_is_public: bool,\n        function_qname: str,\n        function_id: str,\n    ) -> list[Parameter]:\n        parameters = node.args\n        n_implicit_parameters = node.implicit_parameters()\n\n        # For constructors (__init__ functions) the parameters are described on the class\n        if node.name == \"__init__\" and isinstance(node.parent, astroid.ClassDef):\n            docstring = node.parent.doc\n        else:\n            docstring = node.doc\n        function_numpydoc = NumpyDocString(inspect.cleandoc(docstring or \"\"))\n\n        # Arguments that can be specified positionally only ( f(1) works but not f(x=1) )\n        result = [\n            Parameter(\n                id_=function_id + \"/\" + it.name,\n                name=it.name,\n                qname=function_qname + \".\" + it.name,\n                default_value=None,\n                assigned_by=ParameterAssignment.POSITION_ONLY,\n                is_public=function_is_public,\n                docstring=_AstVisitor.__parameter_docstring(function_numpydoc, it.name),\n            )\n            for it in parameters.posonlyargs\n        ]\n\n        # Arguments that can be specified positionally or by name ( f(1) and f(x=1) both work )\n        result += [\n            Parameter(\n                function_id + \"/\" + it.name,\n                it.name,\n                function_qname + \".\" + it.name,\n                _AstVisitor.__parameter_default(\n                    parameters.defaults,\n                    index - len(parameters.args) + len(parameters.defaults),\n                ),\n                ParameterAssignment.POSITION_OR_NAME,\n                function_is_public,\n                _AstVisitor.__parameter_docstring(function_numpydoc, it.name),\n            )\n            for index, it in enumerate(parameters.args)\n        ]\n\n        # Arguments that can be specified by name only ( f(x=1) works but not f(1) )\n        result += [\n            Parameter(\n                function_id + \"/\" + it.name,\n                it.name,\n                function_qname + \".\" + it.name,\n                _AstVisitor.__parameter_default(\n                    parameters.kw_defaults,\n                    index - len(parameters.kwonlyargs) + len(parameters.kw_defaults),\n                ),\n                ParameterAssignment.NAME_ONLY,\n                function_is_public,\n                _AstVisitor.__parameter_docstring(function_numpydoc, it.name),\n            )\n            for index, it in enumerate(parameters.kwonlyargs)\n        ]\n\n        implicit_parameters = result[:n_implicit_parameters]\n        for implicit_parameter in implicit_parameters:\n            implicit_parameter.assigned_by = ParameterAssignment.IMPLICIT\n\n        return result"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id",
      "name": "__get_function_id",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_function_id",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_function_id.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id/name",
          "name": "name",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_function_id.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_function_id/decorators",
          "name": "decorators",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_function_id.decorators",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __get_function_id(self, name: str, decorators: list[str]) -> str:\n        def is_getter() -> bool:\n            return \"property\" in decorators\n\n        def is_setter() -> bool:\n            for decorator in decorators:\n                if re.search(r\"^[^.]*.setter$\", decorator):\n                    return True\n\n            return False\n\n        def is_deleter() -> bool:\n            for decorator in decorators:\n                if re.search(r\"^[^.]*.deleter$\", decorator):\n                    return True\n\n            return False\n\n        result = self.__get_id(name)\n\n        if is_getter():\n            result += \"@getter\"\n        elif is_setter():\n            result += \"@setter\"\n        elif is_deleter():\n            result += \"@deleter\"\n\n        return result"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_id",
      "name": "__get_id",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_id",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_id/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_id.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__get_id/name",
          "name": "name",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__get_id.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __get_id(self, name: str) -> str:\n        segments = [self.api.package]\n        segments += [it.name for it in self.__declaration_stack]\n        segments += [name]\n\n        return \"/\".join(segments)"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__init__/api",
          "name": "api",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__init__.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, api: API) -> None:\n        self.reexported: dict[str, list[str]] = {}\n        self.api: API = api\n        self.__declaration_stack: list[Union[Module, Class, Function]] = []"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__parameter_default",
      "name": "__parameter_default",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__parameter_default",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__parameter_default/defaults",
          "name": "defaults",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__parameter_default.defaults",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__parameter_default/default_index",
          "name": "default_index",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__parameter_default.default_index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def __parameter_default(\n        defaults: list[astroid.NodeNG], default_index: int\n    ) -> Optional[str]:\n        if 0 <= default_index < len(defaults):\n            default = defaults[default_index]\n            if default is None:\n                return None\n            return default.as_string()\n        else:\n            return None"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__parameter_docstring",
      "name": "__parameter_docstring",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__parameter_docstring",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__parameter_docstring/function_numpydoc",
          "name": "function_numpydoc",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__parameter_docstring.function_numpydoc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/__parameter_docstring/parameter_name",
          "name": "parameter_name",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.__parameter_docstring.parameter_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def __parameter_docstring(\n        function_numpydoc: NumpyDocString, parameter_name: str\n    ) -> ParameterAndResultDocstring:\n        parameters_numpydoc = function_numpydoc[\"Parameters\"]\n        candidate_parameters_numpydoc = [\n            it for it in parameters_numpydoc if it.name == parameter_name\n        ]\n\n        if len(candidate_parameters_numpydoc) > 0:\n            last_parameter_numpydoc = candidate_parameters_numpydoc[-1]\n            return ParameterAndResultDocstring(\n                last_parameter_numpydoc.type, \"\\n\".join(last_parameter_numpydoc.desc)\n            )\n\n        return ParameterAndResultDocstring(\"\", \"\")"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_classdef",
      "name": "enter_classdef",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_classdef",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_classdef/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_classdef.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_classdef/class_node",
          "name": "class_node",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_classdef.class_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_classdef(self, class_node: astroid.ClassDef) -> None:\n        qname = class_node.qname()\n\n        decorators: Optional[astroid.Decorators] = class_node.decorators\n        if decorators is not None:\n            decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n        else:\n            decorator_names = []\n\n        numpydoc = NumpyDocString(inspect.cleandoc(class_node.doc or \"\"))\n\n        # Remember class, so we can later add methods\n        class_ = Class(\n            self.__get_id(class_node.name),\n            qname,\n            decorator_names,\n            class_node.basenames,\n            self.is_public(class_node.name, qname),\n            self.reexported.get(qname, []),\n            _AstVisitor.__description(numpydoc),\n            class_node.doc,\n        )\n        self.__declaration_stack.append(class_)"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_functiondef",
      "name": "enter_functiondef",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_functiondef",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_functiondef/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_functiondef.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_functiondef/function_node",
          "name": "function_node",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_functiondef.function_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_functiondef(self, function_node: astroid.FunctionDef) -> None:\n        qname = function_node.qname()\n\n        decorators: Optional[astroid.Decorators] = function_node.decorators\n        if decorators is not None:\n            decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n        else:\n            decorator_names = []\n\n        numpydoc = NumpyDocString(inspect.cleandoc(function_node.doc or \"\"))\n        is_public = self.is_public(function_node.name, qname)\n\n        function = Function(\n            self.__get_function_id(function_node.name, decorator_names),\n            qname,\n            decorator_names,\n            self.__function_parameters(\n                function_node, is_public, qname, self.__get_id(function_node.name)\n            ),\n            [],  # TODO: results\n            is_public,\n            self.reexported.get(qname, []),\n            _AstVisitor.__description(numpydoc),\n            function_node.doc,\n        )\n        self.__declaration_stack.append(function)"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_module",
      "name": "enter_module",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_module",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_module/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_module.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/enter_module/module_node",
          "name": "module_node",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.enter_module.module_node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_module(self, module_node: astroid.Module):\n        imports: list[Import] = []\n        from_imports: list[FromImport] = []\n        visited_global_nodes: set[astroid.NodeNG] = set()\n        id_ = f\"{self.api.package}/{module_node.qname()}\"\n\n        for _, global_node_list in module_node.globals.items():\n            global_node = global_node_list[0]\n\n            # For some reason from-imports get visited as often as there are imported names, leading to duplicates\n            if global_node in visited_global_nodes:\n                continue\n            visited_global_nodes.add(global_node)\n\n            # import X as Y\n            if isinstance(global_node, astroid.Import):\n                for (name, alias) in global_node.names:\n                    imports.append(Import(name, alias))\n\n            # from X import a as b\n            if isinstance(global_node, astroid.ImportFrom):\n                base_import_path = module_node.relative_to_absolute_name(\n                    global_node.modname, global_node.level\n                )\n\n                for (name, alias) in global_node.names:\n                    from_imports.append(FromImport(base_import_path, name, alias))\n\n                # Find re-exported declarations in __init__.py files\n                if _is_init_file(module_node.file) and is_public_module(\n                    module_node.qname()\n                ):\n                    for declaration, _ in global_node.names:\n                        context = InferenceContext()\n                        context.lookupname = declaration\n                        node = safe_infer(global_node, context)\n\n                        if node is None:\n                            logging.warning(\n                                f\"Could not resolve 'from {global_node.modname} import {declaration}\"\n                            )\n                            continue\n\n                        reexported_name = node.qname()\n\n                        if reexported_name.startswith(module_node.name):\n                            if reexported_name not in self.reexported:\n                                self.reexported[reexported_name] = []\n                            self.reexported[reexported_name].append(id_)\n\n        # Remember module, so we can later add classes and global functions\n        module = Module(\n            id_,\n            module_node.qname(),\n            imports,\n            from_imports,\n        )\n        self.__declaration_stack.append(module)"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public",
      "name": "is_public",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.is_public",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.is_public.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public/name",
          "name": "name",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.is_public.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/is_public/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.is_public.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_public(self, name: str, qualified_name: str) -> bool:\n        if name.startswith(\"_\") and not name.endswith(\"__\"):\n            return False\n\n        if qualified_name in self.reexported:\n            return True\n\n        # Containing class is re-exported (always false if the current API element is not a method)\n        if (\n            isinstance(self.__declaration_stack[-1], Class)\n            and parent_qualified_name(qualified_name) in self.reexported\n        ):\n            return True\n\n        # The slicing is necessary so __init__ functions are not excluded (already handled in the first condition).\n        return all(not it.startswith(\"_\") for it in qualified_name.split(\".\")[:-1])"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_classdef",
      "name": "leave_classdef",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_classdef",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_classdef/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_classdef.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_classdef/_",
          "name": "_",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_classdef._",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_classdef(self, _: astroid.ClassDef) -> None:\n        class_ = self.__declaration_stack.pop()\n        if not isinstance(class_, Class):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        if len(self.__declaration_stack) > 0:\n            parent = self.__declaration_stack[-1]\n\n            # Ignore nested classes for now\n            if isinstance(parent, Module):\n                self.api.add_class(class_)\n                parent.add_class(class_.id)"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_functiondef",
      "name": "leave_functiondef",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_functiondef",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_functiondef/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_functiondef.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_functiondef/_",
          "name": "_",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_functiondef._",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_functiondef(self, _: astroid.FunctionDef) -> None:\n        function = self.__declaration_stack.pop()\n        if not isinstance(function, Function):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        if len(self.__declaration_stack) > 0:\n            parent = self.__declaration_stack[-1]\n\n            # Ignore nested functions for now\n            if isinstance(parent, Module):\n                self.api.add_function(function)\n                parent.add_function(function.id)\n            elif isinstance(parent, Class):\n                self.api.add_function(function)\n                parent.add_method(function.id)"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_module",
      "name": "leave_module",
      "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_module",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_module/self",
          "name": "self",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_module.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/_AstVisitor/leave_module/_",
          "name": "_",
          "qname": "package_parser.processing.api._ast_visitor._AstVisitor.leave_module._",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_module(self, _: astroid.Module) -> None:\n        module = self.__declaration_stack.pop()\n        if not isinstance(module, Module):\n            raise AssertionError(\"Imbalanced push/pop on stack\")\n\n        self.api.add_module(module)"
    },
    {
      "id": "package-parser/package_parser.processing.api._ast_visitor/is_public_module",
      "name": "is_public_module",
      "qname": "package_parser.processing.api._ast_visitor.is_public_module",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._ast_visitor/is_public_module/module_name",
          "name": "module_name",
          "qname": "package_parser.processing.api._ast_visitor.is_public_module.module_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def is_public_module(module_name: str) -> bool:\n    return all(not it.startswith(\"_\") for it in module_name.split(\".\"))"
    },
    {
      "id": "package-parser/package_parser.processing.api._file_filters/_is_init_file",
      "name": "_is_init_file",
      "qname": "package_parser.processing.api._file_filters._is_init_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._file_filters/_is_init_file/path",
          "name": "path",
          "qname": "package_parser.processing.api._file_filters._is_init_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _is_init_file(path: str) -> bool:\n    return path.endswith(\"__init__.py\")"
    },
    {
      "id": "package-parser/package_parser.processing.api._file_filters/_is_test_file",
      "name": "_is_test_file",
      "qname": "package_parser.processing.api._file_filters._is_test_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._file_filters/_is_test_file/posix_path",
          "name": "posix_path",
          "qname": "package_parser.processing.api._file_filters._is_test_file.posix_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _is_test_file(posix_path: str) -> bool:\n    return \"/test/\" in posix_path or \"/tests/\" in posix_path"
    },
    {
      "id": "package-parser/package_parser.processing.api._get_api/__module_name",
      "name": "__module_name",
      "qname": "package_parser.processing.api._get_api.__module_name",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._get_api/__module_name/root",
          "name": "root",
          "qname": "package_parser.processing.api._get_api.__module_name.root",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._get_api/__module_name/file",
          "name": "file",
          "qname": "package_parser.processing.api._get_api.__module_name.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __module_name(root: Path, file: Path) -> str:\n    relative_path = file.relative_to(root.parent).as_posix()\n    return str(relative_path).replace(\".py\", \"\").replace(\"/\", \".\")"
    },
    {
      "id": "package-parser/package_parser.processing.api._get_api/get_api",
      "name": "get_api",
      "qname": "package_parser.processing.api._get_api.get_api",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._get_api/get_api/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.api._get_api.get_api.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.api._get_api/get_api/root",
          "name": "root",
          "qname": "package_parser.processing.api._get_api.get_api.root",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_api(package_name: str, root: Optional[Path] = None) -> API:\n    if root is None:\n        root = package_root(package_name)\n    dist = distribution(package_name) or \"\"\n    dist_version = distribution_version(dist) or \"\"\n    files = package_files(root)\n\n    api = API(dist, package_name, dist_version)\n    callable_visitor = _AstVisitor(api)\n    walker = ASTWalker(callable_visitor)\n\n    for file in files:\n        posix_path = Path(file).as_posix()\n        logging.info(f\"Working on file {posix_path}\")\n\n        if _is_test_file(posix_path):\n            logging.info(\"Skipping test file\")\n            continue\n\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            source = f.read()\n            walker.walk(\n                astroid.parse(\n                    source, module_name=__module_name(root, Path(file)), path=file\n                )\n            )\n\n    return callable_visitor.api"
    },
    {
      "id": "package-parser/package_parser.processing.api._package_metadata/__move_init_files_to_front",
      "name": "__move_init_files_to_front",
      "qname": "package_parser.processing.api._package_metadata.__move_init_files_to_front",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._package_metadata/__move_init_files_to_front/files",
          "name": "files",
          "qname": "package_parser.processing.api._package_metadata.__move_init_files_to_front.files",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __move_init_files_to_front(files: list[str]) -> list[str]:\n    init_files = []\n    other_files = []\n\n    for file in files:\n        if _is_init_file(file):\n            init_files.append(file)\n        else:\n            other_files.append(file)\n\n    return init_files + other_files"
    },
    {
      "id": "package-parser/package_parser.processing.api._package_metadata/distribution",
      "name": "distribution",
      "qname": "package_parser.processing.api._package_metadata.distribution",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._package_metadata/distribution/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.api._package_metadata.distribution.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def distribution(package_name: str) -> Optional[str]:\n    dist = packages_distributions().get(package_name)\n    if dist is None or len(dist) == 0:\n        return None\n\n    return dist[0]"
    },
    {
      "id": "package-parser/package_parser.processing.api._package_metadata/distribution_version",
      "name": "distribution_version",
      "qname": "package_parser.processing.api._package_metadata.distribution_version",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._package_metadata/distribution_version/dist",
          "name": "dist",
          "qname": "package_parser.processing.api._package_metadata.distribution_version.dist",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def distribution_version(dist: Optional[str]) -> Optional[str]:\n    if dist is None:\n        return None\n\n    return version(dist)"
    },
    {
      "id": "package-parser/package_parser.processing.api._package_metadata/package_files",
      "name": "package_files",
      "qname": "package_parser.processing.api._package_metadata.package_files",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._package_metadata/package_files/root",
          "name": "root",
          "qname": "package_parser.processing.api._package_metadata.package_files.root",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def package_files(root: Path) -> list[str]:\n    files = list_files(root, \".py\")\n    return __move_init_files_to_front(files)"
    },
    {
      "id": "package-parser/package_parser.processing.api._package_metadata/package_root",
      "name": "package_root",
      "qname": "package_parser.processing.api._package_metadata.package_root",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.api._package_metadata/package_root/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.api._package_metadata.package_root.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def package_root(package_name: str) -> Path:\n    path_as_string = importlib.import_module(package_name).__file__\n    if path_as_string is None:\n        raise AssertionError(f\"Cannot find package root for '{path_as_string}'.\")\n    return Path(path_as_string).parent"
    },
    {
      "id": "package-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause",
      "name": "extract_pattern_parameter_adverbial_clause",
      "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause/dependent_param",
          "name": "dependent_param",
          "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause.dependent_param",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause/func_parameters",
          "name": "func_parameters",
          "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause.func_parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause/match",
          "name": "match",
          "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause.match",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/DependencyExtractor/extract_pattern_parameter_adverbial_clause/param_docstring",
          "name": "param_docstring",
          "qname": "package_parser.processing.dependencies._get_dependency.DependencyExtractor.extract_pattern_parameter_adverbial_clause.param_docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def extract_pattern_parameter_adverbial_clause(\n        dependent_param: Parameter,\n        func_parameters: List[Parameter],\n        match: Tuple,\n        param_docstring: Doc,\n    ) -> Union[Dependency, None]:\n        is_depending_on_param_index = match[1][2]\n        is_depending_on_param_name = param_docstring[is_depending_on_param_index].text\n        is_depending_on_param = next(\n            filter(\n                lambda param: param.name == is_depending_on_param_name, func_parameters\n            ),\n            None,\n        )\n        if is_depending_on_param is None:\n            # Likely not a correct dependency match\n            return None\n\n        condition_token = param_docstring[match[1][1]]\n        condition = extract_condition(condition_token)\n\n        action_token = param_docstring[match[1][0]]\n        action = extract_action(action_token, condition_token)\n\n        return Dependency(\n            hasDependentParameter=dependent_param,\n            isDependingOn=is_depending_on_param,\n            hasCondition=condition,\n            hasAction=action,\n        )"
    },
    {
      "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_action",
      "name": "extract_action",
      "qname": "package_parser.processing.dependencies._get_dependency.extract_action",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_action/action_token",
          "name": "action_token",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_action.action_token",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_action/condition_token",
          "name": "condition_token",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_action.condition_token",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create action object given head token of action phrase in docstring.\nCondition token used to avoid traversing into the condition phrase dependency subtree of the docstring.",
      "docstring": "Create action object given head token of action phrase in docstring.\nCondition token used to avoid traversing into the condition phrase dependency subtree of the docstring.",
      "code": "def extract_action(action_token: Token, condition_token: Token) -> Action:\n    \"\"\"\n    Create action object given head token of action phrase in docstring.\n    Condition token used to avoid traversing into the condition phrase dependency subtree of the docstring.\n    \"\"\"\n    action_tokens = []\n    action_lefts = list(action_token.lefts)\n    action_rights = list(action_token.rights)\n\n    for token in action_lefts:\n        if token != condition_token:\n            action_tokens.extend(extract_lefts_and_rights(token))\n    action_tokens.append(action_token.text)\n    for token in action_rights:\n        if token != condition_token:\n            action_tokens.extend(extract_lefts_and_rights(token))\n\n    # Remove trailing punctuation\n    if any(p == action_tokens[-1] for p in [\",\", \".\"]):\n        del action_tokens[-1]\n    action_text = \" \".join(action_tokens)\n\n    ignored_phrases = [\n        \"ignored\",\n        \"not used\",\n        \"no impact\",\n        \"only supported\",\n        \"only applies\",\n    ]\n    illegal_phrases = [\"raise\", \"exception\", \"must be\", \"must not be\"]\n    if any(phrase in action_text.lower() for phrase in ignored_phrases):\n        return ParameterIsIgnored(action=action_text)\n    elif any(phrase in action_text.lower() for phrase in illegal_phrases):\n        return ParameterIsIllegal(action=action_text)\n    else:\n        return Action(action=action_text)"
    },
    {
      "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_condition",
      "name": "extract_condition",
      "qname": "package_parser.processing.dependencies._get_dependency.extract_condition",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_condition/condition_token",
          "name": "condition_token",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_condition.condition_token",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create condition object given head token of condition phrase in docstring.",
      "docstring": "Create condition object given head token of condition phrase in docstring.",
      "code": "def extract_condition(condition_token: Token) -> Condition:\n    \"\"\"\n    Create condition object given head token of condition phrase in docstring.\n    \"\"\"\n    condition_token_subtree = list(condition_token.subtree)\n    condition_text = \" \".join([token.text for token in condition_token_subtree])\n\n    is_none_phrases = [\n        \"is none\",\n        \"is also none\" \"is not set\",\n        \"is not specified\",\n        \"is not none\",\n        \"if none\",\n        \"if not none\",\n    ]\n    has_value_phrases = [\n        \"equals\",\n        \"is true\",\n        \"is false\",\n        \"is set to\",\n        \"is greater than\",\n        \"is less than\",\n    ]\n    if any(phrase in condition_text.lower() for phrase in is_none_phrases):\n        return ParameterIsNone(condition=condition_text)\n    elif any(phrase in condition_text.lower() for phrase in has_value_phrases):\n        return ParameterHasValue(condition=condition_text)\n    else:\n        return Condition(condition=condition_text)"
    },
    {
      "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring",
      "name": "extract_dependencies_from_docstring",
      "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/parameter",
          "name": "parameter",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.parameter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/func_parameters",
          "name": "func_parameters",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.func_parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/param_docstring",
          "name": "param_docstring",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.param_docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/matches",
          "name": "matches",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.matches",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_dependencies_from_docstring/spacy_id_to_pattern_id_mapping",
          "name": "spacy_id_to_pattern_id_mapping",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_dependencies_from_docstring.spacy_id_to_pattern_id_mapping",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Extract readable dependencies in a Docstring from pattern matches.\nFunction fetched from class DependencyExtractor, when 'extract_' + pattern name match function name in the class.",
      "docstring": "Extract readable dependencies in a Docstring from pattern matches.\nFunction fetched from class DependencyExtractor, when 'extract_' + pattern name match function name in the class.",
      "code": "def extract_dependencies_from_docstring(\n    parameter: Parameter,\n    func_parameters: List[Parameter],\n    param_docstring: Span,\n    matches: List,\n    spacy_id_to_pattern_id_mapping: Dict,\n) -> List[Dependency]:\n    \"\"\"\n    Extract readable dependencies in a Docstring from pattern matches.\n    Function fetched from class DependencyExtractor, when 'extract_' + pattern name match function name in the class.\n    \"\"\"\n    dependencies = list()\n    for match in matches:\n        pattern_id = spacy_id_to_pattern_id_mapping[match[0]]\n        extract_dependency_method = getattr(\n            DependencyExtractor, f\"extract_{pattern_id}\"\n        )\n        dependency = extract_dependency_method(\n            parameter, func_parameters, match, param_docstring\n        )\n        if dependency is not None:\n            dependencies.append(dependency)\n    return dependencies"
    },
    {
      "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_lefts_and_rights",
      "name": "extract_lefts_and_rights",
      "qname": "package_parser.processing.dependencies._get_dependency.extract_lefts_and_rights",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_lefts_and_rights/curr_token",
          "name": "curr_token",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_lefts_and_rights.curr_token",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/extract_lefts_and_rights/extracted",
          "name": "extracted",
          "qname": "package_parser.processing.dependencies._get_dependency.extract_lefts_and_rights.extracted",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Given a spaCy token, extract recursively all tokens in its dependency subtree in inorder traversal.",
      "docstring": "Given a spaCy token, extract recursively all tokens in its dependency subtree in inorder traversal.",
      "code": "def extract_lefts_and_rights(curr_token: Token, extracted: Union[List, None] = None):\n    \"\"\"\n    Given a spaCy token, extract recursively all tokens in its dependency subtree in inorder traversal.\n    \"\"\"\n    if extracted is None:\n        extracted = []\n\n    token_lefts = list(curr_token.lefts)\n    for token in token_lefts:\n        extract_lefts_and_rights(token, extracted)\n\n    extracted.append(curr_token.text)\n\n    token_rights = list(curr_token.rights)\n    for token in token_rights:\n        extract_lefts_and_rights(token, extracted)\n\n    return extracted"
    },
    {
      "id": "package-parser/package_parser.processing.dependencies._get_dependency/get_dependencies",
      "name": "get_dependencies",
      "qname": "package_parser.processing.dependencies._get_dependency.get_dependencies",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.dependencies._get_dependency/get_dependencies/api",
          "name": "api",
          "qname": "package_parser.processing.dependencies._get_dependency.get_dependencies.api",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Loop through all functions in the API\nParse and preprocess each doc string from every function\nExtract and return all dependencies as a dict with function and parameter names as keys",
      "docstring": "Loop through all functions in the API\nParse and preprocess each doc string from every function\nExtract and return all dependencies as a dict with function and parameter names as keys",
      "code": "def get_dependencies(api: API) -> APIDependencies:\n    \"\"\"\n    Loop through all functions in the API\n    Parse and preprocess each doc string from every function\n    Extract and return all dependencies as a dict with function and parameter names as keys\n    \"\"\"\n    nlp = spacy.load(PIPELINE)\n\n    matcher = DependencyMatcher(nlp.vocab)\n    spacy_id_to_pattern_id_mapping: Dict = dict()\n    for pattern_id, pattern in dependency_matcher_patterns.items():\n        matcher.add(pattern_id, [pattern])\n        spacy_id_to_pattern_id_mapping[nlp.vocab.strings[pattern_id]] = pattern_id\n    all_dependencies: Dict = dict()\n    endpoint_functions = api.functions\n\n    for function_name, function in endpoint_functions.items():\n        parameters = function.parameters\n        all_dependencies[function_name] = {}\n        for parameter in parameters:\n            docstring = parameter.docstring.description\n            docstring_preprocessed = preprocess_docstring(docstring)\n            doc = nlp(docstring_preprocessed)\n            param_dependencies = []\n            for sentence in doc.sents:\n                sentence_dependency_matches = matcher(sentence)\n                sentence_dependencies = extract_dependencies_from_docstring(\n                    parameter,\n                    parameters,\n                    sentence,\n                    sentence_dependency_matches,\n                    spacy_id_to_pattern_id_mapping,\n                )\n                if sentence_dependencies:\n                    param_dependencies.extend(sentence_dependencies)\n            if param_dependencies:\n                all_dependencies[function_name][parameter.name] = param_dependencies\n\n    return APIDependencies(dependencies=all_dependencies)"
    },
    {
      "id": "package-parser/package_parser.processing.dependencies._preprocess_docstring/preprocess_docstring",
      "name": "preprocess_docstring",
      "qname": "package_parser.processing.dependencies._preprocess_docstring.preprocess_docstring",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.dependencies._preprocess_docstring/preprocess_docstring/docstring",
          "name": "docstring",
          "qname": "package_parser.processing.dependencies._preprocess_docstring.preprocess_docstring.docstring",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "1. Remove cluttered punctuation around parameter references\n2. Set '=', ==' to 'equals' and set '!=' to 'does not equal'\n3. Handle cases of step two where the signs are not separate tokens, e.g. \"a=b\".\nNote ordered dict since \"=\" is a substring of the other symbols.",
      "docstring": "1. Remove cluttered punctuation around parameter references\n2. Set '=', ==' to 'equals' and set '!=' to 'does not equal'\n3. Handle cases of step two where the signs are not separate tokens, e.g. \"a=b\".\nNote ordered dict since \"=\" is a substring of the other symbols.",
      "code": "def preprocess_docstring(docstring: str) -> str:\n    \"\"\"\n    1. Remove cluttered punctuation around parameter references\n    2. Set '=', ==' to 'equals' and set '!=' to 'does not equal'\n    3. Handle cases of step two where the signs are not separate tokens, e.g. \"a=b\".\n    Note ordered dict since \"=\" is a substring of the other symbols.\n    \"\"\"\n\n    docstring = re.sub(r'[\"\u201c\u201d`]', \"\", docstring)\n    docstring = re.sub(r\"'\", \"\", docstring)\n    docstring = re.sub(r\"!=\", \" does not equal \", docstring)\n    docstring = re.sub(r\"==?\", \" equals \", docstring)\n    docstring = re.sub(r\"\\s+\", \" \", docstring)\n\n    return docstring"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__",
      "name": "__init__",
      "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__/self",
          "name": "self",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/__init__/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.__init__.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, package_name: str) -> None:\n        self.package_name: str = package_name\n        self.usages: UsageCountStore = UsageCountStore()"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call",
      "name": "enter_call",
      "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.enter_call",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call/self",
          "name": "self",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.enter_call.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_UsageFinder/enter_call/node",
          "name": "node",
          "qname": "package_parser.processing.usages._ast_visitor._UsageFinder.enter_call.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_call(self, node: astroid.Call):\n        called_tuple = _analyze_declaration_called_by(node, self.package_name)\n        if called_tuple is None:\n            return\n        called, function_id, parameters, n_implicit_parameters = called_tuple\n\n        bound_parameters = _bound_parameters(\n            parameters, CallSite.from_call(node), n_implicit_parameters\n        )\n        if bound_parameters is None:\n            return\n\n        # Add class usage\n        if (\n            isinstance(called, (astroid.BoundMethod, astroid.UnboundMethod))\n            or isinstance(called, astroid.FunctionDef)\n            and called.is_method()\n        ):\n            self.usages.add_class_usages(parent_id(function_id))\n\n        # Add function usage\n        self.usages.add_function_usages(function_id)\n\n        # Add parameter & value usage\n        for parameter_name, value in bound_parameters.items():\n            parameter_id = f\"{function_id}/{parameter_name}\"\n            self.usages.add_parameter_usages(parameter_id)\n\n            value = _stringify_value(value)\n            self.usages.add_value_usages(parameter_id, value)"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/__called_constructor",
      "name": "__called_constructor",
      "qname": "package_parser.processing.usages._ast_visitor.__called_constructor",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/__called_constructor/class_def",
          "name": "class_def",
          "qname": "package_parser.processing.usages._ast_visitor.__called_constructor.class_def",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __called_constructor(class_def: astroid.ClassDef) -> Optional[astroid.FunctionDef]:\n    try:\n        # Use last __init__\n        constructor = class_def.local_attr(\"__init__\")[-1]\n    except astroid.NotFoundError:\n        return None\n\n    if isinstance(constructor, astroid.FunctionDef):\n        return constructor\n    else:\n        return None"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name",
      "name": "__is_relevant_qualified_name",
      "qname": "package_parser.processing.usages._ast_visitor.__is_relevant_qualified_name",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor.__is_relevant_qualified_name.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/__is_relevant_qualified_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.processing.usages._ast_visitor.__is_relevant_qualified_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __is_relevant_qualified_name(package_name: str, qualified_name: str) -> bool:\n    return qualified_name.startswith(package_name)"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/__n_implicit_parameters",
      "name": "__n_implicit_parameters",
      "qname": "package_parser.processing.usages._ast_visitor.__n_implicit_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/__n_implicit_parameters/called",
          "name": "called",
          "qname": "package_parser.processing.usages._ast_visitor.__n_implicit_parameters.called",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __n_implicit_parameters(called: astroid.NodeNG) -> int:\n    return called.implicit_parameters() if hasattr(called, \"implicit_parameters\") else 0"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by",
      "name": "_analyze_declaration_called_by",
      "qname": "package_parser.processing.usages._ast_visitor._analyze_declaration_called_by",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by/node",
          "name": "node",
          "qname": "package_parser.processing.usages._ast_visitor._analyze_declaration_called_by.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_analyze_declaration_called_by/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._analyze_declaration_called_by.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Returns None if the called declaration could not be determined or if it is not relevant for us. Otherwise, it\nreturns a tuple with the form (called, qualified_name, parameters, n_implicit_parameters).",
      "docstring": "Returns None if the called declaration could not be determined or if it is not relevant for us. Otherwise, it\nreturns a tuple with the form (called, qualified_name, parameters, n_implicit_parameters).",
      "code": "def _analyze_declaration_called_by(\n    node: astroid.Call, package_name: str\n) -> Optional[tuple[astroid.NodeNG, str, astroid.Arguments, int]]:\n    \"\"\"\n    Returns None if the called declaration could not be determined or if it is not relevant for us. Otherwise, it\n    returns a tuple with the form (called, qualified_name, parameters, n_implicit_parameters).\n    \"\"\"\n\n    called = safe_infer(node.func)\n    if called is None or not __is_relevant_qualified_name(package_name, called.qname()):\n        return None\n\n    n_implicit_parameters = __n_implicit_parameters(called)\n\n    if isinstance(called, astroid.ClassDef):\n        called = __called_constructor(called)\n        if called is None:\n            return None\n\n    if isinstance(\n        called, (astroid.BoundMethod, astroid.UnboundMethod, astroid.FunctionDef)\n    ):\n        return called, _id(package_name, called), called.args, n_implicit_parameters\n    else:\n        return None"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_bound_parameters",
      "name": "_bound_parameters",
      "qname": "package_parser.processing.usages._ast_visitor._bound_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_bound_parameters/parameters",
          "name": "parameters",
          "qname": "package_parser.processing.usages._ast_visitor._bound_parameters.parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_bound_parameters/arguments",
          "name": "arguments",
          "qname": "package_parser.processing.usages._ast_visitor._bound_parameters.arguments",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_bound_parameters/n_implicit_parameters",
          "name": "n_implicit_parameters",
          "qname": "package_parser.processing.usages._ast_visitor._bound_parameters.n_implicit_parameters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _bound_parameters(\n    parameters: astroid.Arguments, arguments: CallSite, n_implicit_parameters: int\n) -> Optional[dict[str, astroid.NodeNG]]:\n    # Improper call\n    if (\n        parameters.args is None\n        or arguments.has_invalid_arguments()\n        or arguments.has_invalid_keywords()\n    ):\n        return None\n\n    result: dict[str, astroid.NodeNG] = arguments.keyword_arguments.copy()\n\n    positional_parameter_names = [\n        it.name for it in (parameters.posonlyargs + parameters.args)\n    ][n_implicit_parameters:]\n\n    for index, arg in enumerate(arguments.positional_arguments):\n        if index >= len(positional_parameter_names):\n            break\n\n        result[positional_parameter_names[index]] = arg\n\n    return result"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_id",
      "name": "_id",
      "qname": "package_parser.processing.usages._ast_visitor._id",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_id/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._id.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_id/called",
          "name": "called",
          "qname": "package_parser.processing.usages._ast_visitor._id.called",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _id(\n    package_name: str, called: Union[astroid.UnboundMethod, astroid.FunctionDef]\n) -> str:\n    path = _path(package_name, called)\n\n    decorators: Optional[astroid.Decorators] = called.decorators\n    if decorators is not None:\n        decorator_names = [decorator.as_string() for decorator in decorators.nodes]\n    else:\n        decorator_names = []\n\n    def is_getter() -> bool:\n        return \"property\" in decorator_names\n\n    def is_setter() -> bool:\n        for decorator in decorator_names:\n            if re.search(r\"^[^.]*.setter$\", decorator):\n                return True\n\n        return False\n\n    def is_deleter() -> bool:\n        for decorator in decorator_names:\n            if re.search(r\"^[^.]*.deleter$\", decorator):\n                return True\n\n        return False\n\n    result = \"/\".join(path)\n\n    if is_getter():\n        result += \"@getter\"\n    elif is_setter():\n        result += \"@setter\"\n    elif is_deleter():\n        result += \"@deleter\"\n\n    return result"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_path",
      "name": "_path",
      "qname": "package_parser.processing.usages._ast_visitor._path",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_path/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._ast_visitor._path.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_path/current",
          "name": "current",
          "qname": "package_parser.processing.usages._ast_visitor._path.current",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _path(package_name: str, current: astroid.NodeNG) -> list[str]:\n    if current is None:\n        return []\n\n    if isinstance(current, astroid.Module):\n        return [package_name, current.name]\n    elif hasattr(current, \"name\"):\n        return _path(package_name, current.parent) + [current.name]\n    else:\n        return _path(package_name, current.parent)"
    },
    {
      "id": "package-parser/package_parser.processing.usages._ast_visitor/_stringify_value",
      "name": "_stringify_value",
      "qname": "package_parser.processing.usages._ast_visitor._stringify_value",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._ast_visitor/_stringify_value/value",
          "name": "value",
          "qname": "package_parser.processing.usages._ast_visitor._stringify_value.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _stringify_value(value: astroid.NodeNG):\n    return value.as_string()"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file",
      "name": "__is_relevant_python_file",
      "qname": "package_parser.processing.usages._find_usages.__is_relevant_python_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages.__is_relevant_python_file.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/__is_relevant_python_file/source_code",
          "name": "source_code",
          "qname": "package_parser.processing.usages._find_usages.__is_relevant_python_file.source_code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __is_relevant_python_file(package_name: str, source_code: str) -> bool:\n    return package_name in source_code"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch",
      "name": "_find_usages_in_batch",
      "qname": "package_parser.processing.usages._find_usages._find_usages_in_batch",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_batch.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_batch/python_files",
          "name": "python_files",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_batch.python_files",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _find_usages_in_batch(\n    package_name: str, python_files: list[str]\n) -> UsageCountStore:\n    ast_builder = AstroidBuilder()\n    usage_finder = _UsageFinder(package_name)\n    ast_walker = ASTWalker(usage_finder)\n\n    for python_file in python_files:\n        _find_usages_in_single_file(package_name, python_file, ast_builder, ast_walker)\n\n    return usage_finder.usages"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file",
      "name": "_find_usages_in_single_file",
      "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/python_file",
          "name": "python_file",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.python_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/ast_builder",
          "name": "ast_builder",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.ast_builder",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_find_usages_in_single_file/ast_walker",
          "name": "ast_walker",
          "qname": "package_parser.processing.usages._find_usages._find_usages_in_single_file.ast_walker",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _find_usages_in_single_file(\n    package_name: str,\n    python_file: str,\n    ast_builder: AstroidBuilder,\n    ast_walker: ASTWalker,\n) -> None:\n    logging.info(f\"Working on {python_file}\")\n\n    # noinspection PyBroadException\n    try:\n        with open(python_file, \"r\", encoding=\"UTF-8\") as f:\n            source = f.read()\n\n        if __is_relevant_python_file(package_name, source):\n            module = parse_python_code(source, ast_builder=ast_builder)\n            ast_walker.walk(module)\n        else:\n            logging.info(f\"Skipping {python_file} (irrelevant file)\")\n\n    except UnicodeError:\n        logging.warning(f\"Skipping {python_file} (broken encoding)\")\n    except astroid.exceptions.AstroidSyntaxError:\n        logging.warning(f\"Skipping {python_file} (invalid syntax)\")\n    except RecursionError:\n        logging.warning(f\"Skipping {python_file} (infinite recursion)\")\n    except Exception as e:\n        logging.error(f\"Skipping {python_file} (unknown error: {e})\")"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/_initializer",
      "name": "_initializer",
      "qname": "package_parser.processing.usages._find_usages._initializer",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_initializer/log_level",
          "name": "log_level",
          "qname": "package_parser.processing.usages._find_usages._initializer.log_level",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Ignore CTRL+C in the worker process.",
      "docstring": "Ignore CTRL+C in the worker process.",
      "code": "def _initializer(log_level: int) -> None:\n    \"\"\"\n    Ignore CTRL+C in the worker process.\n    \"\"\"\n\n    logging.basicConfig(level=log_level)\n    signal.signal(signal.SIGINT, signal.SIG_IGN)"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/_split_into_batches",
      "name": "_split_into_batches",
      "qname": "package_parser.processing.usages._find_usages._split_into_batches",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_split_into_batches/list_",
          "name": "list_",
          "qname": "package_parser.processing.usages._find_usages._split_into_batches.list_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/_split_into_batches/batch_size",
          "name": "batch_size",
          "qname": "package_parser.processing.usages._find_usages._split_into_batches.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Splits a list into batches of size batch_size.",
      "docstring": "Splits a list into batches of size batch_size.",
      "code": "def _split_into_batches(list_: list[T], batch_size: int) -> list[list[T]]:\n    \"\"\"\n    Splits a list into batches of size batch_size.\n    \"\"\"\n\n    batches = []\n    batch = []\n\n    for python_file in list_:\n        batch.append(python_file)\n        if len(batch) >= batch_size:\n            batches.append(batch)\n            batch = []\n\n    if len(batch) > 0:\n        batches.append(batch)\n\n    return batches"
    },
    {
      "id": "package-parser/package_parser.processing.usages._find_usages/find_usages",
      "name": "find_usages",
      "qname": "package_parser.processing.usages._find_usages.find_usages",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/find_usages/package_name",
          "name": "package_name",
          "qname": "package_parser.processing.usages._find_usages.find_usages.package_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/find_usages/src_dir",
          "name": "src_dir",
          "qname": "package_parser.processing.usages._find_usages.find_usages.src_dir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/find_usages/n_processes",
          "name": "n_processes",
          "qname": "package_parser.processing.usages._find_usages.find_usages.n_processes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.processing.usages._find_usages/find_usages/batch_size",
          "name": "batch_size",
          "qname": "package_parser.processing.usages._find_usages.find_usages.batch_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def find_usages(\n    package_name: str, src_dir: Path, n_processes: int, batch_size: int\n) -> UsageCountStore:\n    python_files = list_files(src_dir, \".py\")\n    python_file_batches = _split_into_batches(python_files, batch_size)\n\n    aggregated_counts = UsageCountStore()\n\n    for batch_index in range(0, len(python_file_batches), n_processes):\n        python_file_batches_slice = python_file_batches[\n            batch_index : batch_index + n_processes\n        ]\n        n_process_to_spawn = min(n_processes, len(python_file_batches_slice))\n\n        with Pool(\n            processes=n_process_to_spawn,\n            initializer=_initializer,\n            initargs=[logging.root.level],\n        ) as pool:\n            batch_counts = pool.starmap(\n                _find_usages_in_batch,\n                [[package_name, it] for it in python_file_batches_slice],\n            )\n\n            for batch_count in batch_counts:\n                aggregated_counts.merge_other_into_self(batch_count)\n\n    return aggregated_counts"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter",
      "name": "__enter",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__enter/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__enter.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[0]\n        if method is not None:\n            method(node)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks",
      "name": "__get_callbacks",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__get_callbacks/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__get_callbacks.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __get_callbacks(self, node: astroid.NodeNG) -> _EnterAndLeaveFunctions:\n        klass = node.__class__\n        methods = self._cache.get(klass)\n\n        if methods is None:\n            handler = self._handler\n            class_name = klass.__name__.lower()\n            enter_method = getattr(\n                handler, f\"enter_{class_name}\", getattr(handler, \"enter_default\", None)\n            )\n            leave_method = getattr(\n                handler, f\"leave_{class_name}\", getattr(handler, \"leave_default\", None)\n            )\n            self._cache[klass] = (enter_method, leave_method)\n        else:\n            enter_method, leave_method = methods\n\n        return enter_method, leave_method"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__",
      "name": "__init__",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__init__/handler",
          "name": "handler",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__init__.handler",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A walker visiting a tree in preorder, calling on the handler:\n\n* enter_<class_name> on entering a node, where class name is the class of\nthe node in lower case.\n\n* leave_<class_name> on leaving a node, where class name is the class of\nthe node in lower case.",
      "docstring": "",
      "code": "    def __init__(self, handler: Any) -> None:\n        self._handler = handler\n        self._cache: dict[Type, _EnterAndLeaveFunctions] = {}"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave",
      "name": "__leave",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__leave/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__leave.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __leave(self, node: astroid.NodeNG) -> None:\n        method = self.__get_callbacks(node)[1]\n        if method is not None:\n            method(node)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk",
      "name": "__walk",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/__walk/visited_nodes",
          "name": "visited_nodes",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.__walk.visited_nodes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __walk(self, node: astroid.NodeNG, visited_nodes: set[astroid.NodeNG]) -> None:\n        if node in visited_nodes:\n            raise AssertionError(\"Node visited twice\")\n        visited_nodes.add(node)\n\n        self.__enter(node)\n        for child_node in node.get_children():\n            self.__walk(child_node, visited_nodes)\n        self.__leave(node)"
    },
    {
      "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk",
      "name": "walk",
      "qname": "package_parser.utils._ASTWalker.ASTWalker.walk",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk/self",
          "name": "self",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.walk.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._ASTWalker/ASTWalker/walk/node",
          "name": "node",
          "qname": "package_parser.utils._ASTWalker.ASTWalker.walk.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def walk(self, node: astroid.NodeNG) -> None:\n        self.__walk(node, set())"
    },
    {
      "id": "package-parser/package_parser.utils._files/__read_lines",
      "name": "__read_lines",
      "qname": "package_parser.utils._files.__read_lines",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/__read_lines/f",
          "name": "f",
          "qname": "package_parser.utils._files.__read_lines.f",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __read_lines(f: TextIO) -> list[str]:\n    return [it.strip() for it in f.readlines() if it != \"\"]"
    },
    {
      "id": "package-parser/package_parser.utils._files/__write_lines",
      "name": "__write_lines",
      "qname": "package_parser.utils._files.__write_lines",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/__write_lines/f",
          "name": "f",
          "qname": "package_parser.utils._files.__write_lines.f",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._files/__write_lines/lines",
          "name": "lines",
          "qname": "package_parser.utils._files.__write_lines.lines",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __write_lines(f: TextIO, lines: list[str]) -> None:\n    f.writelines(f\"{it}\\n\" for it in lines)"
    },
    {
      "id": "package-parser/package_parser.utils._files/ensure_file_exists",
      "name": "ensure_file_exists",
      "qname": "package_parser.utils._files.ensure_file_exists",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/ensure_file_exists/file",
          "name": "file",
          "qname": "package_parser.utils._files.ensure_file_exists.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Creates a file and all parent directories if they don't exist already.\n\n:param file: The file path.",
      "docstring": "Creates a file and all parent directories if they don't exist already.\n\n:param file: The file path.",
      "code": "def ensure_file_exists(file: Path) -> None:\n    \"\"\"\n    Creates a file and all parent directories if they don't exist already.\n\n    :param file: The file path.\n    \"\"\"\n\n    file.parent.mkdir(parents=True, exist_ok=True)\n    file.touch(exist_ok=True)"
    },
    {
      "id": "package-parser/package_parser.utils._files/initialize_and_read_exclude_file",
      "name": "initialize_and_read_exclude_file",
      "qname": "package_parser.utils._files.initialize_and_read_exclude_file",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/initialize_and_read_exclude_file/exclude_file",
          "name": "exclude_file",
          "qname": "package_parser.utils._files.initialize_and_read_exclude_file.exclude_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def initialize_and_read_exclude_file(exclude_file: Path) -> list[str]:\n    exclude_file.parent.mkdir(parents=True, exist_ok=True)\n    try:\n        with exclude_file.open(\"r\") as f:\n            return __read_lines(f)\n    except FileNotFoundError:\n        return []"
    },
    {
      "id": "package-parser/package_parser.utils._files/list_files",
      "name": "list_files",
      "qname": "package_parser.utils._files.list_files",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._files/list_files/root_dir",
          "name": "root_dir",
          "qname": "package_parser.utils._files.list_files.root_dir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._files/list_files/extension",
          "name": "extension",
          "qname": "package_parser.utils._files.list_files.extension",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": ":param root_dir: The directory containing the files.\n:param extension: The extension the files should have.\n:return: A list with absolute paths to the files.",
      "docstring": ":param root_dir: The directory containing the files.\n:param extension: The extension the files should have.\n:return: A list with absolute paths to the files.",
      "code": "def list_files(root_dir: Path, extension: str = \"\") -> list[str]:\n    \"\"\"\n    :param root_dir: The directory containing the files.\n    :param extension: The extension the files should have.\n    :return: A list with absolute paths to the files.\n    \"\"\"\n\n    result: list[str] = []\n\n    for root, _, files in os.walk(root_dir):\n        for filename in files:\n            if filename.endswith(extension):\n                result.append(str(os.path.join(root, filename)))\n\n    return result"
    },
    {
      "id": "package-parser/package_parser.utils._names/declaration_qname_to_name",
      "name": "declaration_qname_to_name",
      "qname": "package_parser.utils._names.declaration_qname_to_name",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._names/declaration_qname_to_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.utils._names.declaration_qname_to_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def declaration_qname_to_name(qualified_name: str) -> str:\n    return qualified_name.split(\".\")[-1]"
    },
    {
      "id": "package-parser/package_parser.utils._names/parent_id",
      "name": "parent_id",
      "qname": "package_parser.utils._names.parent_id",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._names/parent_id/id_",
          "name": "id_",
          "qname": "package_parser.utils._names.parent_id.id_",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def parent_id(id_: str) -> str:\n    return \"/\".join(id_.split(\"/\")[:-1])"
    },
    {
      "id": "package-parser/package_parser.utils._names/parent_qualified_name",
      "name": "parent_qualified_name",
      "qname": "package_parser.utils._names.parent_qualified_name",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._names/parent_qualified_name/qualified_name",
          "name": "qualified_name",
          "qname": "package_parser.utils._names.parent_qualified_name.qualified_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def parent_qualified_name(qualified_name: str) -> str:\n    return \".\".join(qualified_name.split(\".\")[:-1])"
    },
    {
      "id": "package-parser/package_parser.utils._parsing/parse_python_code",
      "name": "parse_python_code",
      "qname": "package_parser.utils._parsing.parse_python_code",
      "decorators": [],
      "parameters": [
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/code",
          "name": "code",
          "qname": "package_parser.utils._parsing.parse_python_code.code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/module_name",
          "name": "module_name",
          "qname": "package_parser.utils._parsing.parse_python_code.module_name",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/path",
          "name": "path",
          "qname": "package_parser.utils._parsing.parse_python_code.path",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "package-parser/package_parser.utils._parsing/parse_python_code/ast_builder",
          "name": "ast_builder",
          "qname": "package_parser.utils._parsing.parse_python_code.ast_builder",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Parses a source string in order to obtain an astroid AST from it\n\n:param str code: The code for the module.\n:param str module_name: The name for the module, if any\n:param str path: The path for the module\n:param ast_builder: The Astroid builder to use",
      "docstring": "Parses a source string in order to obtain an astroid AST from it\n\n:param str code: The code for the module.\n:param str module_name: The name for the module, if any\n:param str path: The path for the module\n:param ast_builder: The Astroid builder to use",
      "code": "def parse_python_code(\n    code: str,\n    module_name: str = \"\",\n    path: str = None,\n    ast_builder: AstroidBuilder = None,\n) -> astroid.Module:\n    \"\"\"Parses a source string in order to obtain an astroid AST from it\n\n    :param str code: The code for the module.\n    :param str module_name: The name for the module, if any\n    :param str path: The path for the module\n    :param ast_builder: The Astroid builder to use\n    \"\"\"\n\n    if ast_builder is None:\n        ast_builder = AstroidBuilder()\n\n    code = textwrap.dedent(code)\n    return ast_builder.string_build(code, modname=module_name, path=path)"
    }
  ]
}