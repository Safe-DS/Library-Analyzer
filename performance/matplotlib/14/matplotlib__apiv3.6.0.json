{
  "schemaVersion": 1,
  "distribution": "",
  "package": "matplotlib",
  "version": "",
  "modules": [],
  "classes": [
    {
      "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter",
      "name": "AbstractMovieWriter",
      "qname": "lib.matplotlib.animation.AbstractMovieWriter",
      "decorators": [],
      "superclasses": [
        "abc.ABC"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/__init__",
        "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/setup",
        "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/frame_size@getter",
        "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/grab_frame",
        "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/finish",
        "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/saving"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for writing movies, providing a way to grab frames by\ncalling `~AbstractMovieWriter.grab_frame`.\n\n`setup` is called to start the process and `finish` is called afterwards.\n`saving` is provided as a context manager to facilitate this process as ::\n\n    with moviewriter.saving(fig, outfile='myfile.mp4', dpi=100):\n        # Iterate over frames\n        moviewriter.grab_frame(**savefig_kwargs)\n\nThe use of the context manager ensures that `setup` and `finish` are\nperformed as necessary.\n\nAn instance of a concrete subclass of this class can be given as the\n``writer`` argument of `Animation.save()`.",
      "docstring": "Abstract base class for writing movies, providing a way to grab frames by\ncalling `~AbstractMovieWriter.grab_frame`.\n\n`setup` is called to start the process and `finish` is called afterwards.\n`saving` is provided as a context manager to facilitate this process as ::\n\n    with moviewriter.saving(fig, outfile='myfile.mp4', dpi=100):\n        # Iterate over frames\n        moviewriter.grab_frame(**savefig_kwargs)\n\nThe use of the context manager ensures that `setup` and `finish` are\nperformed as necessary.\n\nAn instance of a concrete subclass of this class can be given as the\n``writer`` argument of `Animation.save()`.",
      "code": "class AbstractMovieWriter(abc.ABC):\n    \"\"\"\n    Abstract base class for writing movies, providing a way to grab frames by\n    calling `~AbstractMovieWriter.grab_frame`.\n\n    `setup` is called to start the process and `finish` is called afterwards.\n    `saving` is provided as a context manager to facilitate this process as ::\n\n        with moviewriter.saving(fig, outfile='myfile.mp4', dpi=100):\n            # Iterate over frames\n            moviewriter.grab_frame(**savefig_kwargs)\n\n    The use of the context manager ensures that `setup` and `finish` are\n    performed as necessary.\n\n    An instance of a concrete subclass of this class can be given as the\n    ``writer`` argument of `Animation.save()`.\n    \"\"\"\n\n    def __init__(self, fps=5, metadata=None, codec=None, bitrate=None):\n        self.fps = fps\n        self.metadata = metadata if metadata is not None else {}\n        self.codec = (\n            mpl.rcParams['animation.codec'] if codec is None else codec)\n        self.bitrate = (\n            mpl.rcParams['animation.bitrate'] if bitrate is None else bitrate)\n\n    @abc.abstractmethod\n    def setup(self, fig, outfile, dpi=None):\n        \"\"\"\n        Setup for writing the movie file.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The figure object that contains the information for frames.\n        outfile : str\n            The filename of the resulting movie file.\n        dpi : float, default: ``fig.dpi``\n            The DPI (or resolution) for the file.  This controls the size\n            in pixels of the resulting movie file.\n        \"\"\"\n        self.outfile = outfile\n        self.fig = fig\n        if dpi is None:\n            dpi = self.fig.dpi\n        self.dpi = dpi\n\n    @property\n    def frame_size(self):\n        \"\"\"A tuple ``(width, height)`` in pixels of a movie frame.\"\"\"\n        w, h = self.fig.get_size_inches()\n        return int(w * self.dpi), int(h * self.dpi)\n\n    @abc.abstractmethod\n    def grab_frame(self, **savefig_kwargs):\n        \"\"\"\n        Grab the image information from the figure and save as a movie frame.\n\n        All keyword arguments in *savefig_kwargs* are passed on to the\n        `~.Figure.savefig` call that saves the figure.\n        \"\"\"\n\n    @abc.abstractmethod\n    def finish(self):\n        \"\"\"Finish any processing for writing the movie.\"\"\"\n\n    @contextlib.contextmanager\n    def saving(self, fig, outfile, dpi, *args, **kwargs):\n        \"\"\"\n        Context manager to facilitate writing the movie file.\n\n        ``*args, **kw`` are any parameters that should be passed to `setup`.\n        \"\"\"\n        # This particular sequence is what contextlib.contextmanager wants\n        self.setup(fig, outfile, dpi, *args, **kwargs)\n        try:\n            yield self\n        finally:\n            self.finish()",
      "instance_attributes": [
        {
          "name": "fps",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "metadata",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "codec",
          "types": null
        },
        {
          "name": "bitrate",
          "types": null
        },
        {
          "name": "outfile",
          "types": null
        },
        {
          "name": "fig",
          "types": null
        },
        {
          "name": "dpi",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation",
      "name": "Animation",
      "qname": "lib.matplotlib.animation.Animation",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.animation/Animation/__init__",
        "matplotlib/lib.matplotlib.animation/Animation/__del__",
        "matplotlib/lib.matplotlib.animation/Animation/_start",
        "matplotlib/lib.matplotlib.animation/Animation/_stop",
        "matplotlib/lib.matplotlib.animation/Animation/save",
        "matplotlib/lib.matplotlib.animation/Animation/_step",
        "matplotlib/lib.matplotlib.animation/Animation/new_frame_seq",
        "matplotlib/lib.matplotlib.animation/Animation/new_saved_frame_seq",
        "matplotlib/lib.matplotlib.animation/Animation/_draw_next_frame",
        "matplotlib/lib.matplotlib.animation/Animation/_init_draw",
        "matplotlib/lib.matplotlib.animation/Animation/_pre_draw",
        "matplotlib/lib.matplotlib.animation/Animation/_draw_frame",
        "matplotlib/lib.matplotlib.animation/Animation/_post_draw",
        "matplotlib/lib.matplotlib.animation/Animation/_blit_draw",
        "matplotlib/lib.matplotlib.animation/Animation/_blit_clear",
        "matplotlib/lib.matplotlib.animation/Animation/_setup_blit",
        "matplotlib/lib.matplotlib.animation/Animation/_on_resize",
        "matplotlib/lib.matplotlib.animation/Animation/_end_redraw",
        "matplotlib/lib.matplotlib.animation/Animation/to_html5_video",
        "matplotlib/lib.matplotlib.animation/Animation/to_jshtml",
        "matplotlib/lib.matplotlib.animation/Animation/_repr_html_",
        "matplotlib/lib.matplotlib.animation/Animation/pause",
        "matplotlib/lib.matplotlib.animation/Animation/resume"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A base class for Animations.\n\nThis class is not usable as is, and should be subclassed to provide needed\nbehavior.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.",
      "docstring": "A base class for Animations.\n\nThis class is not usable as is, and should be subclassed to provide needed\nbehavior.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.\n\nParameters\n----------\nfig : `~matplotlib.figure.Figure`\n    The figure object used to get needed events, such as draw or resize.\n\nevent_source : object, optional\n    A class that can run a callback when desired events\n    are generated, as well as be stopped and started.\n\n    Examples include timers (see `TimedAnimation`) and file\n    system notifications.\n\nblit : bool, default: False\n    Whether blitting is used to optimize drawing.\n\nSee Also\n--------\nFuncAnimation,  ArtistAnimation",
      "code": "class Animation:\n    \"\"\"\n    A base class for Animations.\n\n    This class is not usable as is, and should be subclassed to provide needed\n    behavior.\n\n    .. note::\n\n        You must store the created Animation in a variable that lives as long\n        as the animation should run. Otherwise, the Animation object will be\n        garbage-collected and the animation stops.\n\n    Parameters\n    ----------\n    fig : `~matplotlib.figure.Figure`\n        The figure object used to get needed events, such as draw or resize.\n\n    event_source : object, optional\n        A class that can run a callback when desired events\n        are generated, as well as be stopped and started.\n\n        Examples include timers (see `TimedAnimation`) and file\n        system notifications.\n\n    blit : bool, default: False\n        Whether blitting is used to optimize drawing.\n\n    See Also\n    --------\n    FuncAnimation,  ArtistAnimation\n    \"\"\"\n\n    def __init__(self, fig, event_source=None, blit=False):\n        self._draw_was_started = False\n\n        self._fig = fig\n        # Disables blitting for backends that don't support it.  This\n        # allows users to request it if available, but still have a\n        # fallback that works if it is not.\n        self._blit = blit and fig.canvas.supports_blit\n\n        # These are the basics of the animation.  The frame sequence represents\n        # information for each frame of the animation and depends on how the\n        # drawing is handled by the subclasses. The event source fires events\n        # that cause the frame sequence to be iterated.\n        self.frame_seq = self.new_frame_seq()\n        self.event_source = event_source\n\n        # Instead of starting the event source now, we connect to the figure's\n        # draw_event, so that we only start once the figure has been drawn.\n        self._first_draw_id = fig.canvas.mpl_connect('draw_event', self._start)\n\n        # Connect to the figure's close_event so that we don't continue to\n        # fire events and try to draw to a deleted figure.\n        self._close_id = self._fig.canvas.mpl_connect('close_event',\n                                                      self._stop)\n        if self._blit:\n            self._setup_blit()\n\n    def __del__(self):\n        if not getattr(self, '_draw_was_started', True):\n            warnings.warn(\n                'Animation was deleted without rendering anything. This is '\n                'most likely not intended. To prevent deletion, assign the '\n                'Animation to a variable, e.g. `anim`, that exists until you '\n                'output the Animation using `plt.show()` or '\n                '`anim.save()`.'\n            )\n\n    def _start(self, *args):\n        \"\"\"\n        Starts interactive animation. Adds the draw frame command to the GUI\n        handler, calls show to start the event loop.\n        \"\"\"\n        # Do not start the event source if saving() it.\n        if self._fig.canvas.is_saving():\n            return\n        # First disconnect our draw event handler\n        self._fig.canvas.mpl_disconnect(self._first_draw_id)\n\n        # Now do any initial draw\n        self._init_draw()\n\n        # Add our callback for stepping the animation and\n        # actually start the event_source.\n        self.event_source.add_callback(self._step)\n        self.event_source.start()\n\n    def _stop(self, *args):\n        # On stop we disconnect all of our events.\n        if self._blit:\n            self._fig.canvas.mpl_disconnect(self._resize_id)\n        self._fig.canvas.mpl_disconnect(self._close_id)\n        self.event_source.remove_callback(self._step)\n        self.event_source = None\n\n    def save(self, filename, writer=None, fps=None, dpi=None, codec=None,\n             bitrate=None, extra_args=None, metadata=None, extra_anim=None,\n             savefig_kwargs=None, *, progress_callback=None):\n        \"\"\"\n        Save the animation as a movie file by drawing every frame.\n\n        Parameters\n        ----------\n        filename : str\n            The output filename, e.g., :file:`mymovie.mp4`.\n\n        writer : `MovieWriter` or str, default: :rc:`animation.writer`\n            A `MovieWriter` instance to use or a key that identifies a\n            class to use, such as 'ffmpeg'.\n\n        fps : int, optional\n            Movie frame rate (per second).  If not set, the frame rate from the\n            animation's frame interval.\n\n        dpi : float, default: :rc:`savefig.dpi`\n            Controls the dots per inch for the movie frames.  Together with\n            the figure's size in inches, this controls the size of the movie.\n\n        codec : str, default: :rc:`animation.codec`.\n            The video codec to use.  Not all codecs are supported by a given\n            `MovieWriter`.\n\n        bitrate : int, default: :rc:`animation.bitrate`\n            The bitrate of the movie, in kilobits per second.  Higher values\n            means higher quality movies, but increase the file size.  A value\n            of -1 lets the underlying movie encoder select the bitrate.\n\n        extra_args : list of str or None, optional\n            Extra command-line arguments passed to the underlying movie\n            encoder.  The default, None, means to use\n            :rc:`animation.[name-of-encoder]_args` for the builtin writers.\n\n        metadata : dict[str, str], default: {}\n            Dictionary of keys and values for metadata to include in\n            the output file. Some keys that may be of use include:\n            title, artist, genre, subject, copyright, srcform, comment.\n\n        extra_anim : list, default: []\n            Additional `Animation` objects that should be included\n            in the saved movie file. These need to be from the same\n            `matplotlib.figure.Figure` instance. Also, animation frames will\n            just be simply combined, so there should be a 1:1 correspondence\n            between the frames from the different animations.\n\n        savefig_kwargs : dict, default: {}\n            Keyword arguments passed to each `~.Figure.savefig` call used to\n            save the individual frames.\n\n        progress_callback : function, optional\n            A callback function that will be called for every frame to notify\n            the saving progress. It must have the signature ::\n\n                def func(current_frame: int, total_frames: int) -> Any\n\n            where *current_frame* is the current frame number and\n            *total_frames* is the total number of frames to be saved.\n            *total_frames* is set to None, if the total number of frames can\n            not be determined. Return values may exist but are ignored.\n\n            Example code to write the progress to stdout::\n\n                progress_callback =\\\n                    lambda i, n: print(f'Saving frame {i} of {n}')\n\n        Notes\n        -----\n        *fps*, *codec*, *bitrate*, *extra_args* and *metadata* are used to\n        construct a `.MovieWriter` instance and can only be passed if\n        *writer* is a string.  If they are passed as non-*None* and *writer*\n        is a `.MovieWriter`, a `RuntimeError` will be raised.\n        \"\"\"\n\n        if writer is None:\n            writer = mpl.rcParams['animation.writer']\n        elif (not isinstance(writer, str) and\n              any(arg is not None\n                  for arg in (fps, codec, bitrate, extra_args, metadata))):\n            raise RuntimeError('Passing in values for arguments '\n                               'fps, codec, bitrate, extra_args, or metadata '\n                               'is not supported when writer is an existing '\n                               'MovieWriter instance. These should instead be '\n                               'passed as arguments when creating the '\n                               'MovieWriter instance.')\n\n        if savefig_kwargs is None:\n            savefig_kwargs = {}\n\n        if fps is None and hasattr(self, '_interval'):\n            # Convert interval in ms to frames per second\n            fps = 1000. / self._interval\n\n        # Re-use the savefig DPI for ours if none is given\n        if dpi is None:\n            dpi = mpl.rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = self._fig.dpi\n\n        writer_kwargs = {}\n        if codec is not None:\n            writer_kwargs['codec'] = codec\n        if bitrate is not None:\n            writer_kwargs['bitrate'] = bitrate\n        if extra_args is not None:\n            writer_kwargs['extra_args'] = extra_args\n        if metadata is not None:\n            writer_kwargs['metadata'] = metadata\n\n        all_anim = [self]\n        if extra_anim is not None:\n            all_anim.extend(anim\n                            for anim\n                            in extra_anim if anim._fig is self._fig)\n\n        # If we have the name of a writer, instantiate an instance of the\n        # registered class.\n        if isinstance(writer, str):\n            try:\n                writer_cls = writers[writer]\n            except RuntimeError:  # Raised if not available.\n                writer_cls = PillowWriter  # Always available.\n                _log.warning(\"MovieWriter %s unavailable; using Pillow \"\n                             \"instead.\", writer)\n            writer = writer_cls(fps, **writer_kwargs)\n        _log.info('Animation.save using %s', type(writer))\n\n        if 'bbox_inches' in savefig_kwargs:\n            _log.warning(\"Warning: discarding the 'bbox_inches' argument in \"\n                         \"'savefig_kwargs' as it may cause frame size \"\n                         \"to vary, which is inappropriate for animation.\")\n            savefig_kwargs.pop('bbox_inches')\n\n        # Create a new sequence of frames for saved data. This is different\n        # from new_frame_seq() to give the ability to save 'live' generated\n        # frame information to be saved later.\n        # TODO: Right now, after closing the figure, saving a movie won't work\n        # since GUI widgets are gone. Either need to remove extra code to\n        # allow for this non-existent use case or find a way to make it work.\n        if mpl.rcParams['savefig.bbox'] == 'tight':\n            _log.info(\"Disabling savefig.bbox = 'tight', as it may cause \"\n                      \"frame size to vary, which is inappropriate for \"\n                      \"animation.\")\n        # canvas._is_saving = True makes the draw_event animation-starting\n        # callback a no-op; canvas.manager = None prevents resizing the GUI\n        # widget (both are likewise done in savefig()).\n        with mpl.rc_context({'savefig.bbox': None}), \\\n             writer.saving(self._fig, filename, dpi), \\\n             cbook._setattr_cm(self._fig.canvas,\n                               _is_saving=True, manager=None):\n            for anim in all_anim:\n                anim._init_draw()  # Clear the initial frame\n            frame_number = 0\n            # TODO: Currently only FuncAnimation has a save_count\n            #       attribute. Can we generalize this to all Animations?\n            save_count_list = [getattr(a, 'save_count', None)\n                               for a in all_anim]\n            if None in save_count_list:\n                total_frames = None\n            else:\n                total_frames = sum(save_count_list)\n            for data in zip(*[a.new_saved_frame_seq() for a in all_anim]):\n                for anim, d in zip(all_anim, data):\n                    # TODO: See if turning off blit is really necessary\n                    anim._draw_next_frame(d, blit=False)\n                    if progress_callback is not None:\n                        progress_callback(frame_number, total_frames)\n                        frame_number += 1\n                writer.grab_frame(**savefig_kwargs)\n\n    def _step(self, *args):\n        \"\"\"\n        Handler for getting events. By default, gets the next frame in the\n        sequence and hands the data off to be drawn.\n        \"\"\"\n        # Returns True to indicate that the event source should continue to\n        # call _step, until the frame sequence reaches the end of iteration,\n        # at which point False will be returned.\n        try:\n            framedata = next(self.frame_seq)\n            self._draw_next_frame(framedata, self._blit)\n            return True\n        except StopIteration:\n            return False\n\n    def new_frame_seq(self):\n        \"\"\"Return a new sequence of frame information.\"\"\"\n        # Default implementation is just an iterator over self._framedata\n        return iter(self._framedata)\n\n    def new_saved_frame_seq(self):\n        \"\"\"Return a new sequence of saved/cached frame information.\"\"\"\n        # Default is the same as the regular frame sequence\n        return self.new_frame_seq()\n\n    def _draw_next_frame(self, framedata, blit):\n        # Breaks down the drawing of the next frame into steps of pre- and\n        # post- draw, as well as the drawing of the frame itself.\n        self._pre_draw(framedata, blit)\n        self._draw_frame(framedata)\n        self._post_draw(framedata, blit)\n\n    def _init_draw(self):\n        # Initial draw to clear the frame. Also used by the blitting code\n        # when a clean base is required.\n        self._draw_was_started = True\n\n    def _pre_draw(self, framedata, blit):\n        # Perform any cleaning or whatnot before the drawing of the frame.\n        # This default implementation allows blit to clear the frame.\n        if blit:\n            self._blit_clear(self._drawn_artists)\n\n    def _draw_frame(self, framedata):\n        # Performs actual drawing of the frame.\n        raise NotImplementedError('Needs to be implemented by subclasses to'\n                                  ' actually make an animation.')\n\n    def _post_draw(self, framedata, blit):\n        # After the frame is rendered, this handles the actual flushing of\n        # the draw, which can be a direct draw_idle() or make use of the\n        # blitting.\n        if blit and self._drawn_artists:\n            self._blit_draw(self._drawn_artists)\n        else:\n            self._fig.canvas.draw_idle()\n\n    # The rest of the code in this class is to facilitate easy blitting\n    def _blit_draw(self, artists):\n        # Handles blitted drawing, which renders only the artists given instead\n        # of the entire figure.\n        updated_ax = {a.axes for a in artists}\n        # Enumerate artists to cache Axes backgrounds. We do not draw\n        # artists yet to not cache foreground from plots with shared axes\n        for ax in updated_ax:\n            # If we haven't cached the background for the current view of this\n            # Axes object, do so now. This might not always be reliable, but\n            # it's an attempt to automate the process.\n            cur_view = ax._get_view()\n            view, bg = self._blit_cache.get(ax, (object(), None))\n            if cur_view != view:\n                self._blit_cache[ax] = (\n                    cur_view, ax.figure.canvas.copy_from_bbox(ax.bbox))\n        # Make a separate pass to draw foreground.\n        for a in artists:\n            a.axes.draw_artist(a)\n        # After rendering all the needed artists, blit each Axes individually.\n        for ax in updated_ax:\n            ax.figure.canvas.blit(ax.bbox)\n\n    def _blit_clear(self, artists):\n        # Get a list of the Axes that need clearing from the artists that\n        # have been drawn. Grab the appropriate saved background from the\n        # cache and restore.\n        axes = {a.axes for a in artists}\n        for ax in axes:\n            try:\n                view, bg = self._blit_cache[ax]\n            except KeyError:\n                continue\n            if ax._get_view() == view:\n                ax.figure.canvas.restore_region(bg)\n            else:\n                self._blit_cache.pop(ax)\n\n    def _setup_blit(self):\n        # Setting up the blit requires: a cache of the background for the Axes\n        self._blit_cache = dict()\n        self._drawn_artists = []\n        # _post_draw needs to be called first to initialize the renderer\n        self._post_draw(None, self._blit)\n        # Then we need to clear the Frame for the initial draw\n        # This is typically handled in _on_resize because QT and Tk\n        # emit a resize event on launch, but the macosx backend does not,\n        # thus we force it here for everyone for consistency\n        self._init_draw()\n        # Connect to future resize events\n        self._resize_id = self._fig.canvas.mpl_connect('resize_event',\n                                                       self._on_resize)\n\n    def _on_resize(self, event):\n        # On resize, we need to disable the resize event handling so we don't\n        # get too many events. Also stop the animation events, so that\n        # we're paused. Reset the cache and re-init. Set up an event handler\n        # to catch once the draw has actually taken place.\n        self._fig.canvas.mpl_disconnect(self._resize_id)\n        self.event_source.stop()\n        self._blit_cache.clear()\n        self._init_draw()\n        self._resize_id = self._fig.canvas.mpl_connect('draw_event',\n                                                       self._end_redraw)\n\n    def _end_redraw(self, event):\n        # Now that the redraw has happened, do the post draw flushing and\n        # blit handling. Then re-enable all of the original events.\n        self._post_draw(None, False)\n        self.event_source.start()\n        self._fig.canvas.mpl_disconnect(self._resize_id)\n        self._resize_id = self._fig.canvas.mpl_connect('resize_event',\n                                                       self._on_resize)\n\n    def to_html5_video(self, embed_limit=None):\n        \"\"\"\n        Convert the animation to an HTML5 ``<video>`` tag.\n\n        This saves the animation as an h264 video, encoded in base64\n        directly into the HTML5 video tag. This respects :rc:`animation.writer`\n        and :rc:`animation.bitrate`. This also makes use of the\n        ``interval`` to control the speed, and uses the ``repeat``\n        parameter to decide whether to loop.\n\n        Parameters\n        ----------\n        embed_limit : float, optional\n            Limit, in MB, of the returned animation. No animation is created\n            if the limit is exceeded.\n            Defaults to :rc:`animation.embed_limit` = 20.0.\n\n        Returns\n        -------\n        str\n            An HTML5 video tag with the animation embedded as base64 encoded\n            h264 video.\n            If the *embed_limit* is exceeded, this returns the string\n            \"Video too large to embed.\"\n        \"\"\"\n        VIDEO_TAG = r'''<video {size} {options}>\n  <source type=\"video/mp4\" src=\"data:video/mp4;base64,{video}\">\n  Your browser does not support the video tag.\n</video>'''\n        # Cache the rendering of the video as HTML\n        if not hasattr(self, '_base64_video'):\n            # Save embed limit, which is given in MB\n            if embed_limit is None:\n                embed_limit = mpl.rcParams['animation.embed_limit']\n\n            # Convert from MB to bytes\n            embed_limit *= 1024 * 1024\n\n            # Can't open a NamedTemporaryFile twice on Windows, so use a\n            # TemporaryDirectory instead.\n            with TemporaryDirectory() as tmpdir:\n                path = Path(tmpdir, \"temp.m4v\")\n                # We create a writer manually so that we can get the\n                # appropriate size for the tag\n                Writer = writers[mpl.rcParams['animation.writer']]\n                writer = Writer(codec='h264',\n                                bitrate=mpl.rcParams['animation.bitrate'],\n                                fps=1000. / self._interval)\n                self.save(str(path), writer=writer)\n                # Now open and base64 encode.\n                vid64 = base64.encodebytes(path.read_bytes())\n\n            vid_len = len(vid64)\n            if vid_len >= embed_limit:\n                _log.warning(\n                    \"Animation movie is %s bytes, exceeding the limit of %s. \"\n                    \"If you're sure you want a large animation embedded, set \"\n                    \"the animation.embed_limit rc parameter to a larger value \"\n                    \"(in MB).\", vid_len, embed_limit)\n            else:\n                self._base64_video = vid64.decode('ascii')\n                self._video_size = 'width=\"{}\" height=\"{}\"'.format(\n                        *writer.frame_size)\n\n        # If we exceeded the size, this attribute won't exist\n        if hasattr(self, '_base64_video'):\n            # Default HTML5 options are to autoplay and display video controls\n            options = ['controls', 'autoplay']\n\n            # If we're set to repeat, make it loop\n            if hasattr(self, 'repeat') and self.repeat:\n                options.append('loop')\n\n            return VIDEO_TAG.format(video=self._base64_video,\n                                    size=self._video_size,\n                                    options=' '.join(options))\n        else:\n            return 'Video too large to embed.'\n\n    def to_jshtml(self, fps=None, embed_frames=True, default_mode=None):\n        \"\"\"\n        Generate HTML representation of the animation.\n\n        Parameters\n        ----------\n        fps : int, optional\n            Movie frame rate (per second). If not set, the frame rate from\n            the animation's frame interval.\n        embed_frames : bool, optional\n        default_mode : str, optional\n            What to do when the animation ends. Must be one of ``{'loop',\n            'once', 'reflect'}``. Defaults to ``'loop'`` if ``self.repeat``\n            is True, otherwise ``'once'``.\n        \"\"\"\n        if fps is None and hasattr(self, '_interval'):\n            # Convert interval in ms to frames per second\n            fps = 1000 / self._interval\n\n        # If we're not given a default mode, choose one base on the value of\n        # the repeat attribute\n        if default_mode is None:\n            default_mode = 'loop' if self.repeat else 'once'\n\n        if not hasattr(self, \"_html_representation\"):\n            # Can't open a NamedTemporaryFile twice on Windows, so use a\n            # TemporaryDirectory instead.\n            with TemporaryDirectory() as tmpdir:\n                path = Path(tmpdir, \"temp.html\")\n                writer = HTMLWriter(fps=fps,\n                                    embed_frames=embed_frames,\n                                    default_mode=default_mode)\n                self.save(str(path), writer=writer)\n                self._html_representation = path.read_text()\n\n        return self._html_representation\n\n    def _repr_html_(self):\n        \"\"\"IPython display hook for rendering.\"\"\"\n        fmt = mpl.rcParams['animation.html']\n        if fmt == 'html5':\n            return self.to_html5_video()\n        elif fmt == 'jshtml':\n            return self.to_jshtml()\n\n    def pause(self):\n        \"\"\"Pause the animation.\"\"\"\n        self.event_source.stop()\n        if self._blit:\n            for artist in self._drawn_artists:\n                artist.set_animated(False)\n\n    def resume(self):\n        \"\"\"Resume the animation.\"\"\"\n        self.event_source.start()\n        if self._blit:\n            for artist in self._drawn_artists:\n                artist.set_animated(True)",
      "instance_attributes": [
        {
          "name": "_draw_was_started",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_fig",
          "types": null
        },
        {
          "name": "_blit",
          "types": null
        },
        {
          "name": "frame_seq",
          "types": null
        },
        {
          "name": "event_source",
          "types": null
        },
        {
          "name": "_first_draw_id",
          "types": null
        },
        {
          "name": "_close_id",
          "types": null
        },
        {
          "name": "_blit_cache",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_drawn_artists",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_resize_id",
          "types": null
        },
        {
          "name": "_base64_video",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_video_size",
          "types": null
        },
        {
          "name": "_html_representation",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/ArtistAnimation",
      "name": "ArtistAnimation",
      "qname": "lib.matplotlib.animation.ArtistAnimation",
      "decorators": [],
      "superclasses": [
        "TimedAnimation"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/ArtistAnimation/__init__",
        "matplotlib/lib.matplotlib.animation/ArtistAnimation/_init_draw",
        "matplotlib/lib.matplotlib.animation/ArtistAnimation/_pre_draw",
        "matplotlib/lib.matplotlib.animation/ArtistAnimation/_draw_frame"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Animation using a fixed set of `.Artist` objects.\n\nBefore creating an instance, all plotting should have taken place\nand the relevant artists saved.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.",
      "docstring": "Animation using a fixed set of `.Artist` objects.\n\nBefore creating an instance, all plotting should have taken place\nand the relevant artists saved.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.\n\nParameters\n----------\nfig : `~matplotlib.figure.Figure`\n    The figure object used to get needed events, such as draw or resize.\nartists : list\n    Each list entry is a collection of `.Artist` objects that are made\n    visible on the corresponding frame.  Other artists are made invisible.\ninterval : int, default: 200\n    Delay between frames in milliseconds.\nrepeat_delay : int, default: 0\n    The delay in milliseconds between consecutive animation runs, if\n    *repeat* is True.\nrepeat : bool, default: True\n    Whether the animation repeats when the sequence of frames is completed.\nblit : bool, default: False\n    Whether blitting is used to optimize drawing.",
      "code": "class ArtistAnimation(TimedAnimation):\n    \"\"\"\n    Animation using a fixed set of `.Artist` objects.\n\n    Before creating an instance, all plotting should have taken place\n    and the relevant artists saved.\n\n    .. note::\n\n        You must store the created Animation in a variable that lives as long\n        as the animation should run. Otherwise, the Animation object will be\n        garbage-collected and the animation stops.\n\n    Parameters\n    ----------\n    fig : `~matplotlib.figure.Figure`\n        The figure object used to get needed events, such as draw or resize.\n    artists : list\n        Each list entry is a collection of `.Artist` objects that are made\n        visible on the corresponding frame.  Other artists are made invisible.\n    interval : int, default: 200\n        Delay between frames in milliseconds.\n    repeat_delay : int, default: 0\n        The delay in milliseconds between consecutive animation runs, if\n        *repeat* is True.\n    repeat : bool, default: True\n        Whether the animation repeats when the sequence of frames is completed.\n    blit : bool, default: False\n        Whether blitting is used to optimize drawing.\n    \"\"\"\n\n    def __init__(self, fig, artists, *args, **kwargs):\n        # Internal list of artists drawn in the most recent frame.\n        self._drawn_artists = []\n\n        # Use the list of artists as the framedata, which will be iterated\n        # over by the machinery.\n        self._framedata = artists\n        super().__init__(fig, *args, **kwargs)\n\n    def _init_draw(self):\n        super()._init_draw()\n        # Make all the artists involved in *any* frame invisible\n        figs = set()\n        for f in self.new_frame_seq():\n            for artist in f:\n                artist.set_visible(False)\n                artist.set_animated(self._blit)\n                # Assemble a list of unique figures that need flushing\n                if artist.get_figure() not in figs:\n                    figs.add(artist.get_figure())\n\n        # Flush the needed figures\n        for fig in figs:\n            fig.canvas.draw_idle()\n\n    def _pre_draw(self, framedata, blit):\n        \"\"\"Clears artists from the last frame.\"\"\"\n        if blit:\n            # Let blit handle clearing\n            self._blit_clear(self._drawn_artists)\n        else:\n            # Otherwise, make all the artists from the previous frame invisible\n            for artist in self._drawn_artists:\n                artist.set_visible(False)\n\n    def _draw_frame(self, artists):\n        # Save the artists that were passed in as framedata for the other\n        # steps (esp. blitting) to use.\n        self._drawn_artists = artists\n\n        # Make all the artists from the current frame visible\n        for artist in artists:\n            artist.set_visible(True)",
      "instance_attributes": [
        {
          "name": "_drawn_artists",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_framedata",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FFMpegBase",
      "name": "FFMpegBase",
      "qname": "lib.matplotlib.animation.FFMpegBase",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.animation/FFMpegBase/output_args@getter"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Mixin class for FFMpeg output.\n\nThis is a base class for the concrete `FFMpegWriter` and `FFMpegFileWriter`\nclasses.",
      "docstring": "Mixin class for FFMpeg output.\n\nThis is a base class for the concrete `FFMpegWriter` and `FFMpegFileWriter`\nclasses.",
      "code": "class FFMpegBase:\n    \"\"\"\n    Mixin class for FFMpeg output.\n\n    This is a base class for the concrete `FFMpegWriter` and `FFMpegFileWriter`\n    classes.\n    \"\"\"\n\n    _exec_key = 'animation.ffmpeg_path'\n    _args_key = 'animation.ffmpeg_args'\n\n    @property\n    def output_args(self):\n        args = []\n        if Path(self.outfile).suffix == '.gif':\n            self.codec = 'gif'\n        else:\n            args.extend(['-vcodec', self.codec])\n        extra_args = (self.extra_args if self.extra_args is not None\n                      else mpl.rcParams[self._args_key])\n        # For h264, the default format is yuv444p, which is not compatible\n        # with quicktime (and others). Specifying yuv420p fixes playback on\n        # iOS, as well as HTML5 video in firefox and safari (on both Win and\n        # OSX). Also fixes internet explorer. This is as of 2015/10/29.\n        if self.codec == 'h264' and '-pix_fmt' not in extra_args:\n            args.extend(['-pix_fmt', 'yuv420p'])\n        # For GIF, we're telling FFMPEG to split the video stream, to generate\n        # a palette, and then use it for encoding.\n        elif self.codec == 'gif' and '-filter_complex' not in extra_args:\n            args.extend(['-filter_complex',\n                         'split [a][b];[a] palettegen [p];[b][p] paletteuse'])\n        if self.bitrate > 0:\n            args.extend(['-b', '%dk' % self.bitrate])  # %dk: bitrate in kbps.\n        args.extend(extra_args)\n        for k, v in self.metadata.items():\n            args.extend(['-metadata', '%s=%s' % (k, v)])\n\n        return args + ['-y', self.outfile]",
      "instance_attributes": [
        {
          "name": "codec",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FFMpegFileWriter",
      "name": "FFMpegFileWriter",
      "qname": "lib.matplotlib.animation.FFMpegFileWriter",
      "decorators": [
        "writers.register('ffmpeg_file')"
      ],
      "superclasses": [
        "FFMpegBase",
        "FileMovieWriter"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/FFMpegFileWriter/_args"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "File-based ffmpeg writer.\n\nFrames are written to temporary files on disk and then stitched\ntogether at the end.",
      "docstring": "File-based ffmpeg writer.\n\nFrames are written to temporary files on disk and then stitched\ntogether at the end.",
      "code": "class FFMpegFileWriter(FFMpegBase, FileMovieWriter):\n    \"\"\"\n    File-based ffmpeg writer.\n\n    Frames are written to temporary files on disk and then stitched\n    together at the end.\n    \"\"\"\n    supported_formats = ['png', 'jpeg', 'tiff', 'raw', 'rgba']\n\n    def _args(self):\n        # Returns the command line parameters for subprocess to use\n        # ffmpeg to create a movie using a collection of temp images\n        args = []\n        # For raw frames, we need to explicitly tell ffmpeg the metadata.\n        if self.frame_format in {'raw', 'rgba'}:\n            args += [\n                '-f', 'image2', '-vcodec', 'rawvideo',\n                '-video_size', '%dx%d' % self.frame_size,\n                '-pixel_format', 'rgba',\n                '-framerate', str(self.fps),\n            ]\n        args += ['-r', str(self.fps), '-i', self._base_temp_name(),\n                 '-vframes', str(self._frame_counter)]\n        # Logging is quieted because subprocess.PIPE has limited buffer size.\n        # If you have a lot of frames in your animation and set logging to\n        # DEBUG, you will have a buffer overrun.\n        if _log.getEffectiveLevel() > logging.DEBUG:\n            args += ['-loglevel', 'error']\n        return [self.bin_path(), *args, *self.output_args]",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FFMpegWriter",
      "name": "FFMpegWriter",
      "qname": "lib.matplotlib.animation.FFMpegWriter",
      "decorators": [
        "writers.register('ffmpeg')"
      ],
      "superclasses": [
        "FFMpegBase",
        "MovieWriter"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/FFMpegWriter/_args"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Pipe-based ffmpeg writer.\n\nFrames are streamed directly to ffmpeg via a pipe and written in a single\npass.",
      "docstring": "Pipe-based ffmpeg writer.\n\nFrames are streamed directly to ffmpeg via a pipe and written in a single\npass.",
      "code": "class FFMpegWriter(FFMpegBase, MovieWriter):\n    \"\"\"\n    Pipe-based ffmpeg writer.\n\n    Frames are streamed directly to ffmpeg via a pipe and written in a single\n    pass.\n    \"\"\"\n    def _args(self):\n        # Returns the command line parameters for subprocess to use\n        # ffmpeg to create a movie using a pipe.\n        args = [self.bin_path(), '-f', 'rawvideo', '-vcodec', 'rawvideo',\n                '-s', '%dx%d' % self.frame_size, '-pix_fmt', self.frame_format,\n                '-r', str(self.fps)]\n        # Logging is quieted because subprocess.PIPE has limited buffer size.\n        # If you have a lot of frames in your animation and set logging to\n        # DEBUG, you will have a buffer overrun.\n        if _log.getEffectiveLevel() > logging.DEBUG:\n            args += ['-loglevel', 'error']\n        args += ['-i', 'pipe:'] + self.output_args\n        return args",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter",
      "name": "FileMovieWriter",
      "qname": "lib.matplotlib.animation.FileMovieWriter",
      "decorators": [],
      "superclasses": [
        "MovieWriter"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/FileMovieWriter/__init__",
        "matplotlib/lib.matplotlib.animation/FileMovieWriter/setup",
        "matplotlib/lib.matplotlib.animation/FileMovieWriter/__del__",
        "matplotlib/lib.matplotlib.animation/FileMovieWriter/frame_format@getter",
        "matplotlib/lib.matplotlib.animation/FileMovieWriter/frame_format@setter",
        "matplotlib/lib.matplotlib.animation/FileMovieWriter/_base_temp_name",
        "matplotlib/lib.matplotlib.animation/FileMovieWriter/grab_frame",
        "matplotlib/lib.matplotlib.animation/FileMovieWriter/finish"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "`MovieWriter` for writing to individual files and stitching at the end.\n\nThis must be sub-classed to be useful.",
      "docstring": "`MovieWriter` for writing to individual files and stitching at the end.\n\nThis must be sub-classed to be useful.",
      "code": "class FileMovieWriter(MovieWriter):\n    \"\"\"\n    `MovieWriter` for writing to individual files and stitching at the end.\n\n    This must be sub-classed to be useful.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.frame_format = mpl.rcParams['animation.frame_format']\n\n    def setup(self, fig, outfile, dpi=None, frame_prefix=None):\n        \"\"\"\n        Setup for writing the movie file.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The figure to grab the rendered frames from.\n        outfile : str\n            The filename of the resulting movie file.\n        dpi : float, default: ``fig.dpi``\n            The dpi of the output file. This, with the figure size,\n            controls the size in pixels of the resulting movie file.\n        frame_prefix : str, optional\n            The filename prefix to use for temporary files.  If *None* (the\n            default), files are written to a temporary directory which is\n            deleted by `cleanup`; if not *None*, no temporary files are\n            deleted.\n        \"\"\"\n        self.fig = fig\n        self.outfile = outfile\n        if dpi is None:\n            dpi = self.fig.dpi\n        self.dpi = dpi\n        self._adjust_frame_size()\n\n        if frame_prefix is None:\n            self._tmpdir = TemporaryDirectory()\n            self.temp_prefix = str(Path(self._tmpdir.name, 'tmp'))\n        else:\n            self._tmpdir = None\n            self.temp_prefix = frame_prefix\n        self._frame_counter = 0  # used for generating sequential file names\n        self._temp_paths = list()\n        self.fname_format_str = '%s%%07d.%s'\n\n    def __del__(self):\n        if self._tmpdir:\n            self._tmpdir.cleanup()\n\n    @property\n    def frame_format(self):\n        \"\"\"\n        Format (png, jpeg, etc.) to use for saving the frames, which can be\n        decided by the individual subclasses.\n        \"\"\"\n        return self._frame_format\n\n    @frame_format.setter\n    def frame_format(self, frame_format):\n        if frame_format in self.supported_formats:\n            self._frame_format = frame_format\n        else:\n            _api.warn_external(\n                f\"Ignoring file format {frame_format!r} which is not \"\n                f\"supported by {type(self).__name__}; using \"\n                f\"{self.supported_formats[0]} instead.\")\n            self._frame_format = self.supported_formats[0]\n\n    def _base_temp_name(self):\n        # Generates a template name (without number) given the frame format\n        # for extension and the prefix.\n        return self.fname_format_str % (self.temp_prefix, self.frame_format)\n\n    def grab_frame(self, **savefig_kwargs):\n        # docstring inherited\n        # Creates a filename for saving using basename and counter.\n        path = Path(self._base_temp_name() % self._frame_counter)\n        self._temp_paths.append(path)  # Record the filename for later use.\n        self._frame_counter += 1  # Ensures each created name is unique.\n        _log.debug('FileMovieWriter.grab_frame: Grabbing frame %d to path=%s',\n                   self._frame_counter, path)\n        with open(path, 'wb') as sink:  # Save figure to the sink.\n            self.fig.savefig(sink, format=self.frame_format, dpi=self.dpi,\n                             **savefig_kwargs)\n\n    def finish(self):\n        # Call run here now that all frame grabbing is done. All temp files\n        # are available to be assembled.\n        try:\n            self._run()\n            super().finish()\n        finally:\n            if self._tmpdir:\n                _log.debug(\n                    'MovieWriter: clearing temporary path=%s', self._tmpdir\n                )\n                self._tmpdir.cleanup()",
      "instance_attributes": [
        {
          "name": "frame_format",
          "types": null
        },
        {
          "name": "fig",
          "types": null
        },
        {
          "name": "outfile",
          "types": null
        },
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "_tmpdir",
          "types": {
            "kind": "NamedType",
            "name": "TemporaryDirectory"
          }
        },
        {
          "name": "temp_prefix",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_frame_counter",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_temp_paths",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "fname_format_str",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_frame_format",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FuncAnimation",
      "name": "FuncAnimation",
      "qname": "lib.matplotlib.animation.FuncAnimation",
      "decorators": [],
      "superclasses": [
        "TimedAnimation"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__",
        "matplotlib/lib.matplotlib.animation/FuncAnimation/new_frame_seq",
        "matplotlib/lib.matplotlib.animation/FuncAnimation/new_saved_frame_seq",
        "matplotlib/lib.matplotlib.animation/FuncAnimation/_init_draw",
        "matplotlib/lib.matplotlib.animation/FuncAnimation/_draw_frame"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Makes an animation by repeatedly calling a function *func*.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.",
      "docstring": "Makes an animation by repeatedly calling a function *func*.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.\n\nParameters\n----------\nfig : `~matplotlib.figure.Figure`\n    The figure object used to get needed events, such as draw or resize.\n\nfunc : callable\n    The function to call at each frame.  The first argument will\n    be the next value in *frames*.   Any additional positional\n    arguments can be supplied via the *fargs* parameter.\n\n    The required signature is::\n\n        def func(frame, *fargs) -> iterable_of_artists\n\n    If ``blit == True``, *func* must return an iterable of all artists\n    that were modified or created. This information is used by the blitting\n    algorithm to determine which parts of the figure have to be updated.\n    The return value is unused if ``blit == False`` and may be omitted in\n    that case.\n\nframes : iterable, int, generator function, or None, optional\n    Source of data to pass *func* and each frame of the animation\n\n    - If an iterable, then simply use the values provided.  If the\n      iterable has a length, it will override the *save_count* kwarg.\n\n    - If an integer, then equivalent to passing ``range(frames)``\n\n    - If a generator function, then must have the signature::\n\n         def gen_function() -> obj\n\n    - If *None*, then equivalent to passing ``itertools.count``.\n\n    In all of these cases, the values in *frames* is simply passed through\n    to the user-supplied *func* and thus can be of any type.\n\ninit_func : callable, optional\n    A function used to draw a clear frame. If not given, the results of\n    drawing from the first item in the frames sequence will be used. This\n    function will be called once before the first frame.\n\n    The required signature is::\n\n        def init_func() -> iterable_of_artists\n\n    If ``blit == True``, *init_func* must return an iterable of artists\n    to be re-drawn. This information is used by the blitting algorithm to\n    determine which parts of the figure have to be updated.  The return\n    value is unused if ``blit == False`` and may be omitted in that case.\n\nfargs : tuple or None, optional\n    Additional arguments to pass to each call to *func*.\n\nsave_count : int, default: 100\n    Fallback for the number of values from *frames* to cache. This is\n    only used if the number of frames cannot be inferred from *frames*,\n    i.e. when it's an iterator without length or a generator.\n\ninterval : int, default: 200\n    Delay between frames in milliseconds.\n\nrepeat_delay : int, default: 0\n    The delay in milliseconds between consecutive animation runs, if\n    *repeat* is True.\n\nrepeat : bool, default: True\n    Whether the animation repeats when the sequence of frames is completed.\n\nblit : bool, default: False\n    Whether blitting is used to optimize drawing.  Note: when using\n    blitting, any animated artists will be drawn according to their zorder;\n    however, they will be drawn on top of any previous artists, regardless\n    of their zorder.\n\ncache_frame_data : bool, default: True\n    Whether frame data is cached.  Disabling cache might be helpful when\n    frames contain large objects.",
      "code": "class FuncAnimation(TimedAnimation):\n    \"\"\"\n    Makes an animation by repeatedly calling a function *func*.\n\n    .. note::\n\n        You must store the created Animation in a variable that lives as long\n        as the animation should run. Otherwise, the Animation object will be\n        garbage-collected and the animation stops.\n\n    Parameters\n    ----------\n    fig : `~matplotlib.figure.Figure`\n        The figure object used to get needed events, such as draw or resize.\n\n    func : callable\n        The function to call at each frame.  The first argument will\n        be the next value in *frames*.   Any additional positional\n        arguments can be supplied via the *fargs* parameter.\n\n        The required signature is::\n\n            def func(frame, *fargs) -> iterable_of_artists\n\n        If ``blit == True``, *func* must return an iterable of all artists\n        that were modified or created. This information is used by the blitting\n        algorithm to determine which parts of the figure have to be updated.\n        The return value is unused if ``blit == False`` and may be omitted in\n        that case.\n\n    frames : iterable, int, generator function, or None, optional\n        Source of data to pass *func* and each frame of the animation\n\n        - If an iterable, then simply use the values provided.  If the\n          iterable has a length, it will override the *save_count* kwarg.\n\n        - If an integer, then equivalent to passing ``range(frames)``\n\n        - If a generator function, then must have the signature::\n\n             def gen_function() -> obj\n\n        - If *None*, then equivalent to passing ``itertools.count``.\n\n        In all of these cases, the values in *frames* is simply passed through\n        to the user-supplied *func* and thus can be of any type.\n\n    init_func : callable, optional\n        A function used to draw a clear frame. If not given, the results of\n        drawing from the first item in the frames sequence will be used. This\n        function will be called once before the first frame.\n\n        The required signature is::\n\n            def init_func() -> iterable_of_artists\n\n        If ``blit == True``, *init_func* must return an iterable of artists\n        to be re-drawn. This information is used by the blitting algorithm to\n        determine which parts of the figure have to be updated.  The return\n        value is unused if ``blit == False`` and may be omitted in that case.\n\n    fargs : tuple or None, optional\n        Additional arguments to pass to each call to *func*.\n\n    save_count : int, default: 100\n        Fallback for the number of values from *frames* to cache. This is\n        only used if the number of frames cannot be inferred from *frames*,\n        i.e. when it's an iterator without length or a generator.\n\n    interval : int, default: 200\n        Delay between frames in milliseconds.\n\n    repeat_delay : int, default: 0\n        The delay in milliseconds between consecutive animation runs, if\n        *repeat* is True.\n\n    repeat : bool, default: True\n        Whether the animation repeats when the sequence of frames is completed.\n\n    blit : bool, default: False\n        Whether blitting is used to optimize drawing.  Note: when using\n        blitting, any animated artists will be drawn according to their zorder;\n        however, they will be drawn on top of any previous artists, regardless\n        of their zorder.\n\n    cache_frame_data : bool, default: True\n        Whether frame data is cached.  Disabling cache might be helpful when\n        frames contain large objects.\n    \"\"\"\n\n    def __init__(self, fig, func, frames=None, init_func=None, fargs=None,\n                 save_count=None, *, cache_frame_data=True, **kwargs):\n        if fargs:\n            self._args = fargs\n        else:\n            self._args = ()\n        self._func = func\n        self._init_func = init_func\n\n        # Amount of framedata to keep around for saving movies. This is only\n        # used if we don't know how many frames there will be: in the case\n        # of no generator or in the case of a callable.\n        self.save_count = save_count\n        # Set up a function that creates a new iterable when needed. If nothing\n        # is passed in for frames, just use itertools.count, which will just\n        # keep counting from 0. A callable passed in for frames is assumed to\n        # be a generator. An iterable will be used as is, and anything else\n        # will be treated as a number of frames.\n        if frames is None:\n            self._iter_gen = itertools.count\n        elif callable(frames):\n            self._iter_gen = frames\n        elif np.iterable(frames):\n            if kwargs.get('repeat', True):\n                self._tee_from = frames\n                def iter_frames(frames=frames):\n                    this, self._tee_from = itertools.tee(self._tee_from, 2)\n                    yield from this\n                self._iter_gen = iter_frames\n            else:\n                self._iter_gen = lambda: iter(frames)\n            if hasattr(frames, '__len__'):\n                self.save_count = len(frames)\n        else:\n            self._iter_gen = lambda: iter(range(frames))\n            self.save_count = frames\n\n        if self.save_count is None:\n            # If we're passed in and using the default, set save_count to 100.\n            self.save_count = 100\n        else:\n            # itertools.islice returns an error when passed a numpy int instead\n            # of a native python int (https://bugs.python.org/issue30537).\n            # As a workaround, convert save_count to a native python int.\n            self.save_count = int(self.save_count)\n\n        self._cache_frame_data = cache_frame_data\n\n        # Needs to be initialized so the draw functions work without checking\n        self._save_seq = []\n\n        super().__init__(fig, **kwargs)\n\n        # Need to reset the saved seq, since right now it will contain data\n        # for a single frame from init, which is not what we want.\n        self._save_seq = []\n\n    def new_frame_seq(self):\n        # Use the generating function to generate a new frame sequence\n        return self._iter_gen()\n\n    def new_saved_frame_seq(self):\n        # Generate an iterator for the sequence of saved data. If there are\n        # no saved frames, generate a new frame sequence and take the first\n        # save_count entries in it.\n        if self._save_seq:\n            # While iterating we are going to update _save_seq\n            # so make a copy to safely iterate over\n            self._old_saved_seq = list(self._save_seq)\n            return iter(self._old_saved_seq)\n        else:\n            if self.save_count is not None:\n                return itertools.islice(self.new_frame_seq(), self.save_count)\n\n            else:\n                frame_seq = self.new_frame_seq()\n\n                def gen():\n                    try:\n                        for _ in range(100):\n                            yield next(frame_seq)\n                    except StopIteration:\n                        pass\n                    else:\n                        _api.warn_deprecated(\n                            \"2.2\", message=\"FuncAnimation.save has truncated \"\n                            \"your animation to 100 frames.  In the future, no \"\n                            \"such truncation will occur; please pass \"\n                            \"'save_count' accordingly.\")\n\n                return gen()\n\n    def _init_draw(self):\n        super()._init_draw()\n        # Initialize the drawing either using the given init_func or by\n        # calling the draw function with the first item of the frame sequence.\n        # For blitting, the init_func should return a sequence of modified\n        # artists.\n        if self._init_func is None:\n            try:\n                frame_data = next(self.new_frame_seq())\n            except StopIteration:\n                # we can't start the iteration, it may have already been\n                # exhausted by a previous save or just be 0 length.\n                # warn and bail.\n                warnings.warn(\n                    \"Can not start iterating the frames for the initial draw. \"\n                    \"This can be caused by passing in a 0 length sequence \"\n                    \"for *frames*.\\n\\n\"\n                    \"If you passed *frames* as a generator \"\n                    \"it may be exhausted due to a previous display or save.\"\n                )\n                return\n            self._draw_frame(frame_data)\n        else:\n            self._drawn_artists = self._init_func()\n            if self._blit:\n                if self._drawn_artists is None:\n                    raise RuntimeError('The init_func must return a '\n                                       'sequence of Artist objects.')\n                for a in self._drawn_artists:\n                    a.set_animated(self._blit)\n        self._save_seq = []\n\n    def _draw_frame(self, framedata):\n        if self._cache_frame_data:\n            # Save the data for potential saving of movies.\n            self._save_seq.append(framedata)\n\n        # Make sure to respect save_count (keep only the last save_count\n        # around)\n        self._save_seq = self._save_seq[-self.save_count:]\n\n        # Call the func with framedata and args. If blitting is desired,\n        # func needs to return a sequence of any artists that were modified.\n        self._drawn_artists = self._func(framedata, *self._args)\n\n        if self._blit:\n\n            err = RuntimeError('The animation function must return a sequence '\n                               'of Artist objects.')\n            try:\n                # check if a sequence\n                iter(self._drawn_artists)\n            except TypeError:\n                raise err from None\n\n            # check each item if it's artist\n            for i in self._drawn_artists:\n                if not isinstance(i, mpl.artist.Artist):\n                    raise err\n\n            self._drawn_artists = sorted(self._drawn_artists,\n                                         key=lambda x: x.get_zorder())\n\n            for a in self._drawn_artists:\n                a.set_animated(self._blit)",
      "instance_attributes": [
        {
          "name": "_args",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "_func",
          "types": null
        },
        {
          "name": "_init_func",
          "types": null
        },
        {
          "name": "save_count",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_iter_gen",
          "types": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable"
              },
              {
                "kind": "NamedType",
                "name": "type"
              }
            ]
          }
        },
        {
          "name": "_tee_from",
          "types": null
        },
        {
          "name": "_cache_frame_data",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_save_seq",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_old_saved_seq",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_drawn_artists",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/HTMLWriter",
      "name": "HTMLWriter",
      "qname": "lib.matplotlib.animation.HTMLWriter",
      "decorators": [
        "writers.register('html')"
      ],
      "superclasses": [
        "FileMovieWriter"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/HTMLWriter/isAvailable",
        "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__",
        "matplotlib/lib.matplotlib.animation/HTMLWriter/setup",
        "matplotlib/lib.matplotlib.animation/HTMLWriter/grab_frame",
        "matplotlib/lib.matplotlib.animation/HTMLWriter/finish"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Writer for JavaScript-based HTML movies.",
      "docstring": "Writer for JavaScript-based HTML movies.",
      "code": "class HTMLWriter(FileMovieWriter):\n    \"\"\"Writer for JavaScript-based HTML movies.\"\"\"\n\n    supported_formats = ['png', 'jpeg', 'tiff', 'svg']\n\n    @classmethod\n    def isAvailable(cls):\n        return True\n\n    def __init__(self, fps=30, codec=None, bitrate=None, extra_args=None,\n                 metadata=None, embed_frames=False, default_mode='loop',\n                 embed_limit=None):\n\n        if extra_args:\n            _log.warning(\"HTMLWriter ignores 'extra_args'\")\n        extra_args = ()  # Don't lookup nonexistent rcParam[args_key].\n        self.embed_frames = embed_frames\n        self.default_mode = default_mode.lower()\n        _api.check_in_list(['loop', 'once', 'reflect'],\n                           default_mode=self.default_mode)\n\n        # Save embed limit, which is given in MB\n        if embed_limit is None:\n            self._bytes_limit = mpl.rcParams['animation.embed_limit']\n        else:\n            self._bytes_limit = embed_limit\n        # Convert from MB to bytes\n        self._bytes_limit *= 1024 * 1024\n\n        super().__init__(fps, codec, bitrate, extra_args, metadata)\n\n    def setup(self, fig, outfile, dpi=None, frame_dir=None):\n        outfile = Path(outfile)\n        _api.check_in_list(['.html', '.htm'], outfile_extension=outfile.suffix)\n\n        self._saved_frames = []\n        self._total_bytes = 0\n        self._hit_limit = False\n\n        if not self.embed_frames:\n            if frame_dir is None:\n                frame_dir = outfile.with_name(outfile.stem + '_frames')\n            frame_dir.mkdir(parents=True, exist_ok=True)\n            frame_prefix = frame_dir / 'frame'\n        else:\n            frame_prefix = None\n\n        super().setup(fig, outfile, dpi, frame_prefix)\n        self._clear_temp = False\n\n    def grab_frame(self, **savefig_kwargs):\n        if self.embed_frames:\n            # Just stop processing if we hit the limit\n            if self._hit_limit:\n                return\n            f = BytesIO()\n            self.fig.savefig(f, format=self.frame_format,\n                             dpi=self.dpi, **savefig_kwargs)\n            imgdata64 = base64.encodebytes(f.getvalue()).decode('ascii')\n            self._total_bytes += len(imgdata64)\n            if self._total_bytes >= self._bytes_limit:\n                _log.warning(\n                    \"Animation size has reached %s bytes, exceeding the limit \"\n                    \"of %s. If you're sure you want a larger animation \"\n                    \"embedded, set the animation.embed_limit rc parameter to \"\n                    \"a larger value (in MB). This and further frames will be \"\n                    \"dropped.\", self._total_bytes, self._bytes_limit)\n                self._hit_limit = True\n            else:\n                self._saved_frames.append(imgdata64)\n        else:\n            return super().grab_frame(**savefig_kwargs)\n\n    def finish(self):\n        # save the frames to an html file\n        if self.embed_frames:\n            fill_frames = _embedded_frames(self._saved_frames,\n                                           self.frame_format)\n            Nframes = len(self._saved_frames)\n        else:\n            # temp names is filled by FileMovieWriter\n            fill_frames = _included_frames(self._temp_paths, self.frame_format)\n            Nframes = len(self._temp_paths)\n        mode_dict = dict(once_checked='',\n                         loop_checked='',\n                         reflect_checked='')\n        mode_dict[self.default_mode + '_checked'] = 'checked'\n\n        interval = 1000 // self.fps\n\n        with open(self.outfile, 'w') as of:\n            of.write(JS_INCLUDE + STYLE_INCLUDE)\n            of.write(DISPLAY_TEMPLATE.format(id=uuid.uuid4().hex,\n                                             Nframes=Nframes,\n                                             fill_frames=fill_frames,\n                                             interval=interval,\n                                             **mode_dict))\n\n        # duplicate the temporary file clean up logic from\n        # FileMovieWriter.cleanup.  We can not call the inherited\n        # versions of finish or cleanup because both assume that\n        # there is a subprocess that we either need to call to merge\n        # many frames together or that there is a subprocess call that\n        # we need to clean up.\n        if self._tmpdir:\n            _log.debug('MovieWriter: clearing temporary path=%s', self._tmpdir)\n            self._tmpdir.cleanup()",
      "instance_attributes": [
        {
          "name": "embed_frames",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "default_mode",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_bytes_limit",
          "types": null
        },
        {
          "name": "_saved_frames",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_total_bytes",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_hit_limit",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_clear_temp",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/ImageMagickBase",
      "name": "ImageMagickBase",
      "qname": "lib.matplotlib.animation.ImageMagickBase",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.animation/ImageMagickBase/delay@getter",
        "matplotlib/lib.matplotlib.animation/ImageMagickBase/output_args@getter",
        "matplotlib/lib.matplotlib.animation/ImageMagickBase/_args",
        "matplotlib/lib.matplotlib.animation/ImageMagickBase/bin_path",
        "matplotlib/lib.matplotlib.animation/ImageMagickBase/isAvailable"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Mixin class for ImageMagick output.\n\nThis is a base class for the concrete `ImageMagickWriter` and\n`ImageMagickFileWriter` classes, which define an ``input_names`` attribute\n(or property) specifying the input names passed to ImageMagick.",
      "docstring": "Mixin class for ImageMagick output.\n\nThis is a base class for the concrete `ImageMagickWriter` and\n`ImageMagickFileWriter` classes, which define an ``input_names`` attribute\n(or property) specifying the input names passed to ImageMagick.",
      "code": "class ImageMagickBase:\n    \"\"\"\n    Mixin class for ImageMagick output.\n\n    This is a base class for the concrete `ImageMagickWriter` and\n    `ImageMagickFileWriter` classes, which define an ``input_names`` attribute\n    (or property) specifying the input names passed to ImageMagick.\n    \"\"\"\n\n    _exec_key = 'animation.convert_path'\n    _args_key = 'animation.convert_args'\n\n    @_api.deprecated(\"3.6\")\n    @property\n    def delay(self):\n        return 100. / self.fps\n\n    @_api.deprecated(\"3.6\")\n    @property\n    def output_args(self):\n        extra_args = (self.extra_args if self.extra_args is not None\n                      else mpl.rcParams[self._args_key])\n        return [*extra_args, self.outfile]\n\n    def _args(self):\n        # ImageMagick does not recognize \"raw\".\n        fmt = \"rgba\" if self.frame_format == \"raw\" else self.frame_format\n        extra_args = (self.extra_args if self.extra_args is not None\n                      else mpl.rcParams[self._args_key])\n        return [\n            self.bin_path(),\n            \"-size\", \"%ix%i\" % self.frame_size,\n            \"-depth\", \"8\",\n            \"-delay\", str(100 / self.fps),\n            \"-loop\", \"0\",\n            f\"{fmt}:{self.input_names}\",\n            *extra_args,\n            self.outfile,\n        ]\n\n    @classmethod\n    def bin_path(cls):\n        binpath = super().bin_path()\n        if binpath == 'convert':\n            binpath = mpl._get_executable_info('magick').executable\n        return binpath\n\n    @classmethod\n    def isAvailable(cls):\n        try:\n            return super().isAvailable()\n        except mpl.ExecutableNotFoundError as _enf:\n            # May be raised by get_executable_info.\n            _log.debug('ImageMagick unavailable due to: %s', _enf)\n            return False",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/ImageMagickFileWriter",
      "name": "ImageMagickFileWriter",
      "qname": "lib.matplotlib.animation.ImageMagickFileWriter",
      "decorators": [
        "writers.register('imagemagick_file')"
      ],
      "superclasses": [
        "ImageMagickBase",
        "FileMovieWriter"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "File-based animated gif writer.\n\nFrames are written to temporary files on disk and then stitched\ntogether at the end.",
      "docstring": "File-based animated gif writer.\n\nFrames are written to temporary files on disk and then stitched\ntogether at the end.",
      "code": "class ImageMagickFileWriter(ImageMagickBase, FileMovieWriter):\n    \"\"\"\n    File-based animated gif writer.\n\n    Frames are written to temporary files on disk and then stitched\n    together at the end.\n    \"\"\"\n\n    supported_formats = ['png', 'jpeg', 'tiff', 'raw', 'rgba']\n    input_names = property(\n        lambda self: f'{self.temp_prefix}*.{self.frame_format}')",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/ImageMagickWriter",
      "name": "ImageMagickWriter",
      "qname": "lib.matplotlib.animation.ImageMagickWriter",
      "decorators": [
        "writers.register('imagemagick')"
      ],
      "superclasses": [
        "ImageMagickBase",
        "MovieWriter"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Pipe-based animated gif.\n\nFrames are streamed directly to ImageMagick via a pipe and written\nin a single pass.",
      "docstring": "Pipe-based animated gif.\n\nFrames are streamed directly to ImageMagick via a pipe and written\nin a single pass.",
      "code": "class ImageMagickWriter(ImageMagickBase, MovieWriter):\n    \"\"\"\n    Pipe-based animated gif.\n\n    Frames are streamed directly to ImageMagick via a pipe and written\n    in a single pass.\n    \"\"\"\n\n    input_names = \"-\"  # stdin",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriter",
      "name": "MovieWriter",
      "qname": "lib.matplotlib.animation.MovieWriter",
      "decorators": [],
      "superclasses": [
        "AbstractMovieWriter"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/MovieWriter/__init__",
        "matplotlib/lib.matplotlib.animation/MovieWriter/_adjust_frame_size",
        "matplotlib/lib.matplotlib.animation/MovieWriter/setup",
        "matplotlib/lib.matplotlib.animation/MovieWriter/_run",
        "matplotlib/lib.matplotlib.animation/MovieWriter/finish",
        "matplotlib/lib.matplotlib.animation/MovieWriter/grab_frame",
        "matplotlib/lib.matplotlib.animation/MovieWriter/_args",
        "matplotlib/lib.matplotlib.animation/MovieWriter/bin_path",
        "matplotlib/lib.matplotlib.animation/MovieWriter/isAvailable"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Base class for writing movies.\n\nThis is a base class for MovieWriter subclasses that write a movie frame\ndata to a pipe. You cannot instantiate this class directly.\nSee examples for how to use its subclasses.",
      "docstring": "Base class for writing movies.\n\nThis is a base class for MovieWriter subclasses that write a movie frame\ndata to a pipe. You cannot instantiate this class directly.\nSee examples for how to use its subclasses.\n\nAttributes\n----------\nframe_format : str\n    The format used in writing frame data, defaults to 'rgba'.\nfig : `~matplotlib.figure.Figure`\n    The figure to capture data from.\n    This must be provided by the sub-classes.",
      "code": "class MovieWriter(AbstractMovieWriter):\n    \"\"\"\n    Base class for writing movies.\n\n    This is a base class for MovieWriter subclasses that write a movie frame\n    data to a pipe. You cannot instantiate this class directly.\n    See examples for how to use its subclasses.\n\n    Attributes\n    ----------\n    frame_format : str\n        The format used in writing frame data, defaults to 'rgba'.\n    fig : `~matplotlib.figure.Figure`\n        The figure to capture data from.\n        This must be provided by the sub-classes.\n    \"\"\"\n\n    # Builtin writer subclasses additionally define the _exec_key and _args_key\n    # attributes, which indicate the rcParams entries where the path to the\n    # executable and additional command-line arguments to the executable are\n    # stored.  Third-party writers cannot meaningfully set these as they cannot\n    # extend rcParams with new keys.\n\n    # Pipe-based writers only support RGBA, but file-based ones support more\n    # formats.\n    supported_formats = [\"rgba\"]\n\n    def __init__(self, fps=5, codec=None, bitrate=None, extra_args=None,\n                 metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        fps : int, default: 5\n            Movie frame rate (per second).\n        codec : str or None, default: :rc:`animation.codec`\n            The codec to use.\n        bitrate : int, default: :rc:`animation.bitrate`\n            The bitrate of the movie, in kilobits per second.  Higher values\n            means higher quality movies, but increase the file size.  A value\n            of -1 lets the underlying movie encoder select the bitrate.\n        extra_args : list of str or None, optional\n            Extra command-line arguments passed to the underlying movie\n            encoder.  The default, None, means to use\n            :rc:`animation.[name-of-encoder]_args` for the builtin writers.\n        metadata : dict[str, str], default: {}\n            A dictionary of keys and values for metadata to include in the\n            output file. Some keys that may be of use include:\n            title, artist, genre, subject, copyright, srcform, comment.\n        \"\"\"\n        if type(self) is MovieWriter:\n            # TODO MovieWriter is still an abstract class and needs to be\n            #      extended with a mixin. This should be clearer in naming\n            #      and description. For now, just give a reasonable error\n            #      message to users.\n            raise TypeError(\n                'MovieWriter cannot be instantiated directly. Please use one '\n                'of its subclasses.')\n\n        super().__init__(fps=fps, metadata=metadata, codec=codec,\n                         bitrate=bitrate)\n        self.frame_format = self.supported_formats[0]\n        self.extra_args = extra_args\n\n    def _adjust_frame_size(self):\n        if self.codec == 'h264':\n            wo, ho = self.fig.get_size_inches()\n            w, h = adjusted_figsize(wo, ho, self.dpi, 2)\n            if (wo, ho) != (w, h):\n                self.fig.set_size_inches(w, h, forward=True)\n                _log.info('figure size in inches has been adjusted '\n                          'from %s x %s to %s x %s', wo, ho, w, h)\n        else:\n            w, h = self.fig.get_size_inches()\n        _log.debug('frame size in pixels is %s x %s', *self.frame_size)\n        return w, h\n\n    def setup(self, fig, outfile, dpi=None):\n        # docstring inherited\n        super().setup(fig, outfile, dpi=dpi)\n        self._w, self._h = self._adjust_frame_size()\n        # Run here so that grab_frame() can write the data to a pipe. This\n        # eliminates the need for temp files.\n        self._run()\n\n    def _run(self):\n        # Uses subprocess to call the program for assembling frames into a\n        # movie file.  *args* returns the sequence of command line arguments\n        # from a few configuration options.\n        command = self._args()\n        _log.info('MovieWriter._run: running command: %s',\n                  cbook._pformat_subprocess(command))\n        PIPE = subprocess.PIPE\n        self._proc = subprocess.Popen(\n            command, stdin=PIPE, stdout=PIPE, stderr=PIPE,\n            creationflags=subprocess_creation_flags)\n\n    def finish(self):\n        \"\"\"Finish any processing for writing the movie.\"\"\"\n        out, err = self._proc.communicate()\n        # Use the encoding/errors that universal_newlines would use.\n        out = TextIOWrapper(BytesIO(out)).read()\n        err = TextIOWrapper(BytesIO(err)).read()\n        if out:\n            _log.log(\n                logging.WARNING if self._proc.returncode else logging.DEBUG,\n                \"MovieWriter stdout:\\n%s\", out)\n        if err:\n            _log.log(\n                logging.WARNING if self._proc.returncode else logging.DEBUG,\n                \"MovieWriter stderr:\\n%s\", err)\n        if self._proc.returncode:\n            raise subprocess.CalledProcessError(\n                self._proc.returncode, self._proc.args, out, err)\n\n    def grab_frame(self, **savefig_kwargs):\n        # docstring inherited\n        _log.debug('MovieWriter.grab_frame: Grabbing frame.')\n        # Readjust the figure size in case it has been changed by the user.\n        # All frames must have the same size to save the movie correctly.\n        self.fig.set_size_inches(self._w, self._h)\n        # Save the figure data to the sink, using the frame format and dpi.\n        self.fig.savefig(self._proc.stdin, format=self.frame_format,\n                         dpi=self.dpi, **savefig_kwargs)\n\n    def _args(self):\n        \"\"\"Assemble list of encoder-specific command-line arguments.\"\"\"\n        return NotImplementedError(\"args needs to be implemented by subclass.\")\n\n    @classmethod\n    def bin_path(cls):\n        \"\"\"\n        Return the binary path to the commandline tool used by a specific\n        subclass. This is a class method so that the tool can be looked for\n        before making a particular MovieWriter subclass available.\n        \"\"\"\n        return str(mpl.rcParams[cls._exec_key])\n\n    @classmethod\n    def isAvailable(cls):\n        \"\"\"Return whether a MovieWriter subclass is actually available.\"\"\"\n        return shutil.which(cls.bin_path()) is not None",
      "instance_attributes": [
        {
          "name": "frame_format",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "extra_args",
          "types": null
        },
        {
          "name": "_w",
          "types": null
        },
        {
          "name": "_h",
          "types": null
        },
        {
          "name": "_proc",
          "types": {
            "kind": "NamedType",
            "name": "Popen"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry",
      "name": "MovieWriterRegistry",
      "qname": "lib.matplotlib.animation.MovieWriterRegistry",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__init__",
        "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/register",
        "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/is_available",
        "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__iter__",
        "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/list",
        "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__getitem__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Registry of available writer classes by human readable name.",
      "docstring": "Registry of available writer classes by human readable name.",
      "code": "class MovieWriterRegistry:\n    \"\"\"Registry of available writer classes by human readable name.\"\"\"\n\n    def __init__(self):\n        self._registered = dict()\n\n    def register(self, name):\n        \"\"\"\n        Decorator for registering a class under a name.\n\n        Example use::\n\n            @registry.register(name)\n            class Foo:\n                pass\n        \"\"\"\n        def wrapper(writer_cls):\n            self._registered[name] = writer_cls\n            return writer_cls\n        return wrapper\n\n    def is_available(self, name):\n        \"\"\"\n        Check if given writer is available by name.\n\n        Parameters\n        ----------\n        name : str\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        try:\n            cls = self._registered[name]\n        except KeyError:\n            return False\n        return cls.isAvailable()\n\n    def __iter__(self):\n        \"\"\"Iterate over names of available writer class.\"\"\"\n        for name in self._registered:\n            if self.is_available(name):\n                yield name\n\n    def list(self):\n        \"\"\"Get a list of available MovieWriters.\"\"\"\n        return [*self]\n\n    def __getitem__(self, name):\n        \"\"\"Get an available writer class from its name.\"\"\"\n        if self.is_available(name):\n            return self._registered[name]\n        raise RuntimeError(f\"Requested MovieWriter ({name}) not available\")",
      "instance_attributes": [
        {
          "name": "_registered",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/PillowWriter",
      "name": "PillowWriter",
      "qname": "lib.matplotlib.animation.PillowWriter",
      "decorators": [
        "writers.register('pillow')"
      ],
      "superclasses": [
        "AbstractMovieWriter"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/PillowWriter/isAvailable",
        "matplotlib/lib.matplotlib.animation/PillowWriter/setup",
        "matplotlib/lib.matplotlib.animation/PillowWriter/grab_frame",
        "matplotlib/lib.matplotlib.animation/PillowWriter/finish"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class PillowWriter(AbstractMovieWriter):\n    @classmethod\n    def isAvailable(cls):\n        return True\n\n    def setup(self, fig, outfile, dpi=None):\n        super().setup(fig, outfile, dpi=dpi)\n        self._frames = []\n\n    def grab_frame(self, **savefig_kwargs):\n        buf = BytesIO()\n        self.fig.savefig(\n            buf, **{**savefig_kwargs, \"format\": \"rgba\", \"dpi\": self.dpi})\n        self._frames.append(Image.frombuffer(\n            \"RGBA\", self.frame_size, buf.getbuffer(), \"raw\", \"RGBA\", 0, 1))\n\n    def finish(self):\n        self._frames[0].save(\n            self.outfile, save_all=True, append_images=self._frames[1:],\n            duration=int(1000 / self.fps), loop=0)",
      "instance_attributes": [
        {
          "name": "_frames",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/TimedAnimation",
      "name": "TimedAnimation",
      "qname": "lib.matplotlib.animation.TimedAnimation",
      "decorators": [],
      "superclasses": [
        "Animation"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__",
        "matplotlib/lib.matplotlib.animation/TimedAnimation/_step"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "`Animation` subclass for time-based animation.\n\nA new frame is drawn every *interval* milliseconds.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.",
      "docstring": "`Animation` subclass for time-based animation.\n\nA new frame is drawn every *interval* milliseconds.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.\n\nParameters\n----------\nfig : `~matplotlib.figure.Figure`\n    The figure object used to get needed events, such as draw or resize.\ninterval : int, default: 200\n    Delay between frames in milliseconds.\nrepeat_delay : int, default: 0\n    The delay in milliseconds between consecutive animation runs, if\n    *repeat* is True.\nrepeat : bool, default: True\n    Whether the animation repeats when the sequence of frames is completed.\nblit : bool, default: False\n    Whether blitting is used to optimize drawing.",
      "code": "class TimedAnimation(Animation):\n    \"\"\"\n    `Animation` subclass for time-based animation.\n\n    A new frame is drawn every *interval* milliseconds.\n\n    .. note::\n\n        You must store the created Animation in a variable that lives as long\n        as the animation should run. Otherwise, the Animation object will be\n        garbage-collected and the animation stops.\n\n    Parameters\n    ----------\n    fig : `~matplotlib.figure.Figure`\n        The figure object used to get needed events, such as draw or resize.\n    interval : int, default: 200\n        Delay between frames in milliseconds.\n    repeat_delay : int, default: 0\n        The delay in milliseconds between consecutive animation runs, if\n        *repeat* is True.\n    repeat : bool, default: True\n        Whether the animation repeats when the sequence of frames is completed.\n    blit : bool, default: False\n        Whether blitting is used to optimize drawing.\n    \"\"\"\n\n    def __init__(self, fig, interval=200, repeat_delay=0, repeat=True,\n                 event_source=None, *args, **kwargs):\n        self._interval = interval\n        # Undocumented support for repeat_delay = None as backcompat.\n        self._repeat_delay = repeat_delay if repeat_delay is not None else 0\n        self.repeat = repeat\n        # If we're not given an event source, create a new timer. This permits\n        # sharing timers between animation objects for syncing animations.\n        if event_source is None:\n            event_source = fig.canvas.new_timer(interval=self._interval)\n        super().__init__(fig, event_source=event_source, *args, **kwargs)\n\n    def _step(self, *args):\n        \"\"\"Handler for getting events.\"\"\"\n        # Extends the _step() method for the Animation class.  If\n        # Animation._step signals that it reached the end and we want to\n        # repeat, we refresh the frame sequence and return True. If\n        # _repeat_delay is set, change the event_source's interval to our loop\n        # delay and set the callback to one which will then set the interval\n        # back.\n        still_going = super()._step(*args)\n        if not still_going:\n            if self.repeat:\n                # Restart the draw loop\n                self._init_draw()\n                self.frame_seq = self.new_frame_seq()\n                self.event_source.interval = self._repeat_delay\n                return True\n            else:\n                # We are done with the animation. Call pause to remove\n                # animated flags from artists that were using blitting\n                self.pause()\n                if self._blit:\n                    # Remove the resize callback if we were blitting\n                    self._fig.canvas.mpl_disconnect(self._resize_id)\n                self._fig.canvas.mpl_disconnect(self._close_id)\n                self.event_source = None\n                return False\n\n        self.event_source.interval = self._interval\n        return True",
      "instance_attributes": [
        {
          "name": "_interval",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_repeat_delay",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "repeat",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "frame_seq",
          "types": null
        },
        {
          "name": "event_source",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist",
      "name": "Artist",
      "qname": "lib.matplotlib.artist.Artist",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.artist/Artist/__init_subclass__",
        "matplotlib/lib.matplotlib.artist/Artist/_update_set_signature_and_docstring",
        "matplotlib/lib.matplotlib.artist/Artist/__init__",
        "matplotlib/lib.matplotlib.artist/Artist/__getstate__",
        "matplotlib/lib.matplotlib.artist/Artist/remove",
        "matplotlib/lib.matplotlib.artist/Artist/have_units",
        "matplotlib/lib.matplotlib.artist/Artist/convert_xunits",
        "matplotlib/lib.matplotlib.artist/Artist/convert_yunits",
        "matplotlib/lib.matplotlib.artist/Artist/axes@getter",
        "matplotlib/lib.matplotlib.artist/Artist/axes@setter",
        "matplotlib/lib.matplotlib.artist/Artist/stale@getter",
        "matplotlib/lib.matplotlib.artist/Artist/stale@setter",
        "matplotlib/lib.matplotlib.artist/Artist/get_window_extent",
        "matplotlib/lib.matplotlib.artist/Artist/get_tightbbox",
        "matplotlib/lib.matplotlib.artist/Artist/add_callback",
        "matplotlib/lib.matplotlib.artist/Artist/remove_callback",
        "matplotlib/lib.matplotlib.artist/Artist/pchanged",
        "matplotlib/lib.matplotlib.artist/Artist/is_transform_set",
        "matplotlib/lib.matplotlib.artist/Artist/set_transform",
        "matplotlib/lib.matplotlib.artist/Artist/get_transform",
        "matplotlib/lib.matplotlib.artist/Artist/get_children",
        "matplotlib/lib.matplotlib.artist/Artist/_default_contains",
        "matplotlib/lib.matplotlib.artist/Artist/contains",
        "matplotlib/lib.matplotlib.artist/Artist/pickable",
        "matplotlib/lib.matplotlib.artist/Artist/pick",
        "matplotlib/lib.matplotlib.artist/Artist/set_picker",
        "matplotlib/lib.matplotlib.artist/Artist/get_picker",
        "matplotlib/lib.matplotlib.artist/Artist/get_url",
        "matplotlib/lib.matplotlib.artist/Artist/set_url",
        "matplotlib/lib.matplotlib.artist/Artist/get_gid",
        "matplotlib/lib.matplotlib.artist/Artist/set_gid",
        "matplotlib/lib.matplotlib.artist/Artist/get_snap",
        "matplotlib/lib.matplotlib.artist/Artist/set_snap",
        "matplotlib/lib.matplotlib.artist/Artist/get_sketch_params",
        "matplotlib/lib.matplotlib.artist/Artist/set_sketch_params",
        "matplotlib/lib.matplotlib.artist/Artist/set_path_effects",
        "matplotlib/lib.matplotlib.artist/Artist/get_path_effects",
        "matplotlib/lib.matplotlib.artist/Artist/get_figure",
        "matplotlib/lib.matplotlib.artist/Artist/set_figure",
        "matplotlib/lib.matplotlib.artist/Artist/set_clip_box",
        "matplotlib/lib.matplotlib.artist/Artist/set_clip_path",
        "matplotlib/lib.matplotlib.artist/Artist/get_alpha",
        "matplotlib/lib.matplotlib.artist/Artist/get_visible",
        "matplotlib/lib.matplotlib.artist/Artist/get_animated",
        "matplotlib/lib.matplotlib.artist/Artist/get_in_layout",
        "matplotlib/lib.matplotlib.artist/Artist/_fully_clipped_to_axes",
        "matplotlib/lib.matplotlib.artist/Artist/get_clip_on",
        "matplotlib/lib.matplotlib.artist/Artist/get_clip_box",
        "matplotlib/lib.matplotlib.artist/Artist/get_clip_path",
        "matplotlib/lib.matplotlib.artist/Artist/get_transformed_clip_path_and_affine",
        "matplotlib/lib.matplotlib.artist/Artist/set_clip_on",
        "matplotlib/lib.matplotlib.artist/Artist/_set_gc_clip",
        "matplotlib/lib.matplotlib.artist/Artist/get_rasterized",
        "matplotlib/lib.matplotlib.artist/Artist/set_rasterized",
        "matplotlib/lib.matplotlib.artist/Artist/get_agg_filter",
        "matplotlib/lib.matplotlib.artist/Artist/set_agg_filter",
        "matplotlib/lib.matplotlib.artist/Artist/draw",
        "matplotlib/lib.matplotlib.artist/Artist/set_alpha",
        "matplotlib/lib.matplotlib.artist/Artist/_set_alpha_for_array",
        "matplotlib/lib.matplotlib.artist/Artist/set_visible",
        "matplotlib/lib.matplotlib.artist/Artist/set_animated",
        "matplotlib/lib.matplotlib.artist/Artist/set_in_layout",
        "matplotlib/lib.matplotlib.artist/Artist/get_label",
        "matplotlib/lib.matplotlib.artist/Artist/set_label",
        "matplotlib/lib.matplotlib.artist/Artist/get_zorder",
        "matplotlib/lib.matplotlib.artist/Artist/set_zorder",
        "matplotlib/lib.matplotlib.artist/Artist/sticky_edges@getter",
        "matplotlib/lib.matplotlib.artist/Artist/update_from",
        "matplotlib/lib.matplotlib.artist/Artist/properties",
        "matplotlib/lib.matplotlib.artist/Artist/_update_props",
        "matplotlib/lib.matplotlib.artist/Artist/update",
        "matplotlib/lib.matplotlib.artist/Artist/_internal_update",
        "matplotlib/lib.matplotlib.artist/Artist/set",
        "matplotlib/lib.matplotlib.artist/Artist/_cm_set",
        "matplotlib/lib.matplotlib.artist/Artist/findobj",
        "matplotlib/lib.matplotlib.artist/Artist/get_cursor_data",
        "matplotlib/lib.matplotlib.artist/Artist/format_cursor_data",
        "matplotlib/lib.matplotlib.artist/Artist/get_mouseover",
        "matplotlib/lib.matplotlib.artist/Artist/set_mouseover"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.",
      "docstring": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.",
      "code": "class Artist:\n    \"\"\"\n    Abstract base class for objects that render into a FigureCanvas.\n\n    Typically, all visible elements in a figure are subclasses of Artist.\n    \"\"\"\n\n    zorder = 0\n\n    def __init_subclass__(cls):\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._update_set_signature_and_docstring()\n\n    _PROPERTIES_EXCLUDED_FROM_SET = [\n        'navigate_mode',  # not a user-facing function\n        'figure',         # changing the figure is such a profound operation\n                          # that we don't want this in set()\n        '3d_properties',  # cannot be used as a keyword due to leading digit\n    ]\n\n    @classmethod\n    def _update_set_signature_and_docstring(cls):\n        \"\"\"\n        Update the signature of the set function to list all properties\n        as keyword arguments.\n\n        Property aliases are not listed in the signature for brevity, but\n        are still accepted as keyword arguments.\n        \"\"\"\n        cls.set.__signature__ = Signature(\n            [Parameter(\"self\", Parameter.POSITIONAL_OR_KEYWORD),\n             *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_UNSET)\n               for prop in ArtistInspector(cls).get_setters()\n               if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])\n        cls.set._autogenerated_signature = True\n\n        cls.set.__doc__ = (\n            \"Set multiple properties at once.\\n\\n\"\n            \"Supported properties are\\n\\n\"\n            + kwdoc(cls))\n\n    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self.figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True\n\n    def __getstate__(self):\n        d = self.__dict__.copy()\n        # remove the unpicklable remove method, this will get re-added on load\n        # (by the Axes) if the artist lives on an Axes.\n        d['stale_callback'] = None\n        return d\n\n    def remove(self):\n        \"\"\"\n        Remove the artist from the figure if possible.\n\n        The effect will not be visible until the figure is redrawn, e.g.,\n        with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n        update the axes limits if desired.\n\n        Note: `~.axes.Axes.relim` will not see collections even if the\n        collection was added to the axes with *autolim* = True.\n\n        Note: there is no support for removing the artist's legend entry.\n        \"\"\"\n\n        # There is no method to set the callback.  Instead the parent should\n        # set the _remove_method attribute directly.  This would be a\n        # protected attribute if Python supported that sort of thing.  The\n        # callback has one parameter, which is the child to be removed.\n        if self._remove_method is not None:\n            self._remove_method(self)\n            # clear stale callback\n            self.stale_callback = None\n            _ax_flag = False\n            if hasattr(self, 'axes') and self.axes:\n                # remove from the mouse hit list\n                self.axes._mouseover_set.discard(self)\n                self.axes.stale = True\n                self.axes = None  # decouple the artist from the Axes\n                _ax_flag = True\n\n            if self.figure:\n                self.figure = None\n                if not _ax_flag:\n                    self.figure = True\n\n        else:\n            raise NotImplementedError('cannot remove artist')\n        # TODO: the fix for the collections relim problem is to move the\n        # limits calculation into the artist itself, including the property of\n        # whether or not the artist should affect the limits.  Then there will\n        # be no distinction between axes.add_line, axes.add_patch, etc.\n        # TODO: add legend support\n\n    def have_units(self):\n        \"\"\"Return whether units are set on any axis.\"\"\"\n        ax = self.axes\n        return ax and any(axis.have_units() for axis in ax._axis_map.values())\n\n    def convert_xunits(self, x):\n        \"\"\"\n        Convert *x* using the unit type of the xaxis.\n\n        If the artist is not contained in an Axes or if the xaxis does not\n        have units, *x* itself is returned.\n        \"\"\"\n        ax = getattr(self, 'axes', None)\n        if ax is None or ax.xaxis is None:\n            return x\n        return ax.xaxis.convert_units(x)\n\n    def convert_yunits(self, y):\n        \"\"\"\n        Convert *y* using the unit type of the yaxis.\n\n        If the artist is not contained in an Axes or if the yaxis does not\n        have units, *y* itself is returned.\n        \"\"\"\n        ax = getattr(self, 'axes', None)\n        if ax is None or ax.yaxis is None:\n            return y\n        return ax.yaxis.convert_units(y)\n\n    @property\n    def axes(self):\n        \"\"\"The `~.axes.Axes` instance the artist resides in, or *None*.\"\"\"\n        return self._axes\n\n    @axes.setter\n    def axes(self, new_axes):\n        if (new_axes is not None and self._axes is not None\n                and new_axes != self._axes):\n            raise ValueError(\"Can not reset the axes.  You are probably \"\n                             \"trying to re-use an artist in more than one \"\n                             \"Axes which is not supported\")\n        self._axes = new_axes\n        if new_axes is not None and new_axes is not self:\n            self.stale_callback = _stale_axes_callback\n\n    @property\n    def stale(self):\n        \"\"\"\n        Whether the artist is 'stale' and needs to be re-drawn for the output\n        to match the internal state of the artist.\n        \"\"\"\n        return self._stale\n\n    @stale.setter\n    def stale(self, val):\n        self._stale = val\n\n        # if the artist is animated it does not take normal part in the\n        # draw stack and is not expected to be drawn as part of the normal\n        # draw loop (when not saving) so do not propagate this change\n        if self.get_animated():\n            return\n\n        if val and self.stale_callback is not None:\n            self.stale_callback(self, val)\n\n    def get_window_extent(self, renderer=None):\n        \"\"\"\n        Get the artist's bounding box in display space.\n\n        The bounding box' width and height are nonnegative.\n\n        Subclasses should override for inclusion in the bounding box\n        \"tight\" calculation. Default is to return an empty bounding\n        box at 0, 0.\n\n        Be careful when using this function, the results will not update\n        if the artist window extent of the artist changes.  The extent\n        can change due to any changes in the transform stack, such as\n        changing the axes limits, the figure size, or the canvas used\n        (as is done when saving a figure).  This can lead to unexpected\n        behavior where interactive figures will look fine on the screen,\n        but will save incorrectly.\n        \"\"\"\n        return Bbox([[0, 0], [0, 0]])\n\n    def get_tightbbox(self, renderer=None):\n        \"\"\"\n        Like `.Artist.get_window_extent`, but includes any clipping.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n            renderer that will be used to draw the figures (i.e.\n            ``fig.canvas.get_renderer()``)\n\n        Returns\n        -------\n        `.Bbox`\n            The enclosing bounding box (in figure pixel coordinates).\n        \"\"\"\n        bbox = self.get_window_extent(renderer)\n        if self.get_clip_on():\n            clip_box = self.get_clip_box()\n            if clip_box is not None:\n                bbox = Bbox.intersection(bbox, clip_box)\n            clip_path = self.get_clip_path()\n            if clip_path is not None:\n                clip_path = clip_path.get_fully_transformed_path()\n                bbox = Bbox.intersection(bbox, clip_path.get_extents())\n        return bbox\n\n    def add_callback(self, func):\n        \"\"\"\n        Add a callback function that will be called whenever one of the\n        `.Artist`'s properties changes.\n\n        Parameters\n        ----------\n        func : callable\n            The callback function. It must have the signature::\n\n                def func(artist: Artist) -> Any\n\n            where *artist* is the calling `.Artist`. Return values may exist\n            but are ignored.\n\n        Returns\n        -------\n        int\n            The observer id associated with the callback. This id can be\n            used for removing the callback with `.remove_callback` later.\n\n        See Also\n        --------\n        remove_callback\n        \"\"\"\n        # Wrapping func in a lambda ensures it can be connected multiple times\n        # and never gets weakref-gc'ed.\n        return self._callbacks.connect(\"pchanged\", lambda: func(self))\n\n    def remove_callback(self, oid):\n        \"\"\"\n        Remove a callback based on its observer id.\n\n        See Also\n        --------\n        add_callback\n        \"\"\"\n        self._callbacks.disconnect(oid)\n\n    def pchanged(self):\n        \"\"\"\n        Call all of the registered callbacks.\n\n        This function is triggered internally when a property is changed.\n\n        See Also\n        --------\n        add_callback\n        remove_callback\n        \"\"\"\n        self._callbacks.process(\"pchanged\")\n\n    def is_transform_set(self):\n        \"\"\"\n        Return whether the Artist has an explicitly set transform.\n\n        This is *True* after `.set_transform` has been called.\n        \"\"\"\n        return self._transformSet\n\n    def set_transform(self, t):\n        \"\"\"\n        Set the artist transform.\n\n        Parameters\n        ----------\n        t : `.Transform`\n        \"\"\"\n        self._transform = t\n        self._transformSet = True\n        self.pchanged()\n        self.stale = True\n\n    def get_transform(self):\n        \"\"\"Return the `.Transform` instance used by this artist.\"\"\"\n        if self._transform is None:\n            self._transform = IdentityTransform()\n        elif (not isinstance(self._transform, Transform)\n              and hasattr(self._transform, '_as_mpl_transform')):\n            self._transform = self._transform._as_mpl_transform(self.axes)\n        return self._transform\n\n    def get_children(self):\n        r\"\"\"Return a list of the child `.Artist`\\s of this `.Artist`.\"\"\"\n        return []\n\n    def _default_contains(self, mouseevent, figure=None):\n        \"\"\"\n        Base impl. for checking whether a mouseevent happened in an artist.\n\n        1. If the artist figure is known and the event did not occur in that\n           figure (by checking its ``canvas`` attribute), reject it.\n        2. Otherwise, return `None, {}`, indicating that the subclass'\n           implementation should be used.\n\n        Subclasses should start their definition of `contains` as follows:\n\n            inside, info = self._default_contains(mouseevent)\n            if inside is not None:\n                return inside, info\n            # subclass-specific implementation follows\n\n        The *figure* kwarg is provided for the implementation of\n        `.Figure.contains`.\n        \"\"\"\n        if figure is not None and mouseevent.canvas is not figure.canvas:\n            return False, {}\n        return None, {}\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the artist contains the mouse event.\n\n        Parameters\n        ----------\n        mouseevent : `matplotlib.backend_bases.MouseEvent`\n\n        Returns\n        -------\n        contains : bool\n            Whether any values are within the radius.\n        details : dict\n            An artist-specific dictionary of details of the event context,\n            such as which points are contained in the pick radius. See the\n            individual Artist subclasses for details.\n        \"\"\"\n        inside, info = self._default_contains(mouseevent)\n        if inside is not None:\n            return inside, info\n        _log.warning(\"%r needs 'contains' method\", self.__class__.__name__)\n        return False, {}\n\n    def pickable(self):\n        \"\"\"\n        Return whether the artist is pickable.\n\n        See Also\n        --------\n        set_picker, get_picker, pick\n        \"\"\"\n        return self.figure is not None and self._picker is not None\n\n    def pick(self, mouseevent):\n        \"\"\"\n        Process a pick event.\n\n        Each child artist will fire a pick event if *mouseevent* is over\n        the artist and the artist has picker set.\n\n        See Also\n        --------\n        set_picker, get_picker, pickable\n        \"\"\"\n        from .backend_bases import PickEvent  # Circular import.\n        # Pick self\n        if self.pickable():\n            picker = self.get_picker()\n            if callable(picker):\n                inside, prop = picker(self, mouseevent)\n            else:\n                inside, prop = self.contains(mouseevent)\n            if inside:\n                PickEvent(\"pick_event\", self.figure.canvas,\n                          mouseevent, self, **prop)._process()\n\n        # Pick children\n        for a in self.get_children():\n            # make sure the event happened in the same Axes\n            ax = getattr(a, 'axes', None)\n            if (mouseevent.inaxes is None or ax is None\n                    or mouseevent.inaxes == ax):\n                # we need to check if mouseevent.inaxes is None\n                # because some objects associated with an Axes (e.g., a\n                # tick label) can be outside the bounding box of the\n                # Axes and inaxes will be None\n                # also check that ax is None so that it traverse objects\n                # which do no have an axes property but children might\n                a.pick(mouseevent)\n\n    def set_picker(self, picker):\n        \"\"\"\n        Define the picking behavior of the artist.\n\n        Parameters\n        ----------\n        picker : None or bool or float or callable\n            This can be one of the following:\n\n            - *None*: Picking is disabled for this artist (default).\n\n            - A boolean: If *True* then picking will be enabled and the\n              artist will fire a pick event if the mouse event is over\n              the artist.\n\n            - A float: If picker is a number it is interpreted as an\n              epsilon tolerance in points and the artist will fire\n              off an event if its data is within epsilon of the mouse\n              event.  For some artists like lines and patch collections,\n              the artist may provide additional data to the pick event\n              that is generated, e.g., the indices of the data within\n              epsilon of the pick event\n\n            - A function: If picker is callable, it is a user supplied\n              function which determines whether the artist is hit by the\n              mouse event::\n\n                hit, props = picker(artist, mouseevent)\n\n              to determine the hit test.  if the mouse event is over the\n              artist, return *hit=True* and props is a dictionary of\n              properties you want added to the PickEvent attributes.\n        \"\"\"\n        self._picker = picker\n\n    def get_picker(self):\n        \"\"\"\n        Return the picking behavior of the artist.\n\n        The possible values are described in `.set_picker`.\n\n        See Also\n        --------\n        set_picker, pickable, pick\n        \"\"\"\n        return self._picker\n\n    def get_url(self):\n        \"\"\"Return the url.\"\"\"\n        return self._url\n\n    def set_url(self, url):\n        \"\"\"\n        Set the url for the artist.\n\n        Parameters\n        ----------\n        url : str\n        \"\"\"\n        self._url = url\n\n    def get_gid(self):\n        \"\"\"Return the group id.\"\"\"\n        return self._gid\n\n    def set_gid(self, gid):\n        \"\"\"\n        Set the (group) id for the artist.\n\n        Parameters\n        ----------\n        gid : str\n        \"\"\"\n        self._gid = gid\n\n    def get_snap(self):\n        \"\"\"\n        Return the snap setting.\n\n        See `.set_snap` for details.\n        \"\"\"\n        if mpl.rcParams['path.snap']:\n            return self._snap\n        else:\n            return False\n\n    def set_snap(self, snap):\n        \"\"\"\n        Set the snapping behavior.\n\n        Snapping aligns positions with the pixel grid, which results in\n        clearer images. For example, if a black line of 1px width was\n        defined at a position in between two pixels, the resulting image\n        would contain the interpolated value of that line in the pixel grid,\n        which would be a grey value on both adjacent pixel positions. In\n        contrast, snapping will move the line to the nearest integer pixel\n        value, so that the resulting image will really contain a 1px wide\n        black line.\n\n        Snapping is currently only supported by the Agg and MacOSX backends.\n\n        Parameters\n        ----------\n        snap : bool or None\n            Possible values:\n\n            - *True*: Snap vertices to the nearest pixel center.\n            - *False*: Do not modify vertex positions.\n            - *None*: (auto) If the path contains only rectilinear line\n              segments, round to the nearest pixel center.\n        \"\"\"\n        self._snap = snap\n        self.stale = True\n\n    def get_sketch_params(self):\n        \"\"\"\n        Return the sketch parameters for the artist.\n\n        Returns\n        -------\n        tuple or None\n\n            A 3-tuple with the following elements:\n\n            - *scale*: The amplitude of the wiggle perpendicular to the\n              source line.\n            - *length*: The length of the wiggle along the line.\n            - *randomness*: The scale factor by which the length is\n              shrunken or expanded.\n\n            Returns *None* if no sketch parameters were set.\n        \"\"\"\n        return self._sketch\n\n    def set_sketch_params(self, scale=None, length=None, randomness=None):\n        \"\"\"\n        Set the sketch parameters.\n\n        Parameters\n        ----------\n        scale : float, optional\n            The amplitude of the wiggle perpendicular to the source\n            line, in pixels.  If scale is `None`, or not provided, no\n            sketch filter will be provided.\n        length : float, optional\n             The length of the wiggle along the line, in pixels\n             (default 128.0)\n        randomness : float, optional\n            The scale factor by which the length is shrunken or\n            expanded (default 16.0)\n\n            The PGF backend uses this argument as an RNG seed and not as\n            described above. Using the same seed yields the same random shape.\n\n            .. ACCEPTS: (scale: float, length: float, randomness: float)\n        \"\"\"\n        if scale is None:\n            self._sketch = None\n        else:\n            self._sketch = (scale, length or 128.0, randomness or 16.0)\n        self.stale = True\n\n    def set_path_effects(self, path_effects):\n        \"\"\"\n        Set the path effects.\n\n        Parameters\n        ----------\n        path_effects : `.AbstractPathEffect`\n        \"\"\"\n        self._path_effects = path_effects\n        self.stale = True\n\n    def get_path_effects(self):\n        return self._path_effects\n\n    def get_figure(self):\n        \"\"\"Return the `.Figure` instance the artist belongs to.\"\"\"\n        return self.figure\n\n    def set_figure(self, fig):\n        \"\"\"\n        Set the `.Figure` instance the artist belongs to.\n\n        Parameters\n        ----------\n        fig : `.Figure`\n        \"\"\"\n        # if this is a no-op just return\n        if self.figure is fig:\n            return\n        # if we currently have a figure (the case of both `self.figure`\n        # and *fig* being none is taken care of above) we then user is\n        # trying to change the figure an artist is associated with which\n        # is not allowed for the same reason as adding the same instance\n        # to more than one Axes\n        if self.figure is not None:\n            raise RuntimeError(\"Can not put single artist in \"\n                               \"more than one figure\")\n        self.figure = fig\n        if self.figure and self.figure is not self:\n            self.pchanged()\n        self.stale = True\n\n    def set_clip_box(self, clipbox):\n        \"\"\"\n        Set the artist's clip `.Bbox`.\n\n        Parameters\n        ----------\n        clipbox : `.Bbox`\n        \"\"\"\n        self.clipbox = clipbox\n        self.pchanged()\n        self.stale = True\n\n    def set_clip_path(self, path, transform=None):\n        \"\"\"\n        Set the artist's clip path.\n\n        Parameters\n        ----------\n        path : `.Patch` or `.Path` or `.TransformedPath` or None\n            The clip path. If given a `.Path`, *transform* must be provided as\n            well. If *None*, a previously set clip path is removed.\n        transform : `~matplotlib.transforms.Transform`, optional\n            Only used if *path* is a `.Path`, in which case the given `.Path`\n            is converted to a `.TransformedPath` using *transform*.\n\n        Notes\n        -----\n        For efficiency, if *path* is a `.Rectangle` this method will set the\n        clipping box to the corresponding rectangle and set the clipping path\n        to ``None``.\n\n        For technical reasons (support of `~.Artist.set`), a tuple\n        (*path*, *transform*) is also accepted as a single positional\n        parameter.\n\n        .. ACCEPTS: Patch or (Path, Transform) or None\n        \"\"\"\n        from matplotlib.patches import Patch, Rectangle\n\n        success = False\n        if transform is None:\n            if isinstance(path, Rectangle):\n                self.clipbox = TransformedBbox(Bbox.unit(),\n                                               path.get_transform())\n                self._clippath = None\n                success = True\n            elif isinstance(path, Patch):\n                self._clippath = TransformedPatchPath(path)\n                success = True\n            elif isinstance(path, tuple):\n                path, transform = path\n\n        if path is None:\n            self._clippath = None\n            success = True\n        elif isinstance(path, Path):\n            self._clippath = TransformedPath(path, transform)\n            success = True\n        elif isinstance(path, TransformedPatchPath):\n            self._clippath = path\n            success = True\n        elif isinstance(path, TransformedPath):\n            self._clippath = path\n            success = True\n\n        if not success:\n            raise TypeError(\n                \"Invalid arguments to set_clip_path, of type {} and {}\"\n                .format(type(path).__name__, type(transform).__name__))\n        # This may result in the callbacks being hit twice, but guarantees they\n        # will be hit at least once.\n        self.pchanged()\n        self.stale = True\n\n    def get_alpha(self):\n        \"\"\"\n        Return the alpha value used for blending - not supported on all\n        backends.\n        \"\"\"\n        return self._alpha\n\n    def get_visible(self):\n        \"\"\"Return the visibility.\"\"\"\n        return self._visible\n\n    def get_animated(self):\n        \"\"\"Return whether the artist is animated.\"\"\"\n        return self._animated\n\n    def get_in_layout(self):\n        \"\"\"\n        Return boolean flag, ``True`` if artist is included in layout\n        calculations.\n\n        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n        `.Figure.tight_layout()`, and\n        ``fig.savefig(fname, bbox_inches='tight')``.\n        \"\"\"\n        return self._in_layout\n\n    def _fully_clipped_to_axes(self):\n        \"\"\"\n        Return a boolean flag, ``True`` if the artist is clipped to the Axes\n        and can thus be skipped in layout calculations. Requires `get_clip_on`\n        is True, one of `clip_box` or `clip_path` is set, ``clip_box.extents``\n        is equivalent to ``ax.bbox.extents`` (if set), and ``clip_path._patch``\n        is equivalent to ``ax.patch`` (if set).\n        \"\"\"\n        # Note that ``clip_path.get_fully_transformed_path().get_extents()``\n        # cannot be directly compared to ``axes.bbox.extents`` because the\n        # extents may be undefined (i.e. equivalent to ``Bbox.null()``)\n        # before the associated artist is drawn, and this method is meant\n        # to determine whether ``axes.get_tightbbox()`` may bypass drawing\n        clip_box = self.get_clip_box()\n        clip_path = self.get_clip_path()\n        return (self.axes is not None\n                and self.get_clip_on()\n                and (clip_box is not None or clip_path is not None)\n                and (clip_box is None\n                     or np.all(clip_box.extents == self.axes.bbox.extents))\n                and (clip_path is None\n                     or isinstance(clip_path, TransformedPatchPath)\n                     and clip_path._patch is self.axes.patch))\n\n    def get_clip_on(self):\n        \"\"\"Return whether the artist uses clipping.\"\"\"\n        return self._clipon\n\n    def get_clip_box(self):\n        \"\"\"Return the clipbox.\"\"\"\n        return self.clipbox\n\n    def get_clip_path(self):\n        \"\"\"Return the clip path.\"\"\"\n        return self._clippath\n\n    def get_transformed_clip_path_and_affine(self):\n        \"\"\"\n        Return the clip path with the non-affine part of its\n        transformation applied, and the remaining affine part of its\n        transformation.\n        \"\"\"\n        if self._clippath is not None:\n            return self._clippath.get_transformed_path_and_affine()\n        return None, None\n\n    def set_clip_on(self, b):\n        \"\"\"\n        Set whether the artist uses clipping.\n\n        When False artists will be visible outside of the Axes which\n        can lead to unexpected results.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._clipon = b\n        # This may result in the callbacks being hit twice, but ensures they\n        # are hit at least once\n        self.pchanged()\n        self.stale = True\n\n    def _set_gc_clip(self, gc):\n        \"\"\"Set the clip properly for the gc.\"\"\"\n        if self._clipon:\n            if self.clipbox is not None:\n                gc.set_clip_rectangle(self.clipbox)\n            gc.set_clip_path(self._clippath)\n        else:\n            gc.set_clip_rectangle(None)\n            gc.set_clip_path(None)\n\n    def get_rasterized(self):\n        \"\"\"Return whether the artist is to be rasterized.\"\"\"\n        return self._rasterized\n\n    def set_rasterized(self, rasterized):\n        \"\"\"\n        Force rasterized (bitmap) drawing for vector graphics output.\n\n        Rasterized drawing is not supported by all artists. If you try to\n        enable this on an artist that does not support it, the command has no\n        effect and a warning will be issued.\n\n        This setting is ignored for pixel-based output.\n\n        See also :doc:`/gallery/misc/rasterization_demo`.\n\n        Parameters\n        ----------\n        rasterized : bool\n        \"\"\"\n        if rasterized and not hasattr(self.draw, \"_supports_rasterization\"):\n            _api.warn_external(f\"Rasterization of '{self}' will be ignored\")\n\n        self._rasterized = rasterized\n\n    def get_agg_filter(self):\n        \"\"\"Return filter function to be used for agg filter.\"\"\"\n        return self._agg_filter\n\n    def set_agg_filter(self, filter_func):\n        \"\"\"\n        Set the agg filter.\n\n        Parameters\n        ----------\n        filter_func : callable\n            A filter function, which takes a (m, n, depth) float array\n            and a dpi value, and returns a (m, n, depth) array and two\n            offsets from the bottom left corner of the image\n\n            .. ACCEPTS: a filter function, which takes a (m, n, 3) float array\n                and a dpi value, and returns a (m, n, 3) array and two offsets\n                from the bottom left corner of the image\n        \"\"\"\n        self._agg_filter = filter_func\n        self.stale = True\n\n    def draw(self, renderer):\n        \"\"\"\n        Draw the Artist (and its children) using the given renderer.\n\n        This has no effect if the artist is not visible (`.Artist.get_visible`\n        returns False).\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass.\n\n        Notes\n        -----\n        This method is overridden in the Artist subclasses.\n        \"\"\"\n        if not self.get_visible():\n            return\n        self.stale = False\n\n    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        Parameters\n        ----------\n        alpha : scalar or None\n            *alpha* must be within the 0-1 range, inclusive.\n        \"\"\"\n        if alpha is not None and not isinstance(alpha, Number):\n            raise TypeError(\n                f'alpha must be numeric or None, not {type(alpha)}')\n        if alpha is not None and not (0 <= alpha <= 1):\n            raise ValueError(f'alpha ({alpha}) is outside 0-1 range')\n        self._alpha = alpha\n        self.pchanged()\n        self.stale = True\n\n    def _set_alpha_for_array(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        Parameters\n        ----------\n        alpha : array-like or scalar or None\n            All values must be within the 0-1 range, inclusive.\n            Masked values and nans are not supported.\n        \"\"\"\n        if isinstance(alpha, str):\n            raise TypeError(\"alpha must be numeric or None, not a string\")\n        if not np.iterable(alpha):\n            Artist.set_alpha(self, alpha)\n            return\n        alpha = np.asarray(alpha)\n        if not (0 <= alpha.min() and alpha.max() <= 1):\n            raise ValueError('alpha must be between 0 and 1, inclusive, '\n                             f'but min is {alpha.min()}, max is {alpha.max()}')\n        self._alpha = alpha\n        self.pchanged()\n        self.stale = True\n\n    def set_visible(self, b):\n        \"\"\"\n        Set the artist's visibility.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._visible = b\n        self.pchanged()\n        self.stale = True\n\n    def set_animated(self, b):\n        \"\"\"\n        Set whether the artist is intended to be used in an animation.\n\n        If True, the artist is excluded from regular drawing of the figure.\n        You have to call `.Figure.draw_artist` / `.Axes.draw_artist`\n        explicitly on the artist. This approach is used to speed up animations\n        using blitting.\n\n        See also `matplotlib.animation` and\n        :doc:`/tutorials/advanced/blitting`.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        if self._animated != b:\n            self._animated = b\n            self.pchanged()\n\n    def set_in_layout(self, in_layout):\n        \"\"\"\n        Set if artist is to be included in layout calculations,\n        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n        `.Figure.tight_layout()`, and\n        ``fig.savefig(fname, bbox_inches='tight')``.\n\n        Parameters\n        ----------\n        in_layout : bool\n        \"\"\"\n        self._in_layout = in_layout\n\n    def get_label(self):\n        \"\"\"Return the label used for this artist in the legend.\"\"\"\n        return self._label\n\n    def set_label(self, s):\n        \"\"\"\n        Set a label that will be displayed in the legend.\n\n        Parameters\n        ----------\n        s : object\n            *s* will be converted to a string by calling `str`.\n        \"\"\"\n        if s is not None:\n            self._label = str(s)\n        else:\n            self._label = None\n        self.pchanged()\n        self.stale = True\n\n    def get_zorder(self):\n        \"\"\"Return the artist's zorder.\"\"\"\n        return self.zorder\n\n    def set_zorder(self, level):\n        \"\"\"\n        Set the zorder for the artist.  Artists with lower zorder\n        values are drawn first.\n\n        Parameters\n        ----------\n        level : float\n        \"\"\"\n        if level is None:\n            level = self.__class__.zorder\n        self.zorder = level\n        self.pchanged()\n        self.stale = True\n\n    @property\n    def sticky_edges(self):\n        \"\"\"\n        ``x`` and ``y`` sticky edge lists for autoscaling.\n\n        When performing autoscaling, if a data limit coincides with a value in\n        the corresponding sticky_edges list, then no margin will be added--the\n        view limit \"sticks\" to the edge. A typical use case is histograms,\n        where one usually expects no margin on the bottom edge (0) of the\n        histogram.\n\n        Moreover, margin expansion \"bumps\" against sticky edges and cannot\n        cross them.  For example, if the upper data limit is 1.0, the upper\n        view limit computed by simple margin application is 1.2, but there is a\n        sticky edge at 1.1, then the actual upper view limit will be 1.1.\n\n        This attribute cannot be assigned to; however, the ``x`` and ``y``\n        lists can be modified in place as needed.\n\n        Examples\n        --------\n        >>> artist.sticky_edges.x[:] = (xmin, xmax)\n        >>> artist.sticky_edges.y[:] = (ymin, ymax)\n\n        \"\"\"\n        return self._sticky_edges\n\n    def update_from(self, other):\n        \"\"\"Copy properties from *other* to *self*.\"\"\"\n        self._transform = other._transform\n        self._transformSet = other._transformSet\n        self._visible = other._visible\n        self._alpha = other._alpha\n        self.clipbox = other.clipbox\n        self._clipon = other._clipon\n        self._clippath = other._clippath\n        self._label = other._label\n        self._sketch = other._sketch\n        self._path_effects = other._path_effects\n        self.sticky_edges.x[:] = other.sticky_edges.x.copy()\n        self.sticky_edges.y[:] = other.sticky_edges.y.copy()\n        self.pchanged()\n        self.stale = True\n\n    def properties(self):\n        \"\"\"Return a dictionary of all the properties of the artist.\"\"\"\n        return ArtistInspector(self).properties()\n\n    def _update_props(self, props, errfmt):\n        \"\"\"\n        Helper for `.Artist.set` and `.Artist.update`.\n\n        *errfmt* is used to generate error messages for invalid property\n        names; it get formatted with ``type(self)`` and the property name.\n        \"\"\"\n        ret = []\n        with cbook._setattr_cm(self, eventson=False):\n            for k, v in props.items():\n                # Allow attributes we want to be able to update through\n                # art.update, art.set, setp.\n                if k == \"axes\":\n                    ret.append(setattr(self, k, v))\n                else:\n                    func = getattr(self, f\"set_{k}\", None)\n                    if not callable(func):\n                        raise AttributeError(\n                            errfmt.format(cls=type(self), prop_name=k))\n                    ret.append(func(v))\n        if ret:\n            self.pchanged()\n            self.stale = True\n        return ret\n\n    def update(self, props):\n        \"\"\"\n        Update this artist's properties from the dict *props*.\n\n        Parameters\n        ----------\n        props : dict\n        \"\"\"\n        return self._update_props(\n            props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n\n    def _internal_update(self, kwargs):\n        \"\"\"\n        Update artist properties without prenormalizing them, but generating\n        errors as if calling `set`.\n\n        The lack of prenormalization is to maintain backcompatibility.\n        \"\"\"\n        return self._update_props(\n            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n            \"{prop_name!r}\")\n\n    def set(self, **kwargs):\n        # docstring and signature are auto-generated via\n        # Artist._update_set_signature_and_docstring() at the end of the\n        # module.\n        return self._internal_update(cbook.normalize_kwargs(kwargs, self))\n\n    @contextlib.contextmanager\n    def _cm_set(self, **kwargs):\n        \"\"\"\n        `.Artist.set` context-manager that restores original values at exit.\n        \"\"\"\n        orig_vals = {k: getattr(self, f\"get_{k}\")() for k in kwargs}\n        try:\n            self.set(**kwargs)\n            yield\n        finally:\n            self.set(**orig_vals)\n\n    def findobj(self, match=None, include_self=True):\n        \"\"\"\n        Find artist objects.\n\n        Recursively find all `.Artist` instances contained in the artist.\n\n        Parameters\n        ----------\n        match\n            A filter criterion for the matches. This can be\n\n            - *None*: Return all objects contained in artist.\n            - A function with signature ``def match(artist: Artist) -> bool``.\n              The result will only contain artists for which the function\n              returns *True*.\n            - A class instance: e.g., `.Line2D`. The result will only contain\n              artists of this class or its subclasses (``isinstance`` check).\n\n        include_self : bool\n            Include *self* in the list to be checked for a match.\n\n        Returns\n        -------\n        list of `.Artist`\n\n        \"\"\"\n        if match is None:  # always return True\n            def matchfunc(x):\n                return True\n        elif isinstance(match, type) and issubclass(match, Artist):\n            def matchfunc(x):\n                return isinstance(x, match)\n        elif callable(match):\n            matchfunc = match\n        else:\n            raise ValueError('match must be None, a matplotlib.artist.Artist '\n                             'subclass, or a callable')\n\n        artists = sum([c.findobj(matchfunc) for c in self.get_children()], [])\n        if include_self and matchfunc(self):\n            artists.append(self)\n        return artists\n\n    def get_cursor_data(self, event):\n        \"\"\"\n        Return the cursor data for a given event.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        Cursor data can be used by Artists to provide additional context\n        information for a given event. The default implementation just returns\n        *None*.\n\n        Subclasses can override the method and return arbitrary data. However,\n        when doing so, they must ensure that `.format_cursor_data` can convert\n        the data to a string representation.\n\n        The only current use case is displaying the z-value of an `.AxesImage`\n        in the status bar of a plot window, while moving the mouse.\n\n        Parameters\n        ----------\n        event : `matplotlib.backend_bases.MouseEvent`\n\n        See Also\n        --------\n        format_cursor_data\n\n        \"\"\"\n        return None\n\n    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                if isinstance(self.norm, BoundaryNorm):\n                    # not an invertible normalization mapping\n                    cur_idx = np.argmin(np.abs(self.norm.boundaries - data))\n                    neigh_idx = max(0, cur_idx - 1)\n                    # use max diff to prevent delta == 0\n                    delta = np.diff(\n                        self.norm.boundaries[neigh_idx:cur_idx + 2]\n                    ).max()\n\n                else:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(normed * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n        else:\n            try:\n                data[0]\n            except (TypeError, IndexError):\n                data = [data]\n            data_str = ', '.join('{:0.3g}'.format(item) for item in data\n                                 if isinstance(item, Number))\n            return \"[\" + data_str + \"]\"\n\n    def get_mouseover(self):\n        \"\"\"\n        Return whether this artist is queried for custom context information\n        when the mouse cursor moves over it.\n        \"\"\"\n        return self._mouseover\n\n    def set_mouseover(self, mouseover):\n        \"\"\"\n        Set whether this artist is queried for custom context information when\n        the mouse cursor moves over it.\n\n        Parameters\n        ----------\n        mouseover : bool\n\n        See Also\n        --------\n        get_cursor_data\n        .ToolCursorPosition\n        .NavigationToolbar2\n        \"\"\"\n        self._mouseover = bool(mouseover)\n        ax = self.axes\n        if ax:\n            if self._mouseover:\n                ax._mouseover_set.add(self)\n            else:\n                ax._mouseover_set.discard(self)\n\n    mouseover = property(get_mouseover, set_mouseover)  # backcompat.",
      "instance_attributes": [
        {
          "name": "_stale",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "stale_callback",
          "types": {
            "kind": "NamedType",
            "name": "Callable"
          }
        },
        {
          "name": "_axes",
          "types": null
        },
        {
          "name": "figure",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_transform",
          "types": null
        },
        {
          "name": "_transformSet",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_visible",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_animated",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_alpha",
          "types": null
        },
        {
          "name": "clipbox",
          "types": null
        },
        {
          "name": "_clippath",
          "types": null
        },
        {
          "name": "_clipon",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_label",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_picker",
          "types": null
        },
        {
          "name": "_rasterized",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_agg_filter",
          "types": null
        },
        {
          "name": "_mouseover",
          "types": null
        },
        {
          "name": "_callbacks",
          "types": null
        },
        {
          "name": "axes",
          "types": null
        },
        {
          "name": "_remove_method",
          "types": null
        },
        {
          "name": "_url",
          "types": null
        },
        {
          "name": "_gid",
          "types": null
        },
        {
          "name": "_snap",
          "types": null
        },
        {
          "name": "_sketch",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "_path_effects",
          "types": null
        },
        {
          "name": "_sticky_edges",
          "types": {
            "kind": "NamedType",
            "name": "_XYPair"
          }
        },
        {
          "name": "_in_layout",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "stale",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "zorder",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector",
      "name": "ArtistInspector",
      "qname": "lib.matplotlib.artist.ArtistInspector",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.artist/ArtistInspector/__init__",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/get_aliases",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/get_valid_values",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/_replace_path",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/get_setters",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/number_of_parameters",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/is_alias",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/aliased_name",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/aliased_name_rest",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters_rest",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/properties",
        "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_getters"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper class to inspect an `~matplotlib.artist.Artist` and return\ninformation about its settable properties and their current values.",
      "docstring": "A helper class to inspect an `~matplotlib.artist.Artist` and return\ninformation about its settable properties and their current values.",
      "code": "class ArtistInspector:\n    \"\"\"\n    A helper class to inspect an `~matplotlib.artist.Artist` and return\n    information about its settable properties and their current values.\n    \"\"\"\n\n    def __init__(self, o):\n        r\"\"\"\n        Initialize the artist inspector with an `Artist` or an iterable of\n        `Artist`\\s.  If an iterable is used, we assume it is a homogeneous\n        sequence (all `Artist`\\s are of the same type) and it is your\n        responsibility to make sure this is so.\n        \"\"\"\n        if not isinstance(o, Artist):\n            if np.iterable(o):\n                o = list(o)\n                if len(o):\n                    o = o[0]\n\n        self.oorig = o\n        if not isinstance(o, type):\n            o = type(o)\n        self.o = o\n\n        self.aliasd = self.get_aliases()\n\n    def get_aliases(self):\n        \"\"\"\n        Get a dict mapping property fullnames to sets of aliases for each alias\n        in the :class:`~matplotlib.artist.ArtistInspector`.\n\n        e.g., for lines::\n\n          {'markerfacecolor': {'mfc'},\n           'linewidth'      : {'lw'},\n          }\n        \"\"\"\n        names = [name for name in dir(self.o)\n                 if name.startswith(('set_', 'get_'))\n                    and callable(getattr(self.o, name))]\n        aliases = {}\n        for name in names:\n            func = getattr(self.o, name)\n            if not self.is_alias(func):\n                continue\n            propname = re.search(\"`({}.*)`\".format(name[:4]),  # get_.*/set_.*\n                                 inspect.getdoc(func)).group(1)\n            aliases.setdefault(propname[4:], set()).add(name[4:])\n        return aliases\n\n    _get_valid_values_regex = re.compile(\n        r\"\\n\\s*(?:\\.\\.\\s+)?ACCEPTS:\\s*((?:.|\\n)*?)(?:$|(?:\\n\\n))\"\n    )\n\n    def get_valid_values(self, attr):\n        \"\"\"\n        Get the legal arguments for the setter associated with *attr*.\n\n        This is done by querying the docstring of the setter for a line that\n        begins with \"ACCEPTS:\" or \".. ACCEPTS:\", and then by looking for a\n        numpydoc-style documentation for the setter's first argument.\n        \"\"\"\n\n        name = 'set_%s' % attr\n        if not hasattr(self.o, name):\n            raise AttributeError('%s has no function %s' % (self.o, name))\n        func = getattr(self.o, name)\n\n        docstring = inspect.getdoc(func)\n        if docstring is None:\n            return 'unknown'\n\n        if docstring.startswith('Alias for '):\n            return None\n\n        match = self._get_valid_values_regex.search(docstring)\n        if match is not None:\n            return re.sub(\"\\n *\", \" \", match.group(1))\n\n        # Much faster than list(inspect.signature(func).parameters)[1],\n        # although barely relevant wrt. matplotlib's total import time.\n        param_name = func.__code__.co_varnames[1]\n        # We could set the presence * based on whether the parameter is a\n        # varargs (it can't be a varkwargs) but it's not really worth the it.\n        match = re.search(r\"(?m)^ *\\*?{} : (.+)\".format(param_name), docstring)\n        if match:\n            return match.group(1)\n\n        return 'unknown'\n\n    def _replace_path(self, source_class):\n        \"\"\"\n        Changes the full path to the public API path that is used\n        in sphinx. This is needed for links to work.\n        \"\"\"\n        replace_dict = {'_base._AxesBase': 'Axes',\n                        '_axes.Axes': 'Axes'}\n        for key, value in replace_dict.items():\n            source_class = source_class.replace(key, value)\n        return source_class\n\n    def get_setters(self):\n        \"\"\"\n        Get the attribute strings with setters for object.\n\n        For example, for a line, return ``['markerfacecolor', 'linewidth',\n        ....]``.\n        \"\"\"\n        setters = []\n        for name in dir(self.o):\n            if not name.startswith('set_'):\n                continue\n            func = getattr(self.o, name)\n            if (not callable(func)\n                    or self.number_of_parameters(func) < 2\n                    or self.is_alias(func)):\n                continue\n            setters.append(name[4:])\n        return setters\n\n    @staticmethod\n    @lru_cache(maxsize=None)\n    def number_of_parameters(func):\n        \"\"\"Return number of parameters of the callable *func*.\"\"\"\n        return len(inspect.signature(func).parameters)\n\n    @staticmethod\n    @lru_cache(maxsize=None)\n    def is_alias(method):\n        \"\"\"\n        Return whether the object *method* is an alias for another method.\n        \"\"\"\n\n        ds = inspect.getdoc(method)\n        if ds is None:\n            return False\n\n        return ds.startswith('Alias for ')\n\n    def aliased_name(self, s):\n        \"\"\"\n        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'.\n\n        e.g., for the line markerfacecolor property, which has an\n        alias, return 'markerfacecolor or mfc' and for the transform\n        property, which does not, return 'transform'.\n        \"\"\"\n        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n        return s + aliases\n\n    _NOT_LINKABLE = {\n        # A set of property setter methods that are not available in our\n        # current docs. This is a workaround used to prevent trying to link\n        # these setters which would lead to \"target reference not found\"\n        # warnings during doc build.\n        'matplotlib.image._ImageBase.set_alpha',\n        'matplotlib.image._ImageBase.set_array',\n        'matplotlib.image._ImageBase.set_data',\n        'matplotlib.image._ImageBase.set_filternorm',\n        'matplotlib.image._ImageBase.set_filterrad',\n        'matplotlib.image._ImageBase.set_interpolation',\n        'matplotlib.image._ImageBase.set_interpolation_stage',\n        'matplotlib.image._ImageBase.set_resample',\n        'matplotlib.text._AnnotationBase.set_annotation_clip',\n    }\n\n    def aliased_name_rest(self, s, target):\n        \"\"\"\n        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME',\n        formatted for reST.\n\n        e.g., for the line markerfacecolor property, which has an\n        alias, return 'markerfacecolor or mfc' and for the transform\n        property, which does not, return 'transform'.\n        \"\"\"\n        # workaround to prevent \"reference target not found\"\n        if target in self._NOT_LINKABLE:\n            return f'``{s}``'\n\n        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n        return ':meth:`%s <%s>`%s' % (s, target, aliases)\n\n    def pprint_setters(self, prop=None, leadingspace=2):\n        \"\"\"\n        If *prop* is *None*, return a list of strings of all settable\n        properties and their valid values.\n\n        If *prop* is not *None*, it is a valid property name and that\n        property will be returned as a string of property : valid\n        values.\n        \"\"\"\n        if leadingspace:\n            pad = ' ' * leadingspace\n        else:\n            pad = ''\n        if prop is not None:\n            accepts = self.get_valid_values(prop)\n            return '%s%s: %s' % (pad, prop, accepts)\n\n        lines = []\n        for prop in sorted(self.get_setters()):\n            accepts = self.get_valid_values(prop)\n            name = self.aliased_name(prop)\n            lines.append('%s%s: %s' % (pad, name, accepts))\n        return lines\n\n    def pprint_setters_rest(self, prop=None, leadingspace=4):\n        \"\"\"\n        If *prop* is *None*, return a list of reST-formatted strings of all\n        settable properties and their valid values.\n\n        If *prop* is not *None*, it is a valid property name and that\n        property will be returned as a string of \"property : valid\"\n        values.\n        \"\"\"\n        if leadingspace:\n            pad = ' ' * leadingspace\n        else:\n            pad = ''\n        if prop is not None:\n            accepts = self.get_valid_values(prop)\n            return '%s%s: %s' % (pad, prop, accepts)\n\n        prop_and_qualnames = []\n        for prop in sorted(self.get_setters()):\n            # Find the parent method which actually provides the docstring.\n            for cls in self.o.__mro__:\n                method = getattr(cls, f\"set_{prop}\", None)\n                if method and method.__doc__ is not None:\n                    break\n            else:  # No docstring available.\n                method = getattr(self.o, f\"set_{prop}\")\n            prop_and_qualnames.append(\n                (prop, f\"{method.__module__}.{method.__qualname__}\"))\n\n        names = [self.aliased_name_rest(prop, target)\n                 .replace('_base._AxesBase', 'Axes')\n                 .replace('_axes.Axes', 'Axes')\n                 for prop, target in prop_and_qualnames]\n        accepts = [self.get_valid_values(prop)\n                   for prop, _ in prop_and_qualnames]\n\n        col0_len = max(len(n) for n in names)\n        col1_len = max(len(a) for a in accepts)\n        table_formatstr = pad + '   ' + '=' * col0_len + '   ' + '=' * col1_len\n\n        return [\n            '',\n            pad + '.. table::',\n            pad + '   :class: property-table',\n            '',\n            table_formatstr,\n            pad + '   ' + 'Property'.ljust(col0_len)\n            + '   ' + 'Description'.ljust(col1_len),\n            table_formatstr,\n            *[pad + '   ' + n.ljust(col0_len) + '   ' + a.ljust(col1_len)\n              for n, a in zip(names, accepts)],\n            table_formatstr,\n            '',\n        ]\n\n    def properties(self):\n        \"\"\"Return a dictionary mapping property name -> value.\"\"\"\n        o = self.oorig\n        getters = [name for name in dir(o)\n                   if name.startswith('get_') and callable(getattr(o, name))]\n        getters.sort()\n        d = {}\n        for name in getters:\n            func = getattr(o, name)\n            if self.is_alias(func):\n                continue\n            try:\n                with warnings.catch_warnings():\n                    warnings.simplefilter('ignore')\n                    val = func()\n            except Exception:\n                continue\n            else:\n                d[name[4:]] = val\n        return d\n\n    def pprint_getters(self):\n        \"\"\"Return the getters and actual values as list of strings.\"\"\"\n        lines = []\n        for name, val in sorted(self.properties().items()):\n            if getattr(val, 'shape', ()) != () and len(val) > 6:\n                s = str(val[:6]) + '...'\n            else:\n                s = str(val)\n            s = s.replace('\\n', ' ')\n            if len(s) > 50:\n                s = s[:50] + '...'\n            name = self.aliased_name(name)\n            lines.append('    %s = %s' % (name, s))\n        return lines",
      "instance_attributes": [
        {
          "name": "oorig",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "o",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "aliasd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis",
      "name": "Axis",
      "qname": "lib.matplotlib.axis.Axis",
      "decorators": [],
      "superclasses": [
        "martist.Artist"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.axis/Axis/__str__",
        "matplotlib/lib.matplotlib.axis/Axis/__init__",
        "matplotlib/lib.matplotlib.axis/Axis/isDefault_majloc@getter",
        "matplotlib/lib.matplotlib.axis/Axis/isDefault_majloc@setter",
        "matplotlib/lib.matplotlib.axis/Axis/isDefault_majfmt@getter",
        "matplotlib/lib.matplotlib.axis/Axis/isDefault_majfmt@setter",
        "matplotlib/lib.matplotlib.axis/Axis/isDefault_minloc@getter",
        "matplotlib/lib.matplotlib.axis/Axis/isDefault_minloc@setter",
        "matplotlib/lib.matplotlib.axis/Axis/isDefault_minfmt@getter",
        "matplotlib/lib.matplotlib.axis/Axis/isDefault_minfmt@setter",
        "matplotlib/lib.matplotlib.axis/Axis/get_remove_overlapping_locs",
        "matplotlib/lib.matplotlib.axis/Axis/set_remove_overlapping_locs",
        "matplotlib/lib.matplotlib.axis/Axis/set_label_coords",
        "matplotlib/lib.matplotlib.axis/Axis/get_transform",
        "matplotlib/lib.matplotlib.axis/Axis/get_scale",
        "matplotlib/lib.matplotlib.axis/Axis/_set_scale",
        "matplotlib/lib.matplotlib.axis/Axis/_set_axes_scale",
        "matplotlib/lib.matplotlib.axis/Axis/limit_range_for_scale",
        "matplotlib/lib.matplotlib.axis/Axis/_get_autoscale_on",
        "matplotlib/lib.matplotlib.axis/Axis/_set_autoscale_on",
        "matplotlib/lib.matplotlib.axis/Axis/get_children",
        "matplotlib/lib.matplotlib.axis/Axis/_reset_major_tick_kw",
        "matplotlib/lib.matplotlib.axis/Axis/_reset_minor_tick_kw",
        "matplotlib/lib.matplotlib.axis/Axis/clear",
        "matplotlib/lib.matplotlib.axis/Axis/reset_ticks",
        "matplotlib/lib.matplotlib.axis/Axis/set_tick_params",
        "matplotlib/lib.matplotlib.axis/Axis/_translate_tick_params",
        "matplotlib/lib.matplotlib.axis/Axis/set_clip_path",
        "matplotlib/lib.matplotlib.axis/Axis/get_view_interval",
        "matplotlib/lib.matplotlib.axis/Axis/set_view_interval",
        "matplotlib/lib.matplotlib.axis/Axis/get_data_interval",
        "matplotlib/lib.matplotlib.axis/Axis/set_data_interval",
        "matplotlib/lib.matplotlib.axis/Axis/get_inverted",
        "matplotlib/lib.matplotlib.axis/Axis/set_inverted",
        "matplotlib/lib.matplotlib.axis/Axis/set_default_intervals",
        "matplotlib/lib.matplotlib.axis/Axis/_set_lim",
        "matplotlib/lib.matplotlib.axis/Axis/_set_artist_props",
        "matplotlib/lib.matplotlib.axis/Axis/get_ticklabel_extents",
        "matplotlib/lib.matplotlib.axis/Axis/_update_ticks",
        "matplotlib/lib.matplotlib.axis/Axis/_get_ticklabel_bboxes",
        "matplotlib/lib.matplotlib.axis/Axis/get_tightbbox",
        "matplotlib/lib.matplotlib.axis/Axis/get_tick_padding",
        "matplotlib/lib.matplotlib.axis/Axis/draw",
        "matplotlib/lib.matplotlib.axis/Axis/get_gridlines",
        "matplotlib/lib.matplotlib.axis/Axis/get_label",
        "matplotlib/lib.matplotlib.axis/Axis/get_offset_text",
        "matplotlib/lib.matplotlib.axis/Axis/get_pickradius",
        "matplotlib/lib.matplotlib.axis/Axis/get_majorticklabels",
        "matplotlib/lib.matplotlib.axis/Axis/get_minorticklabels",
        "matplotlib/lib.matplotlib.axis/Axis/get_ticklabels",
        "matplotlib/lib.matplotlib.axis/Axis/get_majorticklines",
        "matplotlib/lib.matplotlib.axis/Axis/get_minorticklines",
        "matplotlib/lib.matplotlib.axis/Axis/get_ticklines",
        "matplotlib/lib.matplotlib.axis/Axis/get_majorticklocs",
        "matplotlib/lib.matplotlib.axis/Axis/get_minorticklocs",
        "matplotlib/lib.matplotlib.axis/Axis/get_ticklocs",
        "matplotlib/lib.matplotlib.axis/Axis/get_ticks_direction",
        "matplotlib/lib.matplotlib.axis/Axis/_get_tick",
        "matplotlib/lib.matplotlib.axis/Axis/_get_tick_label_size",
        "matplotlib/lib.matplotlib.axis/Axis/_copy_tick_props",
        "matplotlib/lib.matplotlib.axis/Axis/get_label_text",
        "matplotlib/lib.matplotlib.axis/Axis/get_major_locator",
        "matplotlib/lib.matplotlib.axis/Axis/get_minor_locator",
        "matplotlib/lib.matplotlib.axis/Axis/get_major_formatter",
        "matplotlib/lib.matplotlib.axis/Axis/get_minor_formatter",
        "matplotlib/lib.matplotlib.axis/Axis/get_major_ticks",
        "matplotlib/lib.matplotlib.axis/Axis/get_minor_ticks",
        "matplotlib/lib.matplotlib.axis/Axis/grid",
        "matplotlib/lib.matplotlib.axis/Axis/update_units",
        "matplotlib/lib.matplotlib.axis/Axis/_update_axisinfo",
        "matplotlib/lib.matplotlib.axis/Axis/have_units",
        "matplotlib/lib.matplotlib.axis/Axis/convert_units",
        "matplotlib/lib.matplotlib.axis/Axis/set_units",
        "matplotlib/lib.matplotlib.axis/Axis/get_units",
        "matplotlib/lib.matplotlib.axis/Axis/set_label_text",
        "matplotlib/lib.matplotlib.axis/Axis/set_major_formatter",
        "matplotlib/lib.matplotlib.axis/Axis/set_minor_formatter",
        "matplotlib/lib.matplotlib.axis/Axis/_set_formatter",
        "matplotlib/lib.matplotlib.axis/Axis/set_major_locator",
        "matplotlib/lib.matplotlib.axis/Axis/set_minor_locator",
        "matplotlib/lib.matplotlib.axis/Axis/set_pickradius",
        "matplotlib/lib.matplotlib.axis/Axis/_format_with_dict",
        "matplotlib/lib.matplotlib.axis/Axis/set_ticklabels",
        "matplotlib/lib.matplotlib.axis/Axis/_set_ticklabels",
        "matplotlib/lib.matplotlib.axis/Axis/_set_tick_locations",
        "matplotlib/lib.matplotlib.axis/Axis/set_ticks",
        "matplotlib/lib.matplotlib.axis/Axis/_get_tick_boxes_siblings",
        "matplotlib/lib.matplotlib.axis/Axis/_update_label_position",
        "matplotlib/lib.matplotlib.axis/Axis/_update_offset_text_position",
        "matplotlib/lib.matplotlib.axis/Axis/axis_date",
        "matplotlib/lib.matplotlib.axis/Axis/get_tick_space",
        "matplotlib/lib.matplotlib.axis/Axis/_get_ticks_position",
        "matplotlib/lib.matplotlib.axis/Axis/get_label_position",
        "matplotlib/lib.matplotlib.axis/Axis/set_label_position",
        "matplotlib/lib.matplotlib.axis/Axis/get_minpos"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Base class for `.XAxis` and `.YAxis`.",
      "docstring": "Base class for `.XAxis` and `.YAxis`.\n\nAttributes\n----------\nisDefault_label : bool\n\naxes : `matplotlib.axes.Axes`\n    The `~.axes.Axes` to which the Axis belongs.\nmajor : `matplotlib.axis.Ticker`\n    Determines the major tick positions and their label format.\nminor : `matplotlib.axis.Ticker`\n    Determines the minor tick positions and their label format.\ncallbacks : `matplotlib.cbook.CallbackRegistry`\n\nlabel : `.Text`\n    The axis label.\nlabelpad : float\n    The distance between the axis label and the tick labels.\n    Defaults to :rc:`axes.labelpad` = 4.\noffsetText : `.Text`\n    A `.Text` object containing the data offset of the ticks (if any).\npickradius : float\n    The acceptance radius for containment tests. See also `.Axis.contains`.\nmajorTicks : list of `.Tick`\n    The major ticks.\nminorTicks : list of `.Tick`\n    The minor ticks.",
      "code": "class Axis(martist.Artist):\n    \"\"\"\n    Base class for `.XAxis` and `.YAxis`.\n\n    Attributes\n    ----------\n    isDefault_label : bool\n\n    axes : `matplotlib.axes.Axes`\n        The `~.axes.Axes` to which the Axis belongs.\n    major : `matplotlib.axis.Ticker`\n        Determines the major tick positions and their label format.\n    minor : `matplotlib.axis.Ticker`\n        Determines the minor tick positions and their label format.\n    callbacks : `matplotlib.cbook.CallbackRegistry`\n\n    label : `.Text`\n        The axis label.\n    labelpad : float\n        The distance between the axis label and the tick labels.\n        Defaults to :rc:`axes.labelpad` = 4.\n    offsetText : `.Text`\n        A `.Text` object containing the data offset of the ticks (if any).\n    pickradius : float\n        The acceptance radius for containment tests. See also `.Axis.contains`.\n    majorTicks : list of `.Tick`\n        The major ticks.\n    minorTicks : list of `.Tick`\n        The minor ticks.\n    \"\"\"\n    OFFSETTEXTPAD = 3\n    # The class used in _get_tick() to create tick instances. Must either be\n    # overwritten in subclasses, or subclasses must reimplement _get_tick().\n    _tick_class = None\n\n    def __str__(self):\n        return \"{}({},{})\".format(\n            type(self).__name__, *self.axes.transAxes.transform((0, 0)))\n\n    @_api.make_keyword_only(\"3.6\", name=\"pickradius\")\n    def __init__(self, axes, pickradius=15):\n        \"\"\"\n        Parameters\n        ----------\n        axes : `matplotlib.axes.Axes`\n            The `~.axes.Axes` to which the created Axis belongs.\n        pickradius : float\n            The acceptance radius for containment tests. See also\n            `.Axis.contains`.\n        \"\"\"\n        super().__init__()\n        self._remove_overlapping_locs = True\n\n        self.set_figure(axes.figure)\n\n        self.isDefault_label = True\n\n        self.axes = axes\n        self.major = Ticker()\n        self.minor = Ticker()\n        self.callbacks = cbook.CallbackRegistry(\n            signals=[\"units\", \"units finalize\"])\n\n        self._autolabelpos = True\n\n        self.label = mtext.Text(\n            np.nan, np.nan,\n            fontsize=mpl.rcParams['axes.labelsize'],\n            fontweight=mpl.rcParams['axes.labelweight'],\n            color=mpl.rcParams['axes.labelcolor'],\n        )\n        self._set_artist_props(self.label)\n        self.offsetText = mtext.Text(np.nan, np.nan)\n        self._set_artist_props(self.offsetText)\n\n        self.labelpad = mpl.rcParams['axes.labelpad']\n\n        self.pickradius = pickradius\n\n        # Initialize here for testing; later add API\n        self._major_tick_kw = dict()\n        self._minor_tick_kw = dict()\n\n        self.clear()\n        self._autoscale_on = True\n\n    @property\n    def isDefault_majloc(self):\n        return self.major._locator_is_default\n\n    @isDefault_majloc.setter\n    def isDefault_majloc(self, value):\n        self.major._locator_is_default = value\n\n    @property\n    def isDefault_majfmt(self):\n        return self.major._formatter_is_default\n\n    @isDefault_majfmt.setter\n    def isDefault_majfmt(self, value):\n        self.major._formatter_is_default = value\n\n    @property\n    def isDefault_minloc(self):\n        return self.minor._locator_is_default\n\n    @isDefault_minloc.setter\n    def isDefault_minloc(self, value):\n        self.minor._locator_is_default = value\n\n    @property\n    def isDefault_minfmt(self):\n        return self.minor._formatter_is_default\n\n    @isDefault_minfmt.setter\n    def isDefault_minfmt(self, value):\n        self.minor._formatter_is_default = value\n\n    # During initialization, Axis objects often create ticks that are later\n    # unused; this turns out to be a very slow step.  Instead, use a custom\n    # descriptor to make the tick lists lazy and instantiate them as needed.\n    majorTicks = _LazyTickList(major=True)\n    minorTicks = _LazyTickList(major=False)\n\n    def get_remove_overlapping_locs(self):\n        return self._remove_overlapping_locs\n\n    def set_remove_overlapping_locs(self, val):\n        self._remove_overlapping_locs = bool(val)\n\n    remove_overlapping_locs = property(\n        get_remove_overlapping_locs, set_remove_overlapping_locs,\n        doc=('If minor ticker locations that overlap with major '\n             'ticker locations should be trimmed.'))\n\n    def set_label_coords(self, x, y, transform=None):\n        \"\"\"\n        Set the coordinates of the label.\n\n        By default, the x coordinate of the y label and the y coordinate of the\n        x label are determined by the tick label bounding boxes, but this can\n        lead to poor alignment of multiple labels if there are multiple axes.\n\n        You can also specify the coordinate system of the label with the\n        transform.  If None, the default coordinate system will be the axes\n        coordinate system: (0, 0) is bottom left, (0.5, 0.5) is center, etc.\n        \"\"\"\n        self._autolabelpos = False\n        if transform is None:\n            transform = self.axes.transAxes\n\n        self.label.set_transform(transform)\n        self.label.set_position((x, y))\n        self.stale = True\n\n    def get_transform(self):\n        return self._scale.get_transform()\n\n    def get_scale(self):\n        \"\"\"Return this Axis' scale (as a str).\"\"\"\n        return self._scale.name\n\n    def _set_scale(self, value, **kwargs):\n        if not isinstance(value, mscale.ScaleBase):\n            self._scale = mscale.scale_factory(value, self, **kwargs)\n        else:\n            self._scale = value\n        self._scale.set_default_locators_and_formatters(self)\n\n        self.isDefault_majloc = True\n        self.isDefault_minloc = True\n        self.isDefault_majfmt = True\n        self.isDefault_minfmt = True\n\n    # This method is directly wrapped by Axes.set_{x,y}scale.\n    def _set_axes_scale(self, value, **kwargs):\n        \"\"\"\n        Set this Axis' scale.\n\n        Parameters\n        ----------\n        value : {\"linear\", \"log\", \"symlog\", \"logit\", ...} or `.ScaleBase`\n            The axis scale type to apply.\n\n        **kwargs\n            Different keyword arguments are accepted, depending on the scale.\n            See the respective class keyword arguments:\n\n            - `matplotlib.scale.LinearScale`\n            - `matplotlib.scale.LogScale`\n            - `matplotlib.scale.SymmetricalLogScale`\n            - `matplotlib.scale.LogitScale`\n            - `matplotlib.scale.FuncScale`\n\n        Notes\n        -----\n        By default, Matplotlib supports the above mentioned scales.\n        Additionally, custom scales may be registered using\n        `matplotlib.scale.register_scale`. These scales can then also\n        be used here.\n        \"\"\"\n        name, = [name for name, axis in self.axes._axis_map.items()\n                 if axis is self]  # The axis name.\n        old_default_lims = (self.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        g = self.axes._shared_axes[name]\n        for ax in g.get_siblings(self.axes):\n            ax._axis_map[name]._set_scale(value, **kwargs)\n            ax._update_transScale()\n            ax.stale = True\n        new_default_lims = (self.get_major_locator()\n                            .nonsingular(-np.inf, np.inf))\n        if old_default_lims != new_default_lims:\n            # Force autoscaling now, to take advantage of the scale locator's\n            # nonsingular() before it possibly gets swapped out by the user.\n            self.axes.autoscale_view(\n                **{f\"scale{k}\": k == name for k in self.axes._axis_names})\n\n    def limit_range_for_scale(self, vmin, vmax):\n        return self._scale.limit_range_for_scale(vmin, vmax, self.get_minpos())\n\n    def _get_autoscale_on(self):\n        \"\"\"Return whether this Axis is autoscaled.\"\"\"\n        return self._autoscale_on\n\n    def _set_autoscale_on(self, b):\n        \"\"\"\n        Set whether this Axis is autoscaled when drawing or by\n        `.Axes.autoscale_view`.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._autoscale_on = b\n\n    def get_children(self):\n        return [self.label, self.offsetText,\n                *self.get_major_ticks(), *self.get_minor_ticks()]\n\n    def _reset_major_tick_kw(self):\n        self._major_tick_kw.clear()\n        self._major_tick_kw['gridOn'] = (\n                mpl.rcParams['axes.grid'] and\n                mpl.rcParams['axes.grid.which'] in ('both', 'major'))\n\n    def _reset_minor_tick_kw(self):\n        self._minor_tick_kw.clear()\n        self._minor_tick_kw['gridOn'] = (\n                mpl.rcParams['axes.grid'] and\n                mpl.rcParams['axes.grid.which'] in ('both', 'minor'))\n\n    def clear(self):\n        \"\"\"\n        Clear the axis.\n\n        This resets axis properties to their default values:\n\n        - the label\n        - the scale\n        - locators, formatters and ticks\n        - major and minor grid\n        - units\n        - registered callbacks\n        \"\"\"\n\n        self.label.set_text('')  # self.set_label_text would change isDefault_\n\n        self._set_scale('linear')\n\n        # Clear the callback registry for this axis, or it may \"leak\"\n        self.callbacks = cbook.CallbackRegistry(\n            signals=[\"units\", \"units finalize\"])\n\n        # whether the grids are on\n        self._major_tick_kw['gridOn'] = (\n                mpl.rcParams['axes.grid'] and\n                mpl.rcParams['axes.grid.which'] in ('both', 'major'))\n        self._minor_tick_kw['gridOn'] = (\n                mpl.rcParams['axes.grid'] and\n                mpl.rcParams['axes.grid.which'] in ('both', 'minor'))\n        self.reset_ticks()\n\n        self.converter = None\n        self.units = None\n        self.set_units(None)\n        self.stale = True\n\n    def reset_ticks(self):\n        \"\"\"\n        Re-initialize the major and minor Tick lists.\n\n        Each list starts with a single fresh Tick.\n        \"\"\"\n        # Restore the lazy tick lists.\n        try:\n            del self.majorTicks\n        except AttributeError:\n            pass\n        try:\n            del self.minorTicks\n        except AttributeError:\n            pass\n        try:\n            self.set_clip_path(self.axes.patch)\n        except AttributeError:\n            pass\n\n    def set_tick_params(self, which='major', reset=False, **kwargs):\n        \"\"\"\n        Set appearance parameters for ticks, ticklabels, and gridlines.\n\n        For documentation of keyword arguments, see\n        :meth:`matplotlib.axes.Axes.tick_params`.\n        \"\"\"\n        _api.check_in_list(['major', 'minor', 'both'], which=which)\n        kwtrans = self._translate_tick_params(kwargs)\n\n        # the kwargs are stored in self._major/minor_tick_kw so that any\n        # future new ticks will automatically get them\n        if reset:\n            if which in ['major', 'both']:\n                self._reset_major_tick_kw()\n                self._major_tick_kw.update(kwtrans)\n            if which in ['minor', 'both']:\n                self._reset_minor_tick_kw()\n                self._minor_tick_kw.update(kwtrans)\n            self.reset_ticks()\n        else:\n            if which in ['major', 'both']:\n                self._major_tick_kw.update(kwtrans)\n                for tick in self.majorTicks:\n                    tick._apply_params(**kwtrans)\n            if which in ['minor', 'both']:\n                self._minor_tick_kw.update(kwtrans)\n                for tick in self.minorTicks:\n                    tick._apply_params(**kwtrans)\n            # labelOn and labelcolor also apply to the offset text.\n            if 'label1On' in kwtrans or 'label2On' in kwtrans:\n                self.offsetText.set_visible(\n                    self._major_tick_kw.get('label1On', False)\n                    or self._major_tick_kw.get('label2On', False))\n            if 'labelcolor' in kwtrans:\n                self.offsetText.set_color(kwtrans['labelcolor'])\n\n        self.stale = True\n\n    @staticmethod\n    def _translate_tick_params(kw):\n        \"\"\"\n        Translate the kwargs supported by `.Axis.set_tick_params` to kwargs\n        supported by `.Tick._apply_params`.\n\n        In particular, this maps axis specific names like 'top', 'left'\n        to the generic tick1, tick2 logic of the axis. Additionally, there\n        are some other name translations.\n\n        Returns a new dict of translated kwargs.\n\n        Note: The input *kwargs* are currently modified, but that's ok for\n        the only caller.\n        \"\"\"\n        # The following lists may be moved to a more accessible location.\n        allowed_keys = [\n            'size', 'width', 'color', 'tickdir', 'pad',\n            'labelsize', 'labelcolor', 'zorder', 'gridOn',\n            'tick1On', 'tick2On', 'label1On', 'label2On',\n            'length', 'direction', 'left', 'bottom', 'right', 'top',\n            'labelleft', 'labelbottom', 'labelright', 'labeltop',\n            'labelrotation',\n            *_gridline_param_names]\n\n        keymap = {\n            # tick_params key -> axis key\n            'length': 'size',\n            'direction': 'tickdir',\n            'rotation': 'labelrotation',\n            'left': 'tick1On',\n            'bottom': 'tick1On',\n            'right': 'tick2On',\n            'top': 'tick2On',\n            'labelleft': 'label1On',\n            'labelbottom': 'label1On',\n            'labelright': 'label2On',\n            'labeltop': 'label2On',\n        }\n        kwtrans = {newkey: kw.pop(oldkey)\n                   for oldkey, newkey in keymap.items() if oldkey in kw}\n        if 'colors' in kw:\n            c = kw.pop('colors')\n            kwtrans['color'] = c\n            kwtrans['labelcolor'] = c\n        # Maybe move the checking up to the caller of this method.\n        for key in kw:\n            if key not in allowed_keys:\n                raise ValueError(\n                    \"keyword %s is not recognized; valid keywords are %s\"\n                    % (key, allowed_keys))\n        kwtrans.update(kw)\n        return kwtrans\n\n    def set_clip_path(self, clippath, transform=None):\n        super().set_clip_path(clippath, transform)\n        for child in self.majorTicks + self.minorTicks:\n            child.set_clip_path(clippath, transform)\n        self.stale = True\n\n    def get_view_interval(self):\n        \"\"\"Return the ``(min, max)`` view limits of this axis.\"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def set_view_interval(self, vmin, vmax, ignore=False):\n        \"\"\"\n        Set the axis view limits.  This method is for internal use; Matplotlib\n        users should typically use e.g. `~.Axes.set_xlim` or `~.Axes.set_ylim`.\n\n        If *ignore* is False (the default), this method will never reduce the\n        preexisting view limits, only expand them if *vmin* or *vmax* are not\n        within them.  Moreover, the order of *vmin* and *vmax* does not matter;\n        the orientation of the axis will not change.\n\n        If *ignore* is True, the view limits will be set exactly to ``(vmin,\n        vmax)`` in that order.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def get_data_interval(self):\n        \"\"\"Return the ``(min, max)`` data limits of this axis.\"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def set_data_interval(self, vmin, vmax, ignore=False):\n        \"\"\"\n        Set the axis data limits.  This method is for internal use.\n\n        If *ignore* is False (the default), this method will never reduce the\n        preexisting data limits, only expand them if *vmin* or *vmax* are not\n        within them.  Moreover, the order of *vmin* and *vmax* does not matter;\n        the orientation of the axis will not change.\n\n        If *ignore* is True, the data limits will be set exactly to ``(vmin,\n        vmax)`` in that order.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def get_inverted(self):\n        \"\"\"\n        Return whether this Axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        low, high = self.get_view_interval()\n        return high < low\n\n    def set_inverted(self, inverted):\n        \"\"\"\n        Set whether this Axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        a, b = self.get_view_interval()\n        # cast to bool to avoid bad interaction between python 3.8 and np.bool_\n        self._set_lim(*sorted((a, b), reverse=bool(inverted)), auto=None)\n\n    def set_default_intervals(self):\n        \"\"\"\n        Set the default limits for the axis data and view interval if they\n        have not been not mutated yet.\n        \"\"\"\n        # this is mainly in support of custom object plotting.  For\n        # example, if someone passes in a datetime object, we do not\n        # know automagically how to set the default min/max of the\n        # data and view limits.  The unit conversion AxisInfo\n        # interface provides a hook for custom types to register\n        # default limits through the AxisInfo.default_limits\n        # attribute, and the derived code below will check for that\n        # and use it if it's available (else just use 0..1)\n\n    def _set_lim(self, v0, v1, *, emit=True, auto):\n        \"\"\"\n        Set view limits.\n\n        This method is a helper for the Axes ``set_xlim``, ``set_ylim``, and\n        ``set_zlim`` methods.\n\n        Parameters\n        ----------\n        v0, v1 : float\n            The view limits.  (Passing *v0* as a (low, high) pair is not\n            supported; normalization must occur in the Axes setters.)\n        emit : bool, default: True\n            Whether to notify observers of limit change.\n        auto : bool or None, default: False\n            Whether to turn on autoscaling of the x-axis. True turns on, False\n            turns off, None leaves unchanged.\n        \"\"\"\n        name, = [name for name, axis in self.axes._axis_map.items()\n                 if axis is self]  # The axis name.\n\n        self.axes._process_unit_info([(name, (v0, v1))], convert=False)\n        v0 = self.axes._validate_converted_limits(v0, self.convert_units)\n        v1 = self.axes._validate_converted_limits(v1, self.convert_units)\n\n        if v0 is None or v1 is None:\n            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n            # so only grab the limits if we really need them.\n            old0, old1 = self.get_view_interval()\n            if v0 is None:\n                v0 = old0\n            if v1 is None:\n                v1 = old1\n\n        if self.get_scale() == 'log' and (v0 <= 0 or v1 <= 0):\n            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n            # so only grab the limits if we really need them.\n            old0, old1 = self.get_view_interval()\n            if v0 <= 0:\n                _api.warn_external(f\"Attempt to set non-positive {name}lim on \"\n                                   f\"a log-scaled axis will be ignored.\")\n                v0 = old0\n            if v1 <= 0:\n                _api.warn_external(f\"Attempt to set non-positive {name}lim on \"\n                                   f\"a log-scaled axis will be ignored.\")\n                v1 = old1\n        if v0 == v1:\n            _api.warn_external(\n                f\"Attempting to set identical low and high {name}lims \"\n                f\"makes transformation singular; automatically expanding.\")\n        reverse = bool(v0 > v1)  # explicit cast needed for python3.8+np.bool_.\n        v0, v1 = self.get_major_locator().nonsingular(v0, v1)\n        v0, v1 = self.limit_range_for_scale(v0, v1)\n        v0, v1 = sorted([v0, v1], reverse=bool(reverse))\n\n        self.set_view_interval(v0, v1, ignore=True)\n        # Mark viewlims as no longer stale without triggering an autoscale.\n        for ax in self.axes._shared_axes[name].get_siblings(self.axes):\n            ax._stale_viewlims[name] = False\n        if auto is not None:\n            self._set_autoscale_on(bool(auto))\n\n        if emit:\n            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n            # Call all of the other axes that are shared with this one\n            for other in self.axes._shared_axes[name].get_siblings(self.axes):\n                if other is not self.axes:\n                    other._axis_map[name]._set_lim(\n                        v0, v1, emit=False, auto=auto)\n                    if other.figure != self.figure:\n                        other.figure.canvas.draw_idle()\n\n        self.stale = True\n        return v0, v1\n\n    def _set_artist_props(self, a):\n        if a is None:\n            return\n        a.set_figure(self.figure)\n\n    @_api.deprecated(\"3.6\")\n    def get_ticklabel_extents(self, renderer):\n        \"\"\"Get the extents of the tick labels on either side of the axes.\"\"\"\n        ticks_to_draw = self._update_ticks()\n        tlb1, tlb2 = self._get_ticklabel_bboxes(ticks_to_draw, renderer)\n        if len(tlb1):\n            bbox1 = mtransforms.Bbox.union(tlb1)\n        else:\n            bbox1 = mtransforms.Bbox.from_extents(0, 0, 0, 0)\n        if len(tlb2):\n            bbox2 = mtransforms.Bbox.union(tlb2)\n        else:\n            bbox2 = mtransforms.Bbox.from_extents(0, 0, 0, 0)\n        return bbox1, bbox2\n\n    def _update_ticks(self):\n        \"\"\"\n        Update ticks (position and labels) using the current data interval of\n        the axes.  Return the list of ticks that will be drawn.\n        \"\"\"\n        major_locs = self.get_majorticklocs()\n        major_labels = self.major.formatter.format_ticks(major_locs)\n        major_ticks = self.get_major_ticks(len(major_locs))\n        self.major.formatter.set_locs(major_locs)\n        for tick, loc, label in zip(major_ticks, major_locs, major_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        minor_locs = self.get_minorticklocs()\n        minor_labels = self.minor.formatter.format_ticks(minor_locs)\n        minor_ticks = self.get_minor_ticks(len(minor_locs))\n        self.minor.formatter.set_locs(minor_locs)\n        for tick, loc, label in zip(minor_ticks, minor_locs, minor_labels):\n            tick.update_position(loc)\n            tick.set_label1(label)\n            tick.set_label2(label)\n        ticks = [*major_ticks, *minor_ticks]\n\n        view_low, view_high = self.get_view_interval()\n        if view_low > view_high:\n            view_low, view_high = view_high, view_low\n\n        interval_t = self.get_transform().transform([view_low, view_high])\n\n        ticks_to_draw = []\n        for tick in ticks:\n            try:\n                loc_t = self.get_transform().transform(tick.get_loc())\n            except AssertionError:\n                # transforms.transform doesn't allow masked values but\n                # some scales might make them, so we need this try/except.\n                pass\n            else:\n                if mtransforms._interval_contains_close(interval_t, loc_t):\n                    ticks_to_draw.append(tick)\n\n        return ticks_to_draw\n\n    def _get_ticklabel_bboxes(self, ticks, renderer=None):\n        \"\"\"Return lists of bboxes for ticks' label1's and label2's.\"\"\"\n        if renderer is None:\n            renderer = self.figure._get_renderer()\n        return ([tick.label1.get_window_extent(renderer)\n                 for tick in ticks if tick.label1.get_visible()],\n                [tick.label2.get_window_extent(renderer)\n                 for tick in ticks if tick.label2.get_visible()])\n\n    def get_tightbbox(self, renderer=None, *, for_layout_only=False):\n        \"\"\"\n        Return a bounding box that encloses the axis. It only accounts\n        tick labels, axis label, and offsetText.\n\n        If *for_layout_only* is True, then the width of the label (if this\n        is an x-axis) or the height of the label (if this is a y-axis) is\n        collapsed to near zero.  This allows tight/constrained_layout to ignore\n        too-long labels when doing their layout.\n        \"\"\"\n        if not self.get_visible():\n            return\n        if renderer is None:\n            renderer = self.figure._get_renderer()\n        ticks_to_draw = self._update_ticks()\n\n        self._update_label_position(renderer)\n\n        # go back to just this axis's tick labels\n        tlb1, tlb2 = self._get_ticklabel_bboxes(ticks_to_draw, renderer)\n\n        self._update_offset_text_position(tlb1, tlb2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n\n        bboxes = [\n            *(a.get_window_extent(renderer)\n              for a in [self.offsetText]\n              if a.get_visible()),\n            *tlb1, *tlb2,\n        ]\n        # take care of label\n        if self.label.get_visible():\n            bb = self.label.get_window_extent(renderer)\n            # for constrained/tight_layout, we want to ignore the label's\n            # width/height because the adjustments they make can't be improved.\n            # this code collapses the relevant direction\n            if for_layout_only:\n                if self.axis_name == \"x\" and bb.width > 0:\n                    bb.x0 = (bb.x0 + bb.x1) / 2 - 0.5\n                    bb.x1 = bb.x0 + 1.0\n                if self.axis_name == \"y\" and bb.height > 0:\n                    bb.y0 = (bb.y0 + bb.y1) / 2 - 0.5\n                    bb.y1 = bb.y0 + 1.0\n            bboxes.append(bb)\n        bboxes = [b for b in bboxes\n                  if 0 < b.width < np.inf and 0 < b.height < np.inf]\n        if bboxes:\n            return mtransforms.Bbox.union(bboxes)\n        else:\n            return None\n\n    def get_tick_padding(self):\n        values = []\n        if len(self.majorTicks):\n            values.append(self.majorTicks[0].get_tick_padding())\n        if len(self.minorTicks):\n            values.append(self.minorTicks[0].get_tick_padding())\n        return max(values, default=0)\n\n    @martist.allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        # docstring inherited\n\n        if not self.get_visible():\n            return\n        renderer.open_group(__name__, gid=self.get_gid())\n\n        ticks_to_draw = self._update_ticks()\n        tlb1, tlb2 = self._get_ticklabel_bboxes(ticks_to_draw, renderer)\n\n        for tick in ticks_to_draw:\n            tick.draw(renderer)\n\n        # Scale up the axis label box to also find the neighbors, not just the\n        # tick labels that actually overlap.  We need a *copy* of the axis\n        # label box because we don't want to scale the actual bbox.\n\n        self._update_label_position(renderer)\n\n        self.label.draw(renderer)\n\n        self._update_offset_text_position(tlb1, tlb2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.draw(renderer)\n\n        renderer.close_group(__name__)\n        self.stale = False\n\n    def get_gridlines(self):\n        r\"\"\"Return this Axis' grid lines as a list of `.Line2D`\\s.\"\"\"\n        ticks = self.get_major_ticks()\n        return cbook.silent_list('Line2D gridline',\n                                 [tick.gridline for tick in ticks])\n\n    def get_label(self):\n        \"\"\"Return the axis label as a Text instance.\"\"\"\n        return self.label\n\n    def get_offset_text(self):\n        \"\"\"Return the axis offsetText as a Text instance.\"\"\"\n        return self.offsetText\n\n    def get_pickradius(self):\n        \"\"\"Return the depth of the axis used by the picker.\"\"\"\n        return self._pickradius\n\n    def get_majorticklabels(self):\n        \"\"\"Return this Axis' major tick labels, as a list of `~.text.Text`.\"\"\"\n        self._update_ticks()\n        ticks = self.get_major_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return labels1 + labels2\n\n    def get_minorticklabels(self):\n        \"\"\"Return this Axis' minor tick labels, as a list of `~.text.Text`.\"\"\"\n        self._update_ticks()\n        ticks = self.get_minor_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return labels1 + labels2\n\n    def get_ticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get this Axis' tick labels.\n\n        Parameters\n        ----------\n        minor : bool\n           Whether to return the minor or the major ticklabels.\n\n        which : None, ('minor', 'major', 'both')\n           Overrides *minor*.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        list of `~matplotlib.text.Text`\n        \"\"\"\n        if which is not None:\n            if which == 'minor':\n                return self.get_minorticklabels()\n            elif which == 'major':\n                return self.get_majorticklabels()\n            elif which == 'both':\n                return self.get_majorticklabels() + self.get_minorticklabels()\n            else:\n                _api.check_in_list(['major', 'minor', 'both'], which=which)\n        if minor:\n            return self.get_minorticklabels()\n        return self.get_majorticklabels()\n\n    def get_majorticklines(self):\n        r\"\"\"Return this Axis' major tick lines as a list of `.Line2D`\\s.\"\"\"\n        lines = []\n        ticks = self.get_major_ticks()\n        for tick in ticks:\n            lines.append(tick.tick1line)\n            lines.append(tick.tick2line)\n        return cbook.silent_list('Line2D ticklines', lines)\n\n    def get_minorticklines(self):\n        r\"\"\"Return this Axis' minor tick lines as a list of `.Line2D`\\s.\"\"\"\n        lines = []\n        ticks = self.get_minor_ticks()\n        for tick in ticks:\n            lines.append(tick.tick1line)\n            lines.append(tick.tick2line)\n        return cbook.silent_list('Line2D ticklines', lines)\n\n    def get_ticklines(self, minor=False):\n        r\"\"\"Return this Axis' tick lines as a list of `.Line2D`\\s.\"\"\"\n        if minor:\n            return self.get_minorticklines()\n        return self.get_majorticklines()\n\n    def get_majorticklocs(self):\n        \"\"\"Return this Axis' major tick locations in data coordinates.\"\"\"\n        return self.major.locator()\n\n    def get_minorticklocs(self):\n        \"\"\"Return this Axis' minor tick locations in data coordinates.\"\"\"\n        # Remove minor ticks duplicating major ticks.\n        minor_locs = np.asarray(self.minor.locator())\n        if self.remove_overlapping_locs:\n            major_locs = self.major.locator()\n            transform = self._scale.get_transform()\n            tr_minor_locs = transform.transform(minor_locs)\n            tr_major_locs = transform.transform(major_locs)\n            lo, hi = sorted(transform.transform(self.get_view_interval()))\n            # Use the transformed view limits as scale.  1e-5 is the default\n            # rtol for np.isclose.\n            tol = (hi - lo) * 1e-5\n            mask = np.isclose(tr_minor_locs[:, None], tr_major_locs[None, :],\n                              atol=tol, rtol=0).any(axis=1)\n            minor_locs = minor_locs[~mask]\n        return minor_locs\n\n    def get_ticklocs(self, *, minor=False):\n        \"\"\"\n        Return this Axis' tick locations in data coordinates.\n\n        The locations are not clipped to the current axis limits and hence\n        may contain locations that are not visible in the output.\n\n        Parameters\n        ----------\n        minor : bool, default: False\n            True to return the minor tick directions,\n            False to return the major tick directions.\n\n        Returns\n        -------\n        numpy array of tick locations\n        \"\"\"\n        return self.get_minorticklocs() if minor else self.get_majorticklocs()\n\n    def get_ticks_direction(self, minor=False):\n        \"\"\"\n        Get the tick directions as a numpy array\n\n        Parameters\n        ----------\n        minor : bool, default: False\n            True to return the minor tick directions,\n            False to return the major tick directions.\n\n        Returns\n        -------\n        numpy array of tick directions\n        \"\"\"\n        if minor:\n            return np.array(\n                [tick._tickdir for tick in self.get_minor_ticks()])\n        else:\n            return np.array(\n                [tick._tickdir for tick in self.get_major_ticks()])\n\n    def _get_tick(self, major):\n        \"\"\"Return the default tick instance.\"\"\"\n        if self._tick_class is None:\n            raise NotImplementedError(\n                f\"The Axis subclass {self.__class__.__name__} must define \"\n                \"_tick_class or reimplement _get_tick()\")\n        tick_kw = self._major_tick_kw if major else self._minor_tick_kw\n        return self._tick_class(self.axes, 0, major=major, **tick_kw)\n\n    def _get_tick_label_size(self, axis_name):\n        \"\"\"\n        Return the text size of tick labels for this Axis.\n\n        This is a convenience function to avoid having to create a `Tick` in\n        `.get_tick_space`, since it is expensive.\n        \"\"\"\n        tick_kw = self._major_tick_kw\n        size = tick_kw.get('labelsize',\n                           mpl.rcParams[f'{axis_name}tick.labelsize'])\n        return mtext.FontProperties(size=size).get_size_in_points()\n\n    def _copy_tick_props(self, src, dest):\n        \"\"\"Copy the properties from *src* tick to *dest* tick.\"\"\"\n        if src is None or dest is None:\n            return\n        dest.label1.update_from(src.label1)\n        dest.label2.update_from(src.label2)\n        dest.tick1line.update_from(src.tick1line)\n        dest.tick2line.update_from(src.tick2line)\n        dest.gridline.update_from(src.gridline)\n\n    def get_label_text(self):\n        \"\"\"Get the text of the label.\"\"\"\n        return self.label.get_text()\n\n    def get_major_locator(self):\n        \"\"\"Get the locator of the major ticker.\"\"\"\n        return self.major.locator\n\n    def get_minor_locator(self):\n        \"\"\"Get the locator of the minor ticker.\"\"\"\n        return self.minor.locator\n\n    def get_major_formatter(self):\n        \"\"\"Get the formatter of the major ticker.\"\"\"\n        return self.major.formatter\n\n    def get_minor_formatter(self):\n        \"\"\"Get the formatter of the minor ticker.\"\"\"\n        return self.minor.formatter\n\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n\n    def get_minor_ticks(self, numticks=None):\n        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]\n\n    @_api.rename_parameter(\"3.5\", \"b\", \"visible\")\n    def grid(self, visible=None, which='major', **kwargs):\n        \"\"\"\n        Configure the grid lines.\n\n        Parameters\n        ----------\n        visible : bool or None\n            Whether to show the grid lines.  If any *kwargs* are supplied, it\n            is assumed you want the grid on and *visible* will be set to True.\n\n            If *visible* is *None* and there are no *kwargs*, this toggles the\n            visibility of the lines.\n\n        which : {'major', 'minor', 'both'}\n            The grid lines to apply the changes on.\n\n        **kwargs : `.Line2D` properties\n            Define the line properties of the grid, e.g.::\n\n                grid(color='r', linestyle='-', linewidth=2)\n        \"\"\"\n        if kwargs:\n            if visible is None:\n                visible = True\n            elif not visible:  # something false-like but not None\n                _api.warn_external('First parameter to grid() is false, '\n                                   'but line properties are supplied. The '\n                                   'grid will be enabled.')\n                visible = True\n        which = which.lower()\n        _api.check_in_list(['major', 'minor', 'both'], which=which)\n        gridkw = {f'grid_{name}': value for name, value in kwargs.items()}\n        if which in ['minor', 'both']:\n            gridkw['gridOn'] = (not self._minor_tick_kw['gridOn']\n                                if visible is None else visible)\n            self.set_tick_params(which='minor', **gridkw)\n        if which in ['major', 'both']:\n            gridkw['gridOn'] = (not self._major_tick_kw['gridOn']\n                                if visible is None else visible)\n            self.set_tick_params(which='major', **gridkw)\n        self.stale = True\n\n    def update_units(self, data):\n        \"\"\"\n        Introspect *data* for units converter and update the\n        axis.converter instance if necessary. Return *True*\n        if *data* is registered for unit conversion.\n        \"\"\"\n        converter = munits.registry.get_converter(data)\n        if converter is None:\n            return False\n\n        neednew = self.converter != converter\n        self.converter = converter\n        default = self.converter.default_units(data, self)\n        if default is not None and self.units is None:\n            self.set_units(default)\n\n        elif neednew:\n            self._update_axisinfo()\n        self.stale = True\n        return True\n\n    def _update_axisinfo(self):\n        \"\"\"\n        Check the axis converter for the stored units to see if the\n        axis info needs to be updated.\n        \"\"\"\n        if self.converter is None:\n            return\n\n        info = self.converter.axisinfo(self.units, self)\n\n        if info is None:\n            return\n        if info.majloc is not None and \\\n           self.major.locator != info.majloc and self.isDefault_majloc:\n            self.set_major_locator(info.majloc)\n            self.isDefault_majloc = True\n        if info.minloc is not None and \\\n           self.minor.locator != info.minloc and self.isDefault_minloc:\n            self.set_minor_locator(info.minloc)\n            self.isDefault_minloc = True\n        if info.majfmt is not None and \\\n           self.major.formatter != info.majfmt and self.isDefault_majfmt:\n            self.set_major_formatter(info.majfmt)\n            self.isDefault_majfmt = True\n        if info.minfmt is not None and \\\n           self.minor.formatter != info.minfmt and self.isDefault_minfmt:\n            self.set_minor_formatter(info.minfmt)\n            self.isDefault_minfmt = True\n        if info.label is not None and self.isDefault_label:\n            self.set_label_text(info.label)\n            self.isDefault_label = True\n\n        self.set_default_intervals()\n\n    def have_units(self):\n        return self.converter is not None or self.units is not None\n\n    def convert_units(self, x):\n        # If x is natively supported by Matplotlib, doesn't need converting\n        if munits._is_natively_supported(x):\n            return x\n\n        if self.converter is None:\n            self.converter = munits.registry.get_converter(x)\n\n        if self.converter is None:\n            return x\n        try:\n            ret = self.converter.convert(x, self.units, self)\n        except Exception as e:\n            raise munits.ConversionError('Failed to convert value(s) to axis '\n                                         f'units: {x!r}') from e\n        return ret\n\n    def set_units(self, u):\n        \"\"\"\n        Set the units for axis.\n\n        Parameters\n        ----------\n        u : units tag\n\n        Notes\n        -----\n        The units of any shared axis will also be updated.\n        \"\"\"\n        if u == self.units:\n            return\n        for name, axis in self.axes._axis_map.items():\n            if self is axis:\n                shared = [\n                    getattr(ax, f\"{name}axis\")\n                    for ax\n                    in self.axes._shared_axes[name].get_siblings(self.axes)]\n                break\n        else:\n            shared = [self]\n        for axis in shared:\n            axis.units = u\n            axis._update_axisinfo()\n            axis.callbacks.process('units')\n            axis.callbacks.process('units finalize')\n            axis.stale = True\n\n    def get_units(self):\n        \"\"\"Return the units for axis.\"\"\"\n        return self.units\n\n    def set_label_text(self, label, fontdict=None, **kwargs):\n        \"\"\"\n        Set the text value of the axis label.\n\n        Parameters\n        ----------\n        label : str\n            Text string.\n        fontdict : dict\n            Text properties.\n        **kwargs\n            Merged into fontdict.\n        \"\"\"\n        self.isDefault_label = False\n        self.label.set_text(label)\n        if fontdict is not None:\n            self.label.update(fontdict)\n        self.label.update(kwargs)\n        self.stale = True\n        return self.label\n\n    def set_major_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the major ticker.\n\n        In addition to a `~matplotlib.ticker.Formatter` instance,\n        this also accepts a ``str`` or function.\n\n        For a ``str`` a `~matplotlib.ticker.StrMethodFormatter` is used.\n        The field used for the value must be labeled ``'x'`` and the field used\n        for the position must be labeled ``'pos'``.\n        See the  `~matplotlib.ticker.StrMethodFormatter` documentation for\n        more information.\n\n        For a function, a `~matplotlib.ticker.FuncFormatter` is used.\n        The function must take two inputs (a tick value ``x`` and a\n        position ``pos``), and return a string containing the corresponding\n        tick label.\n        See the  `~matplotlib.ticker.FuncFormatter` documentation for\n        more information.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`, ``str``, or function\n        \"\"\"\n        self._set_formatter(formatter, self.major)\n\n    def set_minor_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the minor ticker.\n\n        In addition to a `~matplotlib.ticker.Formatter` instance,\n        this also accepts a ``str`` or function.\n        See `.Axis.set_major_formatter` for more information.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`, ``str``, or function\n        \"\"\"\n        self._set_formatter(formatter, self.minor)\n\n    def _set_formatter(self, formatter, level):\n        if isinstance(formatter, str):\n            formatter = mticker.StrMethodFormatter(formatter)\n        # Don't allow any other TickHelper to avoid easy-to-make errors,\n        # like using a Locator instead of a Formatter.\n        elif (callable(formatter) and\n              not isinstance(formatter, mticker.TickHelper)):\n            formatter = mticker.FuncFormatter(formatter)\n        else:\n            _api.check_isinstance(mticker.Formatter, formatter=formatter)\n\n        if (isinstance(formatter, mticker.FixedFormatter)\n                and len(formatter.seq) > 0\n                and not isinstance(level.locator, mticker.FixedLocator)):\n            _api.warn_external('FixedFormatter should only be used together '\n                               'with FixedLocator')\n\n        if level == self.major:\n            self.isDefault_majfmt = False\n        else:\n            self.isDefault_minfmt = False\n\n        level.formatter = formatter\n        formatter.set_axis(self)\n        self.stale = True\n\n    def set_major_locator(self, locator):\n        \"\"\"\n        Set the locator of the major ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        _api.check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_majloc = False\n        self.major.locator = locator\n        if self.major.formatter:\n            self.major.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True\n\n    def set_minor_locator(self, locator):\n        \"\"\"\n        Set the locator of the minor ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        _api.check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_minloc = False\n        self.minor.locator = locator\n        if self.minor.formatter:\n            self.minor.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True\n\n    def set_pickradius(self, pickradius):\n        \"\"\"\n        Set the depth of the axis used by the picker.\n\n        Parameters\n        ----------\n        pickradius : float\n            The acceptance radius for containment tests.\n            See also `.Axis.contains`.\n        \"\"\"\n        if not isinstance(pickradius, Number) or pickradius < 0:\n            raise ValueError(\"pick radius should be a distance\")\n        self._pickradius = pickradius\n\n    pickradius = property(\n        get_pickradius, set_pickradius, doc=\"The acceptance radius for \"\n        \"containment tests. See also `.Axis.contains`.\")\n\n    # Helper for set_ticklabels. Defining it here makes it picklable.\n    @staticmethod\n    def _format_with_dict(tickd, x, pos):\n        return tickd.get(x, \"\")\n\n    def set_ticklabels(self, ticklabels, *, minor=False, **kwargs):\n        r\"\"\"\n        [*Discouraged*] Set the text values of the tick labels.\n\n        .. admonition:: Discouraged\n\n            The use of this method is discouraged, because of the dependency\n            on tick positions. In most cases, you'll want to use\n            ``set_[x/y]ticks(positions, labels)`` instead.\n\n            If you are using this method, you should always fix the tick\n            positions before, e.g. by using `.Axis.set_ticks` or by explicitly\n            setting a `~.ticker.FixedLocator`. Otherwise, ticks are free to\n            move and the labels may end up in unexpected positions.\n\n        Parameters\n        ----------\n        ticklabels : sequence of str or of `.Text`\\s\n            Texts for labeling each tick location in the sequence set by\n            `.Axis.set_ticks`; the number of labels must match the number of\n            locations.\n        minor : bool\n            If True, set minor ticks instead of major ticks.\n        **kwargs\n            Text properties.\n\n        Returns\n        -------\n        list of `.Text`\\s\n            For each tick, includes ``tick.label1`` if it is visible, then\n            ``tick.label2`` if it is visible, in that order.\n        \"\"\"\n        try:\n            ticklabels = [t.get_text() if hasattr(t, 'get_text') else t\n                          for t in ticklabels]\n        except TypeError:\n            raise TypeError(f\"{ticklabels:=} must be a sequence\") from None\n        locator = (self.get_minor_locator() if minor\n                   else self.get_major_locator())\n        if isinstance(locator, mticker.FixedLocator):\n            # Passing [] as a list of ticklabels is often used as a way to\n            # remove all tick labels, so only error for > 0 ticklabels\n            if len(locator.locs) != len(ticklabels) and len(ticklabels) != 0:\n                raise ValueError(\n                    \"The number of FixedLocator locations\"\n                    f\" ({len(locator.locs)}), usually from a call to\"\n                    \" set_ticks, does not match\"\n                    f\" the number of ticklabels ({len(ticklabels)}).\")\n            tickd = {loc: lab for loc, lab in zip(locator.locs, ticklabels)}\n            func = functools.partial(self._format_with_dict, tickd)\n            formatter = mticker.FuncFormatter(func)\n        else:\n            formatter = mticker.FixedFormatter(ticklabels)\n\n        if minor:\n            self.set_minor_formatter(formatter)\n            locs = self.get_minorticklocs()\n            ticks = self.get_minor_ticks(len(locs))\n        else:\n            self.set_major_formatter(formatter)\n            locs = self.get_majorticklocs()\n            ticks = self.get_major_ticks(len(locs))\n\n        ret = []\n        for pos, (loc, tick) in enumerate(zip(locs, ticks)):\n            tick.update_position(loc)\n            tick_label = formatter(loc, pos)\n            # deal with label1\n            tick.label1.set_text(tick_label)\n            tick.label1._internal_update(kwargs)\n            # deal with label2\n            tick.label2.set_text(tick_label)\n            tick.label2._internal_update(kwargs)\n            # only return visible tick labels\n            if tick.label1.get_visible():\n                ret.append(tick.label1)\n            if tick.label2.get_visible():\n                ret.append(tick.label2)\n\n        self.stale = True\n        return ret\n\n    # Wrapper around set_ticklabels used to generate Axes.set_x/ytickabels; can\n    # go away once the API of Axes.set_x/yticklabels becomes consistent.\n    def _set_ticklabels(self, labels, *, fontdict=None, minor=False, **kwargs):\n        \"\"\"\n        Set this Axis' labels with list of string labels.\n\n        .. warning::\n            This method should only be used after fixing the tick positions\n            using `.Axis.set_ticks`. Otherwise, the labels may end up in\n            unexpected positions.\n\n        Parameters\n        ----------\n        labels : list of str\n            The label texts.\n\n        fontdict : dict, optional\n            A dictionary controlling the appearance of the ticklabels.\n            The default *fontdict* is::\n\n               {'fontsize': rcParams['axes.titlesize'],\n                'fontweight': rcParams['axes.titleweight'],\n                'verticalalignment': 'baseline',\n                'horizontalalignment': loc}\n\n        minor : bool, default: False\n            Whether to set the minor ticklabels rather than the major ones.\n\n        Returns\n        -------\n        list of `.Text`\n            The labels.\n\n        Other Parameters\n        ----------------\n        **kwargs : `~.text.Text` properties.\n        \"\"\"\n        if fontdict is not None:\n            kwargs.update(fontdict)\n        return self.set_ticklabels(labels, minor=minor, **kwargs)\n\n    def _set_tick_locations(self, ticks, *, minor=False):\n        # see docstring of set_ticks\n\n        # XXX if the user changes units, the information will be lost here\n        ticks = self.convert_units(ticks)\n        for name, axis in self.axes._axis_map.items():\n            if self is axis:\n                shared = [\n                    getattr(ax, f\"{name}axis\")\n                    for ax\n                    in self.axes._shared_axes[name].get_siblings(self.axes)]\n                break\n        else:\n            shared = [self]\n        if len(ticks):\n            for axis in shared:\n                # set_view_interval maintains any preexisting inversion.\n                axis.set_view_interval(min(ticks), max(ticks))\n        self.axes.stale = True\n        if minor:\n            self.set_minor_locator(mticker.FixedLocator(ticks))\n            return self.get_minor_ticks(len(ticks))\n        else:\n            self.set_major_locator(mticker.FixedLocator(ticks))\n            return self.get_major_ticks(len(ticks))\n\n    def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n        \"\"\"\n        Set this Axis' tick locations and optionally labels.\n\n        If necessary, the view limits of the Axis are expanded so that all\n        given ticks are visible.\n\n        Parameters\n        ----------\n        ticks : list of floats\n            List of tick locations.  The axis `.Locator` is replaced by a\n            `~.ticker.FixedLocator`.\n\n            Some tick formatters will not label arbitrary tick positions;\n            e.g. log formatters only label decade ticks by default. In\n            such a case you can set a formatter explicitly on the axis\n            using `.Axis.set_major_formatter` or provide formatted\n            *labels* yourself.\n        labels : list of str, optional\n            List of tick labels. If not set, the labels are generated with\n            the axis tick `.Formatter`.\n        minor : bool, default: False\n            If ``False``, set the major ticks; if ``True``, the minor ticks.\n        **kwargs\n            `.Text` properties for the labels. These take effect only if you\n            pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n        Notes\n        -----\n        The mandatory expansion of the view limits is an intentional design\n        choice to prevent the surprise of a non-visible tick. If you need\n        other limits, you should set the limits explicitly after setting the\n        ticks.\n        \"\"\"\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        return result\n\n    def _get_tick_boxes_siblings(self, renderer):\n        \"\"\"\n        Get the bounding boxes for this `.axis` and its siblings\n        as set by `.Figure.align_xlabels` or  `.Figure.align_ylabels`.\n\n        By default it just gets bboxes for self.\n        \"\"\"\n        # Get the Grouper keeping track of x or y label groups for this figure.\n        axis_names = [\n            name for name, axis in self.axes._axis_map.items()\n            if name in self.figure._align_label_groups and axis is self]\n        if len(axis_names) != 1:\n            return [], []\n        axis_name, = axis_names\n        grouper = self.figure._align_label_groups[axis_name]\n        bboxes = []\n        bboxes2 = []\n        # If we want to align labels from other Axes:\n        for ax in grouper.get_siblings(self.axes):\n            axis = getattr(ax, f\"{axis_name}axis\")\n            ticks_to_draw = axis._update_ticks()\n            tlb, tlb2 = axis._get_ticklabel_bboxes(ticks_to_draw, renderer)\n            bboxes.extend(tlb)\n            bboxes2.extend(tlb2)\n        return bboxes, bboxes2\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset text position based on the sequence of bounding\n        boxes of all the ticklabels.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def axis_date(self, tz=None):\n        \"\"\"\n        Set up axis ticks and labels to treat data along this Axis as dates.\n\n        Parameters\n        ----------\n        tz : str or `datetime.tzinfo`, default: :rc:`timezone`\n            The timezone used to create date labels.\n        \"\"\"\n        # By providing a sample datetime instance with the desired timezone,\n        # the registered converter can be selected, and the \"units\" attribute,\n        # which is the timezone, can be set.\n        if isinstance(tz, str):\n            import dateutil.tz\n            tz = dateutil.tz.gettz(tz)\n        self.update_units(datetime.datetime(2009, 1, 1, 0, 0, 0, 0, tz))\n\n    def get_tick_space(self):\n        \"\"\"Return the estimated number of ticks that can fit on the axis.\"\"\"\n        # Must be overridden in the subclass\n        raise NotImplementedError()\n\n    def _get_ticks_position(self):\n        \"\"\"\n        Helper for `XAxis.get_ticks_position` and `YAxis.get_ticks_position`.\n\n        Check the visibility of tick1line, label1, tick2line, and label2 on\n        the first major and the first minor ticks, and return\n\n        - 1 if only tick1line and label1 are visible (which corresponds to\n          \"bottom\" for the x-axis and \"left\" for the y-axis);\n        - 2 if only tick2line and label2 are visible (which corresponds to\n          \"top\" for the x-axis and \"right\" for the y-axis);\n        - \"default\" if only tick1line, tick2line and label1 are visible;\n        - \"unknown\" otherwise.\n        \"\"\"\n        major = self.majorTicks[0]\n        minor = self.minorTicks[0]\n        if all(tick.tick1line.get_visible()\n               and not tick.tick2line.get_visible()\n               and tick.label1.get_visible()\n               and not tick.label2.get_visible()\n               for tick in [major, minor]):\n            return 1\n        elif all(tick.tick2line.get_visible()\n                 and not tick.tick1line.get_visible()\n                 and tick.label2.get_visible()\n                 and not tick.label1.get_visible()\n                 for tick in [major, minor]):\n            return 2\n        elif all(tick.tick1line.get_visible()\n                 and tick.tick2line.get_visible()\n                 and tick.label1.get_visible()\n                 and not tick.label2.get_visible()\n                 for tick in [major, minor]):\n            return \"default\"\n        else:\n            return \"unknown\"\n\n    def get_label_position(self):\n        \"\"\"\n        Return the label position (top or bottom)\n        \"\"\"\n        return self.label_position\n\n    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_minpos(self):\n        raise NotImplementedError()",
      "instance_attributes": [
        {
          "name": "_remove_overlapping_locs",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "isDefault_label",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "axes",
          "types": null
        },
        {
          "name": "major",
          "types": {
            "kind": "NamedType",
            "name": "Ticker"
          }
        },
        {
          "name": "minor",
          "types": {
            "kind": "NamedType",
            "name": "Ticker"
          }
        },
        {
          "name": "callbacks",
          "types": null
        },
        {
          "name": "_autolabelpos",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "label",
          "types": null
        },
        {
          "name": "offsetText",
          "types": null
        },
        {
          "name": "labelpad",
          "types": null
        },
        {
          "name": "pickradius",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_major_tick_kw",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_minor_tick_kw",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_autoscale_on",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "stale",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_scale",
          "types": null
        },
        {
          "name": "isDefault_majloc",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "isDefault_minloc",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "isDefault_majfmt",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "isDefault_minfmt",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "converter",
          "types": null
        },
        {
          "name": "units",
          "types": null
        },
        {
          "name": "_pickradius",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick",
      "name": "Tick",
      "qname": "lib.matplotlib.axis.Tick",
      "decorators": [],
      "superclasses": [
        "martist.Artist"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.axis/Tick/__init__",
        "matplotlib/lib.matplotlib.axis/Tick/label@getter",
        "matplotlib/lib.matplotlib.axis/Tick/_set_labelrotation",
        "matplotlib/lib.matplotlib.axis/Tick/_apply_tickdir",
        "matplotlib/lib.matplotlib.axis/Tick/apply_tickdir",
        "matplotlib/lib.matplotlib.axis/Tick/get_tickdir",
        "matplotlib/lib.matplotlib.axis/Tick/get_tick_padding",
        "matplotlib/lib.matplotlib.axis/Tick/get_children",
        "matplotlib/lib.matplotlib.axis/Tick/set_clip_path",
        "matplotlib/lib.matplotlib.axis/Tick/get_pad_pixels",
        "matplotlib/lib.matplotlib.axis/Tick/contains",
        "matplotlib/lib.matplotlib.axis/Tick/set_pad",
        "matplotlib/lib.matplotlib.axis/Tick/get_pad",
        "matplotlib/lib.matplotlib.axis/Tick/_get_text1",
        "matplotlib/lib.matplotlib.axis/Tick/_get_text2",
        "matplotlib/lib.matplotlib.axis/Tick/_get_tick1line",
        "matplotlib/lib.matplotlib.axis/Tick/_get_tick2line",
        "matplotlib/lib.matplotlib.axis/Tick/_get_gridline",
        "matplotlib/lib.matplotlib.axis/Tick/get_loc",
        "matplotlib/lib.matplotlib.axis/Tick/draw",
        "matplotlib/lib.matplotlib.axis/Tick/set_label1",
        "matplotlib/lib.matplotlib.axis/Tick/set_label2",
        "matplotlib/lib.matplotlib.axis/Tick/set_url",
        "matplotlib/lib.matplotlib.axis/Tick/_set_artist_props",
        "matplotlib/lib.matplotlib.axis/Tick/get_view_interval",
        "matplotlib/lib.matplotlib.axis/Tick/_apply_params",
        "matplotlib/lib.matplotlib.axis/Tick/update_position",
        "matplotlib/lib.matplotlib.axis/Tick/_get_text1_transform",
        "matplotlib/lib.matplotlib.axis/Tick/_get_text2_transform"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for the axis ticks, grid lines and labels.\n\nTicks mark a position on an Axis. They contain two lines as markers and\ntwo labels; one each for the bottom and top positions (in case of an\n`.XAxis`) or for the left and right positions (in case of a `.YAxis`).",
      "docstring": "Abstract base class for the axis ticks, grid lines and labels.\n\nTicks mark a position on an Axis. They contain two lines as markers and\ntwo labels; one each for the bottom and top positions (in case of an\n`.XAxis`) or for the left and right positions (in case of a `.YAxis`).\n\nAttributes\n----------\ntick1line : `.Line2D`\n    The left/bottom tick marker.\ntick2line : `.Line2D`\n    The right/top tick marker.\ngridline : `.Line2D`\n    The grid line associated with the label position.\nlabel1 : `.Text`\n    The left/bottom tick label.\nlabel2 : `.Text`\n    The right/top tick label.",
      "code": "class Tick(martist.Artist):\n    \"\"\"\n    Abstract base class for the axis ticks, grid lines and labels.\n\n    Ticks mark a position on an Axis. They contain two lines as markers and\n    two labels; one each for the bottom and top positions (in case of an\n    `.XAxis`) or for the left and right positions (in case of a `.YAxis`).\n\n    Attributes\n    ----------\n    tick1line : `.Line2D`\n        The left/bottom tick marker.\n    tick2line : `.Line2D`\n        The right/top tick marker.\n    gridline : `.Line2D`\n        The grid line associated with the label position.\n    label1 : `.Text`\n        The left/bottom tick label.\n    label2 : `.Text`\n        The right/top tick label.\n\n    \"\"\"\n    def __init__(\n        self, axes, loc, *,\n        size=None,  # points\n        width=None,\n        color=None,\n        tickdir=None,\n        pad=None,\n        labelsize=None,\n        labelcolor=None,\n        zorder=None,\n        gridOn=None,  # defaults to axes.grid depending on axes.grid.which\n        tick1On=True,\n        tick2On=True,\n        label1On=True,\n        label2On=False,\n        major=True,\n        labelrotation=0,\n        grid_color=None,\n        grid_linestyle=None,\n        grid_linewidth=None,\n        grid_alpha=None,\n        **kwargs,  # Other Line2D kwargs applied to gridlines.\n    ):\n        \"\"\"\n        bbox is the Bound2D bounding box in display coords of the Axes\n        loc is the tick location in data coords\n        size is the tick size in points\n        \"\"\"\n        super().__init__()\n\n        if gridOn is None:\n            if major and (mpl.rcParams['axes.grid.which']\n                          in ('both', 'major')):\n                gridOn = mpl.rcParams['axes.grid']\n            elif (not major) and (mpl.rcParams['axes.grid.which']\n                                  in ('both', 'minor')):\n                gridOn = mpl.rcParams['axes.grid']\n            else:\n                gridOn = False\n\n        self.set_figure(axes.figure)\n        self.axes = axes\n\n        self._loc = loc\n        self._major = major\n\n        name = self.__name__\n        major_minor = \"major\" if major else \"minor\"\n\n        if size is None:\n            size = mpl.rcParams[f\"{name}.{major_minor}.size\"]\n        self._size = size\n\n        if width is None:\n            width = mpl.rcParams[f\"{name}.{major_minor}.width\"]\n        self._width = width\n\n        if color is None:\n            color = mpl.rcParams[f\"{name}.color\"]\n\n        if pad is None:\n            pad = mpl.rcParams[f\"{name}.{major_minor}.pad\"]\n        self._base_pad = pad\n\n        if labelcolor is None:\n            labelcolor = mpl.rcParams[f\"{name}.labelcolor\"]\n\n        if labelcolor == 'inherit':\n            # inherit from tick color\n            labelcolor = mpl.rcParams[f\"{name}.color\"]\n\n        if labelsize is None:\n            labelsize = mpl.rcParams[f\"{name}.labelsize\"]\n\n        self._set_labelrotation(labelrotation)\n\n        if zorder is None:\n            if major:\n                zorder = mlines.Line2D.zorder + 0.01\n            else:\n                zorder = mlines.Line2D.zorder\n        self._zorder = zorder\n\n        if grid_color is None:\n            grid_color = mpl.rcParams[\"grid.color\"]\n        if grid_linestyle is None:\n            grid_linestyle = mpl.rcParams[\"grid.linestyle\"]\n        if grid_linewidth is None:\n            grid_linewidth = mpl.rcParams[\"grid.linewidth\"]\n        if grid_alpha is None and not mcolors._has_alpha_channel(grid_color):\n            # alpha precedence: kwarg > color alpha > rcParams['grid.alpha']\n            # Note: only resolve to rcParams if the color does not have alpha\n            # otherwise `grid(color=(1, 1, 1, 0.5))` would work like\n            #   grid(color=(1, 1, 1, 0.5), alpha=rcParams['grid.alpha'])\n            # so the that the rcParams default would override color alpha.\n            grid_alpha = mpl.rcParams[\"grid.alpha\"]\n        grid_kw = {k[5:]: v for k, v in kwargs.items()}\n\n        self.tick1line = mlines.Line2D(\n            [], [],\n            color=color, linestyle=\"none\", zorder=zorder, visible=tick1On,\n            markeredgecolor=color, markersize=size, markeredgewidth=width,\n        )\n        self.tick2line = mlines.Line2D(\n            [], [],\n            color=color, linestyle=\"none\", zorder=zorder, visible=tick2On,\n            markeredgecolor=color, markersize=size, markeredgewidth=width,\n        )\n        self.gridline = mlines.Line2D(\n            [], [],\n            color=grid_color, alpha=grid_alpha, visible=gridOn,\n            linestyle=grid_linestyle, linewidth=grid_linewidth, marker=\"\",\n            **grid_kw,\n        )\n        self.gridline.get_path()._interpolation_steps = \\\n            GRIDLINE_INTERPOLATION_STEPS\n        self.label1 = mtext.Text(\n            np.nan, np.nan,\n            fontsize=labelsize, color=labelcolor, visible=label1On,\n            rotation=self._labelrotation[1])\n        self.label2 = mtext.Text(\n            np.nan, np.nan,\n            fontsize=labelsize, color=labelcolor, visible=label2On,\n            rotation=self._labelrotation[1])\n\n        self._apply_tickdir(tickdir)\n\n        for artist in [self.tick1line, self.tick2line, self.gridline,\n                       self.label1, self.label2]:\n            self._set_artist_props(artist)\n\n        self.update_position(loc)\n\n    @property\n    @_api.deprecated(\"3.1\", alternative=\"Tick.label1\", removal=\"3.8\")\n    def label(self):\n        return self.label1\n\n    def _set_labelrotation(self, labelrotation):\n        if isinstance(labelrotation, str):\n            mode = labelrotation\n            angle = 0\n        elif isinstance(labelrotation, (tuple, list)):\n            mode, angle = labelrotation\n        else:\n            mode = 'default'\n            angle = labelrotation\n        _api.check_in_list(['auto', 'default'], labelrotation=mode)\n        self._labelrotation = (mode, angle)\n\n    def _apply_tickdir(self, tickdir):\n        \"\"\"Set tick direction.  Valid values are 'out', 'in', 'inout'.\"\"\"\n        # This method is responsible for updating `_pad`, and, in subclasses,\n        # for setting the tick{1,2}line markers as well.  From the user\n        # perspective this should always be called though _apply_params, which\n        # further updates ticklabel positions using the new pads.\n        if tickdir is None:\n            tickdir = mpl.rcParams[f'{self.__name__}.direction']\n        _api.check_in_list(['in', 'out', 'inout'], tickdir=tickdir)\n        self._tickdir = tickdir\n        self._pad = self._base_pad + self.get_tick_padding()\n\n    @_api.deprecated(\"3.5\", alternative=\"`.Axis.set_tick_params`\")\n    def apply_tickdir(self, tickdir):\n        self._apply_tickdir(tickdir)\n        self.stale = True\n\n    def get_tickdir(self):\n        return self._tickdir\n\n    def get_tick_padding(self):\n        \"\"\"Get the length of the tick outside of the Axes.\"\"\"\n        padding = {\n            'in': 0.0,\n            'inout': 0.5,\n            'out': 1.0\n        }\n        return self._size * padding[self._tickdir]\n\n    def get_children(self):\n        children = [self.tick1line, self.tick2line,\n                    self.gridline, self.label1, self.label2]\n        return children\n\n    def set_clip_path(self, clippath, transform=None):\n        # docstring inherited\n        super().set_clip_path(clippath, transform)\n        self.gridline.set_clip_path(clippath, transform)\n        self.stale = True\n\n    @_api.deprecated(\"3.6\")\n    def get_pad_pixels(self):\n        return self.figure.dpi * self._base_pad / 72\n\n    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the mouse event occurred in the Tick marks.\n\n        This function always returns false.  It is more useful to test if the\n        axis as a whole contains the mouse rather than the set of tick marks.\n        \"\"\"\n        inside, info = self._default_contains(mouseevent)\n        if inside is not None:\n            return inside, info\n        return False, {}\n\n    def set_pad(self, val):\n        \"\"\"\n        Set the tick label pad in points\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        self._apply_params(pad=val)\n        self.stale = True\n\n    def get_pad(self):\n        \"\"\"Get the value of the tick label pad in points.\"\"\"\n        return self._base_pad\n\n    def _get_text1(self):\n        \"\"\"Get the default Text 1 instance.\"\"\"\n\n    def _get_text2(self):\n        \"\"\"Get the default Text 2 instance.\"\"\"\n\n    def _get_tick1line(self):\n        \"\"\"Get the default line2D instance for tick1.\"\"\"\n\n    def _get_tick2line(self):\n        \"\"\"Get the default line2D instance for tick2.\"\"\"\n\n    def _get_gridline(self):\n        \"\"\"Get the default grid Line2d instance for this tick.\"\"\"\n\n    def get_loc(self):\n        \"\"\"Return the tick location (data coords) as a scalar.\"\"\"\n        return self._loc\n\n    @martist.allow_rasterization\n    def draw(self, renderer):\n        if not self.get_visible():\n            self.stale = False\n            return\n        renderer.open_group(self.__name__, gid=self.get_gid())\n        for artist in [self.gridline, self.tick1line, self.tick2line,\n                       self.label1, self.label2]:\n            artist.draw(renderer)\n        renderer.close_group(self.__name__)\n        self.stale = False\n\n    def set_label1(self, s):\n        \"\"\"\n        Set the label1 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label1.set_text(s)\n        self.stale = True\n\n    set_label = set_label1\n\n    def set_label2(self, s):\n        \"\"\"\n        Set the label2 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label2.set_text(s)\n        self.stale = True\n\n    def set_url(self, url):\n        \"\"\"\n        Set the url of label1 and label2.\n\n        Parameters\n        ----------\n        url : str\n        \"\"\"\n        super().set_url(url)\n        self.label1.set_url(url)\n        self.label2.set_url(url)\n        self.stale = True\n\n    def _set_artist_props(self, a):\n        a.set_figure(self.figure)\n\n    def get_view_interval(self):\n        \"\"\"\n        Return the view limits ``(min, max)`` of the axis the tick belongs to.\n        \"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def _apply_params(self, **kwargs):\n        for name, target in [(\"gridOn\", self.gridline),\n                             (\"tick1On\", self.tick1line),\n                             (\"tick2On\", self.tick2line),\n                             (\"label1On\", self.label1),\n                             (\"label2On\", self.label2)]:\n            if name in kwargs:\n                target.set_visible(kwargs.pop(name))\n        if any(k in kwargs for k in ['size', 'width', 'pad', 'tickdir']):\n            self._size = kwargs.pop('size', self._size)\n            # Width could be handled outside this block, but it is\n            # convenient to leave it here.\n            self._width = kwargs.pop('width', self._width)\n            self._base_pad = kwargs.pop('pad', self._base_pad)\n            # _apply_tickdir uses _size and _base_pad to make _pad, and also\n            # sets the ticklines markers.\n            self._apply_tickdir(kwargs.pop('tickdir', self._tickdir))\n            for line in (self.tick1line, self.tick2line):\n                line.set_markersize(self._size)\n                line.set_markeredgewidth(self._width)\n            # _get_text1_transform uses _pad from _apply_tickdir.\n            trans = self._get_text1_transform()[0]\n            self.label1.set_transform(trans)\n            trans = self._get_text2_transform()[0]\n            self.label2.set_transform(trans)\n        tick_kw = {k: v for k, v in kwargs.items() if k in ['color', 'zorder']}\n        if 'color' in kwargs:\n            tick_kw['markeredgecolor'] = kwargs['color']\n        self.tick1line.set(**tick_kw)\n        self.tick2line.set(**tick_kw)\n        for k, v in tick_kw.items():\n            setattr(self, '_' + k, v)\n\n        if 'labelrotation' in kwargs:\n            self._set_labelrotation(kwargs.pop('labelrotation'))\n            self.label1.set(rotation=self._labelrotation[1])\n            self.label2.set(rotation=self._labelrotation[1])\n\n        label_kw = {k[5:]: v for k, v in kwargs.items()\n                    if k in ['labelsize', 'labelcolor']}\n        self.label1.set(**label_kw)\n        self.label2.set(**label_kw)\n\n        grid_kw = {k[5:]: v for k, v in kwargs.items()\n                   if k in _gridline_param_names}\n        self.gridline.set(**grid_kw)\n\n    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        raise NotImplementedError('Derived must override')\n\n    def _get_text1_transform(self):\n        raise NotImplementedError('Derived must override')\n\n    def _get_text2_transform(self):\n        raise NotImplementedError('Derived must override')",
      "instance_attributes": [
        {
          "name": "axes",
          "types": null
        },
        {
          "name": "_loc",
          "types": null
        },
        {
          "name": "_major",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_size",
          "types": null
        },
        {
          "name": "_width",
          "types": null
        },
        {
          "name": "_base_pad",
          "types": null
        },
        {
          "name": "_zorder",
          "types": null
        },
        {
          "name": "tick1line",
          "types": null
        },
        {
          "name": "tick2line",
          "types": null
        },
        {
          "name": "gridline",
          "types": null
        },
        {
          "name": "label1",
          "types": null
        },
        {
          "name": "label2",
          "types": null
        },
        {
          "name": "_labelrotation",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "_tickdir",
          "types": null
        },
        {
          "name": "_pad",
          "types": null
        },
        {
          "name": "stale",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Ticker",
      "name": "Ticker",
      "qname": "lib.matplotlib.axis.Ticker",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.axis/Ticker/__init__",
        "matplotlib/lib.matplotlib.axis/Ticker/locator@getter",
        "matplotlib/lib.matplotlib.axis/Ticker/locator@setter",
        "matplotlib/lib.matplotlib.axis/Ticker/formatter@getter",
        "matplotlib/lib.matplotlib.axis/Ticker/formatter@setter"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A container for the objects defining tick position and format.",
      "docstring": "A container for the objects defining tick position and format.\n\nAttributes\n----------\nlocator : `matplotlib.ticker.Locator` subclass\n    Determines the positions of the ticks.\nformatter : `matplotlib.ticker.Formatter` subclass\n    Determines the format of the tick labels.",
      "code": "class Ticker:\n    \"\"\"\n    A container for the objects defining tick position and format.\n\n    Attributes\n    ----------\n    locator : `matplotlib.ticker.Locator` subclass\n        Determines the positions of the ticks.\n    formatter : `matplotlib.ticker.Formatter` subclass\n        Determines the format of the tick labels.\n    \"\"\"\n\n    def __init__(self):\n        self._locator = None\n        self._formatter = None\n        self._locator_is_default = True\n        self._formatter_is_default = True\n\n    @property\n    def locator(self):\n        return self._locator\n\n    @locator.setter\n    def locator(self, locator):\n        if not isinstance(locator, mticker.Locator):\n            raise TypeError('locator must be a subclass of '\n                            'matplotlib.ticker.Locator')\n        self._locator = locator\n\n    @property\n    def formatter(self):\n        return self._formatter\n\n    @formatter.setter\n    def formatter(self, formatter):\n        if not isinstance(formatter, mticker.Formatter):\n            raise TypeError('formatter must be a subclass of '\n                            'matplotlib.ticker.Formatter')\n        self._formatter = formatter",
      "instance_attributes": [
        {
          "name": "_locator",
          "types": null
        },
        {
          "name": "_formatter",
          "types": null
        },
        {
          "name": "_locator_is_default",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_formatter_is_default",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "locator",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis",
      "name": "XAxis",
      "qname": "lib.matplotlib.axis.XAxis",
      "decorators": [],
      "superclasses": [
        "Axis"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.axis/XAxis/__init__",
        "matplotlib/lib.matplotlib.axis/XAxis/contains",
        "matplotlib/lib.matplotlib.axis/XAxis/set_label_position",
        "matplotlib/lib.matplotlib.axis/XAxis/_update_label_position",
        "matplotlib/lib.matplotlib.axis/XAxis/_update_offset_text_position",
        "matplotlib/lib.matplotlib.axis/XAxis/get_text_heights",
        "matplotlib/lib.matplotlib.axis/XAxis/set_ticks_position",
        "matplotlib/lib.matplotlib.axis/XAxis/tick_top",
        "matplotlib/lib.matplotlib.axis/XAxis/tick_bottom",
        "matplotlib/lib.matplotlib.axis/XAxis/get_ticks_position",
        "matplotlib/lib.matplotlib.axis/XAxis/get_minpos",
        "matplotlib/lib.matplotlib.axis/XAxis/set_default_intervals",
        "matplotlib/lib.matplotlib.axis/XAxis/get_tick_space"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class XAxis(Axis):\n    __name__ = 'xaxis'\n    axis_name = 'x'  #: Read-only name identifying the axis.\n    _tick_class = XTick\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in axes coords, y in display coords (to be updated at draw time by\n        # _update_label_positions and _update_offset_text_position).\n        self.label.set(\n            x=0.5, y=0,\n            verticalalignment='top', horizontalalignment='center',\n            transform=mtransforms.blended_transform_factory(\n                self.axes.transAxes, mtransforms.IdentityTransform()),\n        )\n        self.label_position = 'bottom'\n        self.offsetText.set(\n            x=1, y=0,\n            verticalalignment='top', horizontalalignment='right',\n            transform=mtransforms.blended_transform_factory(\n                self.axes.transAxes, mtransforms.IdentityTransform()),\n            fontsize=mpl.rcParams['xtick.labelsize'],\n            color=mpl.rcParams['xtick.color'],\n        )\n        self.offset_text_position = 'bottom'\n\n    def contains(self, mouseevent):\n        \"\"\"Test whether the mouse event occurred in the x axis.\"\"\"\n        inside, info = self._default_contains(mouseevent)\n        if inside is not None:\n            return inside, info\n\n        x, y = mouseevent.x, mouseevent.y\n        try:\n            trans = self.axes.transAxes.inverted()\n            xaxes, yaxes = trans.transform((x, y))\n        except ValueError:\n            return False, {}\n        (l, b), (r, t) = self.axes.transAxes.transform([(0, 0), (1, 1)])\n        inaxis = 0 <= xaxes <= 1 and (\n            b - self._pickradius < y < b or\n            t < y < t + self._pickradius)\n        return inaxis, {}\n\n    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        self.label.set_verticalalignment(_api.check_getitem({\n            'top': 'baseline', 'bottom': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_xlabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n\n        x, y = self.label.get_position()\n        if self.label_position == 'bottom':\n            try:\n                spine = self.axes.spines['bottom']\n                spinebbox = spine.get_window_extent()\n            except KeyError:\n                # use Axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            bottom = bbox.y0\n\n            self.label.set_position(\n                (x, bottom - self.labelpad * self.figure.dpi / 72)\n            )\n        else:\n            try:\n                spine = self.axes.spines['top']\n                spinebbox = spine.get_window_extent()\n            except KeyError:\n                # use Axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            top = bbox.y1\n\n            self.label.set_position(\n                (x, top + self.labelpad * self.figure.dpi / 72)\n            )\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        if not hasattr(self, '_tick_position'):\n            self._tick_position = 'bottom'\n        if self._tick_position == 'bottom':\n            if not len(bboxes):\n                bottom = self.axes.bbox.ymin\n            else:\n                bbox = mtransforms.Bbox.union(bboxes)\n                bottom = bbox.y0\n            y = bottom - self.OFFSETTEXTPAD * self.figure.dpi / 72\n        else:\n            if not len(bboxes2):\n                top = self.axes.bbox.ymax\n            else:\n                bbox = mtransforms.Bbox.union(bboxes2)\n                top = bbox.y1\n            y = top + self.OFFSETTEXTPAD * self.figure.dpi / 72\n        self.offsetText.set_position((x, y))\n\n    @_api.deprecated(\"3.6\")\n    def get_text_heights(self, renderer):\n        \"\"\"\n        Return how much space should be reserved for text above and below the\n        Axes, as a pair of floats.\n        \"\"\"\n        bbox, bbox2 = self.get_ticklabel_extents(renderer)\n        # MGDTODO: Need a better way to get the pad\n        pad_pixels = self.majorTicks[0].get_pad_pixels()\n\n        above = 0.0\n        if bbox2.height:\n            above += bbox2.height + pad_pixels\n        below = 0.0\n        if bbox.height:\n            below += bbox.height + pad_pixels\n\n        if self.get_label_position() == 'top':\n            above += self.label.get_window_extent(renderer).height + pad_pixels\n        else:\n            below += self.label.get_window_extent(renderer).height + pad_pixels\n        return above, below\n\n    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position.\n\n        Parameters\n        ----------\n        position : {'top', 'bottom', 'both', 'default', 'none'}\n            'both' sets the ticks to appear on both positions, but does not\n            change the tick labels.  'default' resets the tick positions to\n            the default: ticks on both positions, labels at bottom.  'none'\n            can be used if you don't want any ticks. 'none' and 'both'\n            affect only the ticks, not the labels.\n        \"\"\"\n        _api.check_in_list(['top', 'bottom', 'both', 'default', 'none'],\n                           position=position)\n        if position == 'top':\n            self.set_tick_params(which='both', top=True, labeltop=True,\n                                 bottom=False, labelbottom=False)\n            self._tick_position = 'top'\n            self.offsetText.set_verticalalignment('bottom')\n        elif position == 'bottom':\n            self.set_tick_params(which='both', top=False, labeltop=False,\n                                 bottom=True, labelbottom=True)\n            self._tick_position = 'bottom'\n            self.offsetText.set_verticalalignment('top')\n        elif position == 'both':\n            self.set_tick_params(which='both', top=True,\n                                 bottom=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', top=False,\n                                 bottom=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', top=True, labeltop=False,\n                                 bottom=True, labelbottom=True)\n            self._tick_position = 'bottom'\n            self.offsetText.set_verticalalignment('top')\n        else:\n            assert False, \"unhandled parameter not caught by _check_in_list\"\n        self.stale = True\n\n    def tick_top(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the top of the Axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('top')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labeltop=label)\n\n    def tick_bottom(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the bottom of the Axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('bottom')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labelbottom=label)\n\n    def get_ticks_position(self):\n        \"\"\"\n        Return the ticks position (\"top\", \"bottom\", \"default\", or \"unknown\").\n        \"\"\"\n        return {1: \"bottom\", 2: \"top\",\n                \"default\": \"default\", \"unknown\": \"unknown\"}[\n                    self._get_ticks_position()]\n\n    get_view_interval, set_view_interval = _make_getset_interval(\n        \"view\", \"viewLim\", \"intervalx\")\n    get_data_interval, set_data_interval = _make_getset_interval(\n        \"data\", \"dataLim\", \"intervalx\")\n\n    def get_minpos(self):\n        return self.axes.dataLim.minposx\n\n    def set_default_intervals(self):\n        # docstring inherited\n        # only change view if dataLim has not changed and user has\n        # not changed the view:\n        if (not self.axes.dataLim.mutatedx() and\n                not self.axes.viewLim.mutatedx()):\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    xmin, xmax = self.convert_units(info.default_limits)\n                    self.axes.viewLim.intervalx = xmin, xmax\n        self.stale = True\n\n    def get_tick_space(self):\n        ends = mtransforms.Bbox.unit().transformed(\n            self.axes.transAxes - self.figure.dpi_scale_trans)\n        length = ends.width * 72\n        # There is a heuristic here that the aspect ratio of tick text\n        # is no more than 3:1\n        size = self._get_tick_label_size('x') * 3\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1",
      "instance_attributes": [
        {
          "name": "label_position",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "offset_text_position",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "stale",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_tick_position",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XTick",
      "name": "XTick",
      "qname": "lib.matplotlib.axis.XTick",
      "decorators": [],
      "superclasses": [
        "Tick"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.axis/XTick/__init__",
        "matplotlib/lib.matplotlib.axis/XTick/_get_text1_transform",
        "matplotlib/lib.matplotlib.axis/XTick/_get_text2_transform",
        "matplotlib/lib.matplotlib.axis/XTick/_apply_tickdir",
        "matplotlib/lib.matplotlib.axis/XTick/update_position",
        "matplotlib/lib.matplotlib.axis/XTick/get_view_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Contains all the Artists needed to make an x tick - the tick line,\nthe label text and the grid line",
      "docstring": "Contains all the Artists needed to make an x tick - the tick line,\nthe label text and the grid line",
      "code": "class XTick(Tick):\n    \"\"\"\n    Contains all the Artists needed to make an x tick - the tick line,\n    the label text and the grid line\n    \"\"\"\n    __name__ = 'xtick'\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in data coords, y in axes coords\n        ax = self.axes\n        self.tick1line.set(\n            data=([0], [0]), transform=ax.get_xaxis_transform(\"tick1\"))\n        self.tick2line.set(\n            data=([0], [1]), transform=ax.get_xaxis_transform(\"tick2\"))\n        self.gridline.set(\n            data=([0, 0], [0, 1]), transform=ax.get_xaxis_transform(\"grid\"))\n        # the y loc is 3 points below the min of y axis\n        trans, va, ha = self._get_text1_transform()\n        self.label1.set(\n            x=0, y=0,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )\n        trans, va, ha = self._get_text2_transform()\n        self.label2.set(\n            x=0, y=1,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )\n\n    def _get_text1_transform(self):\n        return self.axes.get_xaxis_text1_transform(self._pad)\n\n    def _get_text2_transform(self):\n        return self.axes.get_xaxis_text2_transform(self._pad)\n\n    def _apply_tickdir(self, tickdir):\n        # docstring inherited\n        super()._apply_tickdir(tickdir)\n        mark1, mark2 = {\n            'out': (mlines.TICKDOWN, mlines.TICKUP),\n            'in': (mlines.TICKUP, mlines.TICKDOWN),\n            'inout': ('|', '|'),\n        }[self._tickdir]\n        self.tick1line.set_marker(mark1)\n        self.tick2line.set_marker(mark2)\n\n    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_xdata((loc,))\n        self.tick2line.set_xdata((loc,))\n        self.gridline.set_xdata((loc,))\n        self.label1.set_x(loc)\n        self.label2.set_x(loc)\n        self._loc = loc\n        self.stale = True\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervalx",
      "instance_attributes": [
        {
          "name": "_loc",
          "types": null
        },
        {
          "name": "stale",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis",
      "name": "YAxis",
      "qname": "lib.matplotlib.axis.YAxis",
      "decorators": [],
      "superclasses": [
        "Axis"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.axis/YAxis/__init__",
        "matplotlib/lib.matplotlib.axis/YAxis/contains",
        "matplotlib/lib.matplotlib.axis/YAxis/set_label_position",
        "matplotlib/lib.matplotlib.axis/YAxis/_update_label_position",
        "matplotlib/lib.matplotlib.axis/YAxis/_update_offset_text_position",
        "matplotlib/lib.matplotlib.axis/YAxis/set_offset_position",
        "matplotlib/lib.matplotlib.axis/YAxis/get_text_widths",
        "matplotlib/lib.matplotlib.axis/YAxis/set_ticks_position",
        "matplotlib/lib.matplotlib.axis/YAxis/tick_right",
        "matplotlib/lib.matplotlib.axis/YAxis/tick_left",
        "matplotlib/lib.matplotlib.axis/YAxis/get_ticks_position",
        "matplotlib/lib.matplotlib.axis/YAxis/get_minpos",
        "matplotlib/lib.matplotlib.axis/YAxis/set_default_intervals",
        "matplotlib/lib.matplotlib.axis/YAxis/get_tick_space"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class YAxis(Axis):\n    __name__ = 'yaxis'\n    axis_name = 'y'  #: Read-only name identifying the axis.\n    _tick_class = YTick\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in display coords, y in axes coords (to be updated at draw time by\n        # _update_label_positions and _update_offset_text_position).\n        self.label.set(\n            x=0, y=0.5,\n            verticalalignment='bottom', horizontalalignment='center',\n            rotation='vertical', rotation_mode='anchor',\n            transform=mtransforms.blended_transform_factory(\n                mtransforms.IdentityTransform(), self.axes.transAxes),\n        )\n        self.label_position = 'left'\n        # x in axes coords, y in display coords(!).\n        self.offsetText.set(\n            x=0, y=0.5,\n            verticalalignment='baseline', horizontalalignment='left',\n            transform=mtransforms.blended_transform_factory(\n                self.axes.transAxes, mtransforms.IdentityTransform()),\n            fontsize=mpl.rcParams['ytick.labelsize'],\n            color=mpl.rcParams['ytick.color'],\n        )\n        self.offset_text_position = 'left'\n\n    def contains(self, mouseevent):\n        # docstring inherited\n        inside, info = self._default_contains(mouseevent)\n        if inside is not None:\n            return inside, info\n\n        x, y = mouseevent.x, mouseevent.y\n        try:\n            trans = self.axes.transAxes.inverted()\n            xaxes, yaxes = trans.transform((x, y))\n        except ValueError:\n            return False, {}\n        (l, b), (r, t) = self.axes.transAxes.transform([(0, 0), (1, 1)])\n        inaxis = 0 <= yaxes <= 1 and (\n            l - self._pickradius < x < l or\n            r < x < r + self._pickradius)\n        return inaxis, {}\n\n    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (left or right)\n\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        self.label.set_rotation_mode('anchor')\n        self.label.set_verticalalignment(_api.check_getitem({\n            'left': 'bottom', 'right': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True\n\n    def _update_label_position(self, renderer):\n        \"\"\"\n        Update the label position based on the bounding box enclosing\n        all the ticklabels and axis spine\n        \"\"\"\n        if not self._autolabelpos:\n            return\n\n        # get bounding boxes for this axis and any siblings\n        # that have been set by `fig.align_ylabels()`\n        bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n        x, y = self.label.get_position()\n        if self.label_position == 'left':\n            try:\n                spine = self.axes.spines['left']\n                spinebbox = spine.get_window_extent()\n            except KeyError:\n                # use Axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n            bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n            left = bbox.x0\n            self.label.set_position(\n                (left - self.labelpad * self.figure.dpi / 72, y)\n            )\n\n        else:\n            try:\n                spine = self.axes.spines['right']\n                spinebbox = spine.get_window_extent()\n            except KeyError:\n                # use Axes if spine doesn't exist\n                spinebbox = self.axes.bbox\n\n            bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n            right = bbox.x1\n            self.label.set_position(\n                (right + self.labelpad * self.figure.dpi / 72, y)\n            )\n\n    def _update_offset_text_position(self, bboxes, bboxes2):\n        \"\"\"\n        Update the offset_text position based on the sequence of bounding\n        boxes of all the ticklabels\n        \"\"\"\n        x, _ = self.offsetText.get_position()\n        if 'outline' in self.axes.spines:\n            # Special case for colorbars:\n            bbox = self.axes.spines['outline'].get_window_extent()\n        else:\n            bbox = self.axes.bbox\n        top = bbox.ymax\n        self.offsetText.set_position(\n            (x, top + self.OFFSETTEXTPAD * self.figure.dpi / 72)\n        )\n\n    def set_offset_position(self, position):\n        \"\"\"\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        x = _api.check_getitem({'left': 0, 'right': 1}, position=position)\n\n        self.offsetText.set_ha(position)\n        self.offsetText.set_position((x, y))\n        self.stale = True\n\n    @_api.deprecated(\"3.6\")\n    def get_text_widths(self, renderer):\n        bbox, bbox2 = self.get_ticklabel_extents(renderer)\n        # MGDTODO: Need a better way to get the pad\n        pad_pixels = self.majorTicks[0].get_pad_pixels()\n\n        left = 0.0\n        if bbox.width:\n            left += bbox.width + pad_pixels\n        right = 0.0\n        if bbox2.width:\n            right += bbox2.width + pad_pixels\n\n        if self.get_label_position() == 'left':\n            left += self.label.get_window_extent(renderer).width + pad_pixels\n        else:\n            right += self.label.get_window_extent(renderer).width + pad_pixels\n        return left, right\n\n    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position.\n\n        Parameters\n        ----------\n        position : {'left', 'right', 'both', 'default', 'none'}\n            'both' sets the ticks to appear on both positions, but does not\n            change the tick labels.  'default' resets the tick positions to\n            the default: ticks on both positions, labels at left.  'none'\n            can be used if you don't want any ticks. 'none' and 'both'\n            affect only the ticks, not the labels.\n        \"\"\"\n        _api.check_in_list(['left', 'right', 'both', 'default', 'none'],\n                           position=position)\n        if position == 'right':\n            self.set_tick_params(which='both', right=True, labelright=True,\n                                 left=False, labelleft=False)\n            self.set_offset_position(position)\n        elif position == 'left':\n            self.set_tick_params(which='both', right=False, labelright=False,\n                                 left=True, labelleft=True)\n            self.set_offset_position(position)\n        elif position == 'both':\n            self.set_tick_params(which='both', right=True,\n                                 left=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', right=False,\n                                 left=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', right=True, labelright=False,\n                                 left=True, labelleft=True)\n        else:\n            assert False, \"unhandled parameter not caught by _check_in_list\"\n        self.stale = True\n\n    def tick_right(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the right of the Axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('right')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelright=label)\n\n    def tick_left(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the left of the Axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('left')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelleft=label)\n\n    def get_ticks_position(self):\n        \"\"\"\n        Return the ticks position (\"left\", \"right\", \"default\", or \"unknown\").\n        \"\"\"\n        return {1: \"left\", 2: \"right\",\n                \"default\": \"default\", \"unknown\": \"unknown\"}[\n                    self._get_ticks_position()]\n\n    get_view_interval, set_view_interval = _make_getset_interval(\n        \"view\", \"viewLim\", \"intervaly\")\n    get_data_interval, set_data_interval = _make_getset_interval(\n        \"data\", \"dataLim\", \"intervaly\")\n\n    def get_minpos(self):\n        return self.axes.dataLim.minposy\n\n    def set_default_intervals(self):\n        # docstring inherited\n        # only change view if dataLim has not changed and user has\n        # not changed the view:\n        if (not self.axes.dataLim.mutatedy() and\n                not self.axes.viewLim.mutatedy()):\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    ymin, ymax = self.convert_units(info.default_limits)\n                    self.axes.viewLim.intervaly = ymin, ymax\n        self.stale = True\n\n    def get_tick_space(self):\n        ends = mtransforms.Bbox.unit().transformed(\n            self.axes.transAxes - self.figure.dpi_scale_trans)\n        length = ends.height * 72\n        # Having a spacing of at least 2 just looks good.\n        size = self._get_tick_label_size('y') * 2\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1",
      "instance_attributes": [
        {
          "name": "label_position",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "offset_text_position",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "stale",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YTick",
      "name": "YTick",
      "qname": "lib.matplotlib.axis.YTick",
      "decorators": [],
      "superclasses": [
        "Tick"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.axis/YTick/__init__",
        "matplotlib/lib.matplotlib.axis/YTick/_get_text1_transform",
        "matplotlib/lib.matplotlib.axis/YTick/_get_text2_transform",
        "matplotlib/lib.matplotlib.axis/YTick/_apply_tickdir",
        "matplotlib/lib.matplotlib.axis/YTick/update_position",
        "matplotlib/lib.matplotlib.axis/YTick/get_view_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Contains all the Artists needed to make a Y tick - the tick line,\nthe label text and the grid line",
      "docstring": "Contains all the Artists needed to make a Y tick - the tick line,\nthe label text and the grid line",
      "code": "class YTick(Tick):\n    \"\"\"\n    Contains all the Artists needed to make a Y tick - the tick line,\n    the label text and the grid line\n    \"\"\"\n    __name__ = 'ytick'\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in axes coords, y in data coords\n        ax = self.axes\n        self.tick1line.set(\n            data=([0], [0]), transform=ax.get_yaxis_transform(\"tick1\"))\n        self.tick2line.set(\n            data=([1], [0]), transform=ax.get_yaxis_transform(\"tick2\"))\n        self.gridline.set(\n            data=([0, 1], [0, 0]), transform=ax.get_yaxis_transform(\"grid\"))\n        # the y loc is 3 points below the min of y axis\n        trans, va, ha = self._get_text1_transform()\n        self.label1.set(\n            x=0, y=0,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )\n        trans, va, ha = self._get_text2_transform()\n        self.label2.set(\n            x=1, y=0,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )\n\n    def _get_text1_transform(self):\n        return self.axes.get_yaxis_text1_transform(self._pad)\n\n    def _get_text2_transform(self):\n        return self.axes.get_yaxis_text2_transform(self._pad)\n\n    def _apply_tickdir(self, tickdir):\n        # docstring inherited\n        super()._apply_tickdir(tickdir)\n        mark1, mark2 = {\n            'out': (mlines.TICKLEFT, mlines.TICKRIGHT),\n            'in': (mlines.TICKRIGHT, mlines.TICKLEFT),\n            'inout': ('_', '_'),\n        }[self._tickdir]\n        self.tick1line.set_marker(mark1)\n        self.tick2line.set_marker(mark2)\n\n    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_ydata((loc,))\n        self.tick2line.set_ydata((loc,))\n        self.gridline.set_ydata((loc,))\n        self.label1.set_y(loc)\n        self.label2.set_y(loc)\n        self._loc = loc\n        self.stale = True\n\n    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervaly",
      "instance_attributes": [
        {
          "name": "_loc",
          "types": null
        },
        {
          "name": "stale",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg",
      "name": "FigureCanvasAgg",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/draw",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_rgb",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_argb",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/buffer_rgba",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/_print_pil",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_to_buffer",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasAgg(FigureCanvasBase):\n    # docstring inherited\n\n    _lastKey = None  # Overwritten per-instance on the first draw.\n\n    def copy_from_bbox(self, bbox):\n        renderer = self.get_renderer()\n        return renderer.copy_from_bbox(bbox)\n\n    def restore_region(self, region, bbox=None, xy=None):\n        renderer = self.get_renderer()\n        return renderer.restore_region(region, bbox, xy)\n\n    def draw(self):\n        # docstring inherited\n        self.renderer = self.get_renderer()\n        self.renderer.clear()\n        # Acquire a lock on the shared font cache.\n        with RendererAgg.lock, \\\n             (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self.figure.draw(self.renderer)\n            # A GUI class may be need to update a window using this draw, so\n            # don't forget to call the superclass.\n            super().draw()\n\n    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n\n    def tostring_rgb(self):\n        \"\"\"\n        Get the image as RGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_rgb()\n\n    def tostring_argb(self):\n        \"\"\"\n        Get the image as ARGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_argb()\n\n    def buffer_rgba(self):\n        \"\"\"\n        Get the image as a `memoryview` to the renderer's buffer.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.buffer_rgba()\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_raw(self, filename_or_obj, *args):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        with cbook.open_file_cm(filename_or_obj, \"wb\") as fh:\n            fh.write(renderer.buffer_rgba())\n\n    print_rgba = print_raw\n\n    def _print_pil(self, filename_or_obj, fmt, pil_kwargs, metadata=None):\n        \"\"\"\n        Draw the canvas, then save it using `.image.imsave` (to which\n        *pil_kwargs* and *metadata* are forwarded).\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n        mpl.image.imsave(\n            filename_or_obj, self.buffer_rgba(), format=fmt, origin=\"upper\",\n            dpi=self.figure.dpi, metadata=metadata, pil_kwargs=pil_kwargs)\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_png(self, filename_or_obj, *args,\n                  metadata=None, pil_kwargs=None):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for Matplotlib\n            will be used.  This can be removed by setting it to *None*.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            Keyword arguments passed to `PIL.Image.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n        self._print_pil(filename_or_obj, \"png\", pil_kwargs, metadata)\n\n    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        return (bytes(renderer.buffer_rgba()),\n                (int(renderer.width), int(renderer.height)))\n\n    # Note that these methods should typically be called via savefig() and\n    # print_figure(), and the latter ensures that `self.figure.dpi` already\n    # matches the dpi kwarg (if any).\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_jpg(self, filename_or_obj, *args, pil_kwargs=None):\n        # savefig() has already applied savefig.facecolor; we now set it to\n        # white to make imsave() blend semi-transparent figures against an\n        # assumed white background.\n        with mpl.rc_context({\"savefig.facecolor\": \"white\"}):\n            self._print_pil(filename_or_obj, \"jpeg\", pil_kwargs)\n\n    print_jpeg = print_jpg\n\n    def print_tif(self, filename_or_obj, *, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"tiff\", pil_kwargs)\n\n    print_tiff = print_tif\n\n    def print_webp(self, filename_or_obj, *, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"webp\", pil_kwargs)\n\n    print_jpg.__doc__, print_tif.__doc__, print_webp.__doc__ = map(\n        \"\"\"\n        Write the figure to a {} file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n        \"\"\".format, [\"JPEG\", \"TIFF\", \"WebP\"])",
      "instance_attributes": [
        {
          "name": "renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererAgg"
          }
        },
        {
          "name": "_lastKey",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg",
      "name": "RendererAgg",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__getstate__",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/_update_methods",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/_prepare_font",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/buffer_rgba",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_argb",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgb",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/clear",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_image_nocomposite",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_scale_image",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/start_filter",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles",
      "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles",
      "code": "class RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    # we want to cache the fonts at the class level so that when\n    # multiple figures are created we can reuse them.  This helps with\n    # a bug on windows where the creation of too many figures leads to\n    # too many open file handles.  However, storing them at the class\n    # level is not thread safe.  The solution here is to let the\n    # FigureCanvas acquire a lock on the fontd at the start of the\n    # draw, and release it when it is done.  This allows multiple\n    # renderers to share the cached fonts, but only one figure can\n    # draw at time and so the font cache is used by only one\n    # renderer at a time.\n\n    lock = threading.RLock()\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('Agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangle = self._renderer.draw_gouraud_triangle\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        nmax = mpl.rcParams['agg.path.chunksize']  # here at least for testing\n        npts = path.vertices.shape[0]\n\n        if (npts > nmax > 100 and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts / nmax)\n            chsize = int(np.ceil(npts / nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1, :]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO  # move to end of last chunk\n                p = Path(v, c)\n                p.simplify_threshold = path.simplify_threshold\n                try:\n                    self._renderer.draw_path(gc, p, transform, rgbFace)\n                except OverflowError:\n                    msg = (\n                        \"Exceeded cell block limit in Agg.\\n\\n\"\n                        \"Please reduce the value of \"\n                        f\"rcParams['agg.path.chunksize'] (currently {nmax}) \"\n                        \"or increase the path simplification threshold\"\n                        \"(rcParams['path.simplify_threshold'] = \"\n                        f\"{mpl.rcParams['path.simplify_threshold']:.2f} by \"\n                        \"default and path.simplify_threshold = \"\n                        f\"{path.simplify_threshold:.2f} on the input).\"\n                    )\n                    raise OverflowError(msg) from None\n        else:\n            try:\n                self._renderer.draw_path(gc, path, transform, rgbFace)\n            except OverflowError:\n                cant_chunk = ''\n                if rgbFace is not None:\n                    cant_chunk += \"- can not split filled path\\n\"\n                if gc.get_hatch() is not None:\n                    cant_chunk += \"- can not split hatched path\\n\"\n                if not path.should_simplify:\n                    cant_chunk += \"- path.should_simplify is False\\n\"\n                if len(cant_chunk):\n                    msg = (\n                        \"Exceeded cell block limit in Agg, however for the \"\n                        \"following reasons:\\n\\n\"\n                        f\"{cant_chunk}\\n\"\n                        \"we can not automatically split up this path to draw.\"\n                        \"\\n\\nPlease manually simplify your path.\"\n                    )\n\n                else:\n                    inc_threshold = (\n                        \"or increase the path simplification threshold\"\n                        \"(rcParams['path.simplify_threshold'] = \"\n                        f\"{mpl.rcParams['path.simplify_threshold']} \"\n                        \"by default and path.simplify_threshold \"\n                        f\"= {path.simplify_threshold} \"\n                        \"on the input).\"\n                        )\n                    if nmax > 100:\n                        msg = (\n                            \"Exceeded cell block limit in Agg.  Please reduce \"\n                            \"the value of rcParams['agg.path.chunksize'] \"\n                            f\"(currently {nmax}) {inc_threshold}\"\n                        )\n                    else:\n                        msg = (\n                            \"Exceeded cell block limit in Agg.  Please set \"\n                            \"the value of rcParams['agg.path.chunksize'], \"\n                            f\"(currently {nmax}) to be greater than 100 \"\n                            + inc_threshold\n                        )\n\n                raise OverflowError(msg) from None\n\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw mathtext using :mod:`matplotlib.mathtext`.\"\"\"\n        ox, oy, width, height, descent, font_image = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        xd = descent * sin(radians(angle))\n        yd = descent * cos(radians(angle))\n        x = round(x + ox + xd)\n        y = round(y - oy + yd)\n        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc)\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n        font = self._prepare_font(prop)\n        # We pass '0' for angle here, since it will be rotated (in raster\n        # space) in the following call to draw_text_image).\n        font.set_text(s, 0, flags=get_hinting_flag())\n        font.draw_glyphs_to_bitmap(\n            antialiased=mpl.rcParams['text.antialiased'])\n        d = font.get_descent() / 64.0\n        # The descent needs to be adjusted for the angle.\n        xo, yo = font.get_bitmap_offset()\n        xo /= 64.0\n        yo /= 64.0\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xo + xd)\n        y = round(y + yo + yd)\n        self._renderer.draw_text_image(font, x, y + 1, angle, gc)\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        _api.check_in_list([\"TeX\", True, False], ismath=ismath)\n        if ismath == \"TeX\":\n            # todo: handle props\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(\n                s, fontsize, renderer=self)\n            return w, h, d\n\n        if ismath:\n            ox, oy, width, height, descent, font_image = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        font = self._prepare_font(prop)\n        font.set_text(s, 0.0, flags=get_hinting_flag())\n        w, h = font.get_width_height()  # width and height of unrotated string\n        d = font.get_descent()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d /= 64.0\n        return w, h, d\n\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        # todo, handle props, angle, origins\n        size = prop.get_size_in_points()\n\n        texmanager = self.get_texmanager()\n\n        Z = texmanager.get_grey(s, size, self.dpi)\n        Z = np.array(Z * 255.0, np.uint8)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xd)\n        y = round(y + yd)\n        self._renderer.draw_text_image(Z, x, y, angle, gc)\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def _prepare_font(self, font_prop):\n        \"\"\"\n        Get the `.FT2Font` for *font_prop*, clear its buffer, and set its size.\n        \"\"\"\n        font = get_font(_fontManager._find_fonts_by_props(font_prop))\n        font.clear()\n        size = font_prop.get_size_in_points()\n        font.set_size(size, self.dpi)\n        return font\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * self.dpi / 72\n\n    def buffer_rgba(self):\n        return memoryview(self._renderer)\n\n    def tostring_argb(self):\n        return np.asarray(self._renderer).take([3, 0, 1, 2], axis=2).tobytes()\n\n    def tostring_rgb(self):\n        return np.asarray(self._renderer).take([0, 1, 2], axis=2).tobytes()\n\n    def clear(self):\n        self._renderer.clear()\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n\n        # It is generally faster to composite each image directly to\n        # the Figure, and there's no file size benefit to compositing\n        # with the Agg backend\n        return True\n\n    def option_scale_image(self):\n        # docstring inherited\n        return False\n\n    def restore_region(self, region, bbox=None, xy=None):\n        \"\"\"\n        Restore the saved region. If bbox (instance of BboxBase, or\n        its extents) is given, only the region specified by the bbox\n        will be restored. *xy* (a pair of floats) optionally\n        specifies the new position (the LLC of the original region,\n        not the LLC of the bbox) where the region will be restored.\n\n        >>> region = renderer.copy_from_bbox()\n        >>> x1, y1, x2, y2 = region.get_extents()\n        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n        ...                         xy=(x1-dx, y1))\n\n        \"\"\"\n        if bbox is not None or xy is not None:\n            if bbox is None:\n                x1, y1, x2, y2 = region.get_extents()\n            elif isinstance(bbox, BboxBase):\n                x1, y1, x2, y2 = bbox.extents\n            else:\n                x1, y1, x2, y2 = bbox\n\n            if xy is None:\n                ox, oy = x1, y1\n            else:\n                ox, oy = xy\n\n            # The incoming data is float, but the _renderer type-checking wants\n            # to see integers.\n            self._renderer.restore_region(region, int(x1), int(y1),\n                                          int(x2), int(y2), int(ox), int(oy))\n\n        else:\n            self._renderer.restore_region(region)\n\n    def start_filter(self):\n        \"\"\"\n        Start filtering. It simply create a new canvas (the old one is saved).\n        \"\"\"\n        self._filter_renderers.append(self._renderer)\n        self._renderer = _RendererAgg(int(self.width), int(self.height),\n                                      self.dpi)\n        self._update_methods()\n\n    def stop_filter(self, post_processing):\n        \"\"\"\n        Save the plot in the current canvas as a image and apply\n        the *post_processing* function.\n\n           def post_processing(image, dpi):\n             # ny, nx, depth = image.shape\n             # image (numpy array) has RGBA channels and has a depth of 4.\n             ...\n             # create a new_image (numpy array of 4 channels, size can be\n             # different). The resulting image may have offsets from\n             # lower-left corner of the original image\n             return new_image, offset_x, offset_y\n\n        The saved renderer is restored and the returned image from\n        post_processing is plotted (using draw_image) on it.\n        \"\"\"\n        orig_img = np.asarray(self.buffer_rgba())\n        slice_y, slice_x = cbook._get_nonzero_slices(orig_img[..., 3])\n        cropped_img = orig_img[slice_y, slice_x]\n\n        self._renderer = self._filter_renderers.pop()\n        self._update_methods()\n\n        if cropped_img.size:\n            img, ox, oy = post_processing(cropped_img / 255, self.dpi)\n            gc = self.new_gc()\n            if img.dtype.kind == 'f':\n                img = np.asarray(img * 255., np.uint8)\n            self._renderer.draw_image(\n                gc, slice_x.start + ox, int(self.height) - slice_y.stop + oy,\n                img[::-1])",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "_renderer",
          "types": null
        },
        {
          "name": "_filter_renderers",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "mathtext_parser",
          "types": null
        },
        {
          "name": "bbox",
          "types": null
        },
        {
          "name": "draw_gouraud_triangle",
          "types": null
        },
        {
          "name": "draw_gouraud_triangles",
          "types": null
        },
        {
          "name": "draw_image",
          "types": null
        },
        {
          "name": "draw_markers",
          "types": null
        },
        {
          "name": "draw_path_collection",
          "types": null
        },
        {
          "name": "draw_quad_mesh",
          "types": null
        },
        {
          "name": "copy_from_bbox",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo",
      "name": "FigureCanvasCairo",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/_renderer@getter",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/get_renderer",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/_get_printed_image_surface",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/_save"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasCairo(FigureCanvasBase):\n    @property\n    def _renderer(self):\n        # In theory, _renderer should be set in __init__, but GUI canvas\n        # subclasses (FigureCanvasFooCairo) don't always interact well with\n        # multiple inheritance (FigureCanvasFoo inits but doesn't super-init\n        # FigureCanvasCairo), so initialize it in the getter instead.\n        if not hasattr(self, \"_cached_renderer\"):\n            self._cached_renderer = RendererCairo(self.figure.dpi)\n        return self._cached_renderer\n\n    def get_renderer(self):\n        return self._renderer\n\n    def copy_from_bbox(self, bbox):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"copy_from_bbox only works when rendering to an ImageSurface\")\n        sw = surface.get_width()\n        sh = surface.get_height()\n        x0 = math.ceil(bbox.x0)\n        x1 = math.floor(bbox.x1)\n        y0 = math.ceil(sh - bbox.y1)\n        y1 = math.floor(sh - bbox.y0)\n        if not (0 <= x0 and x1 <= sw and bbox.x0 <= bbox.x1\n                and 0 <= y0 and y1 <= sh and bbox.y0 <= bbox.y1):\n            raise ValueError(\"Invalid bbox\")\n        sls = slice(y0, y0 + max(y1 - y0, 0)), slice(x0, x0 + max(x1 - x0, 0))\n        data = (np.frombuffer(surface.get_data(), np.uint32)\n                .reshape((sh, sw))[sls].copy())\n        return _CairoRegion(sls, data)\n\n    def restore_region(self, region):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"restore_region only works when rendering to an ImageSurface\")\n        surface.flush()\n        sw = surface.get_width()\n        sh = surface.get_height()\n        sly, slx = region._slices\n        (np.frombuffer(surface.get_data(), np.uint32)\n         .reshape((sh, sw))[sly, slx]) = region._data\n        surface.mark_dirty_rectangle(\n            slx.start, sly.start, slx.stop - slx.start, sly.stop - sly.start)\n\n    def print_png(self, fobj):\n        self._get_printed_image_surface().write_to_png(fobj)\n\n    def print_rgba(self, fobj):\n        width, height = self.get_width_height()\n        buf = self._get_printed_image_surface().get_data()\n        fobj.write(cbook._premultiplied_argb32_to_unmultiplied_rgba8888(\n            np.asarray(buf).reshape((width, height, 4))))\n\n    print_raw = print_rgba\n\n    def _get_printed_image_surface(self):\n        self._renderer.dpi = self.figure.dpi\n        width, height = self.get_width_height()\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_context(cairo.Context(surface))\n        self.figure.draw(self._renderer)\n        return surface\n\n    def _save(self, fmt, fobj, *, orientation='portrait'):\n        # save PDF/PS/SVG\n\n        dpi = 72\n        self.figure.dpi = dpi\n        w_in, h_in = self.figure.get_size_inches()\n        width_in_points, height_in_points = w_in * dpi, h_in * dpi\n\n        if orientation == 'landscape':\n            width_in_points, height_in_points = (\n                height_in_points, width_in_points)\n\n        if fmt == 'ps':\n            if not hasattr(cairo, 'PSSurface'):\n                raise RuntimeError('cairo has not been compiled with PS '\n                                   'support enabled')\n            surface = cairo.PSSurface(fobj, width_in_points, height_in_points)\n        elif fmt == 'pdf':\n            if not hasattr(cairo, 'PDFSurface'):\n                raise RuntimeError('cairo has not been compiled with PDF '\n                                   'support enabled')\n            surface = cairo.PDFSurface(fobj, width_in_points, height_in_points)\n        elif fmt in ('svg', 'svgz'):\n            if not hasattr(cairo, 'SVGSurface'):\n                raise RuntimeError('cairo has not been compiled with SVG '\n                                   'support enabled')\n            if fmt == 'svgz':\n                if isinstance(fobj, str):\n                    fobj = gzip.GzipFile(fobj, 'wb')\n                else:\n                    fobj = gzip.GzipFile(None, 'wb', fileobj=fobj)\n            surface = cairo.SVGSurface(fobj, width_in_points, height_in_points)\n        else:\n            raise ValueError(\"Unknown format: {!r}\".format(fmt))\n\n        self._renderer.dpi = self.figure.dpi\n        self._renderer.set_context(cairo.Context(surface))\n        ctx = self._renderer.gc.ctx\n\n        if orientation == 'landscape':\n            ctx.rotate(np.pi / 2)\n            ctx.translate(0, -height_in_points)\n            # Perhaps add an '%%Orientation: Landscape' comment?\n\n        self.figure.draw(self._renderer)\n\n        ctx.show_page()\n        surface.finish()\n        if fmt == 'svgz':\n            fobj.close()\n\n    print_pdf = functools.partialmethod(_save, \"pdf\")\n    print_ps = functools.partialmethod(_save, \"ps\")\n    print_svg = functools.partialmethod(_save, \"svg\")\n    print_svgz = functools.partialmethod(_save, \"svgz\")",
      "instance_attributes": [
        {
          "name": "_cached_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererCairo"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo",
      "name": "GraphicsContextCairo",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/restore",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_antialiased",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/get_rgb",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class GraphicsContextCairo(GraphicsContextBase):\n    _joind = {\n        'bevel':  cairo.LINE_JOIN_BEVEL,\n        'miter':  cairo.LINE_JOIN_MITER,\n        'round':  cairo.LINE_JOIN_ROUND,\n    }\n\n    _capd = {\n        'butt':        cairo.LINE_CAP_BUTT,\n        'projecting':  cairo.LINE_CAP_SQUARE,\n        'round':       cairo.LINE_CAP_ROUND,\n    }\n\n    def __init__(self, renderer):\n        super().__init__()\n        self.renderer = renderer\n\n    def restore(self):\n        self.ctx.restore()\n\n    def set_alpha(self, alpha):\n        super().set_alpha(alpha)\n        _alpha = self.get_alpha()\n        rgb = self._rgb\n        if self.get_forced_alpha():\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], _alpha)\n        else:\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], rgb[3])\n\n    def set_antialiased(self, b):\n        self.ctx.set_antialias(\n            cairo.ANTIALIAS_DEFAULT if b else cairo.ANTIALIAS_NONE)\n\n    def set_capstyle(self, cs):\n        self.ctx.set_line_cap(_api.check_getitem(self._capd, capstyle=cs))\n        self._capstyle = cs\n\n    def set_clip_rectangle(self, rectangle):\n        if not rectangle:\n            return\n        x, y, w, h = np.round(rectangle.bounds)\n        ctx = self.ctx\n        ctx.new_path()\n        ctx.rectangle(x, self.renderer.height - h - y, w, h)\n        ctx.clip()\n\n    def set_clip_path(self, path):\n        if not path:\n            return\n        tpath, affine = path.get_transformed_path_and_affine()\n        ctx = self.ctx\n        ctx.new_path()\n        affine = (affine\n                  + Affine2D().scale(1, -1).translate(0, self.renderer.height))\n        _append_path(ctx, tpath, affine)\n        ctx.clip()\n\n    def set_dashes(self, offset, dashes):\n        self._dashes = offset, dashes\n        if dashes is None:\n            self.ctx.set_dash([], 0)  # switch dashes off\n        else:\n            self.ctx.set_dash(\n                list(self.renderer.points_to_pixels(np.asarray(dashes))),\n                offset)\n\n    def set_foreground(self, fg, isRGBA=None):\n        super().set_foreground(fg, isRGBA)\n        if len(self._rgb) == 3:\n            self.ctx.set_source_rgb(*self._rgb)\n        else:\n            self.ctx.set_source_rgba(*self._rgb)\n\n    def get_rgb(self):\n        return self.ctx.get_source().get_rgba()[:3]\n\n    def set_joinstyle(self, js):\n        self.ctx.set_line_join(_api.check_getitem(self._joind, joinstyle=js))\n        self._joinstyle = js\n\n    def set_linewidth(self, w):\n        self._linewidth = float(w)\n        self.ctx.set_line_width(self.renderer.points_to_pixels(w))",
      "instance_attributes": [
        {
          "name": "ctx",
          "types": null
        },
        {
          "name": "_alpha",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_forced_alpha",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "renderer",
          "types": null
        },
        {
          "name": "_capstyle",
          "types": null
        },
        {
          "name": "_dashes",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "_joinstyle",
          "types": null
        },
        {
          "name": "_linewidth",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo",
      "name": "RendererCairo",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_context",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/_fill_and_stroke",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/_draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererCairo(RendererBase):\n    def __init__(self, dpi):\n        self.dpi = dpi\n        self.gc = GraphicsContextCairo(renderer=self)\n        self.width = None\n        self.height = None\n        self.text_ctx = cairo.Context(\n           cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1))\n        super().__init__()\n\n    def set_context(self, ctx):\n        surface = ctx.get_target()\n        if hasattr(surface, \"get_width\") and hasattr(surface, \"get_height\"):\n            size = surface.get_width(), surface.get_height()\n        elif hasattr(surface, \"get_extents\"):  # GTK4 RecordingSurface.\n            ext = surface.get_extents()\n            size = ext.width, ext.height\n        else:  # vector surfaces.\n            ctx.save()\n            ctx.reset_clip()\n            rect, *rest = ctx.copy_clip_rectangle_list()\n            if rest:\n                raise TypeError(\"Cannot infer surface size\")\n            size = rect.width, rect.height\n            ctx.restore()\n        self.gc.ctx = ctx\n        self.width, self.height = size\n\n    @_api.deprecated(\"3.6\", alternative=\"set_context\")\n    def set_ctx_from_surface(self, surface):\n        self.gc.ctx = cairo.Context(surface)\n\n    @_api.deprecated(\"3.6\")\n    def set_width_height(self, width, height):\n        self.width = width\n        self.height = height\n\n    def _fill_and_stroke(self, ctx, fill_c, alpha, alpha_overrides):\n        if fill_c is not None:\n            ctx.save()\n            if len(fill_c) == 3 or alpha_overrides:\n                ctx.set_source_rgba(fill_c[0], fill_c[1], fill_c[2], alpha)\n            else:\n                ctx.set_source_rgba(fill_c[0], fill_c[1], fill_c[2], fill_c[3])\n            ctx.fill_preserve()\n            ctx.restore()\n        ctx.stroke()\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        ctx = gc.ctx\n        # Clip the path to the actual rendering extents if it isn't filled.\n        clip = (ctx.clip_extents()\n                if rgbFace is None and gc.get_hatch() is None\n                else None)\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n        ctx.new_path()\n        _append_path(ctx, path, transform, clip)\n        self._fill_and_stroke(\n            ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, transform,\n                     rgbFace=None):\n        # docstring inherited\n\n        ctx = gc.ctx\n        ctx.new_path()\n        # Create the path for the marker; it needs to be flipped here already!\n        _append_path(ctx, marker_path, marker_trans + Affine2D().scale(1, -1))\n        marker_path = ctx.copy_path_flat()\n\n        # Figure out whether the path has a fill\n        x1, y1, x2, y2 = ctx.fill_extents()\n        if x1 == 0 and y1 == 0 and x2 == 0 and y2 == 0:\n            filled = False\n            # No fill, just unset this (so we don't try to fill it later on)\n            rgbFace = None\n        else:\n            filled = True\n\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n\n        ctx.new_path()\n        for i, (vertices, codes) in enumerate(\n                path.iter_segments(transform, simplify=False)):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ctx.save()\n\n                # Translate and apply path\n                ctx.translate(x, y)\n                ctx.append_path(marker_path)\n\n                ctx.restore()\n\n                # Slower code path if there is a fill; we need to draw\n                # the fill and stroke for each marker at the same time.\n                # Also flush out the drawing every once in a while to\n                # prevent the paths from getting way too long.\n                if filled or i % 1000 == 0:\n                    self._fill_and_stroke(\n                        ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n        # Fast path, if there is no fill, draw everything in one step\n        if not filled:\n            self._fill_and_stroke(\n                ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n    def draw_image(self, gc, x, y, im):\n        im = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(im[::-1])\n        surface = cairo.ImageSurface.create_for_data(\n            im.ravel().data, cairo.FORMAT_ARGB32,\n            im.shape[1], im.shape[0], im.shape[1] * 4)\n        ctx = gc.ctx\n        y = self.height - y - im.shape[0]\n\n        ctx.save()\n        ctx.set_source_surface(surface, float(x), float(y))\n        ctx.paint()\n        ctx.restore()\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # Note: (x, y) are device/display coords, not user-coords, unlike other\n        # draw_* methods\n        if ismath:\n            self._draw_mathtext(gc, x, y, s, prop, angle)\n\n        else:\n            ctx = gc.ctx\n            ctx.new_path()\n            ctx.move_to(x, y)\n\n            ctx.save()\n            ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n            ctx.set_font_size(self.points_to_pixels(prop.get_size_in_points()))\n            opts = cairo.FontOptions()\n            opts.set_antialias(\n                cairo.ANTIALIAS_DEFAULT if mpl.rcParams[\"text.antialiased\"]\n                else cairo.ANTIALIAS_NONE)\n            ctx.set_font_options(opts)\n            if angle:\n                ctx.rotate(np.deg2rad(-angle))\n            ctx.show_text(s)\n            ctx.restore()\n\n    def _draw_mathtext(self, gc, x, y, s, prop, angle):\n        ctx = gc.ctx\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, self.dpi, prop)\n\n        ctx.save()\n        ctx.translate(x, y)\n        if angle:\n            ctx.rotate(np.deg2rad(-angle))\n\n        for font, fontsize, idx, ox, oy in glyphs:\n            ctx.new_path()\n            ctx.move_to(ox, -oy)\n            ctx.select_font_face(\n                *_cairo_font_args_from_font_prop(ttfFontProperty(font)))\n            ctx.set_font_size(self.points_to_pixels(fontsize))\n            ctx.show_text(chr(idx))\n\n        for ox, oy, w, h in rects:\n            ctx.new_path()\n            ctx.rectangle(ox, -oy, w, -h)\n            ctx.set_source_rgb(0, 0, 0)\n            ctx.fill_preserve()\n\n        ctx.restore()\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath == 'TeX':\n            return super().get_text_width_height_descent(s, prop, ismath)\n\n        if ismath:\n            width, height, descent, *_ = \\\n                self._text2path.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        ctx = self.text_ctx\n        # problem - scale remembers last setting and font can become\n        # enormous causing program to crash\n        # save/restore prevents the problem\n        ctx.save()\n        ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n        ctx.set_font_size(self.points_to_pixels(prop.get_size_in_points()))\n\n        y_bearing, w, h = ctx.text_extents(s)[1:4]\n        ctx.restore()\n\n        return w, h, h + y_bearing\n\n    def new_gc(self):\n        # docstring inherited\n        self.gc.ctx.save()\n        self.gc._alpha = 1\n        self.gc._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        return self.gc\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points / 72 * self.dpi",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "gc",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextCairo"
          }
        },
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "text_ctx",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3",
      "name": "FigureCanvasGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase",
        "Gtk.DrawingArea"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/destroy",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_mpl_coords",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_get_key",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_update_device_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_post_draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/flush_events"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK3(FigureCanvasBase, Gtk.DrawingArea):\n    required_interactive_framework = \"gtk3\"\n    _timer_cls = TimerGTK3\n    manager_class = _api.classproperty(lambda cls: FigureManagerGTK3)\n    # Setting this as a static constant prevents\n    # this resulting expression from leaking\n    event_mask = (Gdk.EventMask.BUTTON_PRESS_MASK\n                  | Gdk.EventMask.BUTTON_RELEASE_MASK\n                  | Gdk.EventMask.EXPOSURE_MASK\n                  | Gdk.EventMask.KEY_PRESS_MASK\n                  | Gdk.EventMask.KEY_RELEASE_MASK\n                  | Gdk.EventMask.ENTER_NOTIFY_MASK\n                  | Gdk.EventMask.LEAVE_NOTIFY_MASK\n                  | Gdk.EventMask.POINTER_MOTION_MASK\n                  | Gdk.EventMask.SCROLL_MASK)\n\n    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n\n    def destroy(self):\n        CloseEvent(\"close_event\", self)._process()\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        window = self.get_property(\"window\")\n        if window is not None:\n            window.set_cursor(_mpl_to_gtk_cursor(cursor))\n            context = GLib.MainContext.default()\n            context.iteration(True)\n\n    def _mpl_coords(self, event=None):\n        \"\"\"\n        Convert the position of a GTK event, or of the current cursor position\n        if *event* is None, to Matplotlib coordinates.\n\n        GTK use logical pixels, but the figure is scaled to physical pixels for\n        rendering.  Transform to physical pixels so that all of the down-stream\n        transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        if event is None:\n            window = self.get_window()\n            t, x, y, state = window.get_device_position(\n                window.get_display().get_device_manager().get_client_pointer())\n        else:\n            x, y = event.x, event.y\n        x = x * self.device_pixel_ratio\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height - y * self.device_pixel_ratio\n        return x, y\n\n    def scroll_event(self, widget, event):\n        step = 1 if event.direction == Gdk.ScrollDirection.UP else -1\n        MouseEvent(\"scroll_event\", self, *self._mpl_coords(event), step=step,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def button_release_event(self, widget, event):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def key_press_event(self, widget, event):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def key_release_event(self, widget, event):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      guiEvent=event)._process()\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    def _get_key(self, event):\n        unikey = chr(Gdk.keyval_to_unicode(event.keyval))\n        key = cbook._unikey_or_keysym_to_mplkey(\n            unikey,\n            Gdk.keyval_name(event.keyval))\n        modifiers = [\n            (Gdk.ModifierType.CONTROL_MASK, 'ctrl'),\n            (Gdk.ModifierType.MOD1_MASK, 'alt'),\n            (Gdk.ModifierType.SHIFT_MASK, 'shift'),\n            (Gdk.ModifierType.MOD4_MASK, 'super'),\n        ]\n        for key_mask, prefix in modifiers:\n            if event.state & key_mask:\n                if not (prefix == 'shift' and unikey.isprintable()):\n                    key = f'{prefix}+{key}'\n        return key\n\n    def _update_device_pixel_ratio(self, *args, **kwargs):\n        # We need to be careful in cases with mixed resolution displays if\n        # device_pixel_ratio changes.\n        if self._set_device_pixel_ratio(self.get_scale_factor()):\n            # The easiest way to resize the canvas is to emit a resize event\n            # since we implement all the logic for resizing the canvas for that\n            # event.\n            self.queue_resize()\n            self.queue_draw()\n\n    def configure_event(self, widget, event):\n        if widget.get_property(\"window\") is None:\n            return\n        w = event.width * self.device_pixel_ratio\n        h = event.height * self.device_pixel_ratio\n        if w < 3 or h < 3:\n            return  # empty fig\n        # resize the figure (in inches)\n        dpi = self.figure.dpi\n        self.figure.set_size_inches(w / dpi, h / dpi, forward=False)\n        return False  # finish event propagation?\n\n    def _draw_rubberband(self, rect):\n        self._rubberband_rect = rect\n        # TODO: Only update the rubberband area.\n        self.queue_draw()\n\n    def _post_draw(self, widget, ctx):\n        if self._rubberband_rect is None:\n            return\n\n        x0, y0, w, h = (dim / self.device_pixel_ratio\n                        for dim in self._rubberband_rect)\n        x1 = x0 + w\n        y1 = y0 + h\n\n        # Draw the lines from x0, y0 towards x1, y1 so that the\n        # dashes don't \"jump\" when moving the zoom box.\n        ctx.move_to(x0, y0)\n        ctx.line_to(x0, y1)\n        ctx.move_to(x0, y0)\n        ctx.line_to(x1, y0)\n        ctx.move_to(x0, y1)\n        ctx.line_to(x1, y1)\n        ctx.move_to(x1, y0)\n        ctx.line_to(x1, y1)\n\n        ctx.set_antialias(1)\n        ctx.set_line_width(1)\n        ctx.set_dash((3, 3), 0)\n        ctx.set_source_rgb(0, 0, 0)\n        ctx.stroke_preserve()\n\n        ctx.set_dash((3, 3), 3)\n        ctx.set_source_rgb(1, 1, 1)\n        ctx.stroke()\n\n    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK3Agg or GTK3Cairo\n        pass\n\n    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()\n\n    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)\n\n    def flush_events(self):\n        # docstring inherited\n        context = GLib.MainContext.default()\n        while context.pending():\n            context.iteration(True)",
      "instance_attributes": [
        {
          "name": "_idle_draw_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_rubberband_rect",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3",
      "name": "FigureManagerGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3",
      "decorators": [],
      "superclasses": [
        "_FigureManagerGTK"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerGTK3(_FigureManagerGTK):\n    _toolbar2_class = NavigationToolbar2GTK3\n    _toolmanager_toolbar_class = ToolbarGTK3",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3",
      "name": "HelpGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK3)"
      ],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_normalize_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_is_valid_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_show_shortcuts_window",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_show_shortcuts_dialog",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpGTK3(backend_tools.ToolHelpBase):\n    def _normalize_shortcut(self, key):\n        \"\"\"\n        Convert Matplotlib key presses to GTK+ accelerator identifiers.\n\n        Related to `FigureCanvasGTK3._get_key`.\n        \"\"\"\n        special = {\n            'backspace': 'BackSpace',\n            'pagedown': 'Page_Down',\n            'pageup': 'Page_Up',\n            'scroll_lock': 'Scroll_Lock',\n        }\n\n        parts = key.split('+')\n        mods = ['<' + mod + '>' for mod in parts[:-1]]\n        key = parts[-1]\n\n        if key in special:\n            key = special[key]\n        elif len(key) > 1:\n            key = key.capitalize()\n        elif key.isupper():\n            mods += ['<shift>']\n\n        return ''.join(mods) + key\n\n    def _is_valid_shortcut(self, key):\n        \"\"\"\n        Check for a valid shortcut to be displayed.\n\n        - GTK will never send 'cmd+' (see `FigureCanvasGTK3._get_key`).\n        - The shortcut window only shows keyboard shortcuts, not mouse buttons.\n        \"\"\"\n        return 'cmd+' not in key and not key.startswith('MouseButton.')\n\n    def _show_shortcuts_window(self):\n        section = Gtk.ShortcutsSection()\n\n        for name, tool in sorted(self.toolmanager.tools.items()):\n            if not tool.description:\n                continue\n\n            # Putting everything in a separate group allows GTK to\n            # automatically split them into separate columns/pages, which is\n            # useful because we have lots of shortcuts, some with many keys\n            # that are very wide.\n            group = Gtk.ShortcutsGroup()\n            section.add(group)\n            # A hack to remove the title since we have no group naming.\n            group.forall(lambda widget, data: widget.set_visible(False), None)\n\n            shortcut = Gtk.ShortcutsShortcut(\n                accelerator=' '.join(\n                    self._normalize_shortcut(key)\n                    for key in self.toolmanager.get_tool_keymap(name)\n                    if self._is_valid_shortcut(key)),\n                title=tool.name,\n                subtitle=tool.description)\n            group.add(shortcut)\n\n        window = Gtk.ShortcutsWindow(\n            title='Help',\n            modal=True,\n            transient_for=self._figure.canvas.get_toplevel())\n        section.show()  # Must be done explicitly before add!\n        window.add(section)\n\n        window.show_all()\n\n    def _show_shortcuts_dialog(self):\n        dialog = Gtk.MessageDialog(\n            self._figure.canvas.get_toplevel(),\n            0, Gtk.MessageType.INFO, Gtk.ButtonsType.OK, self._get_help_text(),\n            title=\"Help\")\n        dialog.run()\n        dialog.destroy()\n\n    def trigger(self, *args):\n        if Gtk.check_version(3, 20, 0) is None:\n            self._show_shortcuts_window()\n        else:\n            self._show_shortcuts_dialog()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3",
      "name": "NavigationToolbar2GTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3",
      "decorators": [],
      "superclasses": [
        "_NavigationToolbar2GTK",
        "Gtk.Toolbar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2GTK3(_NavigationToolbar2GTK, Gtk.Toolbar):\n    @_api.delete_parameter(\"3.6\", \"window\")\n    def __init__(self, canvas, window=None):\n        self._win = window\n        GObject.GObject.__init__(self)\n\n        self.set_style(Gtk.ToolbarStyle.ICONS)\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.insert(Gtk.SeparatorToolItem(), -1)\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            self._gtk_ids[text] = button = (\n                Gtk.ToggleToolButton() if callback in ['zoom', 'pan'] else\n                Gtk.ToolButton())\n            button.set_label(text)\n            button.set_icon_widget(image)\n            # Save the handler id, so that we can block it as needed.\n            button._signal_handler = button.connect(\n                'clicked', getattr(self, callback))\n            button.set_tooltip_text(tooltip_text)\n            self.insert(button, -1)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        toolitem.set_expand(True)  # Push real message to the right.\n        toolitem.add(label)\n\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        self.message = Gtk.Label()\n        self.message.set_justify(Gtk.Justification.RIGHT)\n        toolitem.add(self.message)\n\n        self.show_all()\n\n        _NavigationToolbar2GTK.__init__(self, canvas)\n\n    win = _api.deprecated(\"3.6\")(property(lambda self: self._win))\n\n    def save_figure(self, *args):\n        dialog = Gtk.FileChooserDialog(\n            title=\"Save the figure\",\n            parent=self.canvas.get_toplevel(),\n            action=Gtk.FileChooserAction.SAVE,\n            buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,\n                     Gtk.STOCK_SAVE,   Gtk.ResponseType.OK),\n        )\n        for name, fmts \\\n                in self.canvas.get_supported_filetypes_grouped().items():\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(f'*.{fmt}')\n            dialog.add_filter(ff)\n            if self.canvas.get_default_filetype() in fmts:\n                dialog.set_filter(ff)\n\n        @functools.partial(dialog.connect, \"notify::filter\")\n        def on_notify_filter(*args):\n            name = dialog.get_filter().get_name()\n            fmt = self.canvas.get_supported_filetypes_grouped()[name][0]\n            dialog.set_current_name(\n                str(Path(dialog.get_current_name()).with_suffix(f'.{fmt}')))\n\n        dialog.set_current_folder(mpl.rcParams[\"savefig.directory\"])\n        dialog.set_current_name(self.canvas.get_default_filename())\n        dialog.set_do_overwrite_confirmation(True)\n\n        response = dialog.run()\n        fname = dialog.get_filename()\n        ff = dialog.get_filter()  # Doesn't autoadjust to filename :/\n        fmt = self.canvas.get_supported_filetypes_grouped()[ff.get_name()][0]\n        dialog.destroy()\n        if response != Gtk.ResponseType.OK:\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n        try:\n            self.canvas.figure.savefig(fname, format=fmt)\n        except Exception as e:\n            dialog = Gtk.MessageDialog(\n                parent=self.canvas.get_toplevel(), message_format=str(e),\n                type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK)\n            dialog.run()\n            dialog.destroy()",
      "instance_attributes": [
        {
          "name": "_win",
          "types": null
        },
        {
          "name": "_gtk_ids",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "message",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3",
      "name": "SaveFigureGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK3)"
      ],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureGTK3(backend_tools.SaveFigureBase):\n    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK3.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3",
      "name": "SetCursorGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3",
      "decorators": [
        "_api.deprecated('3.5', alternative='ToolSetCursor')"
      ],
      "superclasses": [
        "backend_tools.SetCursorBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SetCursorGTK3(backend_tools.SetCursorBase):\n    def set_cursor(self, cursor):\n        NavigationToolbar2GTK3.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3",
      "name": "ToolCopyToClipboardGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK3)"
      ],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardGTK3(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        window = self.canvas.get_window()\n        x, y, width, height = window.get_geometry()\n        pb = Gdk.pixbuf_get_from_window(window, x, y, width, height)\n        clipboard.set_image(pb)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3",
      "name": "ToolbarGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "Gtk.Box"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/_add_button",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/_call_tool",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/_add_separator",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarGTK3(ToolContainerBase, Gtk.Box):\n    _icon_extension = '-symbolic.svg'\n\n    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.pack_end(self._message, False, False, 0)\n        self.show_all()\n        self._groups = {}\n        self._toolitems = {}\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleToolButton()\n        else:\n            button = Gtk.ToolButton()\n        button.set_label(name)\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            button.set_icon_widget(image)\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        button.show_all()\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            toolbar = Gtk.Toolbar()\n            toolbar.set_style(Gtk.ToolbarStyle.ICONS)\n            self.pack_start(toolbar, False, False, 0)\n            toolbar.show_all()\n            self._groups[group] = toolbar\n        self._groups[group].insert(button, position)\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event(f'{name} not in toolbar', self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]\n\n    def _add_separator(self):\n        sep = Gtk.Separator()\n        sep.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self.pack_start(sep, False, True, 0)\n        sep.show_all()\n\n    def set_message(self, s):\n        self._message.set_label(s)",
      "instance_attributes": [
        {
          "name": "_message",
          "types": null
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_gtk3.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/__getattr__/cursord@getter"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    @_api.deprecated(\"3.5\", obj_type=\"\")\n    @property\n    def cursord(self):\n        try:\n            new_cursor = functools.partial(\n                Gdk.Cursor.new_from_name, Gdk.Display.get_default())\n            return {\n                Cursors.MOVE:          new_cursor(\"move\"),\n                Cursors.HAND:          new_cursor(\"pointer\"),\n                Cursors.POINTER:       new_cursor(\"default\"),\n                Cursors.SELECT_REGION: new_cursor(\"crosshair\"),\n                Cursors.WAIT:          new_cursor(\"wait\"),\n            }\n        except TypeError:\n            return {}\n\n    icon_filename = _api.deprecated(\"3.6\", obj_type=\"\")(property(\n        lambda self:\n        \"matplotlib.png\" if sys.platform == \"win32\" else \"matplotlib.svg\"))\n    window_icon = _api.deprecated(\"3.6\", obj_type=\"\")(property(\n        lambda self:\n        str(cbook._get_data_path(\"images\", __getattr__(\"icon_filename\")))))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg",
      "name": "FigureCanvasGTK3Agg",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg",
      "decorators": [],
      "superclasses": [
        "backend_agg.FigureCanvasAgg",
        "backend_gtk3.FigureCanvasGTK3"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK3Agg(backend_agg.FigureCanvasAgg,\n                          backend_gtk3.FigureCanvasGTK3):\n    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._bbox_queue = []\n\n    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        w = allocation.width * scale\n        h = allocation.height * scale\n\n        if not len(self._bbox_queue):\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            bbox_queue = [transforms.Bbox([[0, 0], [w, h]])]\n        else:\n            bbox_queue = self._bbox_queue\n\n        for bbox in bbox_queue:\n            x = int(bbox.x0)\n            y = h - int(bbox.y1)\n            width = int(bbox.x1) - int(bbox.x0)\n            height = int(bbox.y1) - int(bbox.y0)\n\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                np.asarray(self.copy_from_bbox(bbox)))\n            image = cairo.ImageSurface.create_for_data(\n                buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n            image.set_device_scale(scale, scale)\n            ctx.set_source_surface(image, x / scale, y / scale)\n            ctx.paint()\n\n        if len(self._bbox_queue):\n            self._bbox_queue = []\n\n        return False\n\n    def blit(self, bbox=None):\n        # If bbox is None, blit the entire canvas to gtk. Otherwise\n        # blit only the area defined by the bbox.\n        if bbox is None:\n            bbox = self.figure.bbox\n\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        x = int(bbox.x0 / scale)\n        y = allocation.height - int(bbox.y1 / scale)\n        width = (int(bbox.x1) - int(bbox.x0)) // scale\n        height = (int(bbox.y1) - int(bbox.y0)) // scale\n\n        self._bbox_queue.append(bbox)\n        self.queue_draw_area(x, y, width, height)",
      "instance_attributes": [
        {
          "name": "_bbox_queue",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureManagerGTK3Agg",
      "name": "FigureManagerGTK3Agg",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureManagerGTK3Agg",
      "decorators": [
        "_api.deprecated('3.6', alternative='backend_gtk3.FigureManagerGTK3')"
      ],
      "superclasses": [
        "backend_gtk3.FigureManagerGTK3"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerGTK3Agg(backend_gtk3.FigureManagerGTK3):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo",
      "name": "FigureCanvasGTK3Cairo",
      "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "FigureCanvasGTK3"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK3Cairo(FigureCanvasCairo, FigureCanvasGTK3):\n    def on_draw_event(self, widget, ctx):\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            scale = self.device_pixel_ratio\n            # Scale physical drawing to logical size.\n            ctx.scale(1 / scale, 1 / scale)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4",
      "name": "FigureCanvasGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase",
        "Gtk.DrawingArea"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/destroy",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_mpl_coords",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/leave_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_get_key",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_update_device_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_draw_func",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_post_draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/flush_events"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK4(FigureCanvasBase, Gtk.DrawingArea):\n    required_interactive_framework = \"gtk4\"\n    supports_blit = False\n    _timer_cls = TimerGTK4\n    manager_class = _api.classproperty(lambda cls: FigureManagerGTK4)\n    _context_is_scaled = False\n\n    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self.set_hexpand(True)\n        self.set_vexpand(True)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.set_draw_func(self._draw_func)\n        self.connect('resize', self.resize_event)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n\n        click = Gtk.GestureClick()\n        click.set_button(0)  # All buttons.\n        click.connect('pressed', self.button_press_event)\n        click.connect('released', self.button_release_event)\n        self.add_controller(click)\n\n        key = Gtk.EventControllerKey()\n        key.connect('key-pressed', self.key_press_event)\n        key.connect('key-released', self.key_release_event)\n        self.add_controller(key)\n\n        motion = Gtk.EventControllerMotion()\n        motion.connect('motion', self.motion_notify_event)\n        motion.connect('enter', self.enter_notify_event)\n        motion.connect('leave', self.leave_notify_event)\n        self.add_controller(motion)\n\n        scroll = Gtk.EventControllerScroll.new(\n            Gtk.EventControllerScrollFlags.VERTICAL)\n        scroll.connect('scroll', self.scroll_event)\n        self.add_controller(scroll)\n\n        self.set_focusable(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n\n    def destroy(self):\n        self.close_event()\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        self.set_cursor_from_name(_backend_gtk.mpl_to_gtk_cursor_name(cursor))\n\n    def _mpl_coords(self, xy=None):\n        \"\"\"\n        Convert the *xy* position of a GTK event, or of the current cursor\n        position if *xy* is None, to Matplotlib coordinates.\n\n        GTK use logical pixels, but the figure is scaled to physical pixels for\n        rendering.  Transform to physical pixels so that all of the down-stream\n        transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        if xy is None:\n            surface = self.get_native().get_surface()\n            is_over, x, y, mask = surface.get_device_position(\n                self.get_display().get_default_seat().get_pointer())\n        else:\n            x, y = xy\n        x = x * self.device_pixel_ratio\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height - y * self.device_pixel_ratio\n        return x, y\n\n    def scroll_event(self, controller, dx, dy):\n        MouseEvent(\"scroll_event\", self,\n                   *self._mpl_coords(), step=dy)._process()\n        return True\n\n    def button_press_event(self, controller, n_press, x, y):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords((x, y)), controller.get_current_button()\n                   )._process()\n        self.grab_focus()\n\n    def button_release_event(self, controller, n_press, x, y):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords((x, y)), controller.get_current_button()\n                   )._process()\n\n    def key_press_event(self, controller, keyval, keycode, state):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(keyval, keycode, state), *self._mpl_coords()\n                 )._process()\n        return True\n\n    def key_release_event(self, controller, keyval, keycode, state):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(keyval, keycode, state), *self._mpl_coords()\n                 )._process()\n        return True\n\n    def motion_notify_event(self, controller, x, y):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._mpl_coords((x, y)))._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\"figure_leave_event\", self,\n                      *self._mpl_coords())._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._mpl_coords((x, y)))._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    def _get_key(self, keyval, keycode, state):\n        unikey = chr(Gdk.keyval_to_unicode(keyval))\n        key = cbook._unikey_or_keysym_to_mplkey(\n            unikey,\n            Gdk.keyval_name(keyval))\n        modifiers = [\n            (Gdk.ModifierType.CONTROL_MASK, 'ctrl'),\n            (Gdk.ModifierType.ALT_MASK, 'alt'),\n            (Gdk.ModifierType.SHIFT_MASK, 'shift'),\n            (Gdk.ModifierType.SUPER_MASK, 'super'),\n        ]\n        for key_mask, prefix in modifiers:\n            if state & key_mask:\n                if not (prefix == 'shift' and unikey.isprintable()):\n                    key = f'{prefix}+{key}'\n        return key\n\n    def _update_device_pixel_ratio(self, *args, **kwargs):\n        # We need to be careful in cases with mixed resolution displays if\n        # device_pixel_ratio changes.\n        if self._set_device_pixel_ratio(self.get_scale_factor()):\n            self.draw()\n\n    def _draw_rubberband(self, rect):\n        self._rubberband_rect = rect\n        # TODO: Only update the rubberband area.\n        self.queue_draw()\n\n    def _draw_func(self, drawing_area, ctx, width, height):\n        self.on_draw_event(self, ctx)\n        self._post_draw(self, ctx)\n\n    def _post_draw(self, widget, ctx):\n        if self._rubberband_rect is None:\n            return\n\n        lw = 1\n        dash = 3\n        if not self._context_is_scaled:\n            x0, y0, w, h = (dim / self.device_pixel_ratio\n                            for dim in self._rubberband_rect)\n        else:\n            x0, y0, w, h = self._rubberband_rect\n            lw *= self.device_pixel_ratio\n            dash *= self.device_pixel_ratio\n        x1 = x0 + w\n        y1 = y0 + h\n\n        # Draw the lines from x0, y0 towards x1, y1 so that the\n        # dashes don't \"jump\" when moving the zoom box.\n        ctx.move_to(x0, y0)\n        ctx.line_to(x0, y1)\n        ctx.move_to(x0, y0)\n        ctx.line_to(x1, y0)\n        ctx.move_to(x0, y1)\n        ctx.line_to(x1, y1)\n        ctx.move_to(x1, y0)\n        ctx.line_to(x1, y1)\n\n        ctx.set_antialias(1)\n        ctx.set_line_width(lw)\n        ctx.set_dash((dash, dash), 0)\n        ctx.set_source_rgb(0, 0, 0)\n        ctx.stroke_preserve()\n\n        ctx.set_dash((dash, dash), dash)\n        ctx.set_source_rgb(1, 1, 1)\n        ctx.stroke()\n\n    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK4Agg or GTK4Cairo\n        pass\n\n    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()\n\n    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)\n\n    def flush_events(self):\n        # docstring inherited\n        context = GLib.MainContext.default()\n        while context.pending():\n            context.iteration(True)",
      "instance_attributes": [
        {
          "name": "_idle_draw_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_rubberband_rect",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureManagerGTK4",
      "name": "FigureManagerGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureManagerGTK4",
      "decorators": [],
      "superclasses": [
        "_FigureManagerGTK"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerGTK4(_FigureManagerGTK):\n    _toolbar2_class = NavigationToolbar2GTK4\n    _toolmanager_toolbar_class = ToolbarGTK4",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4",
      "name": "HelpGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.HelpGTK4",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK4)"
      ],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/_normalize_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/_is_valid_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpGTK4(backend_tools.ToolHelpBase):\n    def _normalize_shortcut(self, key):\n        \"\"\"\n        Convert Matplotlib key presses to GTK+ accelerator identifiers.\n\n        Related to `FigureCanvasGTK4._get_key`.\n        \"\"\"\n        special = {\n            'backspace': 'BackSpace',\n            'pagedown': 'Page_Down',\n            'pageup': 'Page_Up',\n            'scroll_lock': 'Scroll_Lock',\n        }\n\n        parts = key.split('+')\n        mods = ['<' + mod + '>' for mod in parts[:-1]]\n        key = parts[-1]\n\n        if key in special:\n            key = special[key]\n        elif len(key) > 1:\n            key = key.capitalize()\n        elif key.isupper():\n            mods += ['<shift>']\n\n        return ''.join(mods) + key\n\n    def _is_valid_shortcut(self, key):\n        \"\"\"\n        Check for a valid shortcut to be displayed.\n\n        - GTK will never send 'cmd+' (see `FigureCanvasGTK4._get_key`).\n        - The shortcut window only shows keyboard shortcuts, not mouse buttons.\n        \"\"\"\n        return 'cmd+' not in key and not key.startswith('MouseButton.')\n\n    def trigger(self, *args):\n        section = Gtk.ShortcutsSection()\n\n        for name, tool in sorted(self.toolmanager.tools.items()):\n            if not tool.description:\n                continue\n\n            # Putting everything in a separate group allows GTK to\n            # automatically split them into separate columns/pages, which is\n            # useful because we have lots of shortcuts, some with many keys\n            # that are very wide.\n            group = Gtk.ShortcutsGroup()\n            section.append(group)\n            # A hack to remove the title since we have no group naming.\n            child = group.get_first_child()\n            while child is not None:\n                child.set_visible(False)\n                child = child.get_next_sibling()\n\n            shortcut = Gtk.ShortcutsShortcut(\n                accelerator=' '.join(\n                    self._normalize_shortcut(key)\n                    for key in self.toolmanager.get_tool_keymap(name)\n                    if self._is_valid_shortcut(key)),\n                title=tool.name,\n                subtitle=tool.description)\n            group.append(shortcut)\n\n        window = Gtk.ShortcutsWindow(\n            title='Help',\n            modal=True,\n            transient_for=self._figure.canvas.get_root())\n        window.set_child(section)\n\n        window.show()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4",
      "name": "NavigationToolbar2GTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4",
      "decorators": [],
      "superclasses": [
        "_NavigationToolbar2GTK",
        "Gtk.Box"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/save_figure"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2GTK4(_NavigationToolbar2GTK, Gtk.Box):\n    @_api.delete_parameter(\"3.6\", \"window\")\n    def __init__(self, canvas, window=None):\n        self._win = window\n        Gtk.Box.__init__(self)\n\n        self.add_css_class('toolbar')\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.append(Gtk.Separator())\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))))\n            self._gtk_ids[text] = button = (\n                Gtk.ToggleButton() if callback in ['zoom', 'pan'] else\n                Gtk.Button())\n            button.set_child(image)\n            button.add_css_class('flat')\n            button.add_css_class('image-button')\n            # Save the handler id, so that we can block it as needed.\n            button._signal_handler = button.connect(\n                'clicked', getattr(self, callback))\n            button.set_tooltip_text(tooltip_text)\n            self.append(button)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self.message = Gtk.Label()\n        self.message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self.message)\n\n        _NavigationToolbar2GTK.__init__(self, canvas)\n\n    win = _api.deprecated(\"3.6\")(property(lambda self: self._win))\n\n    def save_figure(self, *args):\n        dialog = Gtk.FileChooserNative(\n            title='Save the figure',\n            transient_for=self.canvas.get_root(),\n            action=Gtk.FileChooserAction.SAVE,\n            modal=True)\n        self._save_dialog = dialog  # Must keep a reference.\n\n        ff = Gtk.FileFilter()\n        ff.set_name('All files')\n        ff.add_pattern('*')\n        dialog.add_filter(ff)\n        dialog.set_filter(ff)\n\n        formats = []\n        default_format = None\n        for i, (name, fmts) in enumerate(\n                self.canvas.get_supported_filetypes_grouped().items()):\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(f'*.{fmt}')\n            dialog.add_filter(ff)\n            formats.append(name)\n            if self.canvas.get_default_filetype() in fmts:\n                default_format = i\n        # Setting the choice doesn't always work, so make sure the default\n        # format is first.\n        formats = [formats[default_format], *formats[:default_format],\n                   *formats[default_format+1:]]\n        dialog.add_choice('format', 'File format', formats, formats)\n        dialog.set_choice('format', formats[default_format])\n\n        dialog.set_current_folder(Gio.File.new_for_path(\n            os.path.expanduser(mpl.rcParams['savefig.directory'])))\n        dialog.set_current_name(self.canvas.get_default_filename())\n\n        @functools.partial(dialog.connect, 'response')\n        def on_response(dialog, response):\n            file = dialog.get_file()\n            fmt = dialog.get_choice('format')\n            fmt = self.canvas.get_supported_filetypes_grouped()[fmt][0]\n            dialog.destroy()\n            self._save_dialog = None\n            if response != Gtk.ResponseType.ACCEPT:\n                return\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams['savefig.directory']:\n                parent = file.get_parent()\n                mpl.rcParams['savefig.directory'] = parent.get_path()\n            try:\n                self.canvas.figure.savefig(file.get_path(), format=fmt)\n            except Exception as e:\n                msg = Gtk.MessageDialog(\n                    transient_for=self.canvas.get_root(),\n                    message_type=Gtk.MessageType.ERROR,\n                    buttons=Gtk.ButtonsType.OK, modal=True,\n                    text=str(e))\n                msg.show()\n\n        dialog.show()",
      "instance_attributes": [
        {
          "name": "_win",
          "types": null
        },
        {
          "name": "_gtk_ids",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "message",
          "types": null
        },
        {
          "name": "_save_dialog",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4",
      "name": "SaveFigureGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK4)"
      ],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureGTK4(backend_tools.SaveFigureBase):\n    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK4.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4",
      "name": "ToolCopyToClipboardGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK4)"
      ],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardGTK4(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        with io.BytesIO() as f:\n            self.canvas.print_rgba(f)\n            w, h = self.canvas.get_width_height()\n            pb = GdkPixbuf.Pixbuf.new_from_data(f.getbuffer(),\n                                                GdkPixbuf.Colorspace.RGB, True,\n                                                8, w, h, w*4)\n        clipboard = self.canvas.get_clipboard()\n        clipboard.set(pb)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4",
      "name": "ToolbarGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "Gtk.Box"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/_find_child_at_position",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/_add_button",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/_call_tool",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/_add_separator",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarGTK4(ToolContainerBase, Gtk.Box):\n    _icon_extension = '-symbolic.svg'\n\n    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n\n        # Tool items are created later, but must appear before the message.\n        self._tool_box = Gtk.Box()\n        self.append(self._tool_box)\n        self._groups = {}\n        self._toolitems = {}\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self._message)\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleButton()\n        else:\n            button = Gtk.Button()\n        button.set_label(name)\n        button.add_css_class('flat')\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file))\n            button.set_child(image)\n            button.add_css_class('image-button')\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _find_child_at_position(self, group, position):\n        children = [None]\n        child = self._groups[group].get_first_child()\n        while child is not None:\n            children.append(child)\n            child = child.get_next_sibling()\n        return children[position]\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            group_box = Gtk.Box()\n            self._tool_box.append(group_box)\n            self._groups[group] = group_box\n        self._groups[group].insert_child_after(\n            button, self._find_child_at_position(group, position))\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event(f'{name} not in toolbar', self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]\n\n    def _add_separator(self):\n        sep = Gtk.Separator()\n        sep.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self._tool_box.append(sep)\n\n    def set_message(self, s):\n        self._message.set_label(s)",
      "instance_attributes": [
        {
          "name": "_tool_box",
          "types": null
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_message",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg",
      "name": "FigureCanvasGTK4Agg",
      "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg",
      "decorators": [],
      "superclasses": [
        "backend_agg.FigureCanvasAgg",
        "backend_gtk4.FigureCanvasGTK4"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK4Agg(backend_agg.FigureCanvasAgg,\n                          backend_gtk4.FigureCanvasGTK4):\n\n    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n\n        Gtk.render_background(\n            self.get_style_context(), ctx,\n            allocation.x, allocation.y,\n            allocation.width, allocation.height)\n\n        buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n            np.asarray(self.get_renderer().buffer_rgba()))\n        height, width, _ = buf.shape\n        image = cairo.ImageSurface.create_for_data(\n            buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n        image.set_device_scale(scale, scale)\n        ctx.set_source_surface(image, 0, 0)\n        ctx.paint()\n\n        return False",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureManagerGTK4Agg",
      "name": "FigureManagerGTK4Agg",
      "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureManagerGTK4Agg",
      "decorators": [
        "_api.deprecated('3.6', alternative='backend_gtk4.FigureManagerGTK4')"
      ],
      "superclasses": [
        "backend_gtk4.FigureManagerGTK4"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerGTK4Agg(backend_gtk4.FigureManagerGTK4):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo",
      "name": "FigureCanvasGTK4Cairo",
      "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "FigureCanvasGTK4"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK4Cairo(FigureCanvasCairo, FigureCanvasGTK4):\n    _context_is_scaled = True\n\n    def on_draw_event(self, widget, ctx):\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            scale = self.device_pixel_ratio\n            # Scale physical drawing to logical size.\n            ctx.scale(1 / scale, 1 / scale)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac",
      "name": "FigureCanvasMac",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "_macosx.FigureCanvas",
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/_single_shot_timer",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/_draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n    # docstring inherited\n\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._draw_pending = False\n        self._is_drawing = False\n\n    def draw(self):\n        \"\"\"Render the figure and update the macosx canvas.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()\n\n    def draw_idle(self):\n        # docstring inherited\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            # Add a singleshot timer to the eventloop that will call back\n            # into the Python method _draw_idle to take care of the draw\n            self._single_shot_timer(self._draw_idle)\n\n    def _single_shot_timer(self, callback):\n        \"\"\"Add a single shot timer with the given callback\"\"\"\n        # We need to explicitly stop (called from delete) the timer after\n        # firing, otherwise segfaults will occur when trying to deallocate\n        # the singleshot timers.\n        def callback_func(callback, timer):\n            callback()\n            del timer\n        timer = self.new_timer(interval=0)\n        timer.add_callback(callback_func, callback, timer)\n        timer.start()\n\n    def _draw_idle(self):\n        \"\"\"\n        Draw method for singleshot timer\n\n        This draw method can be added to a singleshot timer, which can\n        accumulate draws while the eventloop is spinning. This method will\n        then only draw the first time and short-circuit the others.\n        \"\"\"\n        with self._idle_draw_cntx():\n            if not self._draw_pending:\n                # Short-circuit because our draw request has already been\n                # taken care of\n                return\n            self._draw_pending = False\n            self.draw()\n\n    def blit(self, bbox=None):\n        # docstring inherited\n        super().blit(bbox)\n        self.update()\n\n    def resize(self, width, height):\n        # Size from macOS is logical pixels, dpi is physical.\n        scale = self.figure.dpi / self.device_pixel_ratio\n        width /= scale\n        height /= scale\n        self.figure.set_size_inches(width, height, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()",
      "instance_attributes": [
        {
          "name": "_draw_pending",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_is_drawing",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac",
      "name": "FigureManagerMac",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac",
      "decorators": [],
      "superclasses": [
        "_macosx.FigureManager",
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/_close_button_pressed",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/close",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/show"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerMac(_macosx.FigureManager, FigureManagerBase):\n    _toolbar2_class = NavigationToolbar2Mac\n\n    def __init__(self, canvas, num):\n        self._shown = False\n        _macosx.FigureManager.__init__(self, canvas)\n        icon_path = str(cbook._get_data_path('images/matplotlib.pdf'))\n        _macosx.FigureManager.set_icon(icon_path)\n        FigureManagerBase.__init__(self, canvas, num)\n        if self.toolbar is not None:\n            self.toolbar.update()\n        if mpl.is_interactive():\n            self.show()\n            self.canvas.draw_idle()\n\n    def _close_button_pressed(self):\n        Gcf.destroy(self)\n        self.canvas.flush_events()\n\n    @_api.deprecated(\"3.6\")\n    def close(self):\n        return self._close_button_pressed()\n\n    def show(self):\n        if not self._shown:\n            self._show()\n            self._shown = True\n        if mpl.rcParams[\"figure.raise_window\"]:\n            self._raise()",
      "instance_attributes": [
        {
          "name": "_shown",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac",
      "name": "NavigationToolbar2Mac",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac",
      "decorators": [],
      "superclasses": [
        "_macosx.NavigationToolbar2",
        "NavigationToolbar2"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/prepare_configure_subplots"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2Mac(_macosx.NavigationToolbar2, NavigationToolbar2):\n\n    def __init__(self, canvas):\n        data_path = cbook._get_data_path('images')\n        _, tooltips, image_names, _ = zip(*NavigationToolbar2.toolitems)\n        _macosx.NavigationToolbar2.__init__(\n            self, canvas,\n            tuple(str(data_path / image_name) + \".pdf\"\n                  for image_name in image_names if image_name is not None),\n            tuple(tooltip for tooltip in tooltips if tooltip is not None))\n        NavigationToolbar2.__init__(self, canvas)\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.set_rubberband(int(x0), int(y0), int(x1), int(y1))\n\n    def remove_rubberband(self):\n        self.canvas.remove_rubberband()\n\n    def save_figure(self, *args):\n        directory = os.path.expanduser(mpl.rcParams['savefig.directory'])\n        filename = _macosx.choose_save_file('Save the figure',\n                                            directory,\n                                            self.canvas.get_default_filename())\n        if filename is None:  # Cancel\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(filename)\n        self.canvas.figure.savefig(filename)\n\n    @_api.deprecated(\"3.6\", alternative='configure_subplots()')\n    def prepare_configure_subplots(self):\n        toolfig = Figure(figsize=(6, 3))\n        canvas = FigureCanvasMac(toolfig)\n        toolfig.subplots_adjust(top=0.9)\n        # Need to keep a reference to the tool.\n        _tool = SubplotTool(self.canvas.figure, toolfig)\n        return canvas",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/TimerMac",
      "name": "TimerMac",
      "qname": "lib.matplotlib.backends.backend_macosx.TimerMac",
      "decorators": [],
      "superclasses": [
        "_macosx.Timer",
        "TimerBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using CFRunLoop timer events.",
      "docstring": "Subclass of `.TimerBase` using CFRunLoop timer events.",
      "code": "class TimerMac(_macosx.Timer, TimerBase):\n    \"\"\"Subclass of `.TimerBase` using CFRunLoop timer events.\"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer",
      "name": "MixedModeRenderer",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__",
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__",
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/start_rasterizing",
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/stop_rasterizing"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper class to implement a renderer that switches between\nvector and raster drawing.  An example may be a PDF writer, where\nmost things are drawn with PDF vector commands, but some very\ncomplex objects, such as quad meshes, are rasterised and then\noutput as images.",
      "docstring": "A helper class to implement a renderer that switches between\nvector and raster drawing.  An example may be a PDF writer, where\nmost things are drawn with PDF vector commands, but some very\ncomplex objects, such as quad meshes, are rasterised and then\noutput as images.",
      "code": "class MixedModeRenderer:\n    \"\"\"\n    A helper class to implement a renderer that switches between\n    vector and raster drawing.  An example may be a PDF writer, where\n    most things are drawn with PDF vector commands, but some very\n    complex objects, such as quad meshes, are rasterised and then\n    output as images.\n    \"\"\"\n    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        Parameters\n        ----------\n        figure : `matplotlib.figure.Figure`\n            The figure instance.\n        width : scalar\n            The width of the canvas in logical units\n        height : scalar\n            The height of the canvas in logical units\n        dpi : float\n            The dpi of the canvas\n        vector_renderer : `matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n        raster_renderer_class : `matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.dpi\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer\n\n    def __getattr__(self, attr):\n        # Proxy everything that hasn't been overridden to the base\n        # renderer. Things that *are* overridden can call methods\n        # on self._renderer directly, but must not cache/store\n        # methods (because things like RendererAgg change their\n        # methods on the fly in order to optimise proxying down\n        # to the underlying C implementation).\n        return getattr(self._renderer, attr)\n\n    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        `stop_rasterizing` is called) will be drawn with the raster backend.\n        \"\"\"\n        # change the dpi of the figure temporarily.\n        self.figure.dpi = self.dpi\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore)\n            self._bbox_inches_restore = r\n\n        self._raster_renderer = self._raster_renderer_class(\n            self._width*self.dpi, self._height*self.dpi, self.dpi)\n        self._renderer = self._raster_renderer\n\n    def stop_rasterizing(self):\n        \"\"\"\n        Exit \"raster\" mode.  All of the drawing that was done since\n        the last `start_rasterizing` call will be copied to the\n        vector backend by calling draw_image.\n        \"\"\"\n\n        self._renderer = self._vector_renderer\n\n        height = self._height * self.dpi\n        img = np.asarray(self._raster_renderer.buffer_rgba())\n        slice_y, slice_x = cbook._get_nonzero_slices(img[..., 3])\n        cropped_img = img[slice_y, slice_x]\n        if cropped_img.size:\n            gc = self._renderer.new_gc()\n            # TODO: If the mixedmode resolution differs from the figure's\n            #       dpi, the image must be scaled (dpi->_figdpi). Not all\n            #       backends support this.\n            self._renderer.draw_image(\n                gc,\n                slice_x.start * self._figdpi / self.dpi,\n                (height - slice_y.stop) * self._figdpi / self.dpi,\n                cropped_img[::-1])\n        self._raster_renderer = None\n\n        # restore the figure dpi.\n        self.figure.dpi = self._figdpi\n\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore,\n                                               self._figdpi)\n            self._bbox_inches_restore = r",
      "instance_attributes": [
        {
          "name": "_raster_renderer_class",
          "types": {
            "kind": "NamedType",
            "name": "type"
          }
        },
        {
          "name": "_width",
          "types": null
        },
        {
          "name": "_height",
          "types": null
        },
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "_vector_renderer",
          "types": null
        },
        {
          "name": "_raster_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererAgg"
          }
        },
        {
          "name": "figure",
          "types": null
        },
        {
          "name": "_figdpi",
          "types": null
        },
        {
          "name": "_bbox_inches_restore",
          "types": null
        },
        {
          "name": "_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererAgg"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket",
      "name": "CommSocket",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/is_open",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_close",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Manages the Comm connection between IPython and the browser (client).\n\nComms are 2 way, with the CommSocket being able to publish a message\nvia the send_json method, and handle a message with on_message. On the\nJS side figure.send_message and figure.ws.onmessage do the sending and\nreceiving respectively.",
      "docstring": "Manages the Comm connection between IPython and the browser (client).\n\nComms are 2 way, with the CommSocket being able to publish a message\nvia the send_json method, and handle a message with on_message. On the\nJS side figure.send_message and figure.ws.onmessage do the sending and\nreceiving respectively.",
      "code": "class CommSocket:\n    \"\"\"\n    Manages the Comm connection between IPython and the browser (client).\n\n    Comms are 2 way, with the CommSocket being able to publish a message\n    via the send_json method, and handle a message with on_message. On the\n    JS side figure.send_message and figure.ws.onmessage do the sending and\n    receiving respectively.\n\n    \"\"\"\n    def __init__(self, manager):\n        self.supports_binary = None\n        self.manager = manager\n        self.uuid = str(uuid.uuid4())\n        # Publish an output area with a unique ID. The javascript can then\n        # hook into this area.\n        display(HTML(\"<div id=%r></div>\" % self.uuid))\n        try:\n            self.comm = Comm('matplotlib', data={'id': self.uuid})\n        except AttributeError as err:\n            raise RuntimeError('Unable to create an IPython notebook Comm '\n                               'instance. Are you in the IPython '\n                               'notebook?') from err\n        self.comm.on_msg(self.on_message)\n\n        manager = self.manager\n        self._ext_close = False\n\n        def _on_close(close_message):\n            self._ext_close = True\n            manager.remove_comm(close_message['content']['comm_id'])\n            manager.clearup_closed()\n\n        self.comm.on_close(_on_close)\n\n    def is_open(self):\n        return not (self._ext_close or self.comm._closed)\n\n    def on_close(self):\n        # When the socket is closed, deregister the websocket with\n        # the FigureManager.\n        if self.is_open():\n            try:\n                self.comm.close()\n            except KeyError:\n                # apparently already cleaned it up?\n                pass\n\n    def send_json(self, content):\n        self.comm.send({'data': json.dumps(content)})\n\n    def send_binary(self, blob):\n        if self.supports_binary:\n            self.comm.send({'blob': 'image/png'}, buffers=[blob])\n        else:\n            # The comm is ASCII, so we send the image in base64 encoded data\n            # URL form.\n            data = b64encode(blob).decode('ascii')\n            data_uri = \"data:image/png;base64,{0}\".format(data)\n            self.comm.send({'data': data_uri})\n\n    def on_message(self, message):\n        # The 'supports_binary' message is relevant to the\n        # websocket itself.  The other messages get passed along\n        # to matplotlib as-is.\n\n        # Every message has a \"type\" and a \"figure_id\".\n        message = json.loads(message['content']['data'])\n        if message['type'] == 'closing':\n            self.on_close()\n            self.manager.clearup_closed()\n        elif message['type'] == 'supports_binary':\n            self.supports_binary = message['value']\n        else:\n            self.manager.handle_json(message)",
      "instance_attributes": [
        {
          "name": "supports_binary",
          "types": null
        },
        {
          "name": "manager",
          "types": null
        },
        {
          "name": "uuid",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "comm",
          "types": {
            "kind": "NamedType",
            "name": "Comm"
          }
        },
        {
          "name": "_ext_close",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureCanvasNbAgg",
      "name": "FigureCanvasNbAgg",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureCanvasNbAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasWebAggCore"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasNbAgg(FigureCanvasWebAggCore):\n    manager_class = FigureManagerNbAgg",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg",
      "name": "FigureManagerNbAgg",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg",
      "decorators": [],
      "superclasses": [
        "FigureManagerWebAgg"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/display_js",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/show",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/reshow",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/connected@getter",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/_create_comm",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/destroy",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/clearup_closed",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerNbAgg(FigureManagerWebAgg):\n    _toolbar2_class = ToolbarCls = NavigationIPy\n\n    def __init__(self, canvas, num):\n        self._shown = False\n        super().__init__(canvas, num)\n\n    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        canvas = canvas_class(figure)\n        manager = cls(canvas, num)\n        if is_interactive():\n            manager.show()\n            canvas.draw_idle()\n\n        def destroy(event):\n            canvas.mpl_disconnect(cid)\n            Gcf.destroy(manager)\n\n        cid = canvas.mpl_connect('close_event', destroy)\n        return manager\n\n    def display_js(self):\n        # XXX How to do this just once? It has to deal with multiple\n        # browser instances using the same kernel (require.js - but the\n        # file isn't static?).\n        display(Javascript(FigureManagerNbAgg.get_javascript()))\n\n    def show(self):\n        if not self._shown:\n            self.display_js()\n            self._create_comm()\n        else:\n            self.canvas.draw_idle()\n        self._shown = True\n        # plt.figure adds an event which makes the figure in focus the active\n        # one. Disable this behaviour, as it results in figures being put as\n        # the active figure after they have been shown, even in non-interactive\n        # mode.\n        if hasattr(self, '_cidgcf'):\n            self.canvas.mpl_disconnect(self._cidgcf)\n        if not is_interactive():\n            from matplotlib._pylab_helpers import Gcf\n            Gcf.figs.pop(self.num, None)\n\n    def reshow(self):\n        \"\"\"\n        A special method to re-show the figure in the notebook.\n\n        \"\"\"\n        self._shown = False\n        self.show()\n\n    @property\n    def connected(self):\n        return bool(self.web_sockets)\n\n    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = io.StringIO()\n        else:\n            output = stream\n        super().get_javascript(stream=output)\n        output.write((pathlib.Path(__file__).parent\n                      / \"web_backend/js/nbagg_mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n        if stream is None:\n            return output.getvalue()\n\n    def _create_comm(self):\n        comm = CommSocket(self)\n        self.add_web_socket(comm)\n        return comm\n\n    def destroy(self):\n        self._send_event('close')\n        # need to copy comms as callbacks will modify this list\n        for comm in list(self.web_sockets):\n            comm.on_close()\n        self.clearup_closed()\n\n    def clearup_closed(self):\n        \"\"\"Clear up any closed Comms.\"\"\"\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.is_open()}\n\n        if len(self.web_sockets) == 0:\n            self.canvas.close_event()\n\n    def remove_comm(self, comm_id):\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.comm.comm_id != comm_id}",
      "instance_attributes": [
        {
          "name": "_shown",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "web_sockets",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/NavigationIPy",
      "name": "NavigationIPy",
      "qname": "lib.matplotlib.backends.backend_nbagg.NavigationIPy",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2WebAgg"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationIPy(NavigationToolbar2WebAgg):\n\n    # Use the standard toolbar items + download button\n    toolitems = [(text, tooltip_text,\n                  _FONT_AWESOME_CLASSES[image_file], name_of_method)\n                 for text, tooltip_text, image_file, name_of_method\n                 in (NavigationToolbar2.toolitems +\n                     (('Download', 'Download plot', 'download', 'download'),))\n                 if image_file in _FONT_AWESOME_CLASSES]",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf",
      "name": "FigureCanvasPdf",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf",
        "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasPdf(FigureCanvasBase):\n    # docstring inherited\n\n    fixed_dpi = 72\n    filetypes = {'pdf': 'Portable Document Format'}\n\n    def get_default_filetype(self):\n        return 'pdf'\n\n    def print_pdf(self, filename, *,\n                  bbox_inches_restore=None, metadata=None):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # there are 72 pdf points to an inch\n        width, height = self.figure.get_size_inches()\n        if isinstance(filename, PdfPages):\n            file = filename._file\n        else:\n            file = PdfFile(filename, metadata=metadata)\n        try:\n            file.newPage(width, height)\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererPdf(file, dpi, height, width),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n            if not isinstance(filename, PdfPages):\n                file.finalize()\n        finally:\n            if isinstance(filename, PdfPages):  # finish off this page\n                file.endStream()\n            else:            # we opened the file above; now finish it off\n                file.close()\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf",
      "name": "GraphicsContextPdf",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/stroke",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/paint",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/push",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/pop",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/finalize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class GraphicsContextPdf(GraphicsContextBase):\n\n    def __init__(self, file):\n        super().__init__()\n        self._fillcolor = (0.0, 0.0, 0.0)\n        self._effective_alphas = (1.0, 1.0)\n        self.file = file\n        self.parent = None\n\n    def __repr__(self):\n        d = dict(self.__dict__)\n        del d['file']\n        del d['parent']\n        return repr(d)\n\n    def stroke(self):\n        \"\"\"\n        Predicate: does the path need to be stroked (its outline drawn)?\n        This tests for the various conditions that disable stroking\n        the path, in which case it would presumably be filled.\n        \"\"\"\n        # _linewidth > 0: in pdf a line of width 0 is drawn at minimum\n        #   possible device width, but e.g., agg doesn't draw at all\n        return (self._linewidth > 0 and self._alpha > 0 and\n                (len(self._rgb) <= 3 or self._rgb[3] != 0.0))\n\n    def fill(self, *args):\n        \"\"\"\n        Predicate: does the path need to be filled?\n\n        An optional argument can be used to specify an alternative\n        _fillcolor, as needed by RendererPdf.draw_markers.\n        \"\"\"\n        if len(args):\n            _fillcolor = args[0]\n        else:\n            _fillcolor = self._fillcolor\n        return (self._hatch or\n                (_fillcolor is not None and\n                 (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))\n\n    def paint(self):\n        \"\"\"\n        Return the appropriate pdf operator to cause the path to be\n        stroked, filled, or both.\n        \"\"\"\n        return Op.paint_path(self.fill(), self.stroke())\n\n    capstyles = {'butt': 0, 'round': 1, 'projecting': 2}\n    joinstyles = {'miter': 0, 'round': 1, 'bevel': 2}\n\n    def capstyle_cmd(self, style):\n        return [self.capstyles[style], Op.setlinecap]\n\n    def joinstyle_cmd(self, style):\n        return [self.joinstyles[style], Op.setlinejoin]\n\n    def linewidth_cmd(self, width):\n        return [width, Op.setlinewidth]\n\n    def dash_cmd(self, dashes):\n        offset, dash = dashes\n        if dash is None:\n            dash = []\n            offset = 0\n        return [list(dash), offset, Op.setdash]\n\n    def alpha_cmd(self, alpha, forced, effective_alphas):\n        name = self.file.alphaState(effective_alphas)\n        return [name, Op.setgstate]\n\n    def hatch_cmd(self, hatch, hatch_color):\n        if not hatch:\n            if self._fillcolor is not None:\n                return self.fillcolor_cmd(self._fillcolor)\n            else:\n                return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]\n        else:\n            hatch_style = (hatch_color, self._fillcolor, hatch)\n            name = self.file.hatchPattern(hatch_style)\n            return [Name('Pattern'), Op.setcolorspace_nonstroke,\n                    name, Op.setcolor_nonstroke]\n\n    def rgb_cmd(self, rgb):\n        if mpl.rcParams['pdf.inheritcolor']:\n            return []\n        if rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_stroke]\n        else:\n            return [*rgb[:3], Op.setrgb_stroke]\n\n    def fillcolor_cmd(self, rgb):\n        if rgb is None or mpl.rcParams['pdf.inheritcolor']:\n            return []\n        elif rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_nonstroke]\n        else:\n            return [*rgb[:3], Op.setrgb_nonstroke]\n\n    def push(self):\n        parent = GraphicsContextPdf(self.file)\n        parent.copy_properties(self)\n        parent.parent = self.parent\n        self.parent = parent\n        return [Op.gsave]\n\n    def pop(self):\n        assert self.parent is not None\n        self.copy_properties(self.parent)\n        self.parent = self.parent.parent\n        return [Op.grestore]\n\n    def clip_cmd(self, cliprect, clippath):\n        \"\"\"Set clip rectangle. Calls `.pop()` and `.push()`.\"\"\"\n        cmds = []\n        # Pop graphics state until we hit the right one or the stack is empty\n        while ((self._cliprect, self._clippath) != (cliprect, clippath)\n                and self.parent is not None):\n            cmds.extend(self.pop())\n        # Unless we hit the right one, set the clip polygon\n        if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n                self.parent is None):\n            cmds.extend(self.push())\n            if self._cliprect != cliprect:\n                cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n            if self._clippath != clippath:\n                path, affine = clippath.get_transformed_path_and_affine()\n                cmds.extend(\n                    PdfFile.pathOperations(path, affine, simplify=False) +\n                    [Op.clip, Op.endpath])\n        return cmds\n\n    commands = (\n        # must come first since may pop\n        (('_cliprect', '_clippath'), clip_cmd),\n        (('_alpha', '_forced_alpha', '_effective_alphas'), alpha_cmd),\n        (('_capstyle',), capstyle_cmd),\n        (('_fillcolor',), fillcolor_cmd),\n        (('_joinstyle',), joinstyle_cmd),\n        (('_linewidth',), linewidth_cmd),\n        (('_dashes',), dash_cmd),\n        (('_rgb',), rgb_cmd),\n        # must come after fillcolor and rgb\n        (('_hatch', '_hatch_color'), hatch_cmd),\n        )\n\n    def delta(self, other):\n        \"\"\"\n        Copy properties of other into self and return PDF commands\n        needed to transform self into other.\n        \"\"\"\n        cmds = []\n        fill_performed = False\n        for params, cmd in self.commands:\n            different = False\n            for p in params:\n                ours = getattr(self, p)\n                theirs = getattr(other, p)\n                try:\n                    if ours is None or theirs is None:\n                        different = ours is not theirs\n                    else:\n                        different = bool(ours != theirs)\n                except ValueError:\n                    ours = np.asarray(ours)\n                    theirs = np.asarray(theirs)\n                    different = (ours.shape != theirs.shape or\n                                 np.any(ours != theirs))\n                if different:\n                    break\n\n            # Need to update hatching if we also updated fillcolor\n            if params == ('_hatch', '_hatch_color') and fill_performed:\n                different = True\n\n            if different:\n                if params == ('_fillcolor',):\n                    fill_performed = True\n                theirs = [getattr(other, p) for p in params]\n                cmds.extend(cmd(self, *theirs))\n                for p in params:\n                    setattr(self, p, getattr(other, p))\n        return cmds\n\n    def copy_properties(self, other):\n        \"\"\"\n        Copy properties of other into self.\n        \"\"\"\n        super().copy_properties(other)\n        fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n        effective_alphas = getattr(other, '_effective_alphas',\n                                   self._effective_alphas)\n        self._fillcolor = fillcolor\n        self._effective_alphas = effective_alphas\n\n    def finalize(self):\n        \"\"\"\n        Make sure every pushed graphics state is popped.\n        \"\"\"\n        cmds = []\n        while self.parent is not None:\n            cmds.extend(self.pop())\n        return cmds",
      "instance_attributes": [
        {
          "name": "_fillcolor",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "_effective_alphas",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "file",
          "types": null
        },
        {
          "name": "parent",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextPdf"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name",
      "name": "Name",
      "qname": "lib.matplotlib.backends.backend_pdf.Name",
      "decorators": [
        "total_ordering"
      ],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__str__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__hash__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/hexify",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/pdfRepr"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF name object.",
      "docstring": "PDF name object.",
      "code": "class Name:\n    \"\"\"PDF name object.\"\"\"\n    __slots__ = ('name',)\n    _hexify = {c: '#%02x' % c\n               for c in {*range(256)} - {*range(ord('!'), ord('~') + 1)}}\n\n    def __init__(self, name):\n        if isinstance(name, Name):\n            self.name = name.name\n        else:\n            if isinstance(name, bytes):\n                name = name.decode('ascii')\n            self.name = name.translate(self._hexify).encode('ascii')\n\n    def __repr__(self):\n        return \"<Name %s>\" % self.name\n\n    def __str__(self):\n        return '/' + self.name.decode('ascii')\n\n    def __eq__(self, other):\n        return isinstance(other, Name) and self.name == other.name\n\n    def __lt__(self, other):\n        return isinstance(other, Name) and self.name < other.name\n\n    def __hash__(self):\n        return hash(self.name)\n\n    @staticmethod\n    @_api.deprecated(\"3.6\")\n    def hexify(match):\n        return '#%02x' % ord(match.group())\n\n    def pdfRepr(self):\n        return b'/' + self.name",
      "instance_attributes": [
        {
          "name": "name",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op",
      "name": "Op",
      "qname": "lib.matplotlib.backends.backend_pdf.Op",
      "decorators": [],
      "superclasses": [
        "Enum"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Op/pdfRepr",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF operators (not an exhaustive list).",
      "docstring": "PDF operators (not an exhaustive list).",
      "code": "class Op(Enum):\n    \"\"\"PDF operators (not an exhaustive list).\"\"\"\n\n    close_fill_stroke = b'b'\n    fill_stroke = b'B'\n    fill = b'f'\n    closepath = b'h'\n    close_stroke = b's'\n    stroke = b'S'\n    endpath = b'n'\n    begin_text = b'BT'\n    end_text = b'ET'\n    curveto = b'c'\n    rectangle = b're'\n    lineto = b'l'\n    moveto = b'm'\n    concat_matrix = b'cm'\n    use_xobject = b'Do'\n    setgray_stroke = b'G'\n    setgray_nonstroke = b'g'\n    setrgb_stroke = b'RG'\n    setrgb_nonstroke = b'rg'\n    setcolorspace_stroke = b'CS'\n    setcolorspace_nonstroke = b'cs'\n    setcolor_stroke = b'SCN'\n    setcolor_nonstroke = b'scn'\n    setdash = b'd'\n    setlinejoin = b'j'\n    setlinecap = b'J'\n    setgstate = b'gs'\n    gsave = b'q'\n    grestore = b'Q'\n    textpos = b'Td'\n    selectfont = b'Tf'\n    textmatrix = b'Tm'\n    show = b'Tj'\n    showkern = b'TJ'\n    setlinewidth = b'w'\n    clip = b'W'\n    shading = b'sh'\n\n    op = _api.deprecated('3.6')(property(lambda self: self.value))\n\n    def pdfRepr(self):\n        return self.value\n\n    @classmethod\n    def paint_path(cls, fill, stroke):\n        \"\"\"\n        Return the PDF operator to paint a path.\n\n        Parameters\n        ----------\n        fill : bool\n            Fill the path with the fill color.\n        stroke : bool\n            Stroke the outline of the path with the line color.\n        \"\"\"\n        if stroke:\n            if fill:\n                return cls.fill_stroke\n            else:\n                return cls.stroke\n        else:\n            if fill:\n                return cls.fill\n            else:\n                return cls.endpath",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator",
      "name": "Operator",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/pdfRepr"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Operator:\n    __slots__ = ('op',)\n\n    def __init__(self, op):\n        self.op = op\n\n    def __repr__(self):\n        return '<Operator %s>' % self.op\n\n    def pdfRepr(self):\n        return self.op",
      "instance_attributes": [
        {
          "name": "op",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile",
      "name": "PdfFile",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_get_subsetted_psname",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/finalize",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/close",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/endStream",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_write_annotations",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeFonts",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_write_afm_font",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_embedTeXFont",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_get_xobject_glyph_name",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_soft_mask_state",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeExtGSTates",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_write_soft_mask_groups",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeHatches",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeGouraudTriangles",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_unpack",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_writePng",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_writeImg",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeImages",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeMarkers",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePathCollectionTemplates",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeXref",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeInfoDict",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeTrailer"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF file object.",
      "docstring": "PDF file object.",
      "code": "class PdfFile:\n    \"\"\"PDF file object.\"\"\"\n\n    def __init__(self, filename, metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n\n        metadata : dict from strings to strings and dates\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        super().__init__()\n\n        self._object_seq = itertools.count(1)  # consumed by reserveObject\n        self.xrefTable = [[0, 65535, 'the zero object']]\n        self.passed_in_file_object = False\n        self.original_file_like = None\n        self.tell_base = 0\n        fh, opened = cbook.to_filehandle(filename, \"wb\", return_opened=True)\n        if not opened:\n            try:\n                self.tell_base = filename.tell()\n            except IOError:\n                fh = BytesIO()\n                self.original_file_like = filename\n            else:\n                fh = filename\n                self.passed_in_file_object = True\n\n        self.fh = fh\n        self.currentstream = None  # stream object to write to, if any\n        fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n        # Output some eight-bit chars as a comment so various utilities\n        # recognize the file as binary by looking at the first few\n        # lines (see note in section 3.4.1 of the PDF reference).\n        fh.write(b\"%\\254\\334 \\253\\272\\n\")\n\n        self.rootObject = self.reserveObject('root')\n        self.pagesObject = self.reserveObject('pages')\n        self.pageList = []\n        self.fontObject = self.reserveObject('fonts')\n        self._extGStateObject = self.reserveObject('extended graphics states')\n        self.hatchObject = self.reserveObject('tiling patterns')\n        self.gouraudObject = self.reserveObject('Gouraud triangles')\n        self.XObjectObject = self.reserveObject('external objects')\n        self.resourceObject = self.reserveObject('resources')\n\n        root = {'Type': Name('Catalog'),\n                'Pages': self.pagesObject}\n        self.writeObject(self.rootObject, root)\n\n        self.infoDict = _create_pdf_info_dict('pdf', metadata or {})\n\n        self.fontNames = {}     # maps filenames to internal font names\n        self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))\n        self.dviFontInfo = {}   # maps dvi font names to embedding information\n        # differently encoded Type-1 fonts may share the same descriptor\n        self.type1Descriptors = {}\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n\n        self.alphaStates = {}   # maps alpha values to graphics state objects\n        self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))\n        self._soft_mask_states = {}\n        self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))\n        self._soft_mask_groups = []\n        self.hatchPatterns = {}\n        self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))\n        self.gouraudTriangles = []\n\n        self._images = {}\n        self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n\n        self.markers = {}\n        self.multi_byte_charprocs = {}\n\n        self.paths = []\n\n        # A list of annotations for each page. Each entry is a tuple of the\n        # overall Annots object reference that's inserted into the page object,\n        # followed by a list of the actual annotations.\n        self._annotations = []\n        # For annotations added before a page is created; mostly for the\n        # purpose of newTextnote.\n        self.pageAnnotations = []\n\n        # The PDF spec recommends to include every procset\n        procsets = [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]\n\n        # Write resource dictionary.\n        # Possibly TODO: more general ExtGState (graphics state dictionaries)\n        #                ColorSpace Pattern Shading Properties\n        resources = {'Font': self.fontObject,\n                     'XObject': self.XObjectObject,\n                     'ExtGState': self._extGStateObject,\n                     'Pattern': self.hatchObject,\n                     'Shading': self.gouraudObject,\n                     'ProcSet': procsets}\n        self.writeObject(self.resourceObject, resources)\n\n    def newPage(self, width, height):\n        self.endStream()\n\n        self.width, self.height = width, height\n        contentObject = self.reserveObject('page contents')\n        annotsObject = self.reserveObject('annotations')\n        thePage = {'Type': Name('Page'),\n                   'Parent': self.pagesObject,\n                   'Resources': self.resourceObject,\n                   'MediaBox': [0, 0, 72 * width, 72 * height],\n                   'Contents': contentObject,\n                   'Annots': annotsObject,\n                   }\n        pageObject = self.reserveObject('page')\n        self.writeObject(pageObject, thePage)\n        self.pageList.append(pageObject)\n        self._annotations.append((annotsObject, self.pageAnnotations))\n\n        self.beginStream(contentObject.id,\n                         self.reserveObject('length of content stream'))\n        # Initialize the pdf graphics state to match the default Matplotlib\n        # graphics context (colorspace and joinstyle).\n        self.output(Name('DeviceRGB'), Op.setcolorspace_stroke)\n        self.output(Name('DeviceRGB'), Op.setcolorspace_nonstroke)\n        self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n\n        # Clear the list of annotations for the next page\n        self.pageAnnotations = []\n\n    def newTextnote(self, text, positionRect=[-100, -100, 0, 0]):\n        # Create a new annotation of type text\n        theNote = {'Type': Name('Annot'),\n                   'Subtype': Name('Text'),\n                   'Contents': text,\n                   'Rect': positionRect,\n                   }\n        self.pageAnnotations.append(theNote)\n\n    def _get_subsetted_psname(self, ps_name, charmap):\n        def toStr(n, base):\n            if n < base:\n                return string.ascii_uppercase[n]\n            else:\n                return (\n                    toStr(n // base, base) + string.ascii_uppercase[n % base]\n                )\n\n        # encode to string using base 26\n        hashed = hash(frozenset(charmap.keys())) % ((sys.maxsize + 1) * 2)\n        prefix = toStr(hashed, 26)\n\n        # get first 6 characters from prefix\n        return prefix[:6] + \"+\" + ps_name\n\n    def finalize(self):\n        \"\"\"Write out the various deferred objects and the pdf end matter.\"\"\"\n\n        self.endStream()\n        self._write_annotations()\n        self.writeFonts()\n        self.writeExtGSTates()\n        self._write_soft_mask_groups()\n        self.writeHatches()\n        self.writeGouraudTriangles()\n        xobjects = {\n            name: ob for image, name, ob in self._images.values()}\n        for tup in self.markers.values():\n            xobjects[tup[0]] = tup[1]\n        for name, value in self.multi_byte_charprocs.items():\n            xobjects[name] = value\n        for name, path, trans, ob, join, cap, padding, filled, stroked \\\n                in self.paths:\n            xobjects[name] = ob\n        self.writeObject(self.XObjectObject, xobjects)\n        self.writeImages()\n        self.writeMarkers()\n        self.writePathCollectionTemplates()\n        self.writeObject(self.pagesObject,\n                         {'Type': Name('Pages'),\n                          'Kids': self.pageList,\n                          'Count': len(self.pageList)})\n        self.writeInfoDict()\n\n        # Finalize the file\n        self.writeXref()\n        self.writeTrailer()\n\n    def close(self):\n        \"\"\"Flush all buffers and free all resources.\"\"\"\n\n        self.endStream()\n        if self.passed_in_file_object:\n            self.fh.flush()\n        else:\n            if self.original_file_like is not None:\n                self.original_file_like.write(self.fh.getvalue())\n            self.fh.close()\n\n    def write(self, data):\n        if self.currentstream is None:\n            self.fh.write(data)\n        else:\n            self.currentstream.write(data)\n\n    def output(self, *data):\n        self.write(_fill([pdfRepr(x) for x in data]))\n        self.write(b'\\n')\n\n    def beginStream(self, id, len, extra=None, png=None):\n        assert self.currentstream is None\n        self.currentstream = Stream(id, len, self, extra, png)\n\n    def endStream(self):\n        if self.currentstream is not None:\n            self.currentstream.end()\n            self.currentstream = None\n\n    def outputStream(self, ref, data, *, extra=None):\n        self.beginStream(ref.id, None, extra)\n        self.currentstream.write(data)\n        self.endStream()\n\n    def _write_annotations(self):\n        for annotsObject, annotations in self._annotations:\n            self.writeObject(annotsObject, annotations)\n\n    def fontName(self, fontprop):\n        \"\"\"\n        Select a font based on fontprop and return a name suitable for\n        Op.selectfont. If fontprop is a string, it will be interpreted\n        as the filename of the font.\n        \"\"\"\n\n        if isinstance(fontprop, str):\n            filenames = [fontprop]\n        elif mpl.rcParams['pdf.use14corefonts']:\n            filenames = _fontManager._find_fonts_by_props(\n                fontprop, fontext='afm', directory=RendererPdf._afm_font_dir\n            )\n        else:\n            filenames = _fontManager._find_fonts_by_props(fontprop)\n        first_Fx = None\n        for fname in filenames:\n            Fx = self.fontNames.get(fname)\n            if not first_Fx:\n                first_Fx = Fx\n            if Fx is None:\n                Fx = next(self._internal_font_seq)\n                self.fontNames[fname] = Fx\n                _log.debug('Assigning font %s = %r', Fx, fname)\n                if not first_Fx:\n                    first_Fx = Fx\n\n        # find_fontsprop's first value always adheres to\n        # findfont's value, so technically no behaviour change\n        return first_Fx\n\n    def dviFontName(self, dvifont):\n        \"\"\"\n        Given a dvi font object, return a name suitable for Op.selectfont.\n        This registers the font information in ``self.dviFontInfo`` if not yet\n        registered.\n        \"\"\"\n\n        dvi_info = self.dviFontInfo.get(dvifont.texname)\n        if dvi_info is not None:\n            return dvi_info.pdfname\n\n        tex_font_map = dviread.PsfontsMap(dviread._find_tex_file('pdftex.map'))\n        psfont = tex_font_map[dvifont.texname]\n        if psfont.filename is None:\n            raise ValueError(\n                \"No usable font file found for {} (TeX: {}); \"\n                \"the font may lack a Type-1 version\"\n                .format(psfont.psname, dvifont.texname))\n\n        pdfname = next(self._internal_font_seq)\n        _log.debug('Assigning font %s = %s (dvi)', pdfname, dvifont.texname)\n        self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(\n            dvifont=dvifont,\n            pdfname=pdfname,\n            fontfile=psfont.filename,\n            basefont=psfont.psname,\n            encodingfile=psfont.encoding,\n            effects=psfont.effects)\n        return pdfname\n\n    def writeFonts(self):\n        fonts = {}\n        for dviname, info in sorted(self.dviFontInfo.items()):\n            Fx = info.pdfname\n            _log.debug('Embedding Type-1 font %s from dvi.', dviname)\n            fonts[Fx] = self._embedTeXFont(info)\n        for filename in sorted(self.fontNames):\n            Fx = self.fontNames[filename]\n            _log.debug('Embedding font %s.', filename)\n            if filename.endswith('.afm'):\n                # from pdf.use14corefonts\n                _log.debug('Writing AFM font.')\n                fonts[Fx] = self._write_afm_font(filename)\n            else:\n                # a normal TrueType font\n                _log.debug('Writing TrueType font.')\n                chars = self._character_tracker.used.get(filename)\n                if chars:\n                    fonts[Fx] = self.embedTTF(filename, chars)\n        self.writeObject(self.fontObject, fonts)\n\n    def _write_afm_font(self, filename):\n        with open(filename, 'rb') as fh:\n            font = AFM(fh)\n        fontname = font.get_fontname()\n        fontdict = {'Type': Name('Font'),\n                    'Subtype': Name('Type1'),\n                    'BaseFont': Name(fontname),\n                    'Encoding': Name('WinAnsiEncoding')}\n        fontdictObject = self.reserveObject('font dictionary')\n        self.writeObject(fontdictObject, fontdict)\n        return fontdictObject\n\n    def _embedTeXFont(self, fontinfo):\n        _log.debug('Embedding TeX font %s - fontinfo=%s',\n                   fontinfo.dvifont.texname, fontinfo.__dict__)\n\n        # Widths\n        widthsObject = self.reserveObject('font widths')\n        self.writeObject(widthsObject, fontinfo.dvifont.widths)\n\n        # Font dictionary\n        fontdictObject = self.reserveObject('font dictionary')\n        fontdict = {\n            'Type':      Name('Font'),\n            'Subtype':   Name('Type1'),\n            'FirstChar': 0,\n            'LastChar':  len(fontinfo.dvifont.widths) - 1,\n            'Widths':    widthsObject,\n            }\n\n        # Encoding (if needed)\n        if fontinfo.encodingfile is not None:\n            fontdict['Encoding'] = {\n                'Type': Name('Encoding'),\n                'Differences': [\n                    0, *map(Name, dviread._parse_enc(fontinfo.encodingfile))],\n            }\n\n        # If no file is specified, stop short\n        if fontinfo.fontfile is None:\n            _log.warning(\n                \"Because of TeX configuration (pdftex.map, see updmap option \"\n                \"pdftexDownloadBase14) the font %s is not embedded. This is \"\n                \"deprecated as of PDF 1.5 and it may cause the consumer \"\n                \"application to show something that was not intended.\",\n                fontinfo.basefont)\n            fontdict['BaseFont'] = Name(fontinfo.basefont)\n            self.writeObject(fontdictObject, fontdict)\n            return fontdictObject\n\n        # We have a font file to embed - read it in and apply any effects\n        t1font = _type1font.Type1Font(fontinfo.fontfile)\n        if fontinfo.effects:\n            t1font = t1font.transform(fontinfo.effects)\n        fontdict['BaseFont'] = Name(t1font.prop['FontName'])\n\n        # Font descriptors may be shared between differently encoded\n        # Type-1 fonts, so only create a new descriptor if there is no\n        # existing descriptor for this font.\n        effects = (fontinfo.effects.get('slant', 0.0),\n                   fontinfo.effects.get('extend', 1.0))\n        fontdesc = self.type1Descriptors.get((fontinfo.fontfile, effects))\n        if fontdesc is None:\n            fontdesc = self.createType1Descriptor(t1font, fontinfo.fontfile)\n            self.type1Descriptors[(fontinfo.fontfile, effects)] = fontdesc\n        fontdict['FontDescriptor'] = fontdesc\n\n        self.writeObject(fontdictObject, fontdict)\n        return fontdictObject\n\n    def createType1Descriptor(self, t1font, fontfile):\n        # Create and write the font descriptor and the font file\n        # of a Type-1 font\n        fontdescObject = self.reserveObject('font descriptor')\n        fontfileObject = self.reserveObject('font file')\n\n        italic_angle = t1font.prop['ItalicAngle']\n        fixed_pitch = t1font.prop['isFixedPitch']\n\n        flags = 0\n        # fixed width\n        if fixed_pitch:\n            flags |= 1 << 0\n        # TODO: serif\n        if 0:\n            flags |= 1 << 1\n        # TODO: symbolic (most TeX fonts are)\n        if 1:\n            flags |= 1 << 2\n        # non-symbolic\n        else:\n            flags |= 1 << 5\n        # italic\n        if italic_angle:\n            flags |= 1 << 6\n        # TODO: all caps\n        if 0:\n            flags |= 1 << 16\n        # TODO: small caps\n        if 0:\n            flags |= 1 << 17\n        # TODO: force bold\n        if 0:\n            flags |= 1 << 18\n\n        ft2font = get_font(fontfile)\n\n        descriptor = {\n            'Type':        Name('FontDescriptor'),\n            'FontName':    Name(t1font.prop['FontName']),\n            'Flags':       flags,\n            'FontBBox':    ft2font.bbox,\n            'ItalicAngle': italic_angle,\n            'Ascent':      ft2font.ascender,\n            'Descent':     ft2font.descender,\n            'CapHeight':   1000,  # TODO: find this out\n            'XHeight':     500,  # TODO: this one too\n            'FontFile':    fontfileObject,\n            'FontFamily':  t1font.prop['FamilyName'],\n            'StemV':       50,  # TODO\n            # (see also revision 3874; but not all TeX distros have AFM files!)\n            # 'FontWeight': a number where 400 = Regular, 700 = Bold\n            }\n\n        self.writeObject(fontdescObject, descriptor)\n\n        self.outputStream(fontfileObject, b\"\".join(t1font.parts[:2]),\n                          extra={'Length1': len(t1font.parts[0]),\n                                 'Length2': len(t1font.parts[1]),\n                                 'Length3': 0})\n\n        return fontdescObject\n\n    def _get_xobject_glyph_name(self, filename, glyph_name):\n        Fx = self.fontName(filename)\n        return \"-\".join([\n            Fx.name.decode(),\n            os.path.splitext(os.path.basename(filename))[0],\n            glyph_name])\n\n    _identityToUnicodeCMap = b\"\"\"/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo\n<< /Registry (Adobe)\n   /Ordering (UCS)\n   /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000> <ffff>\nendcodespacerange\n%d beginbfrange\n%s\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend\"\"\"\n\n    def embedTTF(self, filename, characters):\n        \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n\n        font = get_font(filename)\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"\"\"Convert font coordinates to PDF glyph coordinates.\"\"\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Best(?) to round away from zero for bounding boxes and the like.\n            if value < 0:\n                return math.floor(value)\n            else:\n                return math.ceil(value)\n\n        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array.\n            rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict = {'Type': Name('XObject'),\n                                    'Subtype': Name('Form'),\n                                    'BBox': bbox}\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.outputStream(charprocObject, stream, extra=charprocDict)\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_glyph_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject\n\n        def embedTTFType42(font, characters, descriptor):\n            \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n            fontdescObject = self.reserveObject('font descriptor')\n            cidFontDictObject = self.reserveObject('CID font dictionary')\n            type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n            cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n            fontfileObject = self.reserveObject('font file stream')\n            wObject = self.reserveObject('Type 0 widths')\n            toUnicodeMapObject = self.reserveObject('ToUnicode map')\n\n            subset_str = \"\".join(chr(c) for c in characters)\n            _log.debug(\"SUBSET %s characters: %s\", filename, subset_str)\n            fontdata = _backend_pdf_ps.get_glyphs_subset(filename, subset_str)\n            _log.debug(\n                \"SUBSET %s %d -> %d\", filename,\n                os.stat(filename).st_size, fontdata.getbuffer().nbytes\n            )\n\n            # We need this ref for XObjects\n            full_font = font\n\n            # reload the font object from the subset\n            # (all the necessary data could probably be obtained directly\n            # using fontLib.ttLib)\n            font = FT2Font(fontdata)\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            self.outputStream(\n                fontfileObject, fontdata.getvalue(),\n                extra={'Length1': fontdata.getbuffer().nbytes})\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\0'] * 65536\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph = font.load_char(ccode,\n                                       flags=LOAD_NO_SCALE | LOAD_NO_HINTING)\n                widths.append((ccode, cvt(glyph.horiAdvance)))\n                if ccode < 65536:\n                    cid_to_gid_map[ccode] = chr(gind)\n                max_ccode = max(ccode, max_ccode)\n            widths.sort()\n            cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n\n            last_ccode = -2\n            w = []\n            max_width = 0\n            unicode_groups = []\n            for ccode, width in widths:\n                if ccode != last_ccode + 1:\n                    w.append(ccode)\n                    w.append([width])\n                    unicode_groups.append([ccode, ccode])\n                else:\n                    w[-1].append(width)\n                    unicode_groups[-1][1] = ccode\n                max_width = max(max_width, width)\n                last_ccode = ccode\n\n            unicode_bfrange = []\n            for start, end in unicode_groups:\n                # Ensure the CID map contains only chars from BMP\n                if start > 65535:\n                    continue\n                end = min(65535, end)\n\n                unicode_bfrange.append(\n                    b\"<%04x> <%04x> [%s]\" %\n                    (start, end,\n                     b\" \".join(b\"<%04x>\" % x for x in range(start, end+1))))\n            unicode_cmap = (self._identityToUnicodeCMap %\n                            (len(unicode_groups), b\"\\n\".join(unicode_bfrange)))\n\n            # Add XObjects for unsupported chars\n            glyph_ids = []\n            for ccode in characters:\n                if not _font_supports_glyph(fonttype, ccode):\n                    gind = full_font.get_char_index(ccode)\n                    glyph_ids.append(gind)\n\n            bbox = [cvt(x, nearest=False) for x in full_font.bbox]\n            rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Type': Name('XObject'),\n                                'Subtype': Name('Form'),\n                                'BBox': bbox}\n                # Each glyph includes bounding box information,\n                # but xpdf and ghostscript can't handle it in a\n                # Form XObject (they segfault!!!), so we remove it\n                # from the stream here.  It's not needed anyway,\n                # since the Form XObject includes it in its BBox\n                # value.\n                stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.outputStream(charprocObject, stream, extra=charprocDict)\n\n                name = self._get_xobject_glyph_name(filename, charname)\n                self.multi_byte_charprocs[name] = charprocObject\n\n            # CIDToGIDMap stream\n            cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n            self.outputStream(cidToGidMapObject, cid_to_gid_map)\n\n            # ToUnicode CMap\n            self.outputStream(toUnicodeMapObject, unicode_cmap)\n\n            descriptor['MaxWidth'] = max_width\n\n            # Write everything out\n            self.writeObject(cidFontDictObject, cidFontDict)\n            self.writeObject(type0FontDictObject, type0FontDict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(wObject, w)\n\n            return type0FontDictObject\n\n        # Beginning of main embedTTF function...\n\n        ps_name = self._get_subsetted_psname(\n            font.postscript_name,\n            font.get_charmap()\n        )\n        ps_name = ps_name.encode('ascii', 'replace')\n        ps_name = Name(ps_name)\n        pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n        post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n        ff = font.face_flags\n        sf = font.style_flags\n\n        flags = 0\n        symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n        if ff & FIXED_WIDTH:\n            flags |= 1 << 0\n        if 0:  # TODO: serif\n            flags |= 1 << 1\n        if symbolic:\n            flags |= 1 << 2\n        else:\n            flags |= 1 << 5\n        if sf & ITALIC:\n            flags |= 1 << 6\n        if 0:  # TODO: all caps\n            flags |= 1 << 16\n        if 0:  # TODO: small caps\n            flags |= 1 << 17\n        if 0:  # TODO: force bold\n            flags |= 1 << 18\n\n        descriptor = {\n            'Type': Name('FontDescriptor'),\n            'FontName': ps_name,\n            'Flags': flags,\n            'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n            'Ascent': cvt(font.ascender, nearest=False),\n            'Descent': cvt(font.descender, nearest=False),\n            'CapHeight': cvt(pclt['capHeight'], nearest=False),\n            'XHeight': cvt(pclt['xHeight']),\n            'ItalicAngle': post['italicAngle'][1],  # ???\n            'StemV': 0  # ???\n            }\n\n        if fonttype == 3:\n            return embedTTFType3(font, characters, descriptor)\n        elif fonttype == 42:\n            return embedTTFType42(font, characters, descriptor)\n\n    def alphaState(self, alpha):\n        \"\"\"Return name of an ExtGState that sets alpha to the given value.\"\"\"\n\n        state = self.alphaStates.get(alpha, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._alpha_state_seq)\n        self.alphaStates[alpha] = \\\n            (name, {'Type': Name('ExtGState'),\n                    'CA': alpha[0], 'ca': alpha[1]})\n        return name\n\n    def _soft_mask_state(self, smask):\n        \"\"\"\n        Return an ExtGState that sets the soft mask to the given shading.\n\n        Parameters\n        ----------\n        smask : Reference\n            Reference to a shading in DeviceGray color space, whose luminosity\n            is to be used as the alpha channel.\n\n        Returns\n        -------\n        Name\n        \"\"\"\n\n        state = self._soft_mask_states.get(smask, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._soft_mask_seq)\n        groupOb = self.reserveObject('transparency group for soft mask')\n        self._soft_mask_states[smask] = (\n            name,\n            {\n                'Type': Name('ExtGState'),\n                'AIS': False,\n                'SMask': {\n                    'Type': Name('Mask'),\n                    'S': Name('Luminosity'),\n                    'BC': [1],\n                    'G': groupOb\n                }\n            }\n        )\n        self._soft_mask_groups.append((\n            groupOb,\n            {\n                'Type': Name('XObject'),\n                'Subtype': Name('Form'),\n                'FormType': 1,\n                'Group': {\n                    'S': Name('Transparency'),\n                    'CS': Name('DeviceGray')\n                },\n                'Matrix': [1, 0, 0, 1, 0, 0],\n                'Resources': {'Shading': {'S': smask}},\n                'BBox': [0, 0, 1, 1]\n            },\n            [Name('S'), Op.shading]\n        ))\n        return name\n\n    def writeExtGSTates(self):\n        self.writeObject(\n            self._extGStateObject,\n            dict([\n                *self.alphaStates.values(),\n                *self._soft_mask_states.values()\n            ])\n        )\n\n    def _write_soft_mask_groups(self):\n        for ob, attributes, content in self._soft_mask_groups:\n            self.beginStream(ob.id, None, attributes)\n            self.output(*content)\n            self.endStream()\n\n    def hatchPattern(self, hatch_style):\n        # The colors may come in as numpy arrays, which aren't hashable\n        if hatch_style is not None:\n            edge, face, hatch = hatch_style\n            if edge is not None:\n                edge = tuple(edge)\n            if face is not None:\n                face = tuple(face)\n            hatch_style = (edge, face, hatch)\n\n        pattern = self.hatchPatterns.get(hatch_style, None)\n        if pattern is not None:\n            return pattern\n\n        name = next(self._hatch_pattern_seq)\n        self.hatchPatterns[hatch_style] = name\n        return name\n\n    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self.hatchPatterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n\n            stroke_rgb, fill_rgb, hatch = hatch_style\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_stroke)\n            if fill_rgb is not None:\n                self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n                            Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n\n            self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)\n\n            self.output(*self.pathOperations(\n                Path.hatch(hatch),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.fill_stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)\n\n    def addGouraudTriangles(self, points, colors):\n        \"\"\"\n        Add a Gouraud triangle shading.\n\n        Parameters\n        ----------\n        points : np.ndarray\n            Triangle vertices, shape (n, 3, 2)\n            where n = number of triangles, 3 = vertices, 2 = x, y.\n        colors : np.ndarray\n            Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n            as with points, but last dimension is either (gray,)\n            or (r, g, b, alpha).\n\n        Returns\n        -------\n        Name, Reference\n        \"\"\"\n        name = Name('GT%d' % len(self.gouraudTriangles))\n        ob = self.reserveObject(f'Gouraud triangle {name}')\n        self.gouraudTriangles.append((name, ob, points, colors))\n        return name, ob\n\n    def writeGouraudTriangles(self):\n        gouraudDict = dict()\n        for name, ob, points, colors in self.gouraudTriangles:\n            gouraudDict[name] = ob\n            shape = points.shape\n            flat_points = points.reshape((shape[0] * shape[1], 2))\n            colordim = colors.shape[2]\n            assert colordim in (1, 4)\n            flat_colors = colors.reshape((shape[0] * shape[1], colordim))\n            if colordim == 4:\n                # strip the alpha channel\n                colordim = 3\n            points_min = np.min(flat_points, axis=0) - (1 << 8)\n            points_max = np.max(flat_points, axis=0) + (1 << 8)\n            factor = 0xffffffff / (points_max - points_min)\n\n            self.beginStream(\n                ob.id, None,\n                {'ShadingType': 4,\n                 'BitsPerCoordinate': 32,\n                 'BitsPerComponent': 8,\n                 'BitsPerFlag': 8,\n                 'ColorSpace': Name(\n                     'DeviceRGB' if colordim == 3 else 'DeviceGray'\n                 ),\n                 'AntiAlias': False,\n                 'Decode': ([points_min[0], points_max[0],\n                             points_min[1], points_max[1]]\n                            + [0, 1] * colordim),\n                 })\n\n            streamarr = np.empty(\n                (shape[0] * shape[1],),\n                dtype=[('flags', 'u1'),\n                       ('points', '>u4', (2,)),\n                       ('colors', 'u1', (colordim,))])\n            streamarr['flags'] = 0\n            streamarr['points'] = (flat_points - points_min) * factor\n            streamarr['colors'] = flat_colors[:, :colordim] * 255.0\n\n            self.write(streamarr.tobytes())\n            self.endStream()\n        self.writeObject(self.gouraudObject, gouraudDict)\n\n    def imageObject(self, image):\n        \"\"\"Return name of an image XObject representing the given image.\"\"\"\n\n        entry = self._images.get(id(image), None)\n        if entry is not None:\n            return entry[1]\n\n        name = next(self._image_seq)\n        ob = self.reserveObject(f'image {name}')\n        self._images[id(image)] = (image, name, ob)\n        return name\n\n    def _unpack(self, im):\n        \"\"\"\n        Unpack image array *im* into ``(data, alpha)``, which have shape\n        ``(height, width, 3)`` (RGB) or ``(height, width, 1)`` (grayscale or\n        alpha), except that alpha is None if the image is fully opaque.\n        \"\"\"\n        im = im[::-1]\n        if im.ndim == 2:\n            return im, None\n        else:\n            rgb = im[:, :, :3]\n            rgb = np.array(rgb, order='C')\n            # PDF needs a separate alpha image\n            if im.shape[2] == 4:\n                alpha = im[:, :, 3][..., None]\n                if np.all(alpha == 255):\n                    alpha = None\n                else:\n                    alpha = np.array(alpha, order='C')\n            else:\n                alpha = None\n            return rgb, alpha\n\n    def _writePng(self, img):\n        \"\"\"\n        Write the image *img* into the pdf file using png\n        predictors with Flate compression.\n        \"\"\"\n        buffer = BytesIO()\n        img.save(buffer, format=\"png\")\n        buffer.seek(8)\n        png_data = b''\n        bit_depth = palette = None\n        while True:\n            length, type = struct.unpack(b'!L4s', buffer.read(8))\n            if type in [b'IHDR', b'PLTE', b'IDAT']:\n                data = buffer.read(length)\n                if len(data) != length:\n                    raise RuntimeError(\"truncated data\")\n                if type == b'IHDR':\n                    bit_depth = int(data[8])\n                elif type == b'PLTE':\n                    palette = data\n                elif type == b'IDAT':\n                    png_data += data\n            elif type == b'IEND':\n                break\n            else:\n                buffer.seek(length, 1)\n            buffer.seek(4, 1)   # skip CRC\n        return png_data, bit_depth, palette\n\n    def _writeImg(self, data, id, smask=None):\n        \"\"\"\n        Write the image *data*, of shape ``(height, width, 1)`` (grayscale) or\n        ``(height, width, 3)`` (RGB), as pdf object *id* and with the soft mask\n        (alpha channel) *smask*, which should be either None or a ``(height,\n        width, 1)`` array.\n        \"\"\"\n        height, width, color_channels = data.shape\n        obj = {'Type': Name('XObject'),\n               'Subtype': Name('Image'),\n               'Width': width,\n               'Height': height,\n               'ColorSpace': Name({1: 'DeviceGray',\n                                   3: 'DeviceRGB'}[color_channels]),\n               'BitsPerComponent': 8}\n        if smask:\n            obj['SMask'] = smask\n        if mpl.rcParams['pdf.compression']:\n            if data.shape[-1] == 1:\n                data = data.squeeze(axis=-1)\n            img = Image.fromarray(data)\n            img_colors = img.getcolors(maxcolors=256)\n            if color_channels == 3 and img_colors is not None:\n                # Convert to indexed color if there are 256 colors or fewer\n                # This can significantly reduce the file size\n                num_colors = len(img_colors)\n                # These constants were converted to IntEnums and deprecated in\n                # Pillow 9.2\n                dither = getattr(Image, 'Dither', Image).NONE\n                pmode = getattr(Image, 'Palette', Image).ADAPTIVE\n                img = img.convert(\n                    mode='P', dither=dither, palette=pmode, colors=num_colors\n                )\n                png_data, bit_depth, palette = self._writePng(img)\n                if bit_depth is None or palette is None:\n                    raise RuntimeError(\"invalid PNG header\")\n                palette = palette[:num_colors * 3]  # Trim padding\n                obj['ColorSpace'] = Verbatim(\n                    b'[/Indexed /DeviceRGB %d %s]'\n                    % (num_colors - 1, pdfRepr(palette)))\n                obj['BitsPerComponent'] = bit_depth\n                color_channels = 1\n            else:\n                png_data, _, _ = self._writePng(img)\n            png = {'Predictor': 10, 'Colors': color_channels, 'Columns': width}\n        else:\n            png = None\n        self.beginStream(\n            id,\n            self.reserveObject('length of image stream'),\n            obj,\n            png=png\n            )\n        if png:\n            self.currentstream.write(png_data)\n        else:\n            self.currentstream.write(data.tobytes())\n        self.endStream()\n\n    def writeImages(self):\n        for img, name, ob in self._images.values():\n            data, adata = self._unpack(img)\n            if adata is not None:\n                smaskObject = self.reserveObject(\"smask\")\n                self._writeImg(adata, smaskObject.id)\n            else:\n                smaskObject = None\n            self._writeImg(data, ob.id, smaskObject)\n\n    def markerObject(self, path, trans, fill, stroke, lw, joinstyle,\n                     capstyle):\n        \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n        # self.markers used by markerObject, writeMarkers, close:\n        # mapping from (path operations, fill?, stroke?) to\n        #   [name, object reference, bounding box, linewidth]\n        # This enables different draw_markers calls to share the XObject\n        # if the gc is sufficiently similar: colors etc can vary, but\n        # the choices of whether to fill and whether to stroke cannot.\n        # We need a bounding box enclosing all of the XObject path,\n        # but since line width may vary, we store the maximum of all\n        # occurring line widths in self.markers.\n        # close() is somewhat tightly coupled in that it expects the\n        # first two components of each value in self.markers to be the\n        # name and object reference.\n        pathops = self.pathOperations(path, trans, simplify=False)\n        key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)\n        result = self.markers.get(key)\n        if result is None:\n            name = Name('M%d' % len(self.markers))\n            ob = self.reserveObject('marker %d' % len(self.markers))\n            bbox = path.get_extents(trans)\n            self.markers[key] = [name, ob, bbox, lw]\n        else:\n            if result[-1] < lw:\n                result[-1] = lw\n            name = result[0]\n        return name\n\n    def writeMarkers(self):\n        for ((pathops, fill, stroke, joinstyle, capstyle),\n             (name, ob, bbox, lw)) in self.markers.items():\n            # bbox wraps the exact limits of the control points, so half a line\n            # will appear outside it. If the join style is miter and the line\n            # is not parallel to the edge, then the line will extend even\n            # further. From the PDF specification, Section 8.4.3.5, the miter\n            # limit is miterLength / lineWidth and from Table 52, the default\n            # is 10. With half the miter length outside, that works out to the\n            # following padding:\n            bbox = bbox.padded(lw * 5)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': list(bbox.extents)})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(fill, stroke))\n            self.endStream()\n\n    def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):\n        name = Name('P%d' % len(self.paths))\n        ob = self.reserveObject('path %d' % len(self.paths))\n        self.paths.append(\n            (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),\n             padding, filled, stroked))\n        return name\n\n    def writePathCollectionTemplates(self):\n        for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n             stroked) in self.paths:\n            pathops = self.pathOperations(path, trans, simplify=False)\n            bbox = path.get_extents(trans)\n            if not np.all(np.isfinite(bbox.extents)):\n                extents = [0, 0, 0, 0]\n            else:\n                bbox = bbox.padded(padding)\n                extents = list(bbox.extents)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': extents})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(filled, stroked))\n            self.endStream()\n\n    @staticmethod\n    def pathOperations(path, transform, clip=None, simplify=None, sketch=None):\n        return [Verbatim(_path.convert_to_string(\n            path, transform, clip, simplify, sketch,\n            6,\n            [Op.moveto.value, Op.lineto.value, b'', Op.curveto.value,\n             Op.closepath.value],\n            True))]\n\n    def writePath(self, path, transform, clip=False, sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72, self.height * 72)\n            simplify = path.should_simplify\n        else:\n            clip = None\n            simplify = False\n        cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n                                   sketch=sketch)\n        self.output(*cmds)\n\n    def reserveObject(self, name=''):\n        \"\"\"\n        Reserve an ID for an indirect object.\n\n        The name is used for debugging in case we forget to print out\n        the object with writeObject.\n        \"\"\"\n        id = next(self._object_seq)\n        self.xrefTable.append([None, 0, name])\n        return Reference(id)\n\n    def recordXref(self, id):\n        self.xrefTable[id][0] = self.fh.tell() - self.tell_base\n\n    def writeObject(self, object, contents):\n        self.recordXref(object.id)\n        object.write(contents, self)\n\n    def writeXref(self):\n        \"\"\"Write out the xref table.\"\"\"\n        self.startxref = self.fh.tell() - self.tell_base\n        self.write(b\"xref\\n0 %d\\n\" % len(self.xrefTable))\n        for i, (offset, generation, name) in enumerate(self.xrefTable):\n            if offset is None:\n                raise AssertionError(\n                    'No offset for object %d (%s)' % (i, name))\n            else:\n                key = b\"f\" if name == 'the zero object' else b\"n\"\n                text = b\"%010d %05d %b \\n\" % (offset, generation, key)\n                self.write(text)\n\n    def writeInfoDict(self):\n        \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n\n        self.infoObject = self.reserveObject('info')\n        self.writeObject(self.infoObject, self.infoDict)\n\n    def writeTrailer(self):\n        \"\"\"Write out the PDF trailer.\"\"\"\n\n        self.write(b\"trailer\\n\")\n        self.write(pdfRepr(\n            {'Size': len(self.xrefTable),\n             'Root': self.rootObject,\n             'Info': self.infoObject}))\n        # Could add 'ID'\n        self.write(b\"\\nstartxref\\n%d\\n%%%%EOF\\n\" % self.startxref)",
      "instance_attributes": [
        {
          "name": "_object_seq",
          "types": {
            "kind": "NamedType",
            "name": "count"
          }
        },
        {
          "name": "xrefTable",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "passed_in_file_object",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "original_file_like",
          "types": null
        },
        {
          "name": "tell_base",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "fh",
          "types": {
            "kind": "NamedType",
            "name": "BytesIO"
          }
        },
        {
          "name": "currentstream",
          "types": {
            "kind": "NamedType",
            "name": "Stream"
          }
        },
        {
          "name": "rootObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "pagesObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "pageList",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "fontObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "_extGStateObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "hatchObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "gouraudObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "XObjectObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "resourceObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "infoDict",
          "types": null
        },
        {
          "name": "fontNames",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_internal_font_seq",
          "types": null
        },
        {
          "name": "dviFontInfo",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "type1Descriptors",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_character_tracker",
          "types": null
        },
        {
          "name": "alphaStates",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_alpha_state_seq",
          "types": null
        },
        {
          "name": "_soft_mask_states",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_soft_mask_seq",
          "types": null
        },
        {
          "name": "_soft_mask_groups",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "hatchPatterns",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_hatch_pattern_seq",
          "types": null
        },
        {
          "name": "gouraudTriangles",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_images",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_image_seq",
          "types": null
        },
        {
          "name": "markers",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "multi_byte_charprocs",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "paths",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_annotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "pageAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "startxref",
          "types": null
        },
        {
          "name": "infoObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages",
      "name": "PdfPages",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__enter__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/close",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/infodict",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/get_pagecount",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file.",
      "docstring": "A multi-page PDF file.\n\nExamples\n--------\n>>> import matplotlib.pyplot as plt\n>>> # Initialize:\n>>> with PdfPages('foo.pdf') as pdf:\n...     # As many times as you like, create a figure fig and save it:\n...     fig = plt.figure()\n...     pdf.savefig(fig)\n...     # When no figure is specified the current figure is saved\n...     pdf.savefig()\n\nNotes\n-----\nIn reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid\nconfusion when using `~.pyplot.savefig` and forgetting the format argument.",
      "code": "class PdfPages:\n    \"\"\"\n    A multi-page PDF file.\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> # Initialize:\n    >>> with PdfPages('foo.pdf') as pdf:\n    ...     # As many times as you like, create a figure fig and save it:\n    ...     fig = plt.figure()\n    ...     pdf.savefig(fig)\n    ...     # When no figure is specified the current figure is saved\n    ...     pdf.savefig()\n\n    Notes\n    -----\n    In reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid\n    confusion when using `~.pyplot.savefig` and forgetting the format argument.\n    \"\"\"\n    __slots__ = ('_file', 'keep_empty')\n\n    def __init__(self, filename, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. The file is opened at once and any older file with the\n            same name is overwritten.\n\n        keep_empty : bool, optional\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        self._file = PdfFile(filename, metadata=metadata)\n        self.keep_empty = keep_empty\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        self._file.finalize()\n        self._file.close()\n        if (self.get_pagecount() == 0 and not self.keep_empty and\n                not self._file.passed_in_file_object):\n            os.remove(self._file.fh.name)\n        self._file = None\n\n    def infodict(self):\n        \"\"\"\n        Return a modifiable information dictionary object\n        (see PDF reference section 10.2.1 'Document Information\n        Dictionary').\n        \"\"\"\n        return self._file.infoDict\n\n    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, default: the active figure\n            The figure, or index of the figure, that is saved to the file.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n        # Force use of pdf backend, as PdfPages is tightly coupled with it.\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPdf(figure)\n            figure.savefig(self, format=\"pdf\", **kwargs)\n        finally:\n            figure.canvas = orig_canvas\n\n    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return len(self._file.pageList)\n\n    def attach_note(self, text, positionRect=[-100, -100, 0, 0]):\n        \"\"\"\n        Add a new text note to the page to be saved next. The optional\n        positionRect specifies the position of the new note on the\n        page. It is outside the page per default to make sure it is\n        invisible on printouts.\n        \"\"\"\n        self._file.newTextnote(text, positionRect)",
      "instance_attributes": [
        {
          "name": "_file",
          "types": {
            "kind": "NamedType",
            "name": "PdfFile"
          }
        },
        {
          "name": "keep_empty",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference",
      "name": "Reference",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/pdfRepr",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF reference object.\n\nUse PdfFile.reserveObject() to create References.",
      "docstring": "PDF reference object.\n\nUse PdfFile.reserveObject() to create References.",
      "code": "class Reference:\n    \"\"\"\n    PDF reference object.\n\n    Use PdfFile.reserveObject() to create References.\n    \"\"\"\n\n    def __init__(self, id):\n        self.id = id\n\n    def __repr__(self):\n        return \"<Reference %d>\" % self.id\n\n    def pdfRepr(self):\n        return b\"%d 0 R\" % self.id\n\n    def write(self, contents, file):\n        write = file.write\n        write(b\"%d 0 obj\\n\" % self.id)\n        write(pdfRepr(contents))\n        write(b\"\\nendobj\\n\")",
      "instance_attributes": [
        {
          "name": "id",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf",
      "name": "RendererPdf",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf",
      "decorators": [],
      "superclasses": [
        "_backend_pdf_ps.RendererPDFPSBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/finalize",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/get_image_magnification",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/_setup_textpos",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/_draw_xobject_glyph",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/new_gc"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererPdf(_backend_pdf_ps.RendererPDFPSBase):\n\n    _afm_font_dir = cbook._get_data_path(\"fonts/pdfcorefonts\")\n    _use_afm_rc_name = \"pdf.use14corefonts\"\n\n    def __init__(self, file, image_dpi, height, width):\n        super().__init__(width, height)\n        self.file = file\n        self.gc = self.new_gc()\n        self.image_dpi = image_dpi\n\n    def finalize(self):\n        self.file.output(*self.gc.finalize())\n\n    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc.get_rgb() is None:\n            # It should not matter what color here since linewidth should be\n            # 0 unless affected by global settings in rcParams, hence setting\n            # zero alpha just in case.\n            gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas\n\n    def get_image_magnification(self):\n        return self.image_dpi/72.0\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if transform is None:\n            # If there's no transform, alpha has already been applied\n            gc.set_alpha(1.0)\n\n        self.check_gc(gc)\n\n        w = 72.0 * w / self.image_dpi\n        h = 72.0 * h / self.image_dpi\n\n        imob = self.file.imageObject(im)\n\n        if transform is None:\n            self.file.output(Op.gsave,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n\n            self.file.output(Op.gsave,\n                             1, 0, 0, 1, x, y, Op.concat_matrix,\n                             tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        self.check_gc(gc, rgbFace)\n        self.file.writePath(\n            path, transform,\n            rgbFace is None and gc.get_hatch_path() is None,\n            gc.get_sketch_params())\n        self.file.output(self.gc.paint())\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # We can only reuse the objects if the presence of fill and\n        # stroke (and the amount of alpha for each) is the same for\n        # all of them\n        can_do_optimization = True\n        facecolors = np.asarray(facecolors)\n        edgecolors = np.asarray(edgecolors)\n\n        if not len(facecolors):\n            filled = False\n            can_do_optimization = not gc.get_hatch()\n        else:\n            if np.all(facecolors[:, 3] == facecolors[0, 3]):\n                filled = facecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        if not len(edgecolors):\n            stroked = False\n        else:\n            if np.all(np.asarray(linewidths) == 0.0):\n                stroked = False\n            elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):\n                stroked = edgecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is len_path * uses_per_path\n        # cost of XObject is len_path + 5 for the definition,\n        #    uses_per_path for the uses\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + uses_per_path + 5 < len_path * uses_per_path\n\n        if (not can_do_optimization) or (not should_do_optimization):\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        padding = np.max(linewidths)\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = self.file.pathCollectionObject(\n                gc, path, transform, padding, filled, stroked)\n            path_codes.append(name)\n\n        output = self.file.output\n        output(*self.gc.push())\n        lastx, lasty = 0, 0\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n\n            self.check_gc(gc0, rgbFace)\n            dx, dy = xo - lastx, yo - lasty\n            output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,\n                   Op.use_xobject)\n            lastx, lasty = xo, yo\n        output(*self.gc.pop())\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        # Same logic as in draw_path_collection\n        len_marker_path = len(marker_path)\n        uses = len(path)\n        if len_marker_path * uses < len_marker_path + uses + 5:\n            RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n                                      path, trans, rgbFace)\n            return\n\n        self.check_gc(gc, rgbFace)\n        fill = gc.fill(rgbFace)\n        stroke = gc.stroke()\n\n        output = self.file.output\n        marker = self.file.markerObject(\n            marker_path, marker_trans, fill, stroke, self.gc._linewidth,\n            gc.get_joinstyle(), gc.get_capstyle())\n\n        output(Op.gsave)\n        lastx, lasty = 0, 0\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.file.width*72, self.file.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                if not (0 <= x <= self.file.width * 72\n                        and 0 <= y <= self.file.height * 72):\n                    continue\n                dx, dy = x - lastx, y - lasty\n                output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n                       marker, Op.use_xobject)\n                lastx, lasty = x, y\n        output(Op.grestore)\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)\n\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        if len(points) == 0:\n            return\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] in (1, 4)\n\n        shape = points.shape\n        points = points.reshape((shape[0] * shape[1], 2))\n        tpoints = trans.transform(points)\n        tpoints = tpoints.reshape(shape)\n        name, _ = self.file.addGouraudTriangles(tpoints, colors)\n        output = self.file.output\n\n        if colors.shape[2] == 1:\n            # grayscale\n            gc.set_alpha(1.0)\n            self.check_gc(gc)\n            output(name, Op.shading)\n            return\n\n        alpha = colors[0, 0, 3]\n        if np.allclose(alpha, colors[:, :, 3]):\n            # single alpha value\n            gc.set_alpha(alpha)\n            self.check_gc(gc)\n            output(name, Op.shading)\n        else:\n            # varying alpha: use a soft mask\n            alpha = colors[:, :, 3][:, :, None]\n            _, smask_ob = self.file.addGouraudTriangles(tpoints, alpha)\n            gstate = self.file._soft_mask_state(smask_ob)\n            output(Op.gsave, gstate, Op.setgstate,\n                   name, Op.shading,\n                   Op.grestore)\n\n    def _setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0):\n        if angle == oldangle == 0:\n            self.file.output(x - oldx, y - oldy, Op.textpos)\n        else:\n            angle = math.radians(angle)\n            self.file.output(math.cos(angle), math.sin(angle),\n                             -math.sin(angle), math.cos(angle),\n                             x, y, Op.textmatrix)\n            self.file.output(0, 0, Op.textpos)\n\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        # TODO: fix positioning and encoding\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width, height, angle))\n\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        # Set up a global transformation matrix for the whole math expression\n        a = math.radians(angle)\n        self.file.output(Op.gsave)\n        self.file.output(math.cos(a), math.sin(a),\n                         -math.sin(a), math.cos(a),\n                         x, y, Op.concat_matrix)\n\n        self.check_gc(gc, gc._rgb)\n        prev_font = None, None\n        oldx, oldy = 0, 0\n        unsupported_chars = []\n\n        self.file.output(Op.begin_text)\n        for font, fontsize, num, ox, oy in glyphs:\n            self.file._character_tracker.track_glyph(font, num)\n            fontname = font.fname\n            if not _font_supports_glyph(fonttype, num):\n                # Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in\n                # Type 42) must be emitted separately (below).\n                unsupported_chars.append((font, fontsize, ox, oy, num))\n            else:\n                self._setup_textpos(ox, oy, 0, oldx, oldy)\n                oldx, oldy = ox, oy\n                if (fontname, fontsize) != prev_font:\n                    self.file.output(self.file.fontName(fontname), fontsize,\n                                     Op.selectfont)\n                    prev_font = fontname, fontsize\n                self.file.output(self.encode_string(chr(num), fonttype),\n                                 Op.show)\n        self.file.output(Op.end_text)\n\n        for font, fontsize, ox, oy, num in unsupported_chars:\n            self._draw_xobject_glyph(\n                font, fontsize, font.get_char_index(num), ox, oy)\n\n        # Draw any horizontal lines in the math layout\n        for ox, oy, width, height in rects:\n            self.file.output(Op.gsave, ox, oy, width, height,\n                             Op.rectangle, Op.fill, Op.grestore)\n\n        # Pop off the global transformation\n        self.file.output(Op.grestore)\n\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        texmanager = self.get_texmanager()\n        fontsize = prop.get_size_in_points()\n        dvifile = texmanager.make_dvi(s, fontsize)\n        with dviread.Dvi(dvifile, 72) as dvi:\n            page, = dvi\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, page.width, page.height, angle))\n\n        # Gather font information and do some setup for combining\n        # characters into strings. The variable seq will contain a\n        # sequence of font and text entries. A font entry is a list\n        # ['font', name, size] where name is a Name object for the\n        # font. A text entry is ['text', x, y, glyphs, x+w] where x\n        # and y are the starting coordinates, w is the width, and\n        # glyphs is a list; in this phase it will always contain just\n        # one one-character string, but later it may have longer\n        # strings interspersed with kern amounts.\n        oldfont, seq = None, []\n        for x1, y1, dvifont, glyph, width in page.text:\n            if dvifont != oldfont:\n                pdfname = self.file.dviFontName(dvifont)\n                seq += [['font', pdfname, dvifont.size]]\n                oldfont = dvifont\n            seq += [['text', x1, y1, [bytes([glyph])], x1+width]]\n\n        # Find consecutive text strings with constant y coordinate and\n        # combine into a sequence of strings and kerns, or just one\n        # string (if any kerns would be less than 0.1 points).\n        i, curx, fontsize = 0, 0, None\n        while i < len(seq)-1:\n            elt, nxt = seq[i:i+2]\n            if elt[0] == 'font':\n                fontsize = elt[2]\n            elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:\n                offset = elt[4] - nxt[1]\n                if abs(offset) < 0.1:\n                    elt[3][-1] += nxt[3][0]\n                    elt[4] += nxt[4]-nxt[1]\n                else:\n                    elt[3] += [offset*1000.0/fontsize, nxt[3][0]]\n                    elt[4] = nxt[4]\n                del seq[i+1]\n                continue\n            i += 1\n\n        # Create a transform to map the dvi contents to the canvas.\n        mytrans = Affine2D().rotate_deg(angle).translate(x, y)\n\n        # Output the text.\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        curx, cury, oldx, oldy = 0, 0, 0, 0\n        for elt in seq:\n            if elt[0] == 'font':\n                self.file.output(elt[1], elt[2], Op.selectfont)\n            elif elt[0] == 'text':\n                curx, cury = mytrans.transform((elt[1], elt[2]))\n                self._setup_textpos(curx, cury, angle, oldx, oldy)\n                oldx, oldy = curx, cury\n                if len(elt[3]) == 1:\n                    self.file.output(elt[3][0], Op.show)\n                else:\n                    self.file.output(elt[3], Op.showkern)\n            else:\n                assert False\n        self.file.output(Op.end_text)\n\n        # Then output the boxes (e.g., variable-length lines of square\n        # roots).\n        boxgc = self.new_gc()\n        boxgc.copy_properties(gc)\n        boxgc.set_linewidth(0)\n        pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.CLOSEPOLY]\n        for x1, y1, h, w in page.boxes:\n            path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],\n                         [0, 0]], pathops)\n            self.draw_path(boxgc, path, mytrans, gc._rgb)\n\n    def encode_string(self, s, fonttype):\n        if fonttype in (1, 3):\n            return s.encode('cp1252', 'replace')\n        return s.encode('utf-16be', 'replace')\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # TODO: combine consecutive texts into one BT/ET delimited section\n\n        self.check_gc(gc, gc._rgb)\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        fontsize = prop.get_size_in_points()\n\n        if mpl.rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            fonttype = 1\n        else:\n            font = self._get_font_ttf(prop)\n            self.file._character_tracker.track(font, s)\n            fonttype = mpl.rcParams['pdf.fonttype']\n\n        if gc.get_url() is not None:\n            font.set_text(s)\n            width, height = font.get_width_height()\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width / 64, height / 64, angle))\n\n        # If fonttype is neither 3 nor 42, emit the whole string at once\n        # without manual kerning.\n        if fonttype not in [3, 42]:\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            self._setup_textpos(x, y, angle)\n            self.file.output(self.encode_string(s, fonttype),\n                             Op.show, Op.end_text)\n\n        # A sequence of characters is broken into multiple chunks. The chunking\n        # serves two purposes:\n        #   - For Type 3 fonts, there is no way to access multibyte characters,\n        #     as they cannot have a CIDMap.  Therefore, in this case we break\n        #     the string into chunks, where each chunk contains either a string\n        #     of consecutive 1-byte characters or a single multibyte character.\n        #   - A sequence of 1-byte characters is split into chunks to allow for\n        #     kerning adjustments between consecutive chunks.\n        #\n        # Each chunk is emitted with a separate command: 1-byte characters use\n        # the regular text show command (TJ) with appropriate kerning between\n        # chunks, whereas multibyte characters use the XObject command (Do).\n        else:\n            # List of (ft_object, start_x, [prev_kern, char, char, ...]),\n            # w/o zero kerns.\n            singlebyte_chunks = []\n            # List of (ft_object, start_x, glyph_index).\n            multibyte_glyphs = []\n            prev_was_multibyte = True\n            prev_font = font\n            for item in _text_helpers.layout(\n                    s, font, kern_mode=KERNING_UNFITTED):\n                if _font_supports_glyph(fonttype, ord(item.char)):\n                    if prev_was_multibyte or item.ft_object != prev_font:\n                        singlebyte_chunks.append((item.ft_object, item.x, []))\n                        prev_font = item.ft_object\n                    if item.prev_kern:\n                        singlebyte_chunks[-1][2].append(item.prev_kern)\n                    singlebyte_chunks[-1][2].append(item.char)\n                    prev_was_multibyte = False\n                else:\n                    multibyte_glyphs.append(\n                        (item.ft_object, item.x, item.glyph_idx)\n                    )\n                    prev_was_multibyte = True\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = math.radians(angle)\n            self.file.output(math.cos(a), math.sin(a),\n                             -math.sin(a), math.cos(a),\n                             x, y, Op.concat_matrix)\n            # Emit all the 1-byte characters in a BT/ET group.\n\n            self.file.output(Op.begin_text)\n            prev_start_x = 0\n            for ft_object, start_x, kerns_or_chars in singlebyte_chunks:\n                ft_name = self.file.fontName(ft_object.fname)\n                self.file.output(ft_name, fontsize, Op.selectfont)\n                self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n                self.file.output(\n                    # See pdf spec \"Text space details\" for the 1000/fontsize\n                    # (aka. 1000/T_fs) factor.\n                    [-1000 * next(group) / fontsize if tp == float  # a kern\n                     else self.encode_string(\"\".join(group), fonttype)\n                     for tp, group in itertools.groupby(kerns_or_chars, type)],\n                    Op.showkern)\n                prev_start_x = start_x\n            self.file.output(Op.end_text)\n            # Then emit all the multibyte characters, one at a time.\n            for ft_object, start_x, glyph_idx in multibyte_glyphs:\n                self._draw_xobject_glyph(\n                    ft_object, fontsize, glyph_idx, start_x, 0\n                )\n            self.file.output(Op.grestore)\n\n    def _draw_xobject_glyph(self, font, fontsize, glyph_idx, x, y):\n        \"\"\"Draw a multibyte character from a Type 3 font as an XObject.\"\"\"\n        glyph_name = font.get_glyph_name(glyph_idx)\n        name = self.file._get_xobject_glyph_name(font.fname, glyph_name)\n        self.file.output(\n            Op.gsave,\n            0.001 * fontsize, 0, 0, 0.001 * fontsize, x, y, Op.concat_matrix,\n            Name(name), Op.use_xobject,\n            Op.grestore,\n        )\n\n    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPdf(self.file)",
      "instance_attributes": [
        {
          "name": "file",
          "types": null
        },
        {
          "name": "gc",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextPdf"
          }
        },
        {
          "name": "image_dpi",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream",
      "name": "Stream",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/_writeHeader",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/end",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/_flush"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF stream object.\n\nThis has no pdfRepr method. Instead, call begin(), then output the\ncontents of the stream by calling write(), and finally call end().",
      "docstring": "PDF stream object.\n\nThis has no pdfRepr method. Instead, call begin(), then output the\ncontents of the stream by calling write(), and finally call end().",
      "code": "class Stream:\n    \"\"\"\n    PDF stream object.\n\n    This has no pdfRepr method. Instead, call begin(), then output the\n    contents of the stream by calling write(), and finally call end().\n    \"\"\"\n    __slots__ = ('id', 'len', 'pdfFile', 'file', 'compressobj', 'extra', 'pos')\n\n    def __init__(self, id, len, file, extra=None, png=None):\n        \"\"\"\n        Parameters\n        ----------\n        id : int\n            Object id of the stream.\n        len : Reference or None\n            An unused Reference object for the length of the stream;\n            None means to use a memory buffer so the length can be inlined.\n        file : PdfFile\n            The underlying object to write the stream to.\n        extra : dict from Name to anything, or None\n            Extra key-value pairs to include in the stream header.\n        png : dict or None\n            If the data is already png encoded, the decode parameters.\n        \"\"\"\n        self.id = id            # object id\n        self.len = len          # id of length object\n        self.pdfFile = file\n        self.file = file.fh      # file to which the stream is written\n        self.compressobj = None  # compression object\n        if extra is None:\n            self.extra = dict()\n        else:\n            self.extra = extra.copy()\n        if png is not None:\n            self.extra.update({'Filter':      Name('FlateDecode'),\n                               'DecodeParms': png})\n\n        self.pdfFile.recordXref(self.id)\n        if mpl.rcParams['pdf.compression'] and not png:\n            self.compressobj = zlib.compressobj(\n                mpl.rcParams['pdf.compression'])\n        if self.len is None:\n            self.file = BytesIO()\n        else:\n            self._writeHeader()\n            self.pos = self.file.tell()\n\n    def _writeHeader(self):\n        write = self.file.write\n        write(b\"%d 0 obj\\n\" % self.id)\n        dict = self.extra\n        dict['Length'] = self.len\n        if mpl.rcParams['pdf.compression']:\n            dict['Filter'] = Name('FlateDecode')\n\n        write(pdfRepr(dict))\n        write(b\"\\nstream\\n\")\n\n    def end(self):\n        \"\"\"Finalize stream.\"\"\"\n\n        self._flush()\n        if self.len is None:\n            contents = self.file.getvalue()\n            self.len = len(contents)\n            self.file = self.pdfFile.fh\n            self._writeHeader()\n            self.file.write(contents)\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n        else:\n            length = self.file.tell() - self.pos\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n            self.pdfFile.writeObject(self.len, length)\n\n    def write(self, data):\n        \"\"\"Write some data on the stream.\"\"\"\n\n        if self.compressobj is None:\n            self.file.write(data)\n        else:\n            compressed = self.compressobj.compress(data)\n            self.file.write(compressed)\n\n    def _flush(self):\n        \"\"\"Flush the compression object.\"\"\"\n\n        if self.compressobj is not None:\n            compressed = self.compressobj.flush()\n            self.file.write(compressed)\n            self.compressobj = None",
      "instance_attributes": [
        {
          "name": "id",
          "types": null
        },
        {
          "name": "len",
          "types": null
        },
        {
          "name": "pdfFile",
          "types": null
        },
        {
          "name": "file",
          "types": {
            "kind": "NamedType",
            "name": "BytesIO"
          }
        },
        {
          "name": "compressobj",
          "types": null
        },
        {
          "name": "extra",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "pos",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim",
      "name": "Verbatim",
      "qname": "lib.matplotlib.backends.backend_pdf.Verbatim",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/pdfRepr"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Store verbatim PDF command content for later inclusion in the stream.",
      "docstring": "Store verbatim PDF command content for later inclusion in the stream.",
      "code": "class Verbatim:\n    \"\"\"Store verbatim PDF command content for later inclusion in the stream.\"\"\"\n    def __init__(self, x):\n        self._x = x\n\n    def pdfRepr(self):\n        return self._x",
      "instance_attributes": [
        {
          "name": "_x",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf",
      "name": "FigureCanvasPgf",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/_print_pgf_to_fh",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_renderer",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasPgf(FigureCanvasBase):\n    filetypes = {\"pgf\": \"LaTeX PGF picture\",\n                 \"pdf\": \"LaTeX compiled PGF picture\",\n                 \"png\": \"Portable Network Graphics\", }\n\n    def get_default_filetype(self):\n        return 'pdf'\n\n    def _print_pgf_to_fh(self, fh, *, bbox_inches_restore=None):\n\n        header_text = \"\"\"%% Creator: Matplotlib, PGF backend\n%%\n%% To include the figure in your LaTeX document, write\n%%   \\\\input{<filename>.pgf}\n%%\n%% Make sure the required packages are loaded in your preamble\n%%   \\\\usepackage{pgf}\n%%\n%% Also ensure that all the required font packages are loaded; for instance,\n%% the lmodern package is sometimes necessary when using math font.\n%%   \\\\usepackage{lmodern}\n%%\n%% Figures using additional raster images can only be included by \\\\input if\n%% they are in the same directory as the main LaTeX file. For loading figures\n%% from other directories you can use the `import` package\n%%   \\\\usepackage{import}\n%%\n%% and then include the figures with\n%%   \\\\import{<path to file>}{<filename>.pgf}\n%%\n\"\"\"\n\n        # append the preamble used by the backend as a comment for debugging\n        header_info_preamble = [\"%% Matplotlib used the following preamble\"]\n        for line in _get_preamble().splitlines():\n            header_info_preamble.append(\"%%   \" + line)\n        header_info_preamble.append(\"%%\")\n        header_info_preamble = \"\\n\".join(header_info_preamble)\n\n        # get figure size in inch\n        w, h = self.figure.get_figwidth(), self.figure.get_figheight()\n        dpi = self.figure.dpi\n\n        # create pgfpicture environment and write the pgf code\n        fh.write(header_text)\n        fh.write(header_info_preamble)\n        fh.write(\"\\n\")\n        _writeln(fh, r\"\\begingroup\")\n        _writeln(fh, r\"\\makeatletter\")\n        _writeln(fh, r\"\\begin{pgfpicture}\")\n        _writeln(fh,\n                 r\"\\pgfpathrectangle{\\pgfpointorigin}{\\pgfqpoint{%fin}{%fin}}\"\n                 % (w, h))\n        _writeln(fh, r\"\\pgfusepath{use as bounding box, clip}\")\n        renderer = MixedModeRenderer(self.figure, w, h, dpi,\n                                     RendererPgf(self.figure, fh),\n                                     bbox_inches_restore=bbox_inches_restore)\n        self.figure.draw(renderer)\n\n        # end the pgfpicture environment\n        _writeln(fh, r\"\\end{pgfpicture}\")\n        _writeln(fh, r\"\\makeatother\")\n        _writeln(fh, r\"\\endgroup\")\n\n    def print_pgf(self, fname_or_fh, **kwargs):\n        \"\"\"\n        Output pgf macros for drawing the figure so it can be included and\n        rendered in latex documents.\n        \"\"\"\n        with cbook.open_file_cm(fname_or_fh, \"w\", encoding=\"utf-8\") as file:\n            if not cbook.file_requires_unicode(file):\n                file = codecs.getwriter(\"utf-8\")(file)\n            self._print_pgf_to_fh(file, **kwargs)\n\n    def print_pdf(self, fname_or_fh, *, metadata=None, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf generated figure to pdf.\"\"\"\n        w, h = self.figure.get_size_inches()\n\n        info_dict = _create_pdf_info_dict('pgf', metadata or {})\n        pdfinfo = ','.join(\n            _metadata_to_str(k, v) for k, v in info_dict.items())\n\n        # print figure to pgf and compile it with latex\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            self.print_pgf(tmppath / \"figure.pgf\", **kwargs)\n            (tmppath / \"figure.tex\").write_text(\n                \"\\n\".join([\n                    r\"\\documentclass[12pt]{article}\",\n                    r\"\\usepackage[pdfinfo={%s}]{hyperref}\" % pdfinfo,\n                    r\"\\usepackage[papersize={%fin,%fin}, margin=0in]{geometry}\"\n                    % (w, h),\n                    r\"\\usepackage{pgf}\",\n                    _get_preamble(),\n                    r\"\\begin{document}\",\n                    r\"\\centering\",\n                    r\"\\input{figure.pgf}\",\n                    r\"\\end{document}\",\n                ]), encoding=\"utf-8\")\n            texcommand = mpl.rcParams[\"pgf.texsystem\"]\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 \"figure.tex\"], _log, cwd=tmpdir)\n            with (tmppath / \"figure.pdf\").open(\"rb\") as orig, \\\n                 cbook.open_file_cm(fname_or_fh, \"wb\") as dest:\n                shutil.copyfileobj(orig, dest)  # copy file contents to target\n\n    def print_png(self, fname_or_fh, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf figure to pdf and convert it to png.\"\"\"\n        converter = make_pdf_to_png_converter()\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            pdf_path = tmppath / \"figure.pdf\"\n            png_path = tmppath / \"figure.png\"\n            self.print_pdf(pdf_path, **kwargs)\n            converter(pdf_path, png_path, dpi=self.figure.dpi)\n            with png_path.open(\"rb\") as orig, \\\n                 cbook.open_file_cm(fname_or_fh, \"wb\") as dest:\n                shutil.copyfileobj(orig, dest)  # copy file contents to target\n\n    def get_renderer(self):\n        return RendererPgf(self.figure, None)\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError",
      "name": "LatexError",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__str__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class LatexError(Exception):\n    def __init__(self, message, latex_output=\"\"):\n        super().__init__(message)\n        self.latex_output = latex_output\n\n    def __str__(self):\n        s, = self.args\n        if self.latex_output:\n            s += \"\\n\" + self.latex_output\n        return s",
      "instance_attributes": [
        {
          "name": "latex_output",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager",
      "name": "LatexManager",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_build_latex_header",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_get_cached_or_new",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_get_cached_or_new_impl",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_stdin_writeln",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_expect",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_expect_prompt",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_setup_latex_process",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_get_box_metrics"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.",
      "docstring": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.",
      "code": "class LatexManager:\n    \"\"\"\n    The LatexManager opens an instance of the LaTeX application for\n    determining the metrics of text elements. The LaTeX environment can be\n    modified by setting fonts and/or a custom preamble in `.rcParams`.\n    \"\"\"\n\n    @staticmethod\n    def _build_latex_header():\n        latex_header = [\n            r\"\\documentclass{article}\",\n            # Include TeX program name as a comment for cache invalidation.\n            # TeX does not allow this to be the first line.\n            rf\"% !TeX program = {mpl.rcParams['pgf.texsystem']}\",\n            # Test whether \\includegraphics supports interpolate option.\n            r\"\\usepackage{graphicx}\",\n            _get_preamble(),\n            r\"\\begin{document}\",\n            r\"\\typeout{pgf_backend_query_start}\",\n        ]\n        return \"\\n\".join(latex_header)\n\n    @classmethod\n    def _get_cached_or_new(cls):\n        \"\"\"\n        Return the previous LatexManager if the header and tex system did not\n        change, or a new instance otherwise.\n        \"\"\"\n        return cls._get_cached_or_new_impl(cls._build_latex_header())\n\n    @classmethod\n    @functools.lru_cache(1)\n    def _get_cached_or_new_impl(cls, header):  # Helper for _get_cached_or_new.\n        return cls()\n\n    def _stdin_writeln(self, s):\n        if self.latex is None:\n            self._setup_latex_process()\n        self.latex.stdin.write(s)\n        self.latex.stdin.write(\"\\n\")\n        self.latex.stdin.flush()\n\n    def _expect(self, s):\n        s = list(s)\n        chars = []\n        while True:\n            c = self.latex.stdout.read(1)\n            chars.append(c)\n            if chars[-len(s):] == s:\n                break\n            if not c:\n                self.latex.kill()\n                self.latex = None\n                raise LatexError(\"LaTeX process halted\", \"\".join(chars))\n        return \"\".join(chars)\n\n    def _expect_prompt(self):\n        return self._expect(\"\\n*\")\n\n    def __init__(self):\n        # create a tmp directory for running latex, register it for deletion\n        self._tmpdir = TemporaryDirectory()\n        self.tmpdir = self._tmpdir.name\n        self._finalize_tmpdir = weakref.finalize(self, self._tmpdir.cleanup)\n\n        # test the LaTeX setup to ensure a clean startup of the subprocess\n        try:\n            self._setup_latex_process(expect_reply=False)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{self.latex.args[0]!r} not found.  Install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX \"\n                f\"implementation.\") from err\n        except OSError as err:\n            raise RuntimeError(\n                f\"Error starting process {self.latex.args[0]!r}\") from err\n        stdout, stderr = self.latex.communicate(\"\\n\\\\makeatletter\\\\@@end\\n\")\n        if self.latex.returncode != 0:\n            raise LatexError(\n                f\"LaTeX errored (probably missing font or error in preamble) \"\n                f\"while processing the following input:\\n\"\n                f\"{self._build_latex_header()}\",\n                stdout)\n\n        self.latex = None  # Will be set up on first use.\n        # Per-instance cache.\n        self._get_box_metrics = functools.lru_cache()(self._get_box_metrics)\n\n    str_cache = _api.deprecated(\"3.5\")(property(lambda self: {}))\n    texcommand = _api.deprecated(\"3.6\")(\n        property(lambda self: mpl.rcParams[\"pgf.texsystem\"]))\n    latex_header = _api.deprecated(\"3.6\")(\n        property(lambda self: self._build_latex_header()))\n\n    def _setup_latex_process(self, *, expect_reply=True):\n        # Open LaTeX process for real work; register it for deletion.  On\n        # Windows, we must ensure that the subprocess has quit before being\n        # able to delete the tmpdir in which it runs; in order to do so, we\n        # must first `kill()` it, and then `communicate()` with it.\n        self.latex = subprocess.Popen(\n            [mpl.rcParams[\"pgf.texsystem\"], \"-halt-on-error\"],\n            stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n            encoding=\"utf-8\", cwd=self.tmpdir)\n\n        def finalize_latex(latex):\n            latex.kill()\n            latex.communicate()\n\n        self._finalize_latex = weakref.finalize(\n            self, finalize_latex, self.latex)\n        # write header with 'pgf_backend_query_start' token\n        self._stdin_writeln(self._build_latex_header())\n        if expect_reply:  # read until 'pgf_backend_query_start' token appears\n            self._expect(\"*pgf_backend_query_start\")\n            self._expect_prompt()\n\n    def get_width_height_descent(self, text, prop):\n        \"\"\"\n        Get the width, total height, and descent (in TeX points) for a text\n        typeset by the current LaTeX environment.\n        \"\"\"\n        return self._get_box_metrics(_escape_and_apply_props(text, prop))\n\n    def _get_box_metrics(self, tex):\n        \"\"\"\n        Get the width, total height and descent (in TeX points) for a TeX\n        command's output in the current LaTeX environment.\n        \"\"\"\n        # This method gets wrapped in __init__ for per-instance caching.\n        self._stdin_writeln(  # Send textbox to TeX & request metrics typeout.\n            r\"\\sbox0{%s}\\typeout{\\the\\wd0,\\the\\ht0,\\the\\dp0}\" % tex)\n        try:\n            answer = self._expect_prompt()\n        except LatexError as err:\n            # Here and below, use '{}' instead of {!r} to avoid doubling all\n            # backslashes.\n            raise ValueError(\"Error measuring {}\\nLaTeX Output:\\n{}\"\n                             .format(tex, err.latex_output)) from err\n        try:\n            # Parse metrics from the answer string.  Last line is prompt, and\n            # next-to-last-line is blank line from \\typeout.\n            width, height, offset = answer.splitlines()[-3].split(\",\")\n        except Exception as err:\n            raise ValueError(\"Error measuring {}\\nLaTeX Output:\\n{}\"\n                             .format(tex, answer)) from err\n        w, h, o = float(width[:-2]), float(height[:-2]), float(offset[:-2])\n        # The height returned from LaTeX goes from base to top;\n        # the height Matplotlib expects goes from bottom to top.\n        return w, h + o, o",
      "instance_attributes": [
        {
          "name": "latex",
          "types": {
            "kind": "NamedType",
            "name": "Popen"
          }
        },
        {
          "name": "_tmpdir",
          "types": {
            "kind": "NamedType",
            "name": "TemporaryDirectory"
          }
        },
        {
          "name": "tmpdir",
          "types": null
        },
        {
          "name": "_finalize_tmpdir",
          "types": {
            "kind": "NamedType",
            "name": "finalize"
          }
        },
        {
          "name": "_get_box_metrics",
          "types": null
        },
        {
          "name": "_finalize_latex",
          "types": {
            "kind": "NamedType",
            "name": "finalize"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages",
      "name": "PdfPages",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/_write_header",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__enter__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/close",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/_run_latex",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/get_pagecount"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file using the pgf backend",
      "docstring": "A multi-page PDF file using the pgf backend\n\nExamples\n--------\n>>> import matplotlib.pyplot as plt\n>>> # Initialize:\n>>> with PdfPages('foo.pdf') as pdf:\n...     # As many times as you like, create a figure fig and save it:\n...     fig = plt.figure()\n...     pdf.savefig(fig)\n...     # When no figure is specified the current figure is saved\n...     pdf.savefig()",
      "code": "class PdfPages:\n    \"\"\"\n    A multi-page PDF file using the pgf backend\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> # Initialize:\n    >>> with PdfPages('foo.pdf') as pdf:\n    ...     # As many times as you like, create a figure fig and save it:\n    ...     fig = plt.figure()\n    ...     pdf.savefig(fig)\n    ...     # When no figure is specified the current figure is saved\n    ...     pdf.savefig()\n    \"\"\"\n    __slots__ = (\n        '_output_name',\n        'keep_empty',\n        '_n_figures',\n        '_file',\n        '_info_dict',\n        '_metadata',\n    )\n\n    def __init__(self, filename, *, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. Any older file with the same name is overwritten.\n\n        keep_empty : bool, default: True\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n\n            Note that some versions of LaTeX engines may ignore the 'Producer'\n            key and set it to themselves.\n        \"\"\"\n        self._output_name = filename\n        self._n_figures = 0\n        self.keep_empty = keep_empty\n        self._metadata = (metadata or {}).copy()\n        self._info_dict = _create_pdf_info_dict('pgf', self._metadata)\n        self._file = BytesIO()\n\n    def _write_header(self, width_inches, height_inches):\n        pdfinfo = ','.join(\n            _metadata_to_str(k, v) for k, v in self._info_dict.items())\n        latex_header = \"\\n\".join([\n            r\"\\documentclass[12pt]{article}\",\n            r\"\\usepackage[pdfinfo={%s}]{hyperref}\" % pdfinfo,\n            r\"\\usepackage[papersize={%fin,%fin}, margin=0in]{geometry}\"\n            % (width_inches, height_inches),\n            r\"\\usepackage{pgf}\",\n            _get_preamble(),\n            r\"\\setlength{\\parindent}{0pt}\",\n            r\"\\begin{document}%\",\n        ])\n        self._file.write(latex_header.encode('utf-8'))\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def close(self):\n        \"\"\"\n        Finalize this object, running LaTeX in a temporary directory\n        and moving the final pdf file to *filename*.\n        \"\"\"\n        self._file.write(rb'\\end{document}\\n')\n        if self._n_figures > 0:\n            self._run_latex()\n        elif self.keep_empty:\n            open(self._output_name, 'wb').close()\n        self._file.close()\n\n    def _run_latex(self):\n        texcommand = mpl.rcParams[\"pgf.texsystem\"]\n        with TemporaryDirectory() as tmpdir:\n            tex_source = pathlib.Path(tmpdir, \"pdf_pages.tex\")\n            tex_source.write_bytes(self._file.getvalue())\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 tex_source],\n                _log, cwd=tmpdir)\n            shutil.move(tex_source.with_suffix(\".pdf\"), self._output_name)\n\n    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, default: the active figure\n            The figure, or index of the figure, that is saved to the file.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPgf(figure)\n\n            width, height = figure.get_size_inches()\n            if self._n_figures == 0:\n                self._write_header(width, height)\n            else:\n                # \\pdfpagewidth and \\pdfpageheight exist on pdftex, xetex, and\n                # luatex<0.85; they were renamed to \\pagewidth and \\pageheight\n                # on luatex>=0.85.\n                self._file.write(\n                    br'\\newpage'\n                    br'\\ifdefined\\pdfpagewidth\\pdfpagewidth'\n                    br'\\else\\pagewidth\\fi=%ain'\n                    br'\\ifdefined\\pdfpageheight\\pdfpageheight'\n                    br'\\else\\pageheight\\fi=%ain'\n                    b'%%\\n' % (width, height)\n                )\n\n            figure.savefig(self._file, format=\"pgf\", **kwargs)\n            self._n_figures += 1\n        finally:\n            figure.canvas = orig_canvas\n\n    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return self._n_figures",
      "instance_attributes": [
        {
          "name": "_output_name",
          "types": null
        },
        {
          "name": "_n_figures",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "keep_empty",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_metadata",
          "types": null
        },
        {
          "name": "_info_dict",
          "types": null
        },
        {
          "name": "_file",
          "types": {
            "kind": "NamedType",
            "name": "BytesIO"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf",
      "name": "RendererPgf",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_print_pgf_clip",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_print_pgf_path_styles",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_print_pgf_path",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_pgf_path_draw",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_scale_image",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_image_nocomposite",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/flipy",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererPgf(RendererBase):\n\n    def __init__(self, figure, fh):\n        \"\"\"\n        Create a new PGF renderer that translates any drawing instruction\n        into text commands to be interpreted in a latex pgfpicture environment.\n\n        Attributes\n        ----------\n        figure : `matplotlib.figure.Figure`\n            Matplotlib figure to initialize height, width and dpi from.\n        fh : file-like\n            File handle for the output of the drawing commands.\n        \"\"\"\n\n        super().__init__()\n        self.dpi = figure.dpi\n        self.fh = fh\n        self.figure = figure\n        self.image_counter = 0\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        # convert from display units to in\n        f = 1. / self.dpi\n\n        # set style and clip\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n\n        # build marker definition\n        bl, tr = marker_path.get_extents(marker_trans).get_points()\n        coords = bl[0] * f, bl[1] * f, tr[0] * f, tr[1] * f\n        _writeln(self.fh,\n                 r\"\\pgfsys@defobject{currentmarker}\"\n                 r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}{\" % coords)\n        self._print_pgf_path(None, marker_path, marker_trans)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        _writeln(self.fh, r\"}\")\n\n        maxcoord = 16383 / 72.27 * self.dpi  # Max dimensions in LaTeX.\n        clip = (-maxcoord, -maxcoord, maxcoord, maxcoord)\n\n        # draw marker for each vertex\n        for point, code in path.iter_segments(trans, simplify=False,\n                                              clip=clip):\n            x, y = point[0] * f, point[1] * f\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            _writeln(self.fh, r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x, y))\n            _writeln(self.fh, r\"\\pgfsys@useobject{currentmarker}{}\")\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n        # draw the path\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n        self._print_pgf_path(gc, path, transform, rgbFace)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n        # if present, draw pattern on top\n        if gc.get_hatch():\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            self._print_pgf_path_styles(gc, rgbFace)\n\n            # combine clip and path for clipping\n            self._print_pgf_clip(gc)\n            self._print_pgf_path(gc, path, transform, rgbFace)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n            # build pattern definition\n            _writeln(self.fh,\n                     r\"\\pgfsys@defobject{currentpattern}\"\n                     r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}{\")\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            _writeln(self.fh,\n                     r\"\\pgfpathrectangle\"\n                     r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}\")\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n            scale = mpl.transforms.Affine2D().scale(self.dpi)\n            self._print_pgf_path(None, gc.get_hatch_path(), scale)\n            self._pgf_path_draw(stroke=True)\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n            _writeln(self.fh, r\"}\")\n            # repeat pattern, filling the bounding rect of the path\n            f = 1. / self.dpi\n            (xmin, ymin), (xmax, ymax) = \\\n                path.get_extents(transform).get_points()\n            xmin, xmax = f * xmin, f * xmax\n            ymin, ymax = f * ymin, f * ymax\n            repx, repy = math.ceil(xmax - xmin), math.ceil(ymax - ymin)\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformshift{%fin}{%fin}\" % (xmin, ymin))\n            for iy in range(repy):\n                for ix in range(repx):\n                    _writeln(self.fh, r\"\\pgfsys@useobject{currentpattern}{}\")\n                    _writeln(self.fh, r\"\\pgfsys@transformshift{1in}{0in}\")\n                _writeln(self.fh, r\"\\pgfsys@transformshift{-%din}{0in}\" % repx)\n                _writeln(self.fh, r\"\\pgfsys@transformshift{0in}{1in}\")\n\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def _print_pgf_clip(self, gc):\n        f = 1. / self.dpi\n        # check for clip box\n        bbox = gc.get_clip_rectangle()\n        if bbox:\n            p1, p2 = bbox.get_points()\n            w, h = p2 - p1\n            coords = p1[0] * f, p1[1] * f, w * f, h * f\n            _writeln(self.fh,\n                     r\"\\pgfpathrectangle\"\n                     r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}\"\n                     % coords)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n        # check for clip path\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            self._print_pgf_path(gc, clippath, clippath_trans)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n    def _print_pgf_path_styles(self, gc, rgbFace):\n        # cap style\n        capstyles = {\"butt\": r\"\\pgfsetbuttcap\",\n                     \"round\": r\"\\pgfsetroundcap\",\n                     \"projecting\": r\"\\pgfsetrectcap\"}\n        _writeln(self.fh, capstyles[gc.get_capstyle()])\n\n        # join style\n        joinstyles = {\"miter\": r\"\\pgfsetmiterjoin\",\n                      \"round\": r\"\\pgfsetroundjoin\",\n                      \"bevel\": r\"\\pgfsetbeveljoin\"}\n        _writeln(self.fh, joinstyles[gc.get_joinstyle()])\n\n        # filling\n        has_fill = rgbFace is not None\n\n        if gc.get_forced_alpha():\n            fillopacity = strokeopacity = gc.get_alpha()\n        else:\n            strokeopacity = gc.get_rgb()[3]\n            fillopacity = rgbFace[3] if has_fill and len(rgbFace) > 3 else 1.0\n\n        if has_fill:\n            _writeln(self.fh,\n                     r\"\\definecolor{currentfill}{rgb}{%f,%f,%f}\"\n                     % tuple(rgbFace[:3]))\n            _writeln(self.fh, r\"\\pgfsetfillcolor{currentfill}\")\n        if has_fill and fillopacity != 1.0:\n            _writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % fillopacity)\n\n        # linewidth and color\n        lw = gc.get_linewidth() * mpl_pt_to_in * latex_in_to_pt\n        stroke_rgba = gc.get_rgb()\n        _writeln(self.fh, r\"\\pgfsetlinewidth{%fpt}\" % lw)\n        _writeln(self.fh,\n                 r\"\\definecolor{currentstroke}{rgb}{%f,%f,%f}\"\n                 % stroke_rgba[:3])\n        _writeln(self.fh, r\"\\pgfsetstrokecolor{currentstroke}\")\n        if strokeopacity != 1.0:\n            _writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % strokeopacity)\n\n        # line style\n        dash_offset, dash_list = gc.get_dashes()\n        if dash_list is None:\n            _writeln(self.fh, r\"\\pgfsetdash{}{0pt}\")\n        else:\n            _writeln(self.fh,\n                     r\"\\pgfsetdash{%s}{%fpt}\"\n                     % (\"\".join(r\"{%fpt}\" % dash for dash in dash_list),\n                        dash_offset))\n\n    def _print_pgf_path(self, gc, path, transform, rgbFace=None):\n        f = 1. / self.dpi\n        # check for clip box / ignore clip for filled paths\n        bbox = gc.get_clip_rectangle() if gc else None\n        maxcoord = 16383 / 72.27 * self.dpi  # Max dimensions in LaTeX.\n        if bbox and (rgbFace is None):\n            p1, p2 = bbox.get_points()\n            clip = (max(p1[0], -maxcoord), max(p1[1], -maxcoord),\n                    min(p2[0], maxcoord), min(p2[1], maxcoord))\n        else:\n            clip = (-maxcoord, -maxcoord, maxcoord, maxcoord)\n        # build path\n        for points, code in path.iter_segments(transform, clip=clip):\n            if code == Path.MOVETO:\n                x, y = tuple(points)\n                _writeln(self.fh,\n                         r\"\\pgfpathmoveto{\\pgfqpoint{%fin}{%fin}}\" %\n                         (f * x, f * y))\n            elif code == Path.CLOSEPOLY:\n                _writeln(self.fh, r\"\\pgfpathclose\")\n            elif code == Path.LINETO:\n                x, y = tuple(points)\n                _writeln(self.fh,\n                         r\"\\pgfpathlineto{\\pgfqpoint{%fin}{%fin}}\" %\n                         (f * x, f * y))\n            elif code == Path.CURVE3:\n                cx, cy, px, py = tuple(points)\n                coords = cx * f, cy * f, px * f, py * f\n                _writeln(self.fh,\n                         r\"\\pgfpathquadraticcurveto\"\n                         r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}\"\n                         % coords)\n            elif code == Path.CURVE4:\n                c1x, c1y, c2x, c2y, px, py = tuple(points)\n                coords = c1x * f, c1y * f, c2x * f, c2y * f, px * f, py * f\n                _writeln(self.fh,\n                         r\"\\pgfpathcurveto\"\n                         r\"{\\pgfqpoint{%fin}{%fin}}\"\n                         r\"{\\pgfqpoint{%fin}{%fin}}\"\n                         r\"{\\pgfqpoint{%fin}{%fin}}\"\n                         % coords)\n\n        # apply pgf decorators\n        sketch_params = gc.get_sketch_params() if gc else None\n        if sketch_params is not None:\n            # Only \"length\" directly maps to \"segment length\" in PGF's API.\n            # PGF uses \"amplitude\" to pass the combined deviation in both x-\n            # and y-direction, while matplotlib only varies the length of the\n            # wiggle along the line (\"randomness\" and \"length\" parameters)\n            # and has a separate \"scale\" argument for the amplitude.\n            # -> Use \"randomness\" as PRNG seed to allow the user to force the\n            # same shape on multiple sketched lines\n            scale, length, randomness = sketch_params\n            if scale is not None:\n                # make matplotlib and PGF rendering visually similar\n                length *= 0.5\n                scale *= 2\n                # PGF guarantees that repeated loading is a no-op\n                _writeln(self.fh, r\"\\usepgfmodule{decorations}\")\n                _writeln(self.fh, r\"\\usepgflibrary{decorations.pathmorphing}\")\n                _writeln(self.fh, r\"\\pgfkeys{/pgf/decoration/.cd, \"\n                         f\"segment length = {(length * f):f}in, \"\n                         f\"amplitude = {(scale * f):f}in}}\")\n                _writeln(self.fh, f\"\\\\pgfmathsetseed{{{int(randomness)}}}\")\n                _writeln(self.fh, r\"\\pgfdecoratecurrentpath{random steps}\")\n\n    def _pgf_path_draw(self, stroke=True, fill=False):\n        actions = []\n        if stroke:\n            actions.append(\"stroke\")\n        if fill:\n            actions.append(\"fill\")\n        _writeln(self.fh, r\"\\pgfusepath{%s}\" % \",\".join(actions))\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if not os.path.exists(getattr(self.fh, \"name\", \"\")):\n            raise ValueError(\n                \"streamed pgf-code does not support raster graphics, consider \"\n                \"using the pgf-to-pdf option\")\n\n        # save the images to png files\n        path = pathlib.Path(self.fh.name)\n        fname_img = \"%s-img%d.png\" % (path.stem, self.image_counter)\n        Image.fromarray(im[::-1]).save(path.parent / fname_img)\n        self.image_counter += 1\n\n        # reference the image in the pgf picture\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n        self._print_pgf_clip(gc)\n        f = 1. / self.dpi  # from display coords to inch\n        if transform is None:\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x * f, y * f))\n            w, h = w * f, h * f\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformcm{%f}{%f}{%f}{%f}{%fin}{%fin}\" %\n                     (tr1 * f, tr2 * f, tr3 * f, tr4 * f,\n                      (tr5 + x) * f, (tr6 + y) * f))\n            w = h = 1  # scale is already included in the transform\n        interp = str(transform is None).lower()  # interpolation in PDF reader\n        _writeln(self.fh,\n                 r\"\\pgftext[left,bottom]\"\n                 r\"{%s[interpolate=%s,width=%fin,height=%fin]{%s}}\" %\n                 (_get_image_inclusion_command(),\n                  interp, w, h, fname_img))\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath=\"TeX\", mtext=None):\n        # docstring inherited\n        self.draw_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # prepare string for tex\n        s = _escape_and_apply_props(s, prop)\n\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        alpha = gc.get_alpha()\n        if alpha != 1.0:\n            _writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % alpha)\n            _writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % alpha)\n        rgb = tuple(gc.get_rgb())[:3]\n        _writeln(self.fh, r\"\\definecolor{textcolor}{rgb}{%f,%f,%f}\" % rgb)\n        _writeln(self.fh, r\"\\pgfsetstrokecolor{textcolor}\")\n        _writeln(self.fh, r\"\\pgfsetfillcolor{textcolor}\")\n        s = r\"\\color{textcolor}\" + s\n\n        dpi = self.figure.dpi\n        text_args = []\n        if mtext and (\n                (angle == 0 or\n                 mtext.get_rotation_mode() == \"anchor\") and\n                mtext.get_verticalalignment() != \"center_baseline\"):\n            # if text anchoring can be supported, get the original coordinates\n            # and add alignment information\n            pos = mtext.get_unitless_position()\n            x, y = mtext.get_transform().transform(pos)\n            halign = {\"left\": \"left\", \"right\": \"right\", \"center\": \"\"}\n            valign = {\"top\": \"top\", \"bottom\": \"bottom\",\n                      \"baseline\": \"base\", \"center\": \"\"}\n            text_args.extend([\n                f\"x={x/dpi:f}in\",\n                f\"y={y/dpi:f}in\",\n                halign[mtext.get_horizontalalignment()],\n                valign[mtext.get_verticalalignment()],\n            ])\n        else:\n            # if not, use the text layout provided by Matplotlib.\n            text_args.append(f\"x={x/dpi:f}in, y={y/dpi:f}in, left, base\")\n\n        if angle != 0:\n            text_args.append(\"rotate=%f\" % angle)\n\n        _writeln(self.fh, r\"\\pgftext[%s]{%s}\" % (\",\".join(text_args), s))\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        # get text metrics in units of latex pt, convert to display units\n        w, h, d = (LatexManager._get_cached_or_new()\n                   .get_width_height_descent(s, prop))\n        # TODO: this should be latex_pt_to_in instead of mpl_pt_to_in\n        # but having a little bit more space around the text looks better,\n        # plus the bounding box reported by LaTeX is VERY narrow\n        f = mpl_pt_to_in * self.dpi\n        return w * f, h * f, d * f\n\n    def flipy(self):\n        # docstring inherited\n        return False\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return (self.figure.get_figwidth() * self.dpi,\n                self.figure.get_figheight() * self.dpi)\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * mpl_pt_to_in * self.dpi",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "fh",
          "types": null
        },
        {
          "name": "figure",
          "types": null
        },
        {
          "name": "image_counter",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_pgf.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    NO_ESCAPE = _api.deprecated(\"3.6\", obj_type=\"\")(\n        property(lambda self: _NO_ESCAPE))\n    re_mathsep = _api.deprecated(\"3.6\", obj_type=\"\")(\n        property(lambda self: _split_math.__self__))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS",
      "name": "FigureCanvasPS",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/_print_ps",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/_print_figure",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/_print_figure_tex",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasPS(FigureCanvasBase):\n    fixed_dpi = 72\n    filetypes = {'ps': 'Postscript',\n                 'eps': 'Encapsulated Postscript'}\n\n    def get_default_filetype(self):\n        return 'ps'\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def _print_ps(\n            self, fmt, outfile, *args,\n            metadata=None, papertype=None, orientation='portrait',\n            **kwargs):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            filename = pathlib.Path(outfile).name\n            dsc_comments[\"Title\"] = \\\n                filename.encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"Matplotlib v{mpl.__version__}, https://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.utcfromtimestamp(\n                int(source_date_epoch)).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        _api.check_in_list(['auto', *papersize], papertype=papertype)\n\n        orientation = _api.check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype, **kwargs)\n\n    def _print_figure(\n            self, fmt, outfile, *,\n            dpi, dsc_comments, orientation, papertype,\n            bbox_inches_restore=None):\n        \"\"\"\n        Render the figure to a filesystem path or a file-like object.\n\n        Parameters are as for `.print_figure`, except that *dsc_comments* is a\n        all string containing Document Structuring Convention comments,\n        generated from the *metadata* parameter to `.print_figure`.\n        \"\"\"\n        is_eps = fmt == 'eps'\n        if not (isinstance(outfile, (str, os.PathLike))\n                or is_writable_file_like(outfile)):\n            raise ValueError(\"outfile must be a path or a file-like object\")\n\n        # find the appropriate papertype\n        width, height = self.figure.get_size_inches()\n        if papertype == 'auto':\n            papertype = _get_papertype(\n                *orientation.swap_if_landscape((width, height)))\n        paper_width, paper_height = orientation.swap_if_landscape(\n            papersize[papertype])\n\n        if mpl.rcParams['ps.usedistiller']:\n            # distillers improperly clip eps files if pagesize is too small\n            if width > paper_width or height > paper_height:\n                papertype = _get_papertype(\n                    *orientation.swap_if_landscape((width, height)))\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    papersize[papertype])\n\n        # center the figure on the paper\n        xo = 72 * 0.5 * (paper_width - width)\n        yo = 72 * 0.5 * (paper_height - height)\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        rotation = 0\n        if orientation is _Orientation.landscape:\n            llx, lly, urx, ury = lly, llx, ury, urx\n            xo, yo = 72 * paper_height - yo, xo\n            rotation = 90\n        bbox = (llx, lly, urx, ury)\n\n        self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi, ps_renderer,\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(f\"%!PS-Adobe-3.0\\n\"\n                      f\"%%DocumentPaperSizes: {papertype}\\n\"\n                      f\"%%Pages: 1\\n\",\n                      end=\"\", file=fh)\n            print(f\"{dsc_comments}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"{get_bbox_header(bbox)[0]}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                Ndict += len(ps_renderer._character_tracker.used)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            print(\"\\n\".join(psDefs), file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                for font_path, chars \\\n                        in ps_renderer._character_tracker.used.items():\n                    if not chars:\n                        continue\n                    fonttype = mpl.rcParams['ps.fonttype']\n                    # Can't use more than 255 chars from a single Type 3 font.\n                    if len(chars) > 255:\n                        fonttype = 42\n                    fh.flush()\n                    if fonttype == 3:\n                        fh.write(_font_to_ps_type3(font_path, chars))\n                    else:  # Type 42 only.\n                        _font_to_ps_type42(font_path, chars, fh)\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(\"%s clipbox\" % _nums_to_str(width*72, height*72, 0, 0),\n                  file=fh)\n\n            # write the figure\n            print(self._pswriter.getvalue(), file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()\n\n        if mpl.rcParams['ps.usedistiller']:\n            # We are going to use an external program to process the output.\n            # Write to a temporary file.\n            with TemporaryDirectory() as tmpdir:\n                tmpfile = os.path.join(tmpdir, \"tmp.ps\")\n                with open(tmpfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)\n                if mpl.rcParams['ps.usedistiller'] == 'ghostscript':\n                    _try_distill(gs_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                    _try_distill(xpdf_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                _move_path_to_path_or_stream(tmpfile, outfile)\n\n        else:  # Write directly to outfile.\n            with cbook.open_file_cm(outfile, \"w\", encoding=\"latin-1\") as file:\n                if not file_requires_unicode(file):\n                    file = codecs.getwriter(\"latin-1\")(file)\n                print_figure_impl(file)\n\n    def _print_figure_tex(\n            self, fmt, outfile, *,\n            dpi, dsc_comments, orientation, papertype,\n            bbox_inches_restore=None):\n        \"\"\"\n        If :rc:`text.usetex` is True, a temporary pair of tex/eps files\n        are created to allow tex to manage the text layout via the PSFrags\n        package. These files are processed to yield the final ps or eps file.\n\n        The rest of the behavior is as for `._print_figure`.\n        \"\"\"\n        is_eps = fmt == 'eps'\n\n        width, height = self.figure.get_size_inches()\n        xo = 0\n        yo = 0\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        bbox = (llx, lly, urx, ury)\n\n        self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(self.figure,\n                                     width, height, dpi, ps_renderer,\n                                     bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        # write to a temp file, we'll move it to outfile when done\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir, \"tmp.ps\")\n            tmppath.write_text(\n                f\"\"\"\\\n%!PS-Adobe-3.0 EPSF-3.0\n{dsc_comments}\n{get_bbox_header(bbox)[0]}\n%%EndComments\n%%BeginProlog\n/mpldict {len(psDefs)} dict def\nmpldict begin\n{\"\".join(psDefs)}\nend\n%%EndProlog\nmpldict begin\n{_nums_to_str(xo, yo)} translate\n{_nums_to_str(width*72, height*72)} 0 0 clipbox\n{self._pswriter.getvalue()}\nend\nshowpage\n\"\"\",\n                encoding=\"latin-1\")\n\n            if orientation is _Orientation.landscape:  # now, ready to rotate\n                width, height = height, width\n                bbox = (lly, llx, ury, urx)\n\n            # set the paper size to the figure size if is_eps. The\n            # resulting ps file has the given size with correct bounding\n            # box so that there is no need to call 'pstoeps'\n            if is_eps:\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    self.figure.get_size_inches())\n            else:\n                if papertype == 'auto':\n                    papertype = _get_papertype(width, height)\n                paper_width, paper_height = papersize[papertype]\n\n            psfrag_rotated = _convert_psfrags(\n                tmppath, ps_renderer.psfrag, paper_width, paper_height,\n                orientation.name)\n\n            if (mpl.rcParams['ps.usedistiller'] == 'ghostscript'\n                    or mpl.rcParams['text.usetex']):\n                _try_distill(gs_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n            elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                _try_distill(xpdf_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n            _move_path_to_path_or_stream(tmppath, outfile)\n\n    print_ps = functools.partialmethod(_print_ps, \"ps\")\n    print_eps = functools.partialmethod(_print_ps, \"eps\")\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()",
      "instance_attributes": [
        {
          "name": "_pswriter",
          "types": {
            "kind": "NamedType",
            "name": "StringIO"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper",
      "name": "PsBackendHelper",
      "qname": "lib.matplotlib.backends.backend_ps.PsBackendHelper",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper/__init__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class PsBackendHelper:\n    def __init__(self):\n        self._cached = {}",
      "instance_attributes": [
        {
          "name": "_cached",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS",
      "name": "RendererPS",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS",
      "decorators": [],
      "superclasses": [
        "_backend_pdf_ps.RendererPDFPSBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_is_transparent",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_linejoin_cmd",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_linecap_cmd",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/get_image_magnification",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_convert_path",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_get_clip_cmd",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_draw_ps"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.",
      "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.",
      "code": "class RendererPS(_backend_pdf_ps.RendererPDFPSBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles.\n    \"\"\"\n\n    _afm_font_dir = cbook._get_data_path(\"fonts/afm\")\n    _use_afm_rc_name = \"ps.useafm\"\n\n    def __init__(self, width, height, pswriter, imagedpi=72):\n        # Although postscript itself is dpi independent, we need to inform the\n        # image code about a requested dpi to generate high resolution images\n        # and them scale them before embedding them.\n        super().__init__(width, height)\n        self._pswriter = pswriter\n        if mpl.rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi / 72\n        self._clip_paths = {}\n        self._path_collection_id = 0\n\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n        self._logwarn_once = functools.lru_cache(None)(_log.warning)\n\n    def _is_transparent(self, rgb_or_rgba):\n        if rgb_or_rgba is None:\n            return True  # Consistent with rgbFace semantics.\n        elif len(rgb_or_rgba) == 4:\n            if rgb_or_rgba[3] == 0:\n                return True\n            if rgb_or_rgba[3] != 1:\n                self._logwarn_once(\n                    \"The PostScript backend does not support transparency; \"\n                    \"partially transparent artists will be rendered opaque.\")\n            return False\n        else:  # len() == 3.\n            return False\n\n    def set_color(self, r, g, b, store=True):\n        if (r, g, b) != self.color:\n            self._pswriter.write(f\"{r:1.3f} setgray\\n\"\n                                 if r == g == b else\n                                 f\"{r:1.3f} {g:1.3f} {b:1.3f} setrgbcolor\\n\")\n            if store:\n                self.color = (r, g, b)\n\n    def set_linewidth(self, linewidth, store=True):\n        linewidth = float(linewidth)\n        if linewidth != self.linewidth:\n            self._pswriter.write(\"%1.3f setlinewidth\\n\" % linewidth)\n            if store:\n                self.linewidth = linewidth\n\n    @staticmethod\n    def _linejoin_cmd(linejoin):\n        # Support for directly passing integer values is for backcompat.\n        linejoin = {'miter': 0, 'round': 1, 'bevel': 2, 0: 0, 1: 1, 2: 2}[\n            linejoin]\n        return f\"{linejoin:d} setlinejoin\\n\"\n\n    def set_linejoin(self, linejoin, store=True):\n        if linejoin != self.linejoin:\n            self._pswriter.write(self._linejoin_cmd(linejoin))\n            if store:\n                self.linejoin = linejoin\n\n    @staticmethod\n    def _linecap_cmd(linecap):\n        # Support for directly passing integer values is for backcompat.\n        linecap = {'butt': 0, 'round': 1, 'projecting': 2, 0: 0, 1: 1, 2: 2}[\n            linecap]\n        return f\"{linecap:d} setlinecap\\n\"\n\n    def set_linecap(self, linecap, store=True):\n        if linecap != self.linecap:\n            self._pswriter.write(self._linecap_cmd(linecap))\n            if store:\n                self.linecap = linecap\n\n    def set_linedash(self, offset, seq, store=True):\n        if self.linedash is not None:\n            oldo, oldseq = self.linedash\n            if np.array_equal(seq, oldseq) and oldo == offset:\n                return\n\n        self._pswriter.write(f\"[{_nums_to_str(*seq)}]\"\n                             f\" {_nums_to_str(offset)} setdash\\n\"\n                             if seq is not None and len(seq) else\n                             \"[] 0 setdash\\n\")\n        if store:\n            self.linedash = (offset, seq)\n\n    def set_font(self, fontname, fontsize, store=True):\n        if (fontname, fontsize) != (self.fontname, self.fontsize):\n            self._pswriter.write(f\"/{fontname} {fontsize:1.3f} selectfont\\n\")\n            if store:\n                self.fontname = fontname\n                self.fontsize = fontsize\n\n    def create_hatch(self, hatch):\n        sidelen = 72\n        if hatch in self._hatches:\n            return self._hatches[hatch]\n        name = 'H%d' % len(self._hatches)\n        linewidth = mpl.rcParams['hatch.linewidth']\n        pageheight = self.height * 72\n        self._pswriter.write(f\"\"\"\\\n  << /PatternType 1\n     /PaintType 2\n     /TilingType 2\n     /BBox[0 0 {sidelen:d} {sidelen:d}]\n     /XStep {sidelen:d}\n     /YStep {sidelen:d}\n\n     /PaintProc {{\n        pop\n        {linewidth:g} setlinewidth\n{self._convert_path(\n    Path.hatch(hatch), Affine2D().scale(sidelen), simplify=False)}\n        gsave\n        fill\n        grestore\n        stroke\n     }} bind\n   >>\n   matrix\n   0 {pageheight:g} translate\n   makepattern\n   /{name} exch def\n\"\"\")\n        self._hatches[hatch] = name\n        return name\n\n    def get_image_magnification(self):\n        \"\"\"\n        Get the factor by which to magnify images passed to draw_image.\n        Allows a backend to have images at a different resolution to other\n        artists.\n        \"\"\"\n        return self.image_magnification\n\n    def _convert_path(self, path, transform, clip=False, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0, self.height * 72.0)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, None,\n            6, [b\"m\", b\"l\", b\"\", b\"c\", b\"cl\"], True).decode(\"ascii\")\n\n    def _get_clip_cmd(self, gc):\n        clip = []\n        rect = gc.get_clip_rectangle()\n        if rect is not None:\n            clip.append(\"%s clipbox\\n\" % _nums_to_str(*rect.size, *rect.p0))\n        path, trf = gc.get_clip_path()\n        if path is not None:\n            key = (path, id(trf))\n            custom_clip_cmd = self._clip_paths.get(key)\n            if custom_clip_cmd is None:\n                custom_clip_cmd = \"c%d\" % len(self._clip_paths)\n                self._pswriter.write(f\"\"\"\\\n/{custom_clip_cmd} {{\n{self._convert_path(path, trf, simplify=False)}\nclip\nnewpath\n}} bind def\n\"\"\")\n                self._clip_paths[key] = custom_clip_cmd\n            clip.append(f\"{custom_clip_cmd}\\n\")\n        return \"\".join(clip)\n\n    @_log_if_debug_on\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n[{matrix}] concat\n{xscale:g} {yscale:g} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataString readhexstring pop\n}} bind {imagecmd}\n{hexdata}\ngrestore\n\"\"\")\n\n    @_log_if_debug_on\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        clip = rgbFace is None and gc.get_hatch_path() is None\n        simplify = path.should_simplify and clip\n        ps = self._convert_path(path, transform, clip=clip, simplify=simplify)\n        self._draw_ps(ps, gc, rgbFace)\n\n    @_log_if_debug_on\n    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        ps_color = (\n            None\n            if self._is_transparent(rgbFace)\n            else '%1.3f setgray' % rgbFace[0]\n            if rgbFace[0] == rgbFace[1] == rgbFace[2]\n            else '%1.3f %1.3f %1.3f setrgbcolor' % rgbFace[:3])\n\n        # construct the generic marker command:\n\n        # don't want the translate to be global\n        ps_cmd = ['/o {', 'gsave', 'newpath', 'translate']\n\n        lw = gc.get_linewidth()\n        alpha = (gc.get_alpha()\n                 if gc.get_forced_alpha() or len(gc.get_rgb()) == 3\n                 else gc.get_rgb()[3])\n        stroke = lw > 0 and alpha > 0\n        if stroke:\n            ps_cmd.append('%.1f setlinewidth' % lw)\n            ps_cmd.append(self._linejoin_cmd(gc.get_joinstyle()))\n            ps_cmd.append(self._linecap_cmd(gc.get_capstyle()))\n\n        ps_cmd.append(self._convert_path(marker_path, marker_trans,\n                                         simplify=False))\n\n        if rgbFace:\n            if stroke:\n                ps_cmd.append('gsave')\n            if ps_color:\n                ps_cmd.extend([ps_color, 'fill'])\n            if stroke:\n                ps_cmd.append('grestore')\n\n        if stroke:\n            ps_cmd.append('stroke')\n        ps_cmd.extend(['grestore', '} bind def'])\n\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.width*72, self.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ps_cmd.append(\"%g %g o\" % (x, y))\n\n        ps = '\\n'.join(ps_cmd)\n        self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False)\n\n    @_log_if_debug_on\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #     (len_path + 2) * uses_per_path\n        # cost of definition+use is\n        #     (len_path + 3) + 3 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 3 * uses_per_path + 3 < (len_path + 2) * uses_per_path\n        if not should_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = 'p%d_%d' % (self._path_collection_id, i)\n            path_bytes = self._convert_path(path, transform, simplify=False)\n            self._pswriter.write(f\"\"\"\\\n/{name} {{\nnewpath\ntranslate\n{path_bytes}\n}} bind def\n\"\"\")\n            path_codes.append(name)\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            ps = \"%g %g %s\" % (xo, yo, path_id)\n            self._draw_ps(ps, gc0, rgbFace)\n\n        self._path_collection_id += 1\n\n    @_log_if_debug_on\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if not hasattr(self, \"psfrag\"):\n            self._logwarn_once(\n                \"The PS backend determines usetex status solely based on \"\n                \"rcParams['text.usetex'] and does not support having \"\n                \"usetex=True only for some elements; this element will thus \"\n                \"be rendered as if usetex=False.\")\n            self.draw_text(gc, x, y, s, prop, angle, False, mtext)\n            return\n\n        w, h, bl = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        fontsize = prop.get_size_in_points()\n        thetext = 'psmarker%d' % self.textcnt\n        color = '%1.3f,%1.3f,%1.3f' % gc.get_rgb()[:3]\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(\n                       mpl.rcParams['font.family'][0], r'{\\rmfamily %s}')\n        s = fontcmd % s\n        tex = r'\\color[rgb]{%s} %s' % (color, s)\n\n        # Stick to the bottom alignment.\n        pos = _nums_to_str(x, y-bl)\n        self.psfrag.append(\n            r'\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                thetext, angle, fontsize, fontsize*1.25, tex))\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{pos} moveto\n({thetext})\nshow\ngrestore\n\"\"\")\n        self.textcnt += 1\n\n    @_log_if_debug_on\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if ismath == 'TeX':\n            return self.draw_tex(gc, x, y, s, prop, angle)\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        if mpl.rcParams['ps.useafm']:\n            font = self._get_font_afm(prop)\n            scale = 0.001 * prop.get_size_in_points()\n            stream = []\n            thisx = 0\n            last_name = None  # kerns returns 0 for None.\n            xs_names = []\n            for c in s:\n                name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char('?')\n                kern = font.get_kern_dist_from_name(last_name, name)\n                last_name = name\n                thisx += kern * scale\n                xs_names.append((thisx, name))\n                thisx += width * scale\n            ps_name = (font.postscript_name\n                       .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n            stream.append((ps_name, xs_names))\n\n        else:\n            font = self._get_font_ttf(prop)\n            self._character_tracker.track(font, s)\n            stream = []\n            prev_font = curr_stream = None\n            for item in _text_helpers.layout(s, font):\n                ps_name = (item.ft_object.postscript_name\n                           .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n                if item.ft_object is not prev_font:\n                    if curr_stream:\n                        stream.append(curr_stream)\n                    prev_font = item.ft_object\n                    curr_stream = [ps_name, []]\n                curr_stream[1].append(\n                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                )\n            # append the last entry\n            stream.append(curr_stream)\n\n        self.set_color(*gc.get_rgb())\n\n        for ps_name, xs_names in stream:\n            self.set_font(ps_name, prop.get_size_in_points(), False)\n            thetext = \"\\n\".join(f\"{x:g} 0 m /{name:s} glyphshow\"\n                                for x, name in xs_names)\n            self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n{angle:g} rotate\n{thetext}\ngrestore\n\"\"\")\n\n    @_log_if_debug_on\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw the math text using matplotlib.mathtext.\"\"\"\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n        self.set_color(*gc.get_rgb())\n        self._pswriter.write(\n            f\"gsave\\n\"\n            f\"{x:g} {y:g} translate\\n\"\n            f\"{angle:g} rotate\\n\")\n        lastfont = None\n        for font, fontsize, num, ox, oy in glyphs:\n            self._character_tracker.track_glyph(font, num)\n            if (font.postscript_name, fontsize) != lastfont:\n                lastfont = font.postscript_name, fontsize\n                self._pswriter.write(\n                    f\"/{font.postscript_name} {fontsize} selectfont\\n\")\n            glyph_name = (\n                font.get_name_char(chr(num)) if isinstance(font, AFM) else\n                font.get_glyph_name(font.get_char_index(num)))\n            self._pswriter.write(\n                f\"{ox:g} {oy:g} moveto\\n\"\n                f\"/{glyph_name} glyphshow\\n\")\n        for ox, oy, w, h in rects:\n            self._pswriter.write(f\"{ox} {oy} {w} {h} rectfill\\n\")\n        self._pswriter.write(\"grestore\\n\")\n\n    @_log_if_debug_on\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)\n\n    @_log_if_debug_on\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] == 4\n\n        shape = points.shape\n        flat_points = points.reshape((shape[0] * shape[1], 2))\n        flat_points = trans.transform(flat_points)\n        flat_colors = colors.reshape((shape[0] * shape[1], 4))\n        points_min = np.min(flat_points, axis=0) - (1 << 12)\n        points_max = np.max(flat_points, axis=0) + (1 << 12)\n        factor = np.ceil((2 ** 32 - 1) / (points_max - points_min))\n\n        xmin, ymin = points_min\n        xmax, ymax = points_max\n\n        data = np.empty(\n            shape[0] * shape[1],\n            dtype=[('flags', 'u1'), ('points', '2>u4'), ('colors', '3u1')])\n        data['flags'] = 0\n        data['points'] = (flat_points - points_min) * factor\n        data['colors'] = flat_colors[:, :3] * 255.0\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n<< /ShadingType 4\n   /ColorSpace [/DeviceRGB]\n   /BitsPerCoordinate 32\n   /BitsPerComponent 8\n   /BitsPerFlag 8\n   /AntiAlias true\n   /Decode [ {xmin:g} {xmax:g} {ymin:g} {ymax:g} 0 1 0 1 0 1 ]\n   /DataSource <\n{hexdata}\n>\n>>\nshfill\ngrestore\n\"\"\")\n\n    def _draw_ps(self, ps, gc, rgbFace, *, fill=True, stroke=True):\n        \"\"\"\n        Emit the PostScript snippet *ps* with all the attributes from *gc*\n        applied.  *ps* must consist of PostScript commands to construct a path.\n\n        The *fill* and/or *stroke* kwargs can be set to False if the *ps*\n        string already includes filling and/or stroking, in which case\n        `_draw_ps` is just supplying properties and clipping.\n        \"\"\"\n        write = self._pswriter.write\n        mightstroke = (gc.get_linewidth() > 0\n                       and not self._is_transparent(gc.get_rgb()))\n        if not mightstroke:\n            stroke = False\n        if self._is_transparent(rgbFace):\n            fill = False\n        hatch = gc.get_hatch()\n\n        if mightstroke:\n            self.set_linewidth(gc.get_linewidth())\n            self.set_linejoin(gc.get_joinstyle())\n            self.set_linecap(gc.get_capstyle())\n            self.set_linedash(*gc.get_dashes())\n        if mightstroke or hatch:\n            self.set_color(*gc.get_rgb()[:3])\n        write('gsave\\n')\n\n        write(self._get_clip_cmd(gc))\n\n        write(ps.strip())\n        write(\"\\n\")\n\n        if fill:\n            if stroke or hatch:\n                write(\"gsave\\n\")\n            self.set_color(*rgbFace[:3], store=False)\n            write(\"fill\\n\")\n            if stroke or hatch:\n                write(\"grestore\\n\")\n\n        if hatch:\n            hatch_name = self.create_hatch(hatch)\n            write(\"gsave\\n\")\n            write(\"%f %f %f \" % gc.get_hatch_color()[:3])\n            write(\"%s setpattern fill grestore\\n\" % hatch_name)\n\n        if stroke:\n            write(\"stroke\\n\")\n\n        write(\"grestore\\n\")",
      "instance_attributes": [
        {
          "name": "_pswriter",
          "types": null
        },
        {
          "name": "textcnt",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "psfrag",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "imagedpi",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "color",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "linewidth",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "linejoin",
          "types": null
        },
        {
          "name": "linecap",
          "types": null
        },
        {
          "name": "linedash",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "fontname",
          "types": null
        },
        {
          "name": "fontsize",
          "types": null
        },
        {
          "name": "_hatches",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "image_magnification",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "_clip_paths",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_path_collection_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_character_tracker",
          "types": null
        },
        {
          "name": "_logwarn_once",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt",
      "name": "ConfigureSubplotsQt",
      "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.ConfigureSubplotsBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConfigureSubplotsQt(backend_tools.ConfigureSubplotsBase):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._subplot_dialog = None\n\n    def trigger(self, *args):\n        NavigationToolbar2QT.configure_subplots(self)",
      "instance_attributes": [
        {
          "name": "_subplot_dialog",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT",
      "name": "FigureCanvasQT",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase",
        "QtWidgets.QWidget"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/_update_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/_update_screen",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/showEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseEventCoords",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/enterEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/leaveEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mousePressEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseDoubleClickEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseMoveEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseReleaseEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/wheelEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyPressEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyReleaseEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/resizeEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/sizeHint",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/minumumSizeHint",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/_get_key",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/flush_events",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/start_event_loop",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/stop_event_loop",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/blit",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/_draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/drawRectangle"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasQT(FigureCanvasBase, QtWidgets.QWidget):\n    required_interactive_framework = \"qt\"\n    _timer_cls = TimerQT\n    manager_class = _api.classproperty(lambda cls: FigureManagerQT)\n\n    buttond = {\n        getattr(_enum(\"QtCore.Qt.MouseButton\"), k): v for k, v in [\n            (\"LeftButton\", MouseButton.LEFT),\n            (\"RightButton\", MouseButton.RIGHT),\n            (\"MiddleButton\", MouseButton.MIDDLE),\n            (\"XButton1\", MouseButton.BACK),\n            (\"XButton2\", MouseButton.FORWARD),\n        ]\n    }\n\n    def __init__(self, figure=None):\n        _create_qApp()\n        super().__init__(figure=figure)\n\n        self._draw_pending = False\n        self._is_drawing = False\n        self._draw_rect_callback = lambda painter: None\n        self._in_resize_event = False\n\n        self.setAttribute(\n            _enum(\"QtCore.Qt.WidgetAttribute\").WA_OpaquePaintEvent)\n        self.setMouseTracking(True)\n        self.resize(*self.get_width_height())\n\n        palette = QtGui.QPalette(QtGui.QColor(\"white\"))\n        self.setPalette(palette)\n\n    def _update_pixel_ratio(self):\n        if self._set_device_pixel_ratio(_devicePixelRatioF(self)):\n            # The easiest way to resize the canvas is to emit a resizeEvent\n            # since we implement all the logic for resizing the canvas for\n            # that event.\n            event = QtGui.QResizeEvent(self.size(), self.size())\n            self.resizeEvent(event)\n\n    def _update_screen(self, screen):\n        # Handler for changes to a window's attached screen.\n        self._update_pixel_ratio()\n        if screen is not None:\n            screen.physicalDotsPerInchChanged.connect(self._update_pixel_ratio)\n            screen.logicalDotsPerInchChanged.connect(self._update_pixel_ratio)\n\n    def showEvent(self, event):\n        # Set up correct pixel ratio, and connect to any signal changes for it,\n        # once the window is shown (and thus has these attributes).\n        window = self.window().windowHandle()\n        window.screenChanged.connect(self._update_screen)\n        self._update_screen(window.screen())\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        self.setCursor(_api.check_getitem(cursord, cursor=cursor))\n\n    def mouseEventCoords(self, pos=None):\n        \"\"\"\n        Calculate mouse coordinates in physical pixels.\n\n        Qt uses logical pixels, but the figure is scaled to physical\n        pixels for rendering.  Transform to physical pixels so that\n        all of the down-stream transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        if pos is None:\n            pos = self.mapFromGlobal(QtGui.QCursor.pos())\n        elif hasattr(pos, \"position\"):  # qt6 QtGui.QEvent\n            pos = pos.position()\n        elif hasattr(pos, \"pos\"):  # qt5 QtCore.QEvent\n            pos = pos.pos()\n        # (otherwise, it's already a QPoint)\n        x = pos.x()\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height / self.device_pixel_ratio - pos.y()\n        return x * self.device_pixel_ratio, y * self.device_pixel_ratio\n\n    def enterEvent(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self.mouseEventCoords(event),\n                      guiEvent=event)._process()\n\n    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        LocationEvent(\"figure_leave_event\", self,\n                      *self.mouseEventCoords(),\n                      guiEvent=event)._process()\n\n    def mousePressEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       guiEvent=event)._process()\n\n    def mouseDoubleClickEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       guiEvent=event)._process()\n\n    def mouseMoveEvent(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   guiEvent=event)._process()\n\n    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       guiEvent=event)._process()\n\n    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is sometimes not\n        # provided (`isNull()`) and is unreliable on X11 (\"xcb\").\n        if (event.pixelDelta().isNull()\n                or QtWidgets.QApplication.instance().platformName() == \"xcb\"):\n            steps = event.angleDelta().y() / 120\n        else:\n            steps = event.pixelDelta().y()\n        if steps:\n            MouseEvent(\"scroll_event\", self,\n                       *self.mouseEventCoords(event), step=steps,\n                       guiEvent=event)._process()\n\n    def keyPressEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            KeyEvent(\"key_press_event\", self,\n                     key, *self.mouseEventCoords(),\n                     guiEvent=event)._process()\n\n    def keyReleaseEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            KeyEvent(\"key_release_event\", self,\n                     key, *self.mouseEventCoords(),\n                     guiEvent=event)._process()\n\n    def resizeEvent(self, event):\n        if self._in_resize_event:  # Prevent PyQt6 recursion\n            return\n        self._in_resize_event = True\n        try:\n            w = event.size().width() * self.device_pixel_ratio\n            h = event.size().height() * self.device_pixel_ratio\n            dpival = self.figure.dpi\n            winch = w / dpival\n            hinch = h / dpival\n            self.figure.set_size_inches(winch, hinch, forward=False)\n            # pass back into Qt to let it finish\n            QtWidgets.QWidget.resizeEvent(self, event)\n            # emit our resize events\n            ResizeEvent(\"resize_event\", self)._process()\n            self.draw_idle()\n        finally:\n            self._in_resize_event = False\n\n    def sizeHint(self):\n        w, h = self.get_width_height()\n        return QtCore.QSize(w, h)\n\n    def minumumSizeHint(self):\n        return QtCore.QSize(10, 10)\n\n    def _get_key(self, event):\n        event_key = event.key()\n        event_mods = _to_int(event.modifiers())  # actually a bitmask\n\n        # get names of the pressed modifier keys\n        # 'control' is named 'control' when a standalone key, but 'ctrl' when a\n        # modifier\n        # bit twiddling to pick out modifier keys from event_mods bitmask,\n        # if event_key is a MODIFIER, it should not be duplicated in mods\n        mods = [SPECIAL_KEYS[key].replace('control', 'ctrl')\n                for mod, key in _MODIFIER_KEYS\n                if event_key != key and event_mods & mod]\n        try:\n            # for certain keys (enter, left, backspace, etc) use a word for the\n            # key, rather than Unicode\n            key = SPECIAL_KEYS[event_key]\n        except KeyError:\n            # Unicode defines code points up to 0x10ffff (sys.maxunicode)\n            # QT will use Key_Codes larger than that for keyboard keys that are\n            # are not Unicode characters (like multimedia keys)\n            # skip these\n            # if you really want them, you should add them to SPECIAL_KEYS\n            if event_key > sys.maxunicode:\n                return None\n\n            key = chr(event_key)\n            # qt delivers capitalized letters.  fix capitalization\n            # note that capslock is ignored\n            if 'shift' in mods:\n                mods.remove('shift')\n            else:\n                key = key.lower()\n\n        return '+'.join(mods + [key])\n\n    def flush_events(self):\n        # docstring inherited\n        QtWidgets.QApplication.instance().processEvents()\n\n    def start_event_loop(self, timeout=0):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\") and self._event_loop.isRunning():\n            raise RuntimeError(\"Event loop already running\")\n        self._event_loop = event_loop = QtCore.QEventLoop()\n        if timeout > 0:\n            _ = QtCore.QTimer.singleShot(int(timeout * 1000), event_loop.quit)\n\n        with _maybe_allow_interrupt(event_loop):\n            qt_compat._exec(event_loop)\n\n    def stop_event_loop(self, event=None):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\"):\n            self._event_loop.quit()\n\n    def draw(self):\n        \"\"\"Render the figure, and queue a request for a Qt draw.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()\n\n    def draw_idle(self):\n        \"\"\"Queue redraw of the Agg buffer and request Qt paintEvent.\"\"\"\n        # The Agg draw needs to be handled by the same thread Matplotlib\n        # modifies the scene graph from. Post Agg draw request to the\n        # current event loop in order to ensure thread affinity and to\n        # accumulate multiple draw requests from event handling.\n        # TODO: queued signal connection might be safer than singleShot\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            QtCore.QTimer.singleShot(0, self._draw_idle)\n\n    def blit(self, bbox=None):\n        # docstring inherited\n        if bbox is None and self.figure:\n            bbox = self.figure.bbox  # Blit the entire canvas if bbox is None.\n        # repaint uses logical pixels, not physical pixels like the renderer.\n        l, b, w, h = [int(pt / self.device_pixel_ratio) for pt in bbox.bounds]\n        t = b + h\n        self.repaint(l, self.rect().height() - t, w, h)\n\n    def _draw_idle(self):\n        with self._idle_draw_cntx():\n            if not self._draw_pending:\n                return\n            self._draw_pending = False\n            if self.height() < 0 or self.width() < 0:\n                return\n            try:\n                self.draw()\n            except Exception:\n                # Uncaught exceptions are fatal for PyQt5, so catch them.\n                traceback.print_exc()\n\n    def drawRectangle(self, rect):\n        # Draw the zoom rectangle to the QPainter.  _draw_rect_callback needs\n        # to be called at the end of paintEvent.\n        if rect is not None:\n            x0, y0, w, h = [int(pt / self.device_pixel_ratio) for pt in rect]\n            x1 = x0 + w\n            y1 = y0 + h\n            def _draw_rect_callback(painter):\n                pen = QtGui.QPen(\n                    QtGui.QColor(\"black\"),\n                    1 / self.device_pixel_ratio\n                )\n\n                pen.setDashPattern([3, 3])\n                for color, offset in [\n                        (QtGui.QColor(\"black\"), 0),\n                        (QtGui.QColor(\"white\"), 3),\n                ]:\n                    pen.setDashOffset(offset)\n                    pen.setColor(color)\n                    painter.setPen(pen)\n                    # Draw the lines from x0, y0 towards x1, y1 so that the\n                    # dashes don't \"jump\" when moving the zoom box.\n                    painter.drawLine(x0, y0, x0, y1)\n                    painter.drawLine(x0, y0, x1, y0)\n                    painter.drawLine(x0, y1, x1, y1)\n                    painter.drawLine(x1, y0, x1, y1)\n        else:\n            def _draw_rect_callback(painter):\n                return\n        self._draw_rect_callback = _draw_rect_callback\n        self.update()",
      "instance_attributes": [
        {
          "name": "_draw_pending",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_is_drawing",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_draw_rect_callback",
          "types": {
            "kind": "NamedType",
            "name": "Callable"
          }
        },
        {
          "name": "_in_resize_event",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_event_loop",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT",
      "name": "FigureManagerQT",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/full_screen_toggle",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/_widgetclosed",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/show",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/destroy",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/get_window_title",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/set_window_title"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Attributes\n----------\ncanvas : `FigureCanvas`\n    The FigureCanvas instance\nnum : int or str\n    The Figure number\ntoolbar : qt.QToolBar\n    The qt.QToolBar\nwindow : qt.QMainWindow\n    The qt.QMainWindow",
      "code": "class FigureManagerQT(FigureManagerBase):\n    \"\"\"\n    Attributes\n    ----------\n    canvas : `FigureCanvas`\n        The FigureCanvas instance\n    num : int or str\n        The Figure number\n    toolbar : qt.QToolBar\n        The qt.QToolBar\n    window : qt.QMainWindow\n        The qt.QMainWindow\n    \"\"\"\n\n    def __init__(self, canvas, num):\n        self.window = MainWindow()\n        super().__init__(canvas, num)\n        self.window.closing.connect(\n            # The lambda prevents the event from being immediately gc'd.\n            lambda: CloseEvent(\"close_event\", self.canvas)._process())\n        self.window.closing.connect(self._widgetclosed)\n\n        if sys.platform != \"darwin\":\n            image = str(cbook._get_data_path('images/matplotlib.svg'))\n            icon = QtGui.QIcon(image)\n            self.window.setWindowIcon(icon)\n\n        self.window._destroying = False\n\n        if self.toolbar:\n            self.window.addToolBar(self.toolbar)\n            tbs_height = self.toolbar.sizeHint().height()\n        else:\n            tbs_height = 0\n\n        # resize the main window so it will display the canvas with the\n        # requested size:\n        cs = canvas.sizeHint()\n        cs_height = cs.height()\n        height = cs_height + tbs_height\n        self.window.resize(cs.width(), height)\n\n        self.window.setCentralWidget(self.canvas)\n\n        if mpl.is_interactive():\n            self.window.show()\n            self.canvas.draw_idle()\n\n        # Give the keyboard focus to the figure instead of the manager:\n        # StrongFocus accepts both tab and click to focus and will enable the\n        # canvas to process event without clicking.\n        # https://doc.qt.io/qt-5/qt.html#FocusPolicy-enum\n        self.canvas.setFocusPolicy(_enum(\"QtCore.Qt.FocusPolicy\").StrongFocus)\n        self.canvas.setFocus()\n\n        self.window.raise_()\n\n    def full_screen_toggle(self):\n        if self.window.isFullScreen():\n            self.window.showNormal()\n        else:\n            self.window.showFullScreen()\n\n    def _widgetclosed(self):\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        try:\n            Gcf.destroy(self)\n        except AttributeError:\n            pass\n            # It seems that when the python session is killed,\n            # Gcf can get destroyed before the Gcf.destroy\n            # line is run, leading to a useless AttributeError.\n\n    def resize(self, width, height):\n        # The Qt methods return sizes in 'virtual' pixels so we do need to\n        # rescale from physical to logical pixels.\n        width = int(width / self.canvas.device_pixel_ratio)\n        height = int(height / self.canvas.device_pixel_ratio)\n        extra_width = self.window.width() - self.canvas.width()\n        extra_height = self.window.height() - self.canvas.height()\n        self.canvas.resize(width, height)\n        self.window.resize(width + extra_width, height + extra_height)\n\n    def show(self):\n        self.window.show()\n        if mpl.rcParams['figure.raise_window']:\n            self.window.activateWindow()\n            self.window.raise_()\n\n    def destroy(self, *args):\n        # check for qApp first, as PySide deletes it in its atexit handler\n        if QtWidgets.QApplication.instance() is None:\n            return\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        if self.toolbar:\n            self.toolbar.destroy()\n        self.window.close()\n\n    def get_window_title(self):\n        return self.window.windowTitle()\n\n    def set_window_title(self, title):\n        self.window.setWindowTitle(title)",
      "instance_attributes": [
        {
          "name": "window",
          "types": {
            "kind": "NamedType",
            "name": "MainWindow"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt",
      "name": "HelpQt",
      "qname": "lib.matplotlib.backends.backend_qt.HelpQt",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpQt(backend_tools.ToolHelpBase):\n    def trigger(self, *args):\n        QtWidgets.QMessageBox.information(None, \"Help\", self._get_help_html())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow",
      "name": "MainWindow",
      "qname": "lib.matplotlib.backends.backend_qt.MainWindow",
      "decorators": [],
      "superclasses": [
        "QtWidgets.QMainWindow"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow/closeEvent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class MainWindow(QtWidgets.QMainWindow):\n    closing = QtCore.Signal()\n\n    def closeEvent(self, event):\n        self.closing.emit()\n        super().closeEvent(event)",
      "instance_attributes": [
        {
          "name": "_destroying",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT",
      "name": "NavigationToolbar2QT",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2",
        "QtWidgets.QToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/_icon",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/edit_parameters",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/_update_buttons_checked",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/pan",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/zoom",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_message",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/configure_subplots",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):\n    message = QtCore.Signal(str)\n\n    toolitems = [*NavigationToolbar2.toolitems]\n    toolitems.insert(\n        # Add 'customize' action after 'subplots'\n        [name for name, *_ in toolitems].index(\"Subplots\") + 1,\n        (\"Customize\", \"Edit axis, curve and image parameters\",\n         \"qt4_editor_options\", \"edit_parameters\"))\n\n    def __init__(self, canvas, parent=None, coordinates=True):\n        \"\"\"coordinates: should we show the coordinates on the right?\"\"\"\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(QtCore.Qt.ToolBarArea(\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").TopToolBarArea) |\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").BottomToolBarArea)))\n\n        self.coordinates = coordinates\n        self._actions = {}  # mapping of toolitem method names to QActions.\n        self._subplot_dialog = None\n\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.addSeparator()\n            else:\n                a = self.addAction(self._icon(image_file + '.png'),\n                                   text, getattr(self, callback))\n                self._actions[callback] = a\n                if callback in ['zoom', 'pan']:\n                    a.setCheckable(True)\n                if tooltip_text is not None:\n                    a.setToolTip(tooltip_text)\n\n        # Add the (x, y) location widget at the right side of the toolbar\n        # The stretch factor is 1 which means any resizing of the toolbar\n        # will resize this label instead of the buttons.\n        if self.coordinates:\n            self.locLabel = QtWidgets.QLabel(\"\", self)\n            self.locLabel.setAlignment(QtCore.Qt.AlignmentFlag(\n                _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignRight) |\n                _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignVCenter)))\n            self.locLabel.setSizePolicy(QtWidgets.QSizePolicy(\n                _enum(\"QtWidgets.QSizePolicy.Policy\").Expanding,\n                _enum(\"QtWidgets.QSizePolicy.Policy\").Ignored,\n            ))\n            labelAction = self.addWidget(self.locLabel)\n            labelAction.setVisible(True)\n\n        NavigationToolbar2.__init__(self, canvas)\n\n    def _icon(self, name):\n        \"\"\"\n        Construct a `.QIcon` from an image file *name*, including the extension\n        and relative to Matplotlib's \"images\" data directory.\n        \"\"\"\n        # use a high-resolution icon with suffix '_large' if available\n        # note: user-provided icons may not have '_large' versions\n        path_regular = cbook._get_data_path('images', name)\n        path_large = path_regular.with_name(\n            path_regular.name.replace('.png', '_large.png'))\n        filename = str(path_large if path_large.exists() else path_regular)\n\n        pm = QtGui.QPixmap(filename)\n        _setDevicePixelRatio(pm, _devicePixelRatioF(self))\n        if self.palette().color(self.backgroundRole()).value() < 128:\n            icon_color = self.palette().color(self.foregroundRole())\n            mask = pm.createMaskFromColor(\n                QtGui.QColor('black'),\n                _enum(\"QtCore.Qt.MaskMode\").MaskOutColor)\n            pm.fill(icon_color)\n            pm.setMask(mask)\n        return QtGui.QIcon(pm)\n\n    def edit_parameters(self):\n        axes = self.canvas.figure.get_axes()\n        if not axes:\n            QtWidgets.QMessageBox.warning(\n                self.canvas.parent(), \"Error\", \"There are no axes to edit.\")\n            return\n        elif len(axes) == 1:\n            ax, = axes\n        else:\n            titles = [\n                ax.get_label() or\n                ax.get_title() or\n                ax.get_title(\"left\") or\n                ax.get_title(\"right\") or\n                \" - \".join(filter(None, [ax.get_xlabel(), ax.get_ylabel()])) or\n                f\"<anonymous {type(ax).__name__}>\"\n                for ax in axes]\n            duplicate_titles = [\n                title for title in titles if titles.count(title) > 1]\n            for i, ax in enumerate(axes):\n                if titles[i] in duplicate_titles:\n                    titles[i] += f\" (id: {id(ax):#x})\"  # Deduplicate titles.\n            item, ok = QtWidgets.QInputDialog.getItem(\n                self.canvas.parent(),\n                'Customize', 'Select axes:', titles, 0, False)\n            if not ok:\n                return\n            ax = axes[titles.index(item)]\n        figureoptions.figure_edit(ax, self)\n\n    def _update_buttons_checked(self):\n        # sync button checkstates to match active mode\n        if 'pan' in self._actions:\n            self._actions['pan'].setChecked(self.mode.name == 'PAN')\n        if 'zoom' in self._actions:\n            self._actions['zoom'].setChecked(self.mode.name == 'ZOOM')\n\n    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()\n\n    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()\n\n    def set_message(self, s):\n        self.message.emit(s)\n        if self.coordinates:\n            self.locLabel.setText(s)\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas.drawRectangle(rect)\n\n    def remove_rubberband(self):\n        self.canvas.drawRectangle(None)\n\n    def configure_subplots(self):\n        if self._subplot_dialog is None:\n            self._subplot_dialog = SubplotToolQt(\n                self.canvas.figure, self.canvas.parent())\n            self.canvas.mpl_connect(\n                \"close_event\", lambda e: self._subplot_dialog.reject())\n        self._subplot_dialog.update_from_current_subplotpars()\n        self._subplot_dialog.show()\n        return self._subplot_dialog\n\n    def save_figure(self, *args):\n        filetypes = self.canvas.get_supported_filetypes_grouped()\n        sorted_filetypes = sorted(filetypes.items())\n        default_filetype = self.canvas.get_default_filetype()\n\n        startpath = os.path.expanduser(mpl.rcParams['savefig.directory'])\n        start = os.path.join(startpath, self.canvas.get_default_filename())\n        filters = []\n        selectedFilter = None\n        for name, exts in sorted_filetypes:\n            exts_list = \" \".join(['*.%s' % ext for ext in exts])\n            filter = '%s (%s)' % (name, exts_list)\n            if default_filetype in exts:\n                selectedFilter = filter\n            filters.append(filter)\n        filters = ';;'.join(filters)\n\n        fname, filter = qt_compat._getSaveFileName(\n            self.canvas.parent(), \"Choose a filename to save to\", start,\n            filters, selectedFilter)\n        if fname:\n            # Save dir for next time, unless empty str (i.e., use cwd).\n            if startpath != \"\":\n                mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n            try:\n                self.canvas.figure.savefig(fname)\n            except Exception as e:\n                QtWidgets.QMessageBox.critical(\n                    self, \"Error saving file\", str(e),\n                    _enum(\"QtWidgets.QMessageBox.StandardButton\").Ok,\n                    _enum(\"QtWidgets.QMessageBox.StandardButton\").NoButton)\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'back' in self._actions:\n            self._actions['back'].setEnabled(can_backward)\n        if 'forward' in self._actions:\n            self._actions['forward'].setEnabled(can_forward)",
      "instance_attributes": [
        {
          "name": "coordinates",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_actions",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_subplot_dialog",
          "types": {
            "kind": "NamedType",
            "name": "SubplotToolQt"
          }
        },
        {
          "name": "locLabel",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt",
      "name": "RubberbandQt",
      "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.RubberbandBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/remove_rubberband"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RubberbandQt(backend_tools.RubberbandBase):\n    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2QT.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)\n\n    def remove_rubberband(self):\n        NavigationToolbar2QT.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt",
      "name": "SaveFigureQt",
      "qname": "lib.matplotlib.backends.backend_qt.SaveFigureQt",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureQt(backend_tools.SaveFigureBase):\n    def trigger(self, *args):\n        NavigationToolbar2QT.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt",
      "name": "SetCursorQt",
      "qname": "lib.matplotlib.backends.backend_qt.SetCursorQt",
      "decorators": [
        "_api.deprecated('3.5', alternative='ToolSetCursor')"
      ],
      "superclasses": [
        "backend_tools.SetCursorBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt/set_cursor"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SetCursorQt(backend_tools.SetCursorBase):\n    def set_cursor(self, cursor):\n        NavigationToolbar2QT.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt",
      "name": "SubplotToolQt",
      "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt",
      "decorators": [],
      "superclasses": [
        "QtWidgets.QDialog"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/update_from_current_subplotpars",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/_export_values",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/_on_value_changed",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/_tight_layout",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/_reset"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SubplotToolQt(QtWidgets.QDialog):\n    def __init__(self, targetfig, parent):\n        super().__init__()\n        self.setWindowIcon(QtGui.QIcon(\n            str(cbook._get_data_path(\"images/matplotlib.png\"))))\n        self.setObjectName(\"SubplotTool\")\n        self._spinboxes = {}\n        main_layout = QtWidgets.QHBoxLayout()\n        self.setLayout(main_layout)\n        for group, spinboxes, buttons in [\n                (\"Borders\",\n                 [\"top\", \"bottom\", \"left\", \"right\"],\n                 [(\"Export values\", self._export_values)]),\n                (\"Spacings\",\n                 [\"hspace\", \"wspace\"],\n                 [(\"Tight layout\", self._tight_layout),\n                  (\"Reset\", self._reset),\n                  (\"Close\", self.close)])]:\n            layout = QtWidgets.QVBoxLayout()\n            main_layout.addLayout(layout)\n            box = QtWidgets.QGroupBox(group)\n            layout.addWidget(box)\n            inner = QtWidgets.QFormLayout(box)\n            for name in spinboxes:\n                self._spinboxes[name] = spinbox = QtWidgets.QDoubleSpinBox()\n                spinbox.setRange(0, 1)\n                spinbox.setDecimals(3)\n                spinbox.setSingleStep(0.005)\n                spinbox.setKeyboardTracking(False)\n                spinbox.valueChanged.connect(self._on_value_changed)\n                inner.addRow(name, spinbox)\n            layout.addStretch(1)\n            for name, method in buttons:\n                button = QtWidgets.QPushButton(name)\n                # Don't trigger on <enter>, which is used to input values.\n                button.setAutoDefault(False)\n                button.clicked.connect(method)\n                layout.addWidget(button)\n                if name == \"Close\":\n                    button.setFocus()\n        self._figure = targetfig\n        self._defaults = {}\n        self._export_values_dialog = None\n        self.update_from_current_subplotpars()\n\n    def update_from_current_subplotpars(self):\n        self._defaults = {spinbox: getattr(self._figure.subplotpars, name)\n                          for name, spinbox in self._spinboxes.items()}\n        self._reset()  # Set spinbox current values without triggering signals.\n\n    def _export_values(self):\n        # Explicitly round to 3 decimals (which is also the spinbox precision)\n        # to avoid numbers of the form 0.100...001.\n        self._export_values_dialog = QtWidgets.QDialog()\n        layout = QtWidgets.QVBoxLayout()\n        self._export_values_dialog.setLayout(layout)\n        text = QtWidgets.QPlainTextEdit()\n        text.setReadOnly(True)\n        layout.addWidget(text)\n        text.setPlainText(\n            \",\\n\".join(f\"{attr}={spinbox.value():.3}\"\n                       for attr, spinbox in self._spinboxes.items()))\n        # Adjust the height of the text widget to fit the whole text, plus\n        # some padding.\n        size = text.maximumSize()\n        size.setHeight(\n            QtGui.QFontMetrics(text.document().defaultFont())\n            .size(0, text.toPlainText()).height() + 20)\n        text.setMaximumSize(size)\n        self._export_values_dialog.show()\n\n    def _on_value_changed(self):\n        spinboxes = self._spinboxes\n        # Set all mins and maxes, so that this can also be used in _reset().\n        for lower, higher in [(\"bottom\", \"top\"), (\"left\", \"right\")]:\n            spinboxes[higher].setMinimum(spinboxes[lower].value() + .001)\n            spinboxes[lower].setMaximum(spinboxes[higher].value() - .001)\n        self._figure.subplots_adjust(\n            **{attr: spinbox.value() for attr, spinbox in spinboxes.items()})\n        self._figure.canvas.draw_idle()\n\n    def _tight_layout(self):\n        self._figure.tight_layout()\n        for attr, spinbox in self._spinboxes.items():\n            spinbox.blockSignals(True)\n            spinbox.setValue(vars(self._figure.subplotpars)[attr])\n            spinbox.blockSignals(False)\n        self._figure.canvas.draw_idle()\n\n    def _reset(self):\n        for spinbox, value in self._defaults.items():\n            spinbox.setRange(0, 1)\n            spinbox.blockSignals(True)\n            spinbox.setValue(value)\n            spinbox.blockSignals(False)\n        self._on_value_changed()",
      "instance_attributes": [
        {
          "name": "_spinboxes",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_figure",
          "types": null
        },
        {
          "name": "_defaults",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_export_values_dialog",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT",
      "name": "TimerQT",
      "qname": "lib.matplotlib.backends.backend_qt.TimerQT",
      "decorators": [],
      "superclasses": [
        "TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__del__",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/_timer_set_single_shot",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/_timer_set_interval",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/_timer_stop"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using QTimer events.",
      "docstring": "Subclass of `.TimerBase` using QTimer events.",
      "code": "class TimerQT(TimerBase):\n    \"\"\"Subclass of `.TimerBase` using QTimer events.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # Create a new timer and connect the timeout() signal to the\n        # _on_timer method.\n        self._timer = QtCore.QTimer()\n        self._timer.timeout.connect(self._on_timer)\n        super().__init__(*args, **kwargs)\n\n    def __del__(self):\n        # The check for deletedness is needed to avoid an error at animation\n        # shutdown with PySide2.\n        if not _isdeleted(self._timer):\n            self._timer_stop()\n\n    def _timer_set_single_shot(self):\n        self._timer.setSingleShot(self._single)\n\n    def _timer_set_interval(self):\n        self._timer.setInterval(self._interval)\n\n    def _timer_start(self):\n        self._timer.start()\n\n    def _timer_stop(self):\n        self._timer.stop()",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT",
      "name": "ToolCopyToClipboardQT",
      "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardQT(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        pixmap = self.canvas.grab()\n        QtWidgets.QApplication.instance().clipboard().setPixmap(pixmap)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt",
      "name": "ToolbarQt",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "QtWidgets.QToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/_add_to_group",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarQt(ToolContainerBase, QtWidgets.QToolBar):\n    def __init__(self, toolmanager, parent=None):\n        ToolContainerBase.__init__(self, toolmanager)\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(QtCore.Qt.ToolBarArea(\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").TopToolBarArea) |\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").BottomToolBarArea)))\n        message_label = QtWidgets.QLabel(\"\")\n        message_label.setAlignment(QtCore.Qt.AlignmentFlag(\n            _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignRight) |\n            _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignVCenter)))\n        message_label.setSizePolicy(QtWidgets.QSizePolicy(\n            _enum(\"QtWidgets.QSizePolicy.Policy\").Expanding,\n            _enum(\"QtWidgets.QSizePolicy.Policy\").Ignored,\n        ))\n        self._message_action = self.addWidget(message_label)\n        self._toolitems = {}\n        self._groups = {}\n\n    def add_toolitem(\n            self, name, group, position, image_file, description, toggle):\n\n        button = QtWidgets.QToolButton(self)\n        if image_file:\n            button.setIcon(NavigationToolbar2QT._icon(self, image_file))\n        button.setText(name)\n        if description:\n            button.setToolTip(description)\n\n        def handler():\n            self.trigger_tool(name)\n        if toggle:\n            button.setCheckable(True)\n            button.toggled.connect(handler)\n        else:\n            button.clicked.connect(handler)\n\n        self._toolitems.setdefault(name, [])\n        self._add_to_group(group, name, button, position)\n        self._toolitems[name].append((button, handler))\n\n    def _add_to_group(self, group, name, button, position):\n        gr = self._groups.get(group, [])\n        if not gr:\n            sep = self.insertSeparator(self._message_action)\n            gr.append(sep)\n        before = gr[position]\n        widget = self.insertWidget(before, button)\n        gr.insert(position, widget)\n        self._groups[group] = gr\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for button, handler in self._toolitems[name]:\n            button.toggled.disconnect(handler)\n            button.setChecked(toggled)\n            button.toggled.connect(handler)\n\n    def remove_toolitem(self, name):\n        for button, handler in self._toolitems[name]:\n            button.setParent(None)\n        del self._toolitems[name]\n\n    def set_message(self, s):\n        self.widgetForAction(self._message_action).setText(s)",
      "instance_attributes": [
        {
          "name": "_message_action",
          "types": null
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_qt.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    qApp = _api.deprecated(\n        \"3.6\", alternative=\"QtWidgets.QApplication.instance()\")(\n            property(lambda self: QtWidgets.QApplication.instance()))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg",
      "name": "FigureCanvasQTAgg",
      "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "FigureCanvasQT"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/paintEvent",
        "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasQTAgg(FigureCanvasAgg, FigureCanvasQT):\n\n    def paintEvent(self, event):\n        \"\"\"\n        Copy the image from the Agg canvas to the qt.drawable.\n\n        In Qt, all drawing should be done inside of here when a widget is\n        shown onscreen.\n        \"\"\"\n        self._draw_idle()  # Only does something if a draw is pending.\n\n        # If the canvas does not have a renderer, then give up and wait for\n        # FigureCanvasAgg.draw(self) to be called.\n        if not hasattr(self, 'renderer'):\n            return\n\n        painter = QtGui.QPainter(self)\n        try:\n            # See documentation of QRect: bottom() and right() are off\n            # by 1, so use left() + width() and top() + height().\n            rect = event.rect()\n            # scale rect dimensions using the screen dpi ratio to get\n            # correct values for the Figure coordinates (rather than\n            # QT5's coords)\n            width = rect.width() * self.device_pixel_ratio\n            height = rect.height() * self.device_pixel_ratio\n            left, top = self.mouseEventCoords(rect.topLeft())\n            # shift the \"top\" by the height of the image to get the\n            # correct corner for our coordinate system\n            bottom = top - height\n            # same with the right side of the image\n            right = left + width\n            # create a buffer using the image bounding box\n            bbox = Bbox([[left, bottom], [right, top]])\n            reg = self.copy_from_bbox(bbox)\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                memoryview(reg))\n\n            # clear the widget canvas\n            painter.eraseRect(rect)\n\n            if QT_API == \"PyQt6\":\n                from PyQt6 import sip\n                ptr = int(sip.voidptr(buf))\n            else:\n                ptr = buf\n            qimage = QtGui.QImage(\n                ptr, buf.shape[1], buf.shape[0],\n                _enum(\"QtGui.QImage.Format\").Format_ARGB32_Premultiplied)\n            _setDevicePixelRatio(qimage, self.device_pixel_ratio)\n            # set origin using original QT coordinates\n            origin = QtCore.QPoint(rect.left(), rect.top())\n            painter.drawImage(origin, qimage)\n            # Adjust the buf reference count to work around a memory\n            # leak bug in QImage under PySide.\n            if QT_API in ('PySide', 'PySide2'):\n                if QtCore.__version_info__ < (5, 12):\n                    ctypes.c_long.from_address(id(buf)).value = 1\n\n            self._draw_rect_callback(painter)\n        finally:\n            painter.end()\n\n    def print_figure(self, *args, **kwargs):\n        super().print_figure(*args, **kwargs)\n        self.draw()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo",
      "name": "FigureCanvasQTCairo",
      "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "FigureCanvasQT"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/draw",
        "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/paintEvent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasQTCairo(FigureCanvasCairo, FigureCanvasQT):\n    def draw(self):\n        if hasattr(self._renderer.gc, \"ctx\"):\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        super().draw()\n\n    def paintEvent(self, event):\n        width = int(self.device_pixel_ratio * self.width())\n        height = int(self.device_pixel_ratio * self.height())\n        if (width, height) != self._renderer.get_canvas_width_height():\n            surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n            self._renderer.set_context(cairo.Context(surface))\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        buf = self._renderer.gc.ctx.get_target().get_data()\n        if QT_API == \"PyQt6\":\n            from PyQt6 import sip\n            ptr = int(sip.voidptr(buf))\n        else:\n            ptr = buf\n        qimage = QtGui.QImage(\n            ptr, width, height,\n            _enum(\"QtGui.QImage.Format\").Format_ARGB32_Premultiplied)\n        # Adjust the buf reference count to work around a memory leak bug in\n        # QImage under PySide.\n        if QT_API in ('PySide', 'PySide2'):\n            if QtCore.__version_info__ < (5, 12):\n                ctypes.c_long.from_address(id(buf)).value = 1\n        _setDevicePixelRatio(qimage, self.device_pixel_ratio)\n        painter = QtGui.QPainter(self)\n        painter.eraseRect(event.rect())\n        painter.drawImage(0, 0, qimage)\n        self._draw_rect_callback(painter)\n        painter.end()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG",
      "name": "FigureCanvasSVG",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg",
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz",
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasSVG(FigureCanvasBase):\n    filetypes = {'svg': 'Scalable Vector Graphics',\n                 'svgz': 'Scalable Vector Graphics'}\n\n    fixed_dpi = 72\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_svg(self, filename, *args, bbox_inches_restore=None,\n                  metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n\n        metadata : dict[str, Any], optional\n            Metadata in the SVG file defined as key-value pairs of strings,\n            datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n            'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n            The standard keys and their value types are:\n\n            * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n              ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n              ``'Title'``, and ``'Type'``.\n            * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n              ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n            * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n              non-*str*, then it will be formatted as ISO 8601.\n\n            Values have been predefined for ``'Creator'``, ``'Date'``,\n            ``'Format'``, and ``'Type'``. They can be removed by setting them\n            to `None`.\n\n            Information is encoded as `Dublin Core Metadata`__.\n\n            .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n            __ DC_\n        \"\"\"\n        with cbook.open_file_cm(filename, \"w\", encoding=\"utf-8\") as fh:\n            if not cbook.file_requires_unicode(fh):\n                fh = codecs.getwriter('utf-8')(fh)\n            dpi = self.figure.dpi\n            self.figure.dpi = 72\n            width, height = self.figure.get_size_inches()\n            w, h = width * 72, height * 72\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererSVG(w, h, fh, image_dpi=dpi, metadata=metadata),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_svgz(self, filename, *args, **kwargs):\n        with cbook.open_file_cm(filename, \"wb\") as fh, \\\n                gzip.GzipFile(mode='w', fileobj=fh) as gzipwriter:\n            return self.print_svg(gzipwriter, **kwargs)\n\n    def get_default_filetype(self):\n        return 'svg'\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG",
      "name": "RendererSVG",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/finalize",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_metadata",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_default_style",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_make_id",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_make_flip_transform",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_hatch",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_hatches",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_style_dict",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_style",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_clip_attrs",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_clips",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_image_nocomposite",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_convert_path",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_scale_image",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_image_magnification",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_update_glyph_map_defs",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_adjust_char_id",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_draw_text_as_path",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_draw_text_as_text",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/flipy",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererSVG(RendererBase):\n    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72,\n                 *, metadata=None):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        if basename is None:\n            basename = getattr(svgwriter, \"name\", \"\")\n            if not isinstance(basename, str):\n                basename = \"\"\n        self.basename = basename\n\n        self._groupd = {}\n        self._image_counter = itertools.count()\n        self._clipd = {}\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = {}\n        self._has_gouraud = False\n        self._n_gradients = 0\n\n        super().__init__()\n        self._glyph_map = dict()\n        str_height = _short_float_fmt(height)\n        str_width = _short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width='%spt' % str_width,\n            height='%spt' % str_height,\n            viewBox='0 0 %s %s' % (str_width, str_height),\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()\n\n    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()\n\n    def _write_metadata(self, metadata):\n        # Add metadata following the Dublin Core Metadata Initiative, and the\n        # Creative Commons Rights Expression Language. This is mainly for\n        # compatibility with Inkscape.\n        if metadata is None:\n            metadata = {}\n        metadata = {\n            'Format': 'image/svg+xml',\n            'Type': 'http://purl.org/dc/dcmitype/StillImage',\n            'Creator':\n                f'Matplotlib v{mpl.__version__}, https://matplotlib.org/',\n            **metadata\n        }\n        writer = self.writer\n\n        if 'Title' in metadata:\n            title = metadata['Title']\n            _check_is_str(title, 'Title')\n            writer.element('title', text=title)\n\n        # Special handling.\n        date = metadata.get('Date', None)\n        if date is not None:\n            if isinstance(date, str):\n                dates = [date]\n            elif isinstance(date, (datetime.datetime, datetime.date)):\n                dates = [date.isoformat()]\n            elif np.iterable(date):\n                dates = []\n                for d in date:\n                    if isinstance(d, str):\n                        dates.append(d)\n                    elif isinstance(d, (datetime.datetime, datetime.date)):\n                        dates.append(d.isoformat())\n                    else:\n                        raise TypeError(\n                            f'Invalid type for Date metadata. '\n                            f'Expected iterable of str, date, or datetime, '\n                            f'not {type(d)}.')\n            else:\n                raise TypeError(f'Invalid type for Date metadata. '\n                                f'Expected str, date, datetime, or iterable '\n                                f'of the same, not {type(date)}.')\n            metadata['Date'] = '/'.join(dates)\n        elif 'Date' not in metadata:\n            # Do not add `Date` if the user explicitly set `Date` to `None`\n            # Get source date from SOURCE_DATE_EPOCH, if set.\n            # See https://reproducible-builds.org/specs/source-date-epoch/\n            date = os.getenv(\"SOURCE_DATE_EPOCH\")\n            if date:\n                date = datetime.datetime.utcfromtimestamp(int(date))\n                metadata['Date'] = date.replace(tzinfo=UTC).isoformat()\n            else:\n                metadata['Date'] = datetime.datetime.today().isoformat()\n\n        mid = None\n        def ensure_metadata(mid):\n            if mid is not None:\n                return mid\n            mid = writer.start('metadata')\n            writer.start('rdf:RDF', attrib={\n                'xmlns:dc': \"http://purl.org/dc/elements/1.1/\",\n                'xmlns:cc': \"http://creativecommons.org/ns#\",\n                'xmlns:rdf': \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n            })\n            writer.start('cc:Work')\n            return mid\n\n        uri = metadata.pop('Type', None)\n        if uri is not None:\n            mid = ensure_metadata(mid)\n            writer.element('dc:type', attrib={'rdf:resource': uri})\n\n        # Single value only.\n        for key in ['Title', 'Coverage', 'Date', 'Description', 'Format',\n                    'Identifier', 'Language', 'Relation', 'Source']:\n            info = metadata.pop(key, None)\n            if info is not None:\n                mid = ensure_metadata(mid)\n                _check_is_str(info, key)\n                writer.element(f'dc:{key.lower()}', text=info)\n\n        # Multiple Agent values.\n        for key in ['Creator', 'Contributor', 'Publisher', 'Rights']:\n            agents = metadata.pop(key, None)\n            if agents is None:\n                continue\n\n            if isinstance(agents, str):\n                agents = [agents]\n\n            _check_is_iterable_of_str(agents, key)\n            # Now we know that we have an iterable of str\n            mid = ensure_metadata(mid)\n            writer.start(f'dc:{key.lower()}')\n            for agent in agents:\n                writer.start('cc:Agent')\n                writer.element('dc:title', text=agent)\n                writer.end('cc:Agent')\n            writer.end(f'dc:{key.lower()}')\n\n        # Multiple values.\n        keywords = metadata.pop('Keywords', None)\n        if keywords is not None:\n            if isinstance(keywords, str):\n                keywords = [keywords]\n            _check_is_iterable_of_str(keywords, 'Keywords')\n            # Now we know that we have an iterable of str\n            mid = ensure_metadata(mid)\n            writer.start('dc:subject')\n            writer.start('rdf:Bag')\n            for keyword in keywords:\n                writer.element('rdf:li', text=keyword)\n            writer.end('rdf:Bag')\n            writer.end('dc:subject')\n\n        if mid is not None:\n            writer.close(mid)\n\n        if metadata:\n            raise ValueError('Unknown metadata key(s) passed to SVG writer: ' +\n                             ','.join(metadata))\n\n    def _write_default_style(self):\n        writer = self.writer\n        default_style = _generate_css({\n            'stroke-linejoin': 'round',\n            'stroke-linecap': 'butt'})\n        writer.start('defs')\n        writer.element('style', type='text/css', text='*{%s}' % default_style)\n        writer.end('defs')\n\n    def _make_id(self, type, content):\n        salt = mpl.rcParams['svg.hashsalt']\n        if salt is None:\n            salt = str(uuid.uuid4())\n        m = hashlib.sha256()\n        m.update(salt.encode('utf8'))\n        m.update(str(content).encode('utf8'))\n        return '%s%s' % (type, m.hexdigest()[:10])\n\n    def _make_flip_transform(self, transform):\n        return transform + Affine2D().scale(1, -1).translate(0, self.height)\n\n    def _get_hatch(self, gc, rgbFace):\n        \"\"\"\n        Create a new hatch pattern\n        \"\"\"\n        if rgbFace is not None:\n            rgbFace = tuple(rgbFace)\n        edge = gc.get_hatch_color()\n        if edge is not None:\n            edge = tuple(edge)\n        dictkey = (gc.get_hatch(), rgbFace, edge)\n        oid = self._hatchd.get(dictkey)\n        if oid is None:\n            oid = self._make_id('h', dictkey)\n            self._hatchd[dictkey] = ((gc.get_hatch_path(), rgbFace, edge), oid)\n        else:\n            _, oid = oid\n        return oid\n\n    def _write_hatches(self):\n        if not len(self._hatchd):\n            return\n        HATCH_SIZE = 72\n        writer = self.writer\n        writer.start('defs')\n        for (path, face, stroke), oid in self._hatchd.values():\n            writer.start(\n                'pattern',\n                id=oid,\n                patternUnits=\"userSpaceOnUse\",\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE),\n                height=str(HATCH_SIZE))\n            path_data = self._convert_path(\n                path,\n                Affine2D()\n                .scale(HATCH_SIZE).scale(1.0, -1.0).translate(0, HATCH_SIZE),\n                simplify=False)\n            if face is None:\n                fill = 'none'\n            else:\n                fill = rgb2hex(face)\n            writer.element(\n                'rect',\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE+1),\n                height=str(HATCH_SIZE+1),\n                fill=fill)\n            hatch_style = {\n                    'fill': rgb2hex(stroke),\n                    'stroke': rgb2hex(stroke),\n                    'stroke-width': str(mpl.rcParams['hatch.linewidth']),\n                    'stroke-linecap': 'butt',\n                    'stroke-linejoin': 'miter'\n                    }\n            if stroke[3] < 1:\n                hatch_style['stroke-opacity'] = str(stroke[3])\n            writer.element(\n                'path',\n                d=path_data,\n                style=_generate_css(hatch_style)\n                )\n            writer.end('pattern')\n        writer.end('defs')\n\n    def _get_style_dict(self, gc, rgbFace):\n        \"\"\"Generate a style string from the GraphicsContext and rgbFace.\"\"\"\n        attrib = {}\n\n        forced_alpha = gc.get_forced_alpha()\n\n        if gc.get_hatch() is not None:\n            attrib['fill'] = \"url(#%s)\" % self._get_hatch(gc, rgbFace)\n            if (rgbFace is not None and len(rgbFace) == 4 and rgbFace[3] != 1.0\n                    and not forced_alpha):\n                attrib['fill-opacity'] = _short_float_fmt(rgbFace[3])\n        else:\n            if rgbFace is None:\n                attrib['fill'] = 'none'\n            else:\n                if tuple(rgbFace[:3]) != (0, 0, 0):\n                    attrib['fill'] = rgb2hex(rgbFace)\n                if (len(rgbFace) == 4 and rgbFace[3] != 1.0\n                        and not forced_alpha):\n                    attrib['fill-opacity'] = _short_float_fmt(rgbFace[3])\n\n        if forced_alpha and gc.get_alpha() != 1.0:\n            attrib['opacity'] = _short_float_fmt(gc.get_alpha())\n\n        offset, seq = gc.get_dashes()\n        if seq is not None:\n            attrib['stroke-dasharray'] = ','.join(\n                _short_float_fmt(val) for val in seq)\n            attrib['stroke-dashoffset'] = _short_float_fmt(float(offset))\n\n        linewidth = gc.get_linewidth()\n        if linewidth:\n            rgb = gc.get_rgb()\n            attrib['stroke'] = rgb2hex(rgb)\n            if not forced_alpha and rgb[3] != 1.0:\n                attrib['stroke-opacity'] = _short_float_fmt(rgb[3])\n            if linewidth != 1.0:\n                attrib['stroke-width'] = _short_float_fmt(linewidth)\n            if gc.get_joinstyle() != 'round':\n                attrib['stroke-linejoin'] = gc.get_joinstyle()\n            if gc.get_capstyle() != 'butt':\n                attrib['stroke-linecap'] = _capstyle_d[gc.get_capstyle()]\n\n        return attrib\n\n    def _get_style(self, gc, rgbFace):\n        return _generate_css(self._get_style_dict(gc, rgbFace))\n\n    def _get_clip_attrs(self, gc):\n        cliprect = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            clippath_trans = self._make_flip_transform(clippath_trans)\n            dictkey = (id(clippath), str(clippath_trans))\n        elif cliprect is not None:\n            x, y, w, h = cliprect.bounds\n            y = self.height-(y+h)\n            dictkey = (x, y, w, h)\n        else:\n            return {}\n        clip = self._clipd.get(dictkey)\n        if clip is None:\n            oid = self._make_id('p', dictkey)\n            if clippath is not None:\n                self._clipd[dictkey] = ((clippath, clippath_trans), oid)\n            else:\n                self._clipd[dictkey] = (dictkey, oid)\n        else:\n            clip, oid = clip\n        return {'clip-path': f'url(#{oid})'}\n\n    def _write_clips(self):\n        if not len(self._clipd):\n            return\n        writer = self.writer\n        writer.start('defs')\n        for clip, oid in self._clipd.values():\n            writer.start('clipPath', id=oid)\n            if len(clip) == 2:\n                clippath, clippath_trans = clip\n                path_data = self._convert_path(\n                    clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(y),\n                    width=_short_float_fmt(w),\n                    height=_short_float_fmt(h))\n            writer.end('clipPath')\n        writer.end('defs')\n\n    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=\"%s_%d\" % (s, self._groupd[s]))\n\n    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def _convert_path(self, path, transform=None, clip=None, simplify=None,\n                      sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width, self.height)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, sketch, 6,\n            [b'M', b'L', b'Q', b'C', b'z'], False).decode('ascii')\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify,\n            sketch=gc.get_sketch_params())\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, **self._get_clip_attrs(gc),\n                            style=self._get_style(gc, rgbFace))\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, _generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = _generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        writer.start('g', **self._get_clip_attrs(gc))\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': '#%s' % oid}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = _short_float_fmt(x)\n                attrib['y'] = _short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        writer.end('g')\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #    (len_path + 5) * uses_per_path\n        # cost of definition+use is\n        #    (len_path + 3) + 9 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 9 * uses_per_path + 3 < (len_path + 5) * uses_per_path\n        if not should_do_optimization:\n            return super().draw_path_collection(\n                gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C%x_%x_%s' % (\n                self._path_collection_id, i, self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            clip_attrs = self._get_clip_attrs(gc0)\n            if clip_attrs:\n                writer.start('g', **clip_attrs)\n            attrib = {\n                'xlink:href': '#%s' % path_id,\n                'x': _short_float_fmt(xo),\n                'y': _short_float_fmt(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clip_attrs:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        # docstring inherited\n\n        # This uses a method described here:\n        #\n        #   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html\n        #\n        # that uses three overlapping linear gradients to simulate a\n        # Gouraud triangle.  Each gradient goes from fully opaque in\n        # one corner to fully transparent along the opposite edge.\n        # The line between the stop points is perpendicular to the\n        # opposite edge.  Underlying these three gradients is a solid\n        # triangle whose color is the average of all three points.\n\n        writer = self.writer\n        if not self._has_gouraud:\n            self._has_gouraud = True\n            writer.start(\n                'filter',\n                id='colorAdd')\n            writer.element(\n                'feComposite',\n                attrib={'in': 'SourceGraphic'},\n                in2='BackgroundImage',\n                operator='arithmetic',\n                k2=\"1\", k3=\"1\")\n            writer.end('filter')\n            # feColorMatrix filter to correct opacity\n            writer.start(\n                'filter',\n                id='colorMat')\n            writer.element(\n                'feColorMatrix',\n                attrib={'type': 'matrix'},\n                values='1 0 0 0 0 \\n0 1 0 0 0 \\n0 0 1 0 0' +\n                       ' \\n1 1 1 1 0 \\n0 0 0 0 1 ')\n            writer.end('filter')\n\n        avg_color = np.average(colors, axis=0)\n        if avg_color[-1] == 0:\n            # Skip fully-transparent triangles\n            return\n\n        trans_and_flip = self._make_flip_transform(trans)\n        tpoints = trans_and_flip.transform(points)\n\n        writer.start('defs')\n        for i in range(3):\n            x1, y1 = tpoints[i]\n            x2, y2 = tpoints[(i + 1) % 3]\n            x3, y3 = tpoints[(i + 2) % 3]\n            rgba_color = colors[i]\n\n            if x2 == x3:\n                xb = x2\n                yb = y1\n            elif y2 == y3:\n                xb = x1\n                yb = y2\n            else:\n                m1 = (y2 - y3) / (x2 - x3)\n                b1 = y2 - (m1 * x2)\n                m2 = -(1.0 / m1)\n                b2 = y1 - (m2 * x1)\n                xb = (-b1 + b2) / (m1 - m2)\n                yb = m2 * xb + b2\n\n            writer.start(\n                'linearGradient',\n                id=\"GR%x_%d\" % (self._n_gradients, i),\n                gradientUnits=\"userSpaceOnUse\",\n                x1=_short_float_fmt(x1), y1=_short_float_fmt(y1),\n                x2=_short_float_fmt(xb), y2=_short_float_fmt(yb))\n            writer.element(\n                'stop',\n                offset='1',\n                style=_generate_css({\n                    'stop-color': rgb2hex(avg_color),\n                    'stop-opacity': _short_float_fmt(rgba_color[-1])}))\n            writer.element(\n                'stop',\n                offset='0',\n                style=_generate_css({'stop-color': rgb2hex(rgba_color),\n                                    'stop-opacity': \"0\"}))\n\n            writer.end('linearGradient')\n\n        writer.end('defs')\n\n        # triangle formation using \"path\"\n        dpath = \"M \" + _short_float_fmt(x1)+',' + _short_float_fmt(y1)\n        dpath += \" L \" + _short_float_fmt(x2) + ',' + _short_float_fmt(y2)\n        dpath += \" \" + _short_float_fmt(x3) + ',' + _short_float_fmt(y3) + \" Z\"\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': rgb2hex(avg_color),\n                    'fill-opacity': '1',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.start(\n                'g',\n                attrib={'stroke': \"none\",\n                        'stroke-width': \"0\",\n                        'shape-rendering': \"crispEdges\",\n                        'filter': \"url(#colorMat)\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_0)' % self._n_gradients,\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_1)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_2)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.end('g')\n\n        self._n_gradients += 1\n\n    def draw_gouraud_triangles(self, gc, triangles_array, colors_array,\n                               transform):\n        self.writer.start('g', **self._get_clip_attrs(gc))\n        transform = transform.frozen()\n        for tri, col in zip(triangles_array, colors_array):\n            self.draw_gouraud_triangle(gc, tri, col, transform)\n        self.writer.end('g')\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True\n\n    def get_image_magnification(self):\n        return self.image_dpi / 72.0\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n\n        if w == 0 or h == 0:\n            return\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Can't apply clip-path directly to the image because the image has\n            # a transformation, which would also be applied to the clip-path.\n            self.writer.start('g', **clip_attrs)\n\n        url = gc.get_url()\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n\n        attrib = {}\n        oid = gc.get_gid()\n        if mpl.rcParams['svg.image_inline']:\n            buf = BytesIO()\n            Image.fromarray(im).save(buf, format=\"png\")\n            oid = oid or self._make_id('image', buf.getvalue())\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(buf.getvalue()).decode('ascii'))\n        else:\n            if self.basename is None:\n                raise ValueError(\"Cannot save image data to filesystem when \"\n                                 \"writing SVG to an in-memory buffer\")\n            filename = '{}.image{}.png'.format(\n                self.basename, next(self._image_counter))\n            _log.info('Writing image file for inclusion: %s', filename)\n            Image.fromarray(im).save(filename)\n            oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n        attrib['id'] = oid\n\n        if transform is None:\n            w = 72.0 * w / self.image_dpi\n            h = 72.0 * h / self.image_dpi\n\n            self.writer.element(\n                'image',\n                transform=_generate_transform([\n                    ('scale', (1, -1)), ('translate', (0, -h))]),\n                x=_short_float_fmt(x),\n                y=_short_float_fmt(-(self.height - y - h)),\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n        else:\n            alpha = gc.get_alpha()\n            if alpha != 1.0:\n                attrib['opacity'] = _short_float_fmt(alpha)\n\n            flipped = (\n                Affine2D().scale(1.0 / w, 1.0 / h) +\n                transform +\n                Affine2D()\n                .translate(x, y)\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n            attrib['transform'] = _generate_transform(\n                [('matrix', flipped.frozen())])\n            attrib['style'] = (\n                'image-rendering:crisp-edges;'\n                'image-rendering:pixelated')\n            self.writer.element(\n                'image',\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clip_attrs:\n            self.writer.end('g')\n\n    def _update_glyph_map_defs(self, glyph_map_new):\n        \"\"\"\n        Emit definitions for not-yet-defined glyphs, and record them as having\n        been defined.\n        \"\"\"\n        writer = self.writer\n        if glyph_map_new:\n            writer.start('defs')\n            for char_id, (vertices, codes) in glyph_map_new.items():\n                char_id = self._adjust_char_id(char_id)\n                # x64 to go back to FreeType's internal (integral) units.\n                path_data = self._convert_path(\n                    Path(vertices * 64, codes), simplify=False)\n                writer.element(\n                    'path', id=char_id, d=path_data,\n                    transform=_generate_transform([('scale', (1 / 64,))]))\n            writer.end('defs')\n            self._glyph_map.update(glyph_map_new)\n\n    def _adjust_char_id(self, char_id):\n        return char_id.replace(\"%20\", \"_\")\n\n    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        \"\"\"\n        Draw the text by converting them to paths using the textpath module.\n\n        Parameters\n        ----------\n        s : str\n            text to be converted\n        prop : `matplotlib.font_manager.FontProperties`\n            font property\n        ismath : bool\n            If True, use mathtext parser. If \"TeX\", use *usetex* mode.\n        \"\"\"\n        writer = self.writer\n\n        writer.comment(s)\n\n        glyph_map = self._glyph_map\n\n        text2path = self._text2path\n        color = rgb2hex(gc.get_rgb())\n        fontsize = prop.get_size_in_points()\n\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = _short_float_fmt(alpha)\n        font_scale = fontsize / text2path.FONT_SCALE\n        attrib = {\n            'style': _generate_css(style),\n            'transform': _generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))]),\n        }\n        writer.start('g', attrib=attrib)\n\n        if not ismath:\n            font = text2path._get_font(prop)\n            _glyphs = text2path.get_glyphs_with_font(\n                font, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for glyph_id, xposition, yposition, scale in glyph_info:\n                attrib = {'xlink:href': '#%s' % glyph_id}\n                if xposition != 0.0:\n                    attrib['x'] = _short_float_fmt(xposition)\n                if yposition != 0.0:\n                    attrib['y'] = _short_float_fmt(yposition)\n                writer.element('use', attrib=attrib)\n\n        else:\n            if ismath == \"TeX\":\n                _glyphs = text2path.get_glyphs_tex(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            else:\n                _glyphs = text2path.get_glyphs_mathtext(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for char_id, xposition, yposition, scale in glyph_info:\n                char_id = self._adjust_char_id(char_id)\n                writer.element(\n                    'use',\n                    transform=_generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': '#%s' % char_id})\n\n            for verts, codes in rects:\n                path = Path(verts, codes)\n                path_data = self._convert_path(path, simplify=False)\n                writer.element('path', d=path_data)\n\n        writer.end('g')\n\n    def _draw_text_as_text(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        writer = self.writer\n\n        color = rgb2hex(gc.get_rgb())\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = _short_float_fmt(alpha)\n\n        if not ismath:\n            attrib = {}\n\n            font_parts = []\n            if prop.get_style() != 'normal':\n                font_parts.append(prop.get_style())\n            if prop.get_variant() != 'normal':\n                font_parts.append(prop.get_variant())\n            weight = fm.weight_dict[prop.get_weight()]\n            if weight != 400:\n                font_parts.append(f'{weight}')\n            font_parts.extend([\n                f'{_short_float_fmt(prop.get_size())}px',\n                # ensure quoting\n                f'{\", \".join(repr(f) for f in prop.get_family())}',\n            ])\n            style['font'] = ' '.join(font_parts)\n            if prop.get_stretch() != 'normal':\n                style['font-stretch'] = prop.get_stretch()\n            attrib['style'] = _generate_css(style)\n\n            if mtext and (angle == 0 or mtext.get_rotation_mode() == \"anchor\"):\n                # If text anchoring can be supported, get the original\n                # coordinates and add alignment information.\n\n                # Get anchor coordinates.\n                transform = mtext.get_transform()\n                ax, ay = transform.transform(mtext.get_unitless_position())\n                ay = self.height - ay\n\n                # Don't do vertical anchor alignment. Most applications do not\n                # support 'alignment-baseline' yet. Apply the vertical layout\n                # to the anchor point manually for now.\n                angle_rad = np.deg2rad(angle)\n                dir_vert = np.array([np.sin(angle_rad), np.cos(angle_rad)])\n                v_offset = np.dot(dir_vert, [(x - ax), (y - ay)])\n                ax = ax + v_offset * dir_vert[0]\n                ay = ay + v_offset * dir_vert[1]\n\n                ha_mpl_to_svg = {'left': 'start', 'right': 'end',\n                                 'center': 'middle'}\n                style['text-anchor'] = ha_mpl_to_svg[mtext.get_ha()]\n\n                attrib['x'] = _short_float_fmt(ax)\n                attrib['y'] = _short_float_fmt(ay)\n                attrib['style'] = _generate_css(style)\n                attrib['transform'] = _generate_transform([\n                    (\"rotate\", (-angle, ax, ay))])\n\n            else:\n                attrib['transform'] = _generate_transform([\n                    ('translate', (x, y)),\n                    ('rotate', (-angle,))])\n\n            writer.element('text', s, attrib=attrib)\n\n        else:\n            writer.comment(s)\n\n            width, height, descent, glyphs, rects = \\\n                self._text2path.mathtext_parser.parse(s, 72, prop)\n\n            # Apply attributes to 'g', not 'text', because we likely have some\n            # rectangles as well with the same style and transformation.\n            writer.start('g',\n                         style=_generate_css(style),\n                         transform=_generate_transform([\n                             ('translate', (x, y)),\n                             ('rotate', (-angle,))]),\n                         )\n\n            writer.start('text')\n\n            # Sort the characters by font, and output one tspan for each.\n            spans = {}\n            for font, fontsize, thetext, new_x, new_y in glyphs:\n                entry = fm.ttfFontProperty(font)\n                font_parts = []\n                if entry.style != 'normal':\n                    font_parts.append(entry.style)\n                if entry.variant != 'normal':\n                    font_parts.append(entry.variant)\n                if entry.weight != 400:\n                    font_parts.append(f'{entry.weight}')\n                font_parts.extend([\n                    f'{_short_float_fmt(fontsize)}px',\n                    f'{entry.name!r}',  # ensure quoting\n                ])\n                style = {'font': ' '.join(font_parts)}\n                if entry.stretch != 'normal':\n                    style['font-stretch'] = entry.stretch\n                style = _generate_css(style)\n                if thetext == 32:\n                    thetext = 0xa0  # non-breaking space\n                spans.setdefault(style, []).append((new_x, -new_y, thetext))\n\n            for style, chars in spans.items():\n                chars.sort()\n\n                if len({y for x, y, t in chars}) == 1:  # Are all y's the same?\n                    ys = str(chars[0][1])\n                else:\n                    ys = ' '.join(str(c[1]) for c in chars)\n\n                attrib = {\n                    'style': style,\n                    'x': ' '.join(_short_float_fmt(c[0]) for c in chars),\n                    'y': ys\n                    }\n\n                writer.element(\n                    'tspan',\n                    ''.join(chr(c[2]) for c in chars),\n                    attrib=attrib)\n\n            writer.end('text')\n\n            for x, y, width, height in rects:\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(-y-1),\n                    width=_short_float_fmt(width),\n                    height=_short_float_fmt(height)\n                    )\n\n            writer.end('g')\n\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath=\"TeX\")\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Cannot apply clip-path directly to the text, because\n            # it has a transformation\n            self.writer.start('g', **clip_attrs)\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n\n        if mpl.rcParams['svg.fonttype'] == 'path':\n            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n        else:\n            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n        if clip_attrs:\n            self.writer.end('g')\n\n    def flipy(self):\n        # docstring inherited\n        return True\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)",
      "instance_attributes": [
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "writer",
          "types": {
            "kind": "NamedType",
            "name": "XMLWriter"
          }
        },
        {
          "name": "image_dpi",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "basename",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_groupd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_image_counter",
          "types": {
            "kind": "NamedType",
            "name": "count"
          }
        },
        {
          "name": "_clipd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_markers",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_path_collection_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_hatchd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_has_gouraud",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_n_gradients",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_glyph_map",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_start_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter",
      "name": "XMLWriter",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__flush",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/flush"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Parameters\n----------\nfile : writable text file-like object",
      "code": "class XMLWriter:\n    \"\"\"\n    Parameters\n    ----------\n    file : writable text file-like object\n    \"\"\"\n\n    def __init__(self, file):\n        self.__write = file.write\n        if hasattr(file, \"flush\"):\n            self.flush = file.flush\n        self.__open = 0  # true if start tag is open\n        self.__tags = []\n        self.__data = []\n        self.__indentation = \" \" * 64\n\n    def __flush(self, indent=True):\n        # flush internal buffers\n        if self.__open:\n            if indent:\n                self.__write(\">\\n\")\n            else:\n                self.__write(\">\")\n            self.__open = 0\n        if self.__data:\n            data = ''.join(self.__data)\n            self.__write(_escape_cdata(data))\n            self.__data = []\n\n    def start(self, tag, attrib={}, **extra):\n        \"\"\"\n        Open a new element.  Attributes can be given as keyword\n        arguments, or as a string/string dictionary. The method returns\n        an opaque identifier that can be passed to the :meth:`close`\n        method, to close all open elements up to and including this one.\n\n        Parameters\n        ----------\n        tag\n            Element tag.\n        attrib\n            Attribute dictionary.  Alternatively, attributes can be given as\n            keyword arguments.\n\n        Returns\n        -------\n        An element identifier.\n        \"\"\"\n        self.__flush()\n        tag = _escape_cdata(tag)\n        self.__data = []\n        self.__tags.append(tag)\n        self.__write(self.__indentation[:len(self.__tags) - 1])\n        self.__write(\"<%s\" % tag)\n        for k, v in {**attrib, **extra}.items():\n            if v:\n                k = _escape_cdata(k)\n                v = _quote_escape_attrib(v)\n                self.__write(' %s=%s' % (k, v))\n        self.__open = 1\n        return len(self.__tags) - 1\n\n    def comment(self, comment):\n        \"\"\"\n        Add a comment to the output stream.\n\n        Parameters\n        ----------\n        comment : str\n            Comment text.\n        \"\"\"\n        self.__flush()\n        self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"<!-- %s -->\\n\" % _escape_comment(comment))\n\n    def data(self, text):\n        \"\"\"\n        Add character data to the output stream.\n\n        Parameters\n        ----------\n        text : str\n            Character data.\n        \"\"\"\n        self.__data.append(text)\n\n    def end(self, tag=None, indent=True):\n        \"\"\"\n        Close the current element (opened by the most recent call to\n        :meth:`start`).\n\n        Parameters\n        ----------\n        tag\n            Element tag.  If given, the tag must match the start tag.  If\n            omitted, the current element is closed.\n        \"\"\"\n        if tag:\n            assert self.__tags, \"unbalanced end(%s)\" % tag\n            assert _escape_cdata(tag) == self.__tags[-1], \\\n                \"expected end(%s), got %s\" % (self.__tags[-1], tag)\n        else:\n            assert self.__tags, \"unbalanced end()\"\n        tag = self.__tags.pop()\n        if self.__data:\n            self.__flush(indent)\n        elif self.__open:\n            self.__open = 0\n            self.__write(\"/>\\n\")\n            return\n        if indent:\n            self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"</%s>\\n\" % tag)\n\n    def close(self, id):\n        \"\"\"\n        Close open elements, up to (and including) the element identified\n        by the given identifier.\n\n        Parameters\n        ----------\n        id\n            Element identifier, as returned by the :meth:`start` method.\n        \"\"\"\n        while len(self.__tags) > id:\n            self.end()\n\n    def element(self, tag, text=None, attrib={}, **extra):\n        \"\"\"\n        Add an entire element.  This is the same as calling :meth:`start`,\n        :meth:`data`, and :meth:`end` in sequence. The *text* argument can be\n        omitted.\n        \"\"\"\n        self.start(tag, attrib, **extra)\n        if text:\n            self.data(text)\n        self.end(indent=False)\n\n    def flush(self):\n        \"\"\"Flush the output stream.\"\"\"\n        pass  # replaced by the constructor",
      "instance_attributes": [
        {
          "name": "__write",
          "types": null
        },
        {
          "name": "flush",
          "types": null
        },
        {
          "name": "__open",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "__tags",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "__data",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "__indentation",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate",
      "name": "FigureCanvasTemplate",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/draw",
        "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo",
        "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/get_default_filetype"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc.\n\nNote: GUI templates will want to connect events for button presses,\nmouse movements and key presses to functions that call the base\nclass methods button_press_event, button_release_event,\nmotion_notify_event, key_press_event, and key_release_event.  See the\nimplementations of the interactive backends for examples.",
      "docstring": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc.\n\nNote: GUI templates will want to connect events for button presses,\nmouse movements and key presses to functions that call the base\nclass methods button_press_event, button_release_event,\nmotion_notify_event, key_press_event, and key_release_event.  See the\nimplementations of the interactive backends for examples.\n\nAttributes\n----------\nfigure : `matplotlib.figure.Figure`\n    A high-level Figure instance",
      "code": "class FigureCanvasTemplate(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc.\n\n    Note: GUI templates will want to connect events for button presses,\n    mouse movements and key presses to functions that call the base\n    class methods button_press_event, button_release_event,\n    motion_notify_event, key_press_event, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file type is not in the base set of filetypes,\n    # you should add it to the class-scope filetypes dictionary as follows:\n    filetypes = {**FigureCanvasBase.filetypes, 'foo': 'My magic Foo format'}\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_foo(self, filename, *args, **kwargs):\n        \"\"\"\n        Write out format foo.\n\n        This method is normally called via `.Figure.savefig` and\n        `.FigureCanvasBase.print_figure`, which take care of setting the figure\n        facecolor, edgecolor, and dpi to the desired output values, and will\n        restore them to the original values.  Therefore, `print_foo` does not\n        need to handle these settings.\n        \"\"\"\n        self.draw()\n\n    def get_default_filetype(self):\n        return 'foo'",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureManagerTemplate",
      "name": "FigureManagerTemplate",
      "qname": "lib.matplotlib.backends.backend_template.FigureManagerTemplate",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.",
      "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.",
      "code": "class FigureManagerTemplate(FigureManagerBase):\n    \"\"\"\n    Helper class for pyplot mode, wraps everything up into a neat bundle.\n\n    For non-interactive backends, the base class is sufficient.\n    \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/GraphicsContextTemplate",
      "name": "GraphicsContextTemplate",
      "qname": "lib.matplotlib.backends.backend_template.GraphicsContextTemplate",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The graphics context provides the color, line styles, etc.  See the cairo\nand postscript backends for examples of mapping the graphics context\nattributes (cap styles, join styles, line widths, colors) to a particular\nbackend.  In cairo this is done by wrapping a cairo.Context object and\nforwarding the appropriate calls to it using a dictionary mapping styles\nto gdk constants.  In Postscript, all the work is done by the renderer,\nmapping line styles to postscript calls.\n\nIf it's more appropriate to do the mapping at the renderer level (as in\nthe postscript backend), you don't need to override any of the GC methods.\nIf it's more appropriate to wrap an instance (as in the cairo backend) and\ndo the mapping here, you'll need to override several of the setter\nmethods.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\nappropriate for your backend.",
      "docstring": "The graphics context provides the color, line styles, etc.  See the cairo\nand postscript backends for examples of mapping the graphics context\nattributes (cap styles, join styles, line widths, colors) to a particular\nbackend.  In cairo this is done by wrapping a cairo.Context object and\nforwarding the appropriate calls to it using a dictionary mapping styles\nto gdk constants.  In Postscript, all the work is done by the renderer,\nmapping line styles to postscript calls.\n\nIf it's more appropriate to do the mapping at the renderer level (as in\nthe postscript backend), you don't need to override any of the GC methods.\nIf it's more appropriate to wrap an instance (as in the cairo backend) and\ndo the mapping here, you'll need to override several of the setter\nmethods.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\nappropriate for your backend.",
      "code": "class GraphicsContextTemplate(GraphicsContextBase):\n    \"\"\"\n    The graphics context provides the color, line styles, etc.  See the cairo\n    and postscript backends for examples of mapping the graphics context\n    attributes (cap styles, join styles, line widths, colors) to a particular\n    backend.  In cairo this is done by wrapping a cairo.Context object and\n    forwarding the appropriate calls to it using a dictionary mapping styles\n    to gdk constants.  In Postscript, all the work is done by the renderer,\n    mapping line styles to postscript calls.\n\n    If it's more appropriate to do the mapping at the renderer level (as in\n    the postscript backend), you don't need to override any of the GC methods.\n    If it's more appropriate to wrap an instance (as in the cairo backend) and\n    do the mapping here, you'll need to override several of the setter\n    methods.\n\n    The base GraphicsContext stores colors as a RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\n    appropriate for your backend.\n    \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate",
      "name": "RendererTemplate",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/flipy",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `.backend_bases.RendererBase` for\ndocumentation of the methods.",
      "docstring": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `.backend_bases.RendererBase` for\ndocumentation of the methods.",
      "code": "class RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offset_trans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                        coordinates, offsets, offsetTrans, facecolors,\n#                        antialiased, edgecolors):\n#         pass\n\n    def draw_image(self, gc, x, y, im):\n        pass\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        pass\n\n    def flipy(self):\n        # docstring inherited\n        return True\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return 100, 100\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        return 1, 1, 1\n\n    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextTemplate()\n\n    def points_to_pixels(self, points):\n        # if backend doesn't have dpi, e.g., postscript or svg\n        return points",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg",
      "name": "FigureCanvasTkAgg",
      "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "FigureCanvasTk"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/draw",
        "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasTkAgg(FigureCanvasAgg, FigureCanvasTk):\n    def draw(self):\n        super().draw()\n        self.blit()\n\n    def blit(self, bbox=None):\n        _backend_tk.blit(self._tkphoto, self.renderer.buffer_rgba(),\n                         (0, 1, 2, 3), bbox=bbox)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo",
      "name": "FigureCanvasTkCairo",
      "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "FigureCanvasTk"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasTkCairo(FigureCanvasCairo, FigureCanvasTk):\n    def draw(self):\n        width = int(self.figure.bbox.width)\n        height = int(self.figure.bbox.height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_context(cairo.Context(surface))\n        self._renderer.dpi = self.figure.dpi\n        self.figure.draw(self._renderer)\n        buf = np.reshape(surface.get_data(), (height, width, 4))\n        _backend_tk.blit(\n            self._tkphoto, buf,\n            (2, 1, 0, 3) if sys.byteorder == \"little\" else (1, 2, 3, 0))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/FigureCanvasWebAgg",
      "name": "FigureCanvasWebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg.FigureCanvasWebAgg",
      "decorators": [],
      "superclasses": [
        "core.FigureCanvasWebAggCore"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasWebAgg(core.FigureCanvasWebAggCore):\n    manager_class = FigureManagerWebAgg",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/FigureManagerWebAgg",
      "name": "FigureManagerWebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg.FigureManagerWebAgg",
      "decorators": [],
      "superclasses": [
        "core.FigureManagerWebAgg"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerWebAgg(core.FigureManagerWebAgg):\n    _toolbar2_class = core.NavigationToolbar2WebAgg",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread",
      "name": "ServerThread",
      "qname": "lib.matplotlib.backends.backend_webagg.ServerThread",
      "decorators": [],
      "superclasses": [
        "threading.Thread"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread/run"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ServerThread(threading.Thread):\n    def run(self):\n        tornado.ioloop.IOLoop.instance().start()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication",
      "name": "WebAggApplication",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication",
      "decorators": [],
      "superclasses": [
        "tornado.web.Application"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize",
        "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/start"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class WebAggApplication(tornado.web.Application):\n    initialized = False\n    started = False\n\n    class FavIcon(tornado.web.RequestHandler):\n        def get(self):\n            self.set_header('Content-Type', 'image/png')\n            self.write(Path(mpl.get_data_path(),\n                            'images/matplotlib.png').read_bytes())\n\n    class SingleFigurePage(tornado.web.RequestHandler):\n        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)\n\n        def get(self, fignum):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"single_figure.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                fig_id=fignum,\n                toolitems=core.NavigationToolbar2WebAgg.toolitems,\n                canvas=manager.canvas)\n\n    class AllFiguresPage(tornado.web.RequestHandler):\n        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)\n\n        def get(self):\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"all_figures.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                figures=sorted(Gcf.figs.items()),\n                toolitems=core.NavigationToolbar2WebAgg.toolitems)\n\n    class MplJs(tornado.web.RequestHandler):\n        def get(self):\n            self.set_header('Content-Type', 'application/javascript')\n\n            js_content = core.FigureManagerWebAgg.get_javascript()\n\n            self.write(js_content)\n\n    class Download(tornado.web.RequestHandler):\n        def get(self, fignum, fmt):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n            self.set_header(\n                'Content-Type', mimetypes.types_map.get(fmt, 'binary'))\n            buff = BytesIO()\n            manager.canvas.figure.savefig(buff, format=fmt)\n            self.write(buff.getvalue())\n\n    class WebSocket(tornado.websocket.WebSocketHandler):\n        supports_binary = True\n\n        def open(self, fignum):\n            self.fignum = int(fignum)\n            self.manager = Gcf.get_fig_manager(self.fignum)\n            self.manager.add_web_socket(self)\n            if hasattr(self, 'set_nodelay'):\n                self.set_nodelay(True)\n\n        def on_close(self):\n            self.manager.remove_web_socket(self)\n\n        def on_message(self, message):\n            message = json.loads(message)\n            # The 'supports_binary' message is on a client-by-client\n            # basis.  The others affect the (shared) canvas as a\n            # whole.\n            if message['type'] == 'supports_binary':\n                self.supports_binary = message['value']\n            else:\n                manager = Gcf.get_fig_manager(self.fignum)\n                # It is possible for a figure to be closed,\n                # but a stale figure UI is still sending messages\n                # from the browser.\n                if manager is not None:\n                    manager.handle_json(message)\n\n        def send_json(self, content):\n            self.write_message(json.dumps(content))\n\n        def send_binary(self, blob):\n            if self.supports_binary:\n                self.write_message(blob, binary=True)\n            else:\n                data_uri = \"data:image/png;base64,{0}\".format(\n                    blob.encode('base64').replace('\\n', ''))\n                self.write_message(data_uri)\n\n    def __init__(self, url_prefix=''):\n        if url_prefix:\n            assert url_prefix[0] == '/' and url_prefix[-1] != '/', \\\n                'url_prefix must start with a \"/\" and not end with one.'\n\n        super().__init__(\n            [\n                # Static files for the CSS and JS\n                (url_prefix + r'/_static/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': core.FigureManagerWebAgg.get_static_file_path()}),\n\n                # Static images for the toolbar\n                (url_prefix + r'/_images/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': Path(mpl.get_data_path(), 'images')}),\n\n                # A Matplotlib favicon\n                (url_prefix + r'/favicon.ico', self.FavIcon),\n\n                # The page that contains all of the pieces\n                (url_prefix + r'/([0-9]+)', self.SingleFigurePage,\n                 {'url_prefix': url_prefix}),\n\n                # The page that contains all of the figures\n                (url_prefix + r'/?', self.AllFiguresPage,\n                 {'url_prefix': url_prefix}),\n\n                (url_prefix + r'/js/mpl.js', self.MplJs),\n\n                # Sends images and events to the browser, and receives\n                # events from the browser\n                (url_prefix + r'/([0-9]+)/ws', self.WebSocket),\n\n                # Handles the downloading (i.e., saving) of static images\n                (url_prefix + r'/([0-9]+)/download.([a-z0-9.]+)',\n                 self.Download),\n            ],\n            template_path=core.FigureManagerWebAgg.get_static_file_path())\n\n    @classmethod\n    def initialize(cls, url_prefix='', port=None, address=None):\n        if cls.initialized:\n            return\n\n        # Create the class instance\n        app = cls(url_prefix=url_prefix)\n\n        cls.url_prefix = url_prefix\n\n        # This port selection algorithm is borrowed, more or less\n        # verbatim, from IPython.\n        def random_ports(port, n):\n            \"\"\"\n            Generate a list of n random ports near the given port.\n\n            The first 5 ports will be sequential, and the remaining n-5 will be\n            randomly selected in the range [port-2*n, port+2*n].\n            \"\"\"\n            for i in range(min(5, n)):\n                yield port + i\n            for i in range(n - 5):\n                yield port + random.randint(-2 * n, 2 * n)\n\n        if address is None:\n            cls.address = mpl.rcParams['webagg.address']\n        else:\n            cls.address = address\n        cls.port = mpl.rcParams['webagg.port']\n        for port in random_ports(cls.port,\n                                 mpl.rcParams['webagg.port_retries']):\n            try:\n                app.listen(port, cls.address)\n            except socket.error as e:\n                if e.errno != errno.EADDRINUSE:\n                    raise\n            else:\n                cls.port = port\n                break\n        else:\n            raise SystemExit(\n                \"The webagg server could not be started because an available \"\n                \"port could not be found\")\n\n        cls.initialized = True\n\n    @classmethod\n    def start(cls):\n        if cls.started:\n            return\n\n        \"\"\"\n        IOLoop.running() was removed as of Tornado 2.4; see for example\n        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY\n        Thus there is no correct way to check if the loop has already been\n        launched. We may end up with two concurrently running loops in that\n        unlucky case with all the expected consequences.\n        \"\"\"\n        ioloop = tornado.ioloop.IOLoop.instance()\n\n        def shutdown():\n            ioloop.stop()\n            print(\"Server is stopped\")\n            sys.stdout.flush()\n            cls.started = False\n\n        @contextmanager\n        def catch_sigint():\n            old_handler = signal.signal(\n                signal.SIGINT,\n                lambda sig, frame: ioloop.add_callback_from_signal(shutdown))\n            try:\n                yield\n            finally:\n                signal.signal(signal.SIGINT, old_handler)\n\n        # Set the flag to True *before* blocking on ioloop.start()\n        cls.started = True\n\n        print(\"Press Ctrl+C to stop WebAgg server\")\n        sys.stdout.flush()\n        with catch_sigint():\n            ioloop.start()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore",
      "name": "FigureCanvasWebAggCore",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore",
      "decorators": [],
      "superclasses": [
        "backend_agg.FigureCanvasAgg"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/show",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/blit",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_diff_image",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/_handle_mouse",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/_handle_key",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_device_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/_handle_set_device_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasWebAggCore(backend_agg.FigureCanvasAgg):\n    manager_class = _api.classproperty(lambda cls: FigureManagerWebAgg)\n    _timer_cls = TimerAsyncio\n    # Webagg and friends having the right methods, but still\n    # having bugs in practice.  Do not advertise that it works until\n    # we can debug this.\n    supports_blit = False\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Set to True when the renderer contains data that is newer\n        # than the PNG buffer.\n        self._png_is_old = True\n        # Set to True by the `refresh` message so that the next frame\n        # sent to the clients will be a full frame.\n        self._force_full = True\n        # The last buffer, for diff mode.\n        self._last_buff = np.empty((0, 0))\n        # Store the current image mode so that at any point, clients can\n        # request the information. This should be changed by calling\n        # self.set_image_mode(mode) so that the notification can be given\n        # to the connected clients.\n        self._current_image_mode = 'full'\n        # Track mouse events to fill in the x, y position of key events.\n        self._last_mouse_xy = (None, None)\n\n    def show(self):\n        # show the figure window\n        from matplotlib.pyplot import show\n        show()\n\n    def draw(self):\n        self._png_is_old = True\n        try:\n            super().draw()\n        finally:\n            self.manager.refresh_all()  # Swap the frames.\n\n    def blit(self, bbox=None):\n        self._png_is_old = True\n        self.manager.refresh_all()\n\n    def draw_idle(self):\n        self.send_event(\"draw\")\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        cursor = _api.check_getitem({\n            backend_tools.Cursors.HAND: 'pointer',\n            backend_tools.Cursors.POINTER: 'default',\n            backend_tools.Cursors.SELECT_REGION: 'crosshair',\n            backend_tools.Cursors.MOVE: 'move',\n            backend_tools.Cursors.WAIT: 'wait',\n            backend_tools.Cursors.RESIZE_HORIZONTAL: 'ew-resize',\n            backend_tools.Cursors.RESIZE_VERTICAL: 'ns-resize',\n        }, cursor=cursor)\n        self.send_event('cursor', cursor=cursor)\n\n    def set_image_mode(self, mode):\n        \"\"\"\n        Set the image mode for any subsequent images which will be sent\n        to the clients. The modes may currently be either 'full' or 'diff'.\n\n        Note: diff images may not contain transparency, therefore upon\n        draw this mode may be changed if the resulting image has any\n        transparent component.\n        \"\"\"\n        _api.check_in_list(['full', 'diff'], mode=mode)\n        if self._current_image_mode != mode:\n            self._current_image_mode = mode\n            self.handle_send_image_mode(None)\n\n    def get_diff_image(self):\n        if self._png_is_old:\n            renderer = self.get_renderer()\n\n            pixels = np.asarray(renderer.buffer_rgba())\n            # The buffer is created as type uint32 so that entire\n            # pixels can be compared in one numpy call, rather than\n            # needing to compare each plane separately.\n            buff = pixels.view(np.uint32).squeeze(2)\n\n            if (self._force_full\n                    # If the buffer has changed size we need to do a full draw.\n                    or buff.shape != self._last_buff.shape\n                    # If any pixels have transparency, we need to force a full\n                    # draw as we cannot overlay new on top of old.\n                    or (pixels[:, :, 3] != 255).any()):\n                self.set_image_mode('full')\n                output = buff\n            else:\n                self.set_image_mode('diff')\n                diff = buff != self._last_buff\n                output = np.where(diff, buff, 0)\n\n            # Store the current buffer so we can compute the next diff.\n            self._last_buff = buff.copy()\n            self._force_full = False\n            self._png_is_old = False\n\n            data = output.view(dtype=np.uint8).reshape((*output.shape, 4))\n            with BytesIO() as png:\n                Image.fromarray(data).save(png, format=\"png\")\n                return png.getvalue()\n\n    def handle_event(self, event):\n        e_type = event['type']\n        handler = getattr(self, 'handle_{0}'.format(e_type),\n                          self.handle_unknown_event)\n        return handler(event)\n\n    def handle_unknown_event(self, event):\n        _log.warning('Unhandled message type {0}. {1}'.format(\n                     event['type'], event))\n\n    def handle_ack(self, event):\n        # Network latency tends to decrease if traffic is flowing\n        # in both directions.  Therefore, the browser sends back\n        # an \"ack\" message after each image frame is received.\n        # This could also be used as a simple sanity check in the\n        # future, but for now the performance increase is enough\n        # to justify it, even if the server does nothing with it.\n        pass\n\n    def handle_draw(self, event):\n        self.draw()\n\n    def _handle_mouse(self, event):\n        x = event['x']\n        y = event['y']\n        y = self.get_renderer().height - y\n        self._last_mouse_xy = x, y\n        # JavaScript button numbers and Matplotlib button numbers are off by 1.\n        button = event['button'] + 1\n\n        e_type = event['type']\n        guiEvent = event.get('guiEvent')\n        if e_type in ['button_press', 'button_release']:\n            MouseEvent(e_type + '_event', self, x, y, button,\n                       guiEvent=guiEvent)._process()\n        elif e_type == 'dblclick':\n            MouseEvent('button_press_event', self, x, y, button, dblclick=True,\n                       guiEvent=guiEvent)._process()\n        elif e_type == 'scroll':\n            MouseEvent('scroll_event', self, x, y, step=event['step'],\n                       guiEvent=guiEvent)._process()\n        elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       guiEvent=guiEvent)._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          guiEvent=guiEvent)._process()\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def handle_refresh(self, event):\n        figure_label = self.figure.get_label()\n        if not figure_label:\n            figure_label = \"Figure {0}\".format(self.manager.num)\n        self.send_event('figure_label', label=figure_label)\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()\n\n    def handle_resize(self, event):\n        x = int(event.get('width', 800)) * self.device_pixel_ratio\n        y = int(event.get('height', 800)) * self.device_pixel_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        ResizeEvent('resize_event', self)._process()\n        self.draw_idle()\n\n    def handle_send_image_mode(self, event):\n        # The client requests notification of what the current image mode is.\n        self.send_event('image_mode', mode=self._current_image_mode)\n\n    def handle_set_device_pixel_ratio(self, event):\n        self._handle_set_device_pixel_ratio(event.get('device_pixel_ratio', 1))\n\n    def handle_set_dpi_ratio(self, event):\n        # This handler is for backwards-compatibility with older ipympl.\n        self._handle_set_device_pixel_ratio(event.get('dpi_ratio', 1))\n\n    def _handle_set_device_pixel_ratio(self, device_pixel_ratio):\n        if self._set_device_pixel_ratio(device_pixel_ratio):\n            self._force_full = True\n            self.draw_idle()\n\n    def send_event(self, event_type, **kwargs):\n        if self.manager:\n            self.manager._send_event(event_type, **kwargs)",
      "instance_attributes": [
        {
          "name": "_png_is_old",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_force_full",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_last_buff",
          "types": {
            "kind": "NamedType",
            "name": "ndarray"
          }
        },
        {
          "name": "_current_image_mode",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_last_mouse_xy",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg",
      "name": "FigureManagerWebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg",
      "decorators": [],
      "superclasses": [
        "backend_bases.FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/show",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/refresh_all",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_static_file_path",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/_send_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerWebAgg(backend_bases.FigureManagerBase):\n    # This must be None to not break ipympl\n    _toolbar2_class = None\n    ToolbarCls = NavigationToolbar2WebAgg\n\n    def __init__(self, canvas, num):\n        self.web_sockets = set()\n        super().__init__(canvas, num)\n\n    def show(self):\n        pass\n\n    def resize(self, w, h, forward=True):\n        self._send_event(\n            'resize',\n            size=(w / self.canvas.device_pixel_ratio,\n                  h / self.canvas.device_pixel_ratio),\n            forward=forward)\n\n    def set_window_title(self, title):\n        self._send_event('figure_label', label=title)\n\n    # The following methods are specific to FigureManagerWebAgg\n\n    def add_web_socket(self, web_socket):\n        assert hasattr(web_socket, 'send_binary')\n        assert hasattr(web_socket, 'send_json')\n        self.web_sockets.add(web_socket)\n        self.resize(*self.canvas.figure.bbox.size)\n        self._send_event('refresh')\n\n    def remove_web_socket(self, web_socket):\n        self.web_sockets.remove(web_socket)\n\n    def handle_json(self, content):\n        self.canvas.handle_event(content)\n\n    def refresh_all(self):\n        if self.web_sockets:\n            diff = self.canvas.get_diff_image()\n            if diff is not None:\n                for s in self.web_sockets:\n                    s.send_binary(diff)\n\n    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = StringIO()\n        else:\n            output = stream\n\n        output.write((Path(__file__).parent / \"web_backend/js/mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n\n        toolitems = []\n        for name, tooltip, image, method in cls.ToolbarCls.toolitems:\n            if name is None:\n                toolitems.append(['', '', '', ''])\n            else:\n                toolitems.append([name, tooltip, image, method])\n        output.write(\"mpl.toolbar_items = {0};\\n\\n\".format(\n            json.dumps(toolitems)))\n\n        extensions = []\n        for filetype, ext in sorted(FigureCanvasWebAggCore.\n                                    get_supported_filetypes_grouped().\n                                    items()):\n            extensions.append(ext[0])\n        output.write(\"mpl.extensions = {0};\\n\\n\".format(\n            json.dumps(extensions)))\n\n        output.write(\"mpl.default_extension = {0};\".format(\n            json.dumps(FigureCanvasWebAggCore.get_default_filetype())))\n\n        if stream is None:\n            return output.getvalue()\n\n    @classmethod\n    def get_static_file_path(cls):\n        return os.path.join(os.path.dirname(__file__), 'web_backend')\n\n    def _send_event(self, event_type, **kwargs):\n        payload = {'type': event_type, **kwargs}\n        for s in self.web_sockets:\n            s.send_json(payload)",
      "instance_attributes": [
        {
          "name": "web_sockets",
          "types": {
            "kind": "NamedType",
            "name": "set"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg",
      "name": "NavigationToolbar2WebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg",
      "decorators": [],
      "superclasses": [
        "backend_bases.NavigationToolbar2"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/pan",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/zoom",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2WebAgg(backend_bases.NavigationToolbar2):\n\n    # Use the standard toolbar items + download button\n    toolitems = [\n        (text, tooltip_text, image_file, name_of_method)\n        for text, tooltip_text, image_file, name_of_method\n        in (*backend_bases.NavigationToolbar2.toolitems,\n            ('Download', 'Download plot', 'filesave', 'download'))\n        if name_of_method in _ALLOWED_TOOL_ITEMS\n    ]\n\n    cursor = _api.deprecate_privatize_attribute(\"3.5\")\n\n    def __init__(self, canvas):\n        self.message = ''\n        self._cursor = None  # Remove with deprecation.\n        super().__init__(canvas)\n\n    def set_message(self, message):\n        if message != self.message:\n            self.canvas.send_event(\"message\", message=message)\n        self.message = message\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.send_event(\"rubberband\", x0=x0, y0=y0, x1=x1, y1=y1)\n\n    def remove_rubberband(self):\n        self.canvas.send_event(\"rubberband\", x0=-1, y0=-1, x1=-1, y1=-1)\n\n    def save_figure(self, *args):\n        \"\"\"Save the current figure\"\"\"\n        self.canvas.send_event('save')\n\n    def pan(self):\n        super().pan()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)\n\n    def zoom(self):\n        super().zoom()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        self.canvas.send_event('history_buttons',\n                               Back=can_backward, Forward=can_forward)",
      "instance_attributes": [
        {
          "name": "message",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_cursor",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio",
      "name": "TimerAsyncio",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio",
      "decorators": [],
      "superclasses": [
        "backend_bases.TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/_timer_stop",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/_timer_set_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class TimerAsyncio(backend_bases.TimerBase):\n    def __init__(self, *args, **kwargs):\n        self._task = None\n        super().__init__(*args, **kwargs)\n\n    async def _timer_task(self, interval):\n        while True:\n            try:\n                await asyncio.sleep(interval)\n                self._on_timer()\n\n                if self._single:\n                    break\n            except asyncio.CancelledError:\n                break\n\n    def _timer_start(self):\n        self._timer_stop()\n\n        self._task = asyncio.ensure_future(\n            self._timer_task(max(self.interval / 1_000., 1e-6))\n        )\n\n    def _timer_stop(self):\n        if self._task is not None:\n            self._task.cancel()\n        self._task = None\n\n    def _timer_set_interval(self):\n        # Only stop and restart it if the timer has already been started\n        if self._task is not None:\n            self._timer_stop()\n            self._timer_start()",
      "instance_attributes": [
        {
          "name": "_task",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado",
      "name": "TimerTornado",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado",
      "decorators": [],
      "superclasses": [
        "backend_bases.TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/_timer_stop",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/_timer_set_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class TimerTornado(backend_bases.TimerBase):\n    def __init__(self, *args, **kwargs):\n        self._timer = None\n        super().__init__(*args, **kwargs)\n\n    def _timer_start(self):\n        import tornado\n\n        self._timer_stop()\n        if self._single:\n            ioloop = tornado.ioloop.IOLoop.instance()\n            self._timer = ioloop.add_timeout(\n                datetime.timedelta(milliseconds=self.interval),\n                self._on_timer)\n        else:\n            self._timer = tornado.ioloop.PeriodicCallback(\n                self._on_timer,\n                max(self.interval, 1e-6))\n            self._timer.start()\n\n    def _timer_stop(self):\n        import tornado\n\n        if self._timer is None:\n            return\n        elif self._single:\n            ioloop = tornado.ioloop.IOLoop.instance()\n            ioloop.remove_timeout(self._timer)\n        else:\n            self._timer.stop()\n        self._timer = None\n\n    def _timer_set_interval(self):\n        # Only stop and restart it if the timer has already been started\n        if self._timer is not None:\n            self._timer_stop()\n            self._timer_start()",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": {
            "kind": "NamedType",
            "name": "PeriodicCallback"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx",
      "name": "ConfigureSubplotsWx",
      "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.ConfigureSubplotsBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConfigureSubplotsWx(backend_tools.ConfigureSubplotsBase):\n    def trigger(self, *args):\n        NavigationToolbar2Wx.configure_subplots(self)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx",
      "name": "FigureCanvasWx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx",
      "decorators": [],
      "superclasses": [
        "_FigureCanvasWxBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/_print_image"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasWx(_FigureCanvasWxBase):\n    # Rendering to a Wx canvas using the deprecated Wx renderer.\n\n    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using RendererWx instance renderer, or using a\n        previously defined renderer if none is specified.\n        \"\"\"\n        _log.debug(\"%s - draw()\", type(self))\n        self.renderer = RendererWx(self.bitmap, self.figure.dpi)\n        self.figure.draw(self.renderer)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)\n\n    def _print_image(self, filetype, filename):\n        bitmap = wx.Bitmap(math.ceil(self.figure.bbox.width),\n                           math.ceil(self.figure.bbox.height))\n        self.figure.draw(RendererWx(bitmap, self.figure.dpi))\n        saved_obj = (bitmap.ConvertToImage()\n                     if cbook.is_writable_file_like(filename)\n                     else bitmap)\n        if not saved_obj.SaveFile(filename, filetype):\n            raise RuntimeError(f'Could not save figure to {filename}')\n        # draw() is required here since bits of state about the last renderer\n        # are strewn about the artist draw methods.  Do not remove the draw\n        # without first verifying that these have been cleaned up.  The artist\n        # contains() methods will fail otherwise.\n        if self._isDrawn:\n            self.draw()\n        # The \"if self\" check avoids a \"wrapped C/C++ object has been deleted\"\n        # RuntimeError if doing things after window is closed.\n        if self:\n            self.Refresh()\n\n    print_bmp = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_BMP)\n    print_jpeg = print_jpg = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_JPEG)\n    print_pcx = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_PCX)\n    print_png = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_PNG)\n    print_tiff = print_tif = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_TIF)\n    print_xpm = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_XPM)",
      "instance_attributes": [
        {
          "name": "renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererWx"
          }
        },
        {
          "name": "_isDrawn",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx",
      "name": "FigureFrameWx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx",
      "decorators": [],
      "superclasses": [
        "wx.Frame"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_figure_manager",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/_on_close"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureFrameWx(wx.Frame):\n    def __init__(self, num, fig, *, canvas_class=None):\n        # On non-Windows platform, explicitly set the position - fix\n        # positioning bug on some Linux platforms\n        if wx.Platform == '__WXMSW__':\n            pos = wx.DefaultPosition\n        else:\n            pos = wx.Point(20, 20)\n        super().__init__(parent=None, id=-1, pos=pos)\n        # Frame will be sized later by the Fit method\n        _log.debug(\"%s - __init__()\", type(self))\n        _set_frame_icon(self)\n\n        # The parameter will become required after the deprecation elapses.\n        if canvas_class is not None:\n            self.canvas = canvas_class(self, -1, fig)\n        else:\n            _api.warn_deprecated(\n                \"3.6\", message=\"The canvas_class parameter will become \"\n                \"required after the deprecation period starting in Matplotlib \"\n                \"%(since)s elapses.\")\n            self.canvas = self.get_canvas(fig)\n\n        # Auto-attaches itself to self.canvas.manager\n        manager = FigureManagerWx(self.canvas, num, self)\n\n        toolbar = self.canvas.manager.toolbar\n        if toolbar is not None:\n            self.SetToolBar(toolbar)\n\n        # On Windows, canvas sizing must occur after toolbar addition;\n        # otherwise the toolbar further resizes the canvas.\n        w, h = map(math.ceil, fig.bbox.size)\n        self.canvas.SetInitialSize(wx.Size(w, h))\n        self.canvas.SetMinSize((2, 2))\n        self.canvas.SetFocus()\n\n        self.Fit()\n\n        self.Bind(wx.EVT_CLOSE, self._on_close)\n\n    sizer = _api.deprecated(\"3.6\", alternative=\"frame.GetSizer()\")(\n        property(lambda self: self.GetSizer()))\n    figmgr = _api.deprecated(\"3.6\", alternative=\"frame.canvas.manager\")(\n        property(lambda self: self.canvas.manager))\n    num = _api.deprecated(\"3.6\", alternative=\"frame.canvas.manager.num\")(\n        property(lambda self: self.canvas.manager.num))\n    toolbar = _api.deprecated(\"3.6\", alternative=\"frame.GetToolBar()\")(\n        property(lambda self: self.GetToolBar()))\n    toolmanager = _api.deprecated(\n        \"3.6\", alternative=\"frame.canvas.manager.toolmanager\")(\n            property(lambda self: self.canvas.manager.toolmanager))\n\n    @_api.deprecated(\n        \"3.6\", alternative=\"the canvas_class constructor parameter\")\n    def get_canvas(self, fig):\n        return FigureCanvasWx(self, -1, fig)\n\n    @_api.deprecated(\"3.6\", alternative=\"frame.canvas.manager\")\n    def get_figure_manager(self):\n        _log.debug(\"%s - get_figure_manager()\", type(self))\n        return self.canvas.manager\n\n    def _on_close(self, event):\n        _log.debug(\"%s - on_close()\", type(self))\n        CloseEvent(\"close_event\", self.canvas)._process()\n        self.canvas.stop_event_loop()\n        # set FigureManagerWx.frame to None to prevent repeated attempts to\n        # close this frame from FigureManagerWx.destroy()\n        self.canvas.manager.frame = None\n        # remove figure manager from Gcf.figs\n        Gcf.destroy(self.canvas.manager)\n        try:  # See issue 2941338.\n            self.canvas.mpl_disconnect(self.canvas.toolbar._id_drag)\n        except AttributeError:  # If there's no toolbar.\n            pass\n        # Carry on with close event propagation, frame & children destruction\n        event.Skip()",
      "instance_attributes": [
        {
          "name": "canvas",
          "types": {
            "kind": "NamedType",
            "name": "FigureCanvasWx"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx",
      "name": "FigureManagerWx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/show",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/full_screen_toggle",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/get_window_title",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.",
      "docstring": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.\n\nAttributes\n----------\ncanvas : `FigureCanvas`\n    a FigureCanvasWx(wx.Panel) instance\nwindow : wxFrame\n    a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html",
      "code": "class FigureManagerWx(FigureManagerBase):\n    \"\"\"\n    Container/controller for the FigureCanvas and GUI frame.\n\n    It is instantiated by Gcf whenever a new figure is created.  Gcf is\n    responsible for managing multiple instances of FigureManagerWx.\n\n    Attributes\n    ----------\n    canvas : `FigureCanvas`\n        a FigureCanvasWx(wx.Panel) instance\n    window : wxFrame\n        a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html\n    \"\"\"\n\n    def __init__(self, canvas, num, frame):\n        _log.debug(\"%s - __init__()\", type(self))\n        self.frame = self.window = frame\n        super().__init__(canvas, num)\n\n    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        # docstring inherited\n        wxapp = wx.GetApp() or _create_wxapp()\n        frame = FigureFrameWx(num, figure, canvas_class=canvas_class)\n        manager = figure.canvas.manager\n        if mpl.is_interactive():\n            manager.frame.Show()\n            figure.canvas.draw_idle()\n        return manager\n\n    def show(self):\n        # docstring inherited\n        self.frame.Show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.frame.Raise()\n\n    def destroy(self, *args):\n        # docstring inherited\n        _log.debug(\"%s - destroy()\", type(self))\n        frame = self.frame\n        if frame:  # Else, may have been already deleted, e.g. when closing.\n            # As this can be called from non-GUI thread from plt.close use\n            # wx.CallAfter to ensure thread safety.\n            wx.CallAfter(frame.Close)\n\n    def full_screen_toggle(self):\n        # docstring inherited\n        self.frame.ShowFullScreen(not self.frame.IsFullScreen())\n\n    def get_window_title(self):\n        # docstring inherited\n        return self.window.GetTitle()\n\n    def set_window_title(self, title):\n        # docstring inherited\n        self.window.SetTitle(title)\n\n    def resize(self, width, height):\n        # docstring inherited\n        # Directly using SetClientSize doesn't handle the toolbar on Windows.\n        self.window.SetSize(self.window.ClientToWindowSize(wx.Size(\n            math.ceil(width), math.ceil(height))))",
      "instance_attributes": [
        {
          "name": "frame",
          "types": null
        },
        {
          "name": "window",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx",
      "name": "GraphicsContextWx",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/select",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/unselect",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The graphics context provides the color, line styles, etc.\n\nThis class stores a reference to a wxMemoryDC, and a\nwxGraphicsContext that draws to it.  Creating a wxGraphicsContext\nseems to be fairly heavy, so these objects are cached based on the\nbitmap object that is passed in.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\nsince wxPython colour management is rather simple, I have not chosen\nto implement a separate colour manager class.",
      "docstring": "The graphics context provides the color, line styles, etc.\n\nThis class stores a reference to a wxMemoryDC, and a\nwxGraphicsContext that draws to it.  Creating a wxGraphicsContext\nseems to be fairly heavy, so these objects are cached based on the\nbitmap object that is passed in.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\nsince wxPython colour management is rather simple, I have not chosen\nto implement a separate colour manager class.",
      "code": "class GraphicsContextWx(GraphicsContextBase):\n    \"\"\"\n    The graphics context provides the color, line styles, etc.\n\n    This class stores a reference to a wxMemoryDC, and a\n    wxGraphicsContext that draws to it.  Creating a wxGraphicsContext\n    seems to be fairly heavy, so these objects are cached based on the\n    bitmap object that is passed in.\n\n    The base GraphicsContext stores colors as a RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\n    since wxPython colour management is rather simple, I have not chosen\n    to implement a separate colour manager class.\n    \"\"\"\n    _capd = {'butt': wx.CAP_BUTT,\n             'projecting': wx.CAP_PROJECTING,\n             'round': wx.CAP_ROUND}\n\n    _joind = {'bevel': wx.JOIN_BEVEL,\n              'miter': wx.JOIN_MITER,\n              'round': wx.JOIN_ROUND}\n\n    _cache = weakref.WeakKeyDictionary()\n\n    def __init__(self, bitmap, renderer):\n        super().__init__()\n        # assert self.Ok(), \"wxMemoryDC not OK to use\"\n        _log.debug(\"%s - __init__(): %s\", type(self), bitmap)\n\n        dc, gfx_ctx = self._cache.get(bitmap, (None, None))\n        if dc is None:\n            dc = wx.MemoryDC(bitmap)\n            gfx_ctx = wx.GraphicsContext.Create(dc)\n            gfx_ctx._lastcliprect = None\n            self._cache[bitmap] = dc, gfx_ctx\n\n        self.bitmap = bitmap\n        self.dc = dc\n        self.gfx_ctx = gfx_ctx\n        self._pen = wx.Pen('BLACK', 1, wx.SOLID)\n        gfx_ctx.SetPen(self._pen)\n        self.renderer = renderer\n\n    def select(self):\n        \"\"\"Select the current bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(self.bitmap)\n            self.IsSelected = True\n\n    def unselect(self):\n        \"\"\"Select a Null bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(wx.NullBitmap)\n            self.IsSelected = False\n\n    def set_foreground(self, fg, isRGBA=None):\n        # docstring inherited\n        # Implementation note: wxPython has a separate concept of pen and\n        # brush - the brush fills any outline trace left by the pen.\n        # Here we set both to the same colour - if a figure is not to be\n        # filled, the renderer will set the brush to be transparent\n        # Same goes for text foreground...\n        _log.debug(\"%s - set_foreground()\", type(self))\n        self.select()\n        super().set_foreground(fg, isRGBA)\n\n        self._pen.SetColour(self.get_wxcolour(self.get_rgb()))\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def set_linewidth(self, w):\n        # docstring inherited\n        w = float(w)\n        _log.debug(\"%s - set_linewidth()\", type(self))\n        self.select()\n        if 0 < w < 1:\n            w = 1\n        super().set_linewidth(w)\n        lw = int(self.renderer.points_to_pixels(self._linewidth))\n        if lw == 0:\n            lw = 1\n        self._pen.SetWidth(lw)\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def set_capstyle(self, cs):\n        # docstring inherited\n        _log.debug(\"%s - set_capstyle()\", type(self))\n        self.select()\n        super().set_capstyle(cs)\n        self._pen.SetCap(GraphicsContextWx._capd[self._capstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def set_joinstyle(self, js):\n        # docstring inherited\n        _log.debug(\"%s - set_joinstyle()\", type(self))\n        self.select()\n        super().set_joinstyle(js)\n        self._pen.SetJoin(GraphicsContextWx._joind[self._joinstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def get_wxcolour(self, color):\n        \"\"\"Convert a RGB(A) color to a wx.Colour.\"\"\"\n        _log.debug(\"%s - get_wx_color()\", type(self))\n        return wx.Colour(*[int(255 * x) for x in color])",
      "instance_attributes": [
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "dc",
          "types": null
        },
        {
          "name": "gfx_ctx",
          "types": null
        },
        {
          "name": "_pen",
          "types": null
        },
        {
          "name": "renderer",
          "types": null
        },
        {
          "name": "IsSelected",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx",
      "name": "HelpWx",
      "qname": "lib.matplotlib.backends.backend_wx.HelpWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpWx(backend_tools.ToolHelpBase):\n    def trigger(self, *args):\n        _HelpDialog.show(self.figure.canvas.GetTopLevelParent(),\n                         self._get_help_entries())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx",
      "name": "NavigationToolbar2Wx",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2",
        "wx.ToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/_icon",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/_update_buttons_checked",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2Wx(NavigationToolbar2, wx.ToolBar):\n    def __init__(self, canvas, coordinates=True, *, style=wx.TB_BOTTOM):\n        wx.ToolBar.__init__(self, canvas.GetParent(), -1, style=style)\n\n        if 'wxMac' in wx.PlatformInfo:\n            self.SetToolBitmapSize((24, 24))\n        self.wx_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.AddSeparator()\n                continue\n            self.wx_ids[text] = (\n                self.AddTool(\n                    -1,\n                    bitmap=self._icon(f\"{image_file}.png\"),\n                    bmpDisabled=wx.NullBitmap,\n                    label=text, shortHelp=tooltip_text,\n                    kind=(wx.ITEM_CHECK if text in [\"Pan\", \"Zoom\"]\n                          else wx.ITEM_NORMAL))\n                .Id)\n            self.Bind(wx.EVT_TOOL, getattr(self, callback),\n                      id=self.wx_ids[text])\n\n        self._coordinates = coordinates\n        if self._coordinates:\n            self.AddStretchableSpace()\n            self._label_text = wx.StaticText(self, style=wx.ALIGN_RIGHT)\n            self.AddControl(self._label_text)\n\n        self.Realize()\n\n        NavigationToolbar2.__init__(self, canvas)\n\n    @staticmethod\n    def _icon(name):\n        \"\"\"\n        Construct a `wx.Bitmap` suitable for use as icon from an image file\n        *name*, including the extension and relative to Matplotlib's \"images\"\n        data directory.\n        \"\"\"\n        image = np.array(PIL.Image.open(cbook._get_data_path(\"images\", name)))\n        try:\n            dark = wx.SystemSettings.GetAppearance().IsDark()\n        except AttributeError:  # wxpython < 4.1\n            # copied from wx's IsUsingDarkBackground / GetLuminance.\n            bg = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)\n            fg = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n            # See wx.Colour.GetLuminance.\n            bg_lum = (.299 * bg.red + .587 * bg.green + .114 * bg.blue) / 255\n            fg_lum = (.299 * fg.red + .587 * fg.green + .114 * fg.blue) / 255\n            dark = fg_lum - bg_lum > .2\n        if dark:\n            fg = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n            black_mask = (image[..., :3] == 0).all(axis=-1)\n            image[black_mask, :3] = (fg.Red(), fg.Green(), fg.Blue())\n        return wx.Bitmap.FromBufferRGBA(\n            image.shape[1], image.shape[0], image.tobytes())\n\n    def _update_buttons_checked(self):\n        if \"Pan\" in self.wx_ids:\n            self.ToggleTool(self.wx_ids[\"Pan\"], self.mode.name == \"PAN\")\n        if \"Zoom\" in self.wx_ids:\n            self.ToggleTool(self.wx_ids[\"Zoom\"], self.mode.name == \"ZOOM\")\n\n    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()\n\n    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()\n\n    def save_figure(self, *args):\n        # Fetch the required filename and file type.\n        filetypes, exts, filter_index = self.canvas._get_imagesave_wildcards()\n        default_file = self.canvas.get_default_filename()\n        dialog = wx.FileDialog(\n            self.canvas.GetParent(), \"Save to file\",\n            mpl.rcParams[\"savefig.directory\"], default_file, filetypes,\n            wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)\n        dialog.SetFilterIndex(filter_index)\n        if dialog.ShowModal() == wx.ID_OK:\n            path = pathlib.Path(dialog.GetPath())\n            _log.debug('%s - Save file path: %s', type(self), path)\n            fmt = exts[dialog.GetFilterIndex()]\n            ext = path.suffix[1:]\n            if ext in self.canvas.get_supported_filetypes() and fmt != ext:\n                # looks like they forgot to set the image type drop\n                # down, going with the extension.\n                _log.warning('extension %s did not match the selected '\n                             'image type %s; going with %s',\n                             ext, fmt, ext)\n                fmt = ext\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams[\"savefig.directory\"]:\n                mpl.rcParams[\"savefig.directory\"] = str(path.parent)\n            try:\n                self.canvas.figure.savefig(str(path), format=fmt)\n            except Exception as e:\n                dialog = wx.MessageDialog(\n                    parent=self.canvas.GetParent(), message=str(e),\n                    caption='Matplotlib error')\n                dialog.ShowModal()\n                dialog.Destroy()\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        self.canvas._rubberband_rect = (x0, height - y0, x1, height - y1)\n        self.canvas.Refresh()\n\n    def remove_rubberband(self):\n        self.canvas._rubberband_rect = None\n        self.canvas.Refresh()\n\n    def set_message(self, s):\n        if self._coordinates:\n            self._label_text.SetLabel(s)\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'Back' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Back'], can_backward)\n        if 'Forward' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Forward'], can_forward)",
      "instance_attributes": [
        {
          "name": "wx_ids",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_coordinates",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_label_text",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx",
      "name": "RendererWx",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx",
      "decorators": [
        "_api.deprecated('2.0', name='wx', obj_type='backend', removal='the future', alternative='wxagg', addendum='See the Matplotlib usage FAQ for more info on backends.')"
      ],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/flipy",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/offset_text_height",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles. It acts as the\n'renderer' instance used by many classes in the hierarchy.",
      "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles. It acts as the\n'renderer' instance used by many classes in the hierarchy.",
      "code": "class RendererWx(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles. It acts as the\n    'renderer' instance used by many classes in the hierarchy.\n    \"\"\"\n    # In wxPython, drawing is performed on a wxDC instance, which will\n    # generally be mapped to the client area of the window displaying\n    # the plot. Under wxPython, the wxDC instance has a wx.Pen which\n    # describes the colour and weight of any lines drawn, and a wxBrush\n    # which describes the fill colour of any closed polygon.\n\n    # Font styles, families and weight.\n    fontweights = {\n        100: wx.FONTWEIGHT_LIGHT,\n        200: wx.FONTWEIGHT_LIGHT,\n        300: wx.FONTWEIGHT_LIGHT,\n        400: wx.FONTWEIGHT_NORMAL,\n        500: wx.FONTWEIGHT_NORMAL,\n        600: wx.FONTWEIGHT_NORMAL,\n        700: wx.FONTWEIGHT_BOLD,\n        800: wx.FONTWEIGHT_BOLD,\n        900: wx.FONTWEIGHT_BOLD,\n        'ultralight': wx.FONTWEIGHT_LIGHT,\n        'light': wx.FONTWEIGHT_LIGHT,\n        'normal': wx.FONTWEIGHT_NORMAL,\n        'medium': wx.FONTWEIGHT_NORMAL,\n        'semibold': wx.FONTWEIGHT_NORMAL,\n        'bold': wx.FONTWEIGHT_BOLD,\n        'heavy': wx.FONTWEIGHT_BOLD,\n        'ultrabold': wx.FONTWEIGHT_BOLD,\n        'black': wx.FONTWEIGHT_BOLD,\n    }\n    fontangles = {\n        'italic': wx.FONTSTYLE_ITALIC,\n        'normal': wx.FONTSTYLE_NORMAL,\n        'oblique': wx.FONTSTYLE_SLANT,\n    }\n\n    # wxPython allows for portable font styles, choosing them appropriately for\n    # the target platform. Map some standard font names to the portable styles.\n    # QUESTION: Is it wise to agree to standard fontnames across all backends?\n    fontnames = {\n        'Sans': wx.FONTFAMILY_SWISS,\n        'Roman': wx.FONTFAMILY_ROMAN,\n        'Script': wx.FONTFAMILY_SCRIPT,\n        'Decorative': wx.FONTFAMILY_DECORATIVE,\n        'Modern': wx.FONTFAMILY_MODERN,\n        'Courier': wx.FONTFAMILY_MODERN,\n        'courier': wx.FONTFAMILY_MODERN,\n    }\n\n    def __init__(self, bitmap, dpi):\n        \"\"\"Initialise a wxWindows renderer instance.\"\"\"\n        super().__init__()\n        _log.debug(\"%s - __init__()\", type(self))\n        self.width = bitmap.GetWidth()\n        self.height = bitmap.GetHeight()\n        self.bitmap = bitmap\n        self.fontd = {}\n        self.dpi = dpi\n        self.gc = None\n\n    def flipy(self):\n        # docstring inherited\n        return True\n\n    @_api.deprecated(\"3.6\")\n    def offset_text_height(self):\n        return True\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n\n        if self.gc is None:\n            gc = self.new_gc()\n        else:\n            gc = self.gc\n        gfx_ctx = gc.gfx_ctx\n        font = self.get_wx_font(s, prop)\n        gfx_ctx.SetFont(font, wx.BLACK)\n        w, h, descent, leading = gfx_ctx.GetFullTextExtent(s)\n\n        return w, h, descent\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def handle_clip_rectangle(self, gc):\n        new_bounds = gc.get_clip_rectangle()\n        if new_bounds is not None:\n            new_bounds = new_bounds.bounds\n        gfx_ctx = gc.gfx_ctx\n        if gfx_ctx._lastcliprect != new_bounds:\n            gfx_ctx._lastcliprect = new_bounds\n            if new_bounds is None:\n                gfx_ctx.ResetClip()\n            else:\n                gfx_ctx.Clip(new_bounds[0],\n                             self.height - new_bounds[1] - new_bounds[3],\n                             new_bounds[2], new_bounds[3])\n\n    @staticmethod\n    def convert_path(gfx_ctx, path, transform):\n        wxpath = gfx_ctx.CreatePath()\n        for points, code in path.iter_segments(transform):\n            if code == Path.MOVETO:\n                wxpath.MoveToPoint(*points)\n            elif code == Path.LINETO:\n                wxpath.AddLineToPoint(*points)\n            elif code == Path.CURVE3:\n                wxpath.AddQuadCurveToPoint(*points)\n            elif code == Path.CURVE4:\n                wxpath.AddCurveToPoint(*points)\n            elif code == Path.CLOSEPOLY:\n                wxpath.CloseSubpath()\n        return wxpath\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n        transform = transform + \\\n            Affine2D().scale(1.0, -1.0).translate(0.0, self.height)\n        wxpath = self.convert_path(gfx_ctx, path, transform)\n        if rgbFace is not None:\n            gfx_ctx.SetBrush(wx.Brush(gc.get_wxcolour(rgbFace)))\n            gfx_ctx.DrawPath(wxpath)\n        else:\n            gfx_ctx.StrokePath(wxpath)\n        gc.unselect()\n\n    def draw_image(self, gc, x, y, im):\n        bbox = gc.get_clip_rectangle()\n        if bbox is not None:\n            l, b, w, h = bbox.bounds\n        else:\n            l = 0\n            b = 0\n            w = self.width\n            h = self.height\n        rows, cols = im.shape[:2]\n        bitmap = wx.Bitmap.FromBufferRGBA(cols, rows, im.tobytes())\n        gc.select()\n        gc.gfx_ctx.DrawBitmap(bitmap, int(l), int(self.height - b),\n                              int(w), int(-h))\n        gc.unselect()\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n        _log.debug(\"%s - draw_text()\", type(self))\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n\n        font = self.get_wx_font(s, prop)\n        color = gc.get_wxcolour(gc.get_rgb())\n        gfx_ctx.SetFont(font, color)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath)\n        x = int(x)\n        y = int(y - h)\n\n        if angle == 0.0:\n            gfx_ctx.DrawText(s, x, y)\n        else:\n            rads = math.radians(angle)\n            xo = h * math.sin(rads)\n            yo = h * math.cos(rads)\n            gfx_ctx.DrawRotatedText(s, x - xo, y - yo, rads)\n\n        gc.unselect()\n\n    def new_gc(self):\n        # docstring inherited\n        _log.debug(\"%s - new_gc()\", type(self))\n        self.gc = GraphicsContextWx(self.bitmap, self)\n        self.gc.select()\n        self.gc.unselect()\n        return self.gc\n\n    def get_wx_font(self, s, prop):\n        \"\"\"Return a wx font.  Cache font instances for efficiency.\"\"\"\n        _log.debug(\"%s - get_wx_font()\", type(self))\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is not None:\n            return font\n        size = self.points_to_pixels(prop.get_size_in_points())\n        # Font colour is determined by the active wx.Pen\n        # TODO: It may be wise to cache font information\n        self.fontd[key] = font = wx.Font(  # Cache the font and gc.\n            pointSize=int(size + 0.5),\n            family=self.fontnames.get(prop.get_name(), wx.ROMAN),\n            style=self.fontangles[prop.get_style()],\n            weight=self.fontweights[prop.get_weight()])\n        return font\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0)",
      "instance_attributes": [
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "fontd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "gc",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextWx"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx",
      "name": "RubberbandWx",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.RubberbandBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RubberbandWx(backend_tools.RubberbandBase):\n    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2Wx.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)\n\n    def remove_rubberband(self):\n        NavigationToolbar2Wx.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx",
      "name": "SaveFigureWx",
      "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureWx(backend_tools.SaveFigureBase):\n    def trigger(self, *args):\n        NavigationToolbar2Wx.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx",
      "name": "SetCursorWx",
      "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx",
      "decorators": [
        "_api.deprecated('3.5', alternative='ToolSetCursor')"
      ],
      "superclasses": [
        "backend_tools.SetCursorBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SetCursorWx(backend_tools.SetCursorBase):\n    def set_cursor(self, cursor):\n        NavigationToolbar2Wx.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx",
      "name": "TimerWx",
      "qname": "lib.matplotlib.backends.backend_wx.TimerWx",
      "decorators": [],
      "superclasses": [
        "TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/_timer_stop",
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/_timer_set_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using wx.Timer events.",
      "docstring": "Subclass of `.TimerBase` using wx.Timer events.",
      "code": "class TimerWx(TimerBase):\n    \"\"\"Subclass of `.TimerBase` using wx.Timer events.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._timer = wx.Timer()\n        self._timer.Notify = self._on_timer\n        super().__init__(*args, **kwargs)\n\n    def _timer_start(self):\n        self._timer.Start(self._interval, self._single)\n\n    def _timer_stop(self):\n        self._timer.Stop()\n\n    def _timer_set_interval(self):\n        if self._timer.IsRunning():\n            self._timer_start()  # Restart with new interval.",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx",
      "name": "ToolCopyToClipboardWx",
      "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardWx(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        if not self.canvas._isDrawn:\n            self.canvas.draw()\n        if not self.canvas.bitmap.IsOk() or not wx.TheClipboard.Open():\n            return\n        try:\n            wx.TheClipboard.SetData(wx.BitmapDataObject(self.canvas.bitmap))\n        finally:\n            wx.TheClipboard.Close()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx",
      "name": "ToolbarWx",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "wx.ToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/_get_tool_pos",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarWx(ToolContainerBase, wx.ToolBar):\n    def __init__(self, toolmanager, parent=None, style=wx.TB_BOTTOM):\n        if parent is None:\n            parent = toolmanager.canvas.GetParent()\n        ToolContainerBase.__init__(self, toolmanager)\n        wx.ToolBar.__init__(self, parent, -1, style=style)\n        self._space = self.AddStretchableSpace()\n        self._label_text = wx.StaticText(self, style=wx.ALIGN_RIGHT)\n        self.AddControl(self._label_text)\n        self._toolitems = {}\n        self._groups = {}  # Mapping of groups to the separator after them.\n\n    def _get_tool_pos(self, tool):\n        \"\"\"\n        Find the position (index) of a wx.ToolBarToolBase in a ToolBar.\n\n        ``ToolBar.GetToolPos`` is not useful because wx assigns the same Id to\n        all Separators and StretchableSpaces.\n        \"\"\"\n        pos, = [pos for pos in range(self.ToolsCount)\n                if self.GetToolByPos(pos) == tool]\n        return pos\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        # Find or create the separator that follows this group.\n        if group not in self._groups:\n            self._groups[group] = self.InsertSeparator(\n                self._get_tool_pos(self._space))\n        sep = self._groups[group]\n        # List all separators.\n        seps = [t for t in map(self.GetToolByPos, range(self.ToolsCount))\n                if t.IsSeparator() and not t.IsStretchableSpace()]\n        # Find where to insert the tool.\n        if position >= 0:\n            # Find the start of the group by looking for the separator\n            # preceding this one; then move forward from it.\n            start = (0 if sep == seps[0]\n                     else self._get_tool_pos(seps[seps.index(sep) - 1]) + 1)\n        else:\n            # Move backwards from this separator.\n            start = self._get_tool_pos(sep) + 1\n        idx = start + position\n        if image_file:\n            bmp = NavigationToolbar2Wx._icon(image_file)\n            kind = wx.ITEM_NORMAL if not toggle else wx.ITEM_CHECK\n            tool = self.InsertTool(idx, -1, name, bmp, wx.NullBitmap, kind,\n                                   description or \"\")\n        else:\n            size = (self.GetTextExtent(name)[0] + 10, -1)\n            if toggle:\n                control = wx.ToggleButton(self, -1, name, size=size)\n            else:\n                control = wx.Button(self, -1, name, size=size)\n            tool = self.InsertControl(idx, control, label=name)\n        self.Realize()\n\n        def handler(event):\n            self.trigger_tool(name)\n\n        if image_file:\n            self.Bind(wx.EVT_TOOL, handler, tool)\n        else:\n            control.Bind(wx.EVT_LEFT_DOWN, handler)\n\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tool, handler))\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for tool, handler in self._toolitems[name]:\n            if not tool.IsControl():\n                self.ToggleTool(tool.Id, toggled)\n            else:\n                tool.GetControl().SetValue(toggled)\n        self.Refresh()\n\n    def remove_toolitem(self, name):\n        for tool, handler in self._toolitems[name]:\n            self.DeleteTool(tool.Id)\n        del self._toolitems[name]\n\n    def set_message(self, s):\n        self._label_text.SetLabel(s)",
      "instance_attributes": [
        {
          "name": "_space",
          "types": null
        },
        {
          "name": "_label_text",
          "types": null
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_wx.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    cursord = _api.deprecated(\"3.5\", obj_type=\"\")(property(lambda self: {\n        cursors.MOVE: wx.CURSOR_HAND,\n        cursors.HAND: wx.CURSOR_HAND,\n        cursors.POINTER: wx.CURSOR_ARROW,\n        cursors.SELECT_REGION: wx.CURSOR_CROSS,\n        cursors.WAIT: wx.CURSOR_WAIT,\n        cursors.RESIZE_HORIZONTAL: wx.CURSOR_SIZEWE,\n        cursors.RESIZE_VERTICAL: wx.CURSOR_SIZENS,\n    }))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg",
      "name": "FigureCanvasWxAgg",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "_FigureCanvasWxBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw",
        "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually)\nlives inside a frame instantiated by a FigureManagerWx. The parent\nwindow probably implements a wxSizer to control the displayed\ncontrol size - but we give a hint as to our preferred minimum\nsize.",
      "docstring": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually)\nlives inside a frame instantiated by a FigureManagerWx. The parent\nwindow probably implements a wxSizer to control the displayed\ncontrol size - but we give a hint as to our preferred minimum\nsize.",
      "code": "class FigureCanvasWxAgg(FigureCanvasAgg, _FigureCanvasWxBase):\n    \"\"\"\n    The FigureCanvas contains the figure and does event handling.\n\n    In the wxPython backend, it is derived from wxPanel, and (usually)\n    lives inside a frame instantiated by a FigureManagerWx. The parent\n    window probably implements a wxSizer to control the displayed\n    control size - but we give a hint as to our preferred minimum\n    size.\n    \"\"\"\n\n    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using agg.\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n        self.bitmap = _rgba_to_wx_bitmap(self.get_renderer().buffer_rgba())\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)\n\n    def blit(self, bbox=None):\n        # docstring inherited\n        bitmap = _rgba_to_wx_bitmap(self.get_renderer().buffer_rgba())\n        if bbox is None:\n            self.bitmap = bitmap\n        else:\n            srcDC = wx.MemoryDC(bitmap)\n            destDC = wx.MemoryDC(self.bitmap)\n            x = int(bbox.x0)\n            y = int(self.bitmap.GetHeight() - bbox.y1)\n            destDC.Blit(x, y, int(bbox.width), int(bbox.height), srcDC, x, y)\n            destDC.SelectObject(wx.NullBitmap)\n            srcDC.SelectObject(wx.NullBitmap)\n        self.gui_repaint()",
      "instance_attributes": [
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "_isDrawn",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg",
      "name": "FigureFrameWxAgg",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg",
      "decorators": [
        "_api.deprecated('3.6', alternative='FigureFrameWx(..., canvas_class=FigureCanvasWxAgg)')"
      ],
      "superclasses": [
        "FigureFrameWx"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureFrameWxAgg(FigureFrameWx):\n    def get_canvas(self, fig):\n        return FigureCanvasWxAgg(self, -1, fig)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo",
      "name": "FigureCanvasWxCairo",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "_FigureCanvasWxBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually) lives\ninside a frame instantiated by a FigureManagerWx. The parent window\nprobably implements a wxSizer to control the displayed control size - but\nwe give a hint as to our preferred minimum size.",
      "docstring": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually) lives\ninside a frame instantiated by a FigureManagerWx. The parent window\nprobably implements a wxSizer to control the displayed control size - but\nwe give a hint as to our preferred minimum size.",
      "code": "class FigureCanvasWxCairo(FigureCanvasCairo, _FigureCanvasWxBase):\n    \"\"\"\n    The FigureCanvas contains the figure and does event handling.\n\n    In the wxPython backend, it is derived from wxPanel, and (usually) lives\n    inside a frame instantiated by a FigureManagerWx. The parent window\n    probably implements a wxSizer to control the displayed control size - but\n    we give a hint as to our preferred minimum size.\n    \"\"\"\n\n    def draw(self, drawDC=None):\n        size = self.figure.bbox.size.astype(int)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, *size)\n        self._renderer.set_context(cairo.Context(surface))\n        self._renderer.dpi = self.figure.dpi\n        self.figure.draw(self._renderer)\n        self.bitmap = wxcairo.BitmapFromImageSurface(surface)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)",
      "instance_attributes": [
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "_isDrawn",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo",
      "name": "FigureFrameWxCairo",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo",
      "decorators": [
        "_api.deprecated('3.6', alternative='FigureFrameWx(..., canvas_class=FigureCanvasWxCairo)')"
      ],
      "superclasses": [
        "FigureFrameWx"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureFrameWxCairo(FigureFrameWx):\n    def get_canvas(self, fig):\n        return FigureCanvasWxCairo(self, -1, fig)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.qt_compat/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.qt_compat.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    ETS = _api.deprecated(\"3.5\")(property(lambda self: dict(\n        pyqt5=(QT_API_PYQT5, 5), pyside2=(QT_API_PYSIDE2, 5))))\n    QT_RC_MAJOR_VERSION = _api.deprecated(\"3.5\")(property(\n        lambda self: int(QtCore.qVersion().split(\".\")[0])))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry",
      "name": "CallbackRegistry",
      "qname": "lib.matplotlib.cbook.CallbackRegistry",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__getstate__",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__setstate__",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/_connect_picklable",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/_remove_proxy",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/blocked"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Handle registering, processing, blocking, and disconnecting\nfor a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...    print('eat', x)\n    >>> def ondrink(x):\n    ...    print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456)   # nothing will be called\n\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)        # nothing will be called\n\n    >>> with callbacks.blocked(signal='drink'):\n    ...     callbacks.process('drink', 123)  # nothing will be called\n    >>> callbacks.process('drink', 123)\n    drink 123\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.",
      "docstring": "Handle registering, processing, blocking, and disconnecting\nfor a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...    print('eat', x)\n    >>> def ondrink(x):\n    ...    print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456)   # nothing will be called\n\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)        # nothing will be called\n\n    >>> with callbacks.blocked(signal='drink'):\n    ...     callbacks.process('drink', 123)  # nothing will be called\n    >>> callbacks.process('drink', 123)\n    drink 123\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.\n\nParameters\n----------\nexception_handler : callable, optional\n   If not None, *exception_handler* must be a function that takes an\n   `Exception` as single parameter.  It gets called with any `Exception`\n   raised by the callbacks during `CallbackRegistry.process`, and may\n   either re-raise the exception or handle it in another manner.\n\n   The default handler prints the exception (with `traceback.print_exc`) if\n   an interactive event loop is running; it re-raises the exception if no\n   interactive event loop is running.\n\nsignals : list, optional\n    If not None, *signals* is a list of signals that this registry handles:\n    attempting to `process` or to `connect` to a signal not in the list\n    throws a `ValueError`.  The default, None, does not restrict the\n    handled signals.",
      "code": "class CallbackRegistry:\n    \"\"\"\n    Handle registering, processing, blocking, and disconnecting\n    for a set of signals and callbacks:\n\n        >>> def oneat(x):\n        ...    print('eat', x)\n        >>> def ondrink(x):\n        ...    print('drink', x)\n\n        >>> from matplotlib.cbook import CallbackRegistry\n        >>> callbacks = CallbackRegistry()\n\n        >>> id_eat = callbacks.connect('eat', oneat)\n        >>> id_drink = callbacks.connect('drink', ondrink)\n\n        >>> callbacks.process('drink', 123)\n        drink 123\n        >>> callbacks.process('eat', 456)\n        eat 456\n        >>> callbacks.process('be merry', 456)   # nothing will be called\n\n        >>> callbacks.disconnect(id_eat)\n        >>> callbacks.process('eat', 456)        # nothing will be called\n\n        >>> with callbacks.blocked(signal='drink'):\n        ...     callbacks.process('drink', 123)  # nothing will be called\n        >>> callbacks.process('drink', 123)\n        drink 123\n\n    In practice, one should always disconnect all callbacks when they are\n    no longer needed to avoid dangling references (and thus memory leaks).\n    However, real code in Matplotlib rarely does so, and due to its design,\n    it is rather difficult to place this kind of code.  To get around this,\n    and prevent this class of memory leaks, we instead store weak references\n    to bound methods only, so when the destination object needs to die, the\n    CallbackRegistry won't keep it alive.\n\n    Parameters\n    ----------\n    exception_handler : callable, optional\n       If not None, *exception_handler* must be a function that takes an\n       `Exception` as single parameter.  It gets called with any `Exception`\n       raised by the callbacks during `CallbackRegistry.process`, and may\n       either re-raise the exception or handle it in another manner.\n\n       The default handler prints the exception (with `traceback.print_exc`) if\n       an interactive event loop is running; it re-raises the exception if no\n       interactive event loop is running.\n\n    signals : list, optional\n        If not None, *signals* is a list of signals that this registry handles:\n        attempting to `process` or to `connect` to a signal not in the list\n        throws a `ValueError`.  The default, None, does not restrict the\n        handled signals.\n    \"\"\"\n\n    # We maintain two mappings:\n    #   callbacks: signal -> {cid -> weakref-to-callback}\n    #   _func_cid_map: signal -> {weakref-to-callback -> cid}\n\n    def __init__(self, exception_handler=_exception_printer, *, signals=None):\n        self._signals = None if signals is None else list(signals)  # Copy it.\n        self.exception_handler = exception_handler\n        self.callbacks = {}\n        self._cid_gen = itertools.count()\n        self._func_cid_map = {}\n        # A hidden variable that marks cids that need to be pickled.\n        self._pickled_cids = set()\n\n    def __getstate__(self):\n        return {\n            **vars(self),\n            # In general, callbacks may not be pickled, so we just drop them,\n            # unless directed otherwise by self._pickled_cids.\n            \"callbacks\": {s: {cid: proxy() for cid, proxy in d.items()\n                              if cid in self._pickled_cids}\n                          for s, d in self.callbacks.items()},\n            # It is simpler to reconstruct this from callbacks in __setstate__.\n            \"_func_cid_map\": None,\n        }\n\n    def __setstate__(self, state):\n        vars(self).update(state)\n        self.callbacks = {\n            s: {cid: _weak_or_strong_ref(func, self._remove_proxy)\n                for cid, func in d.items()}\n            for s, d in self.callbacks.items()}\n        self._func_cid_map = {\n            s: {proxy: cid for cid, proxy in d.items()}\n            for s, d in self.callbacks.items()}\n\n    def connect(self, signal, func):\n        \"\"\"Register *func* to be called when signal *signal* is generated.\"\"\"\n        if signal == \"units finalize\":\n            _api.warn_deprecated(\n                \"3.5\", name=signal, obj_type=\"signal\", alternative=\"units\")\n        if self._signals is not None:\n            _api.check_in_list(self._signals, signal=signal)\n        self._func_cid_map.setdefault(signal, {})\n        proxy = _weak_or_strong_ref(func, self._remove_proxy)\n        if proxy in self._func_cid_map[signal]:\n            return self._func_cid_map[signal][proxy]\n        cid = next(self._cid_gen)\n        self._func_cid_map[signal][proxy] = cid\n        self.callbacks.setdefault(signal, {})\n        self.callbacks[signal][cid] = proxy\n        return cid\n\n    def _connect_picklable(self, signal, func):\n        \"\"\"\n        Like `.connect`, but the callback is kept when pickling/unpickling.\n\n        Currently internal-use only.\n        \"\"\"\n        cid = self.connect(signal, func)\n        self._pickled_cids.add(cid)\n        return cid\n\n    # Keep a reference to sys.is_finalizing, as sys may have been cleared out\n    # at that point.\n    def _remove_proxy(self, proxy, *, _is_finalizing=sys.is_finalizing):\n        if _is_finalizing():\n            # Weakrefs can't be properly torn down at that point anymore.\n            return\n        for signal, proxy_to_cid in list(self._func_cid_map.items()):\n            cid = proxy_to_cid.pop(proxy, None)\n            if cid is not None:\n                del self.callbacks[signal][cid]\n                self._pickled_cids.discard(cid)\n                break\n        else:\n            # Not found\n            return\n        # Clean up empty dicts\n        if len(self.callbacks[signal]) == 0:\n            del self.callbacks[signal]\n            del self._func_cid_map[signal]\n\n    def disconnect(self, cid):\n        \"\"\"\n        Disconnect the callback registered with callback id *cid*.\n\n        No error is raised if such a callback does not exist.\n        \"\"\"\n        self._pickled_cids.discard(cid)\n        # Clean up callbacks\n        for signal, cid_to_proxy in list(self.callbacks.items()):\n            proxy = cid_to_proxy.pop(cid, None)\n            if proxy is not None:\n                break\n        else:\n            # Not found\n            return\n\n        proxy_to_cid = self._func_cid_map[signal]\n        for current_proxy, current_cid in list(proxy_to_cid.items()):\n            if current_cid == cid:\n                assert proxy is current_proxy\n                del proxy_to_cid[current_proxy]\n        # Clean up empty dicts\n        if len(self.callbacks[signal]) == 0:\n            del self.callbacks[signal]\n            del self._func_cid_map[signal]\n\n    def process(self, s, *args, **kwargs):\n        \"\"\"\n        Process signal *s*.\n\n        All of the functions registered to receive callbacks on *s* will be\n        called with ``*args`` and ``**kwargs``.\n        \"\"\"\n        if self._signals is not None:\n            _api.check_in_list(self._signals, signal=s)\n        for cid, ref in list(self.callbacks.get(s, {}).items()):\n            func = ref()\n            if func is not None:\n                try:\n                    func(*args, **kwargs)\n                # this does not capture KeyboardInterrupt, SystemExit,\n                # and GeneratorExit\n                except Exception as exc:\n                    if self.exception_handler is not None:\n                        self.exception_handler(exc)\n                    else:\n                        raise\n\n    @contextlib.contextmanager\n    def blocked(self, *, signal=None):\n        \"\"\"\n        Block callback signals from being processed.\n\n        A context manager to temporarily block/disable callback signals\n        from being processed by the registered listeners.\n\n        Parameters\n        ----------\n        signal : str, optional\n            The callback signal to block. The default is to block all signals.\n        \"\"\"\n        orig = self.callbacks\n        try:\n            if signal is None:\n                # Empty out the callbacks\n                self.callbacks = {}\n            else:\n                # Only remove the specific signal\n                self.callbacks = {k: orig[k] for k in orig if k != signal}\n            yield\n        finally:\n            self.callbacks = orig",
      "instance_attributes": [
        {
          "name": "_signals",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "exception_handler",
          "types": {
            "kind": "NamedType",
            "name": "Callable"
          }
        },
        {
          "name": "callbacks",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_cid_gen",
          "types": {
            "kind": "NamedType",
            "name": "count"
          }
        },
        {
          "name": "_func_cid_map",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_pickled_cids",
          "types": {
            "kind": "NamedType",
            "name": "set"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper",
      "name": "Grouper",
      "qname": "lib.matplotlib.cbook.Grouper",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/Grouper/__init__",
        "matplotlib/lib.matplotlib.cbook/Grouper/__contains__",
        "matplotlib/lib.matplotlib.cbook/Grouper/clean",
        "matplotlib/lib.matplotlib.cbook/Grouper/join",
        "matplotlib/lib.matplotlib.cbook/Grouper/joined",
        "matplotlib/lib.matplotlib.cbook/Grouper/remove",
        "matplotlib/lib.matplotlib.cbook/Grouper/__iter__",
        "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.",
      "docstring": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.\n\nExamples\n--------\n>>> from matplotlib.cbook import Grouper\n>>> class Foo:\n...     def __init__(self, s):\n...         self.s = s\n...     def __repr__(self):\n...         return self.s\n...\n>>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n>>> grp = Grouper()\n>>> grp.join(a, b)\n>>> grp.join(b, c)\n>>> grp.join(d, e)\n>>> list(grp)\n[[a, b, c], [d, e]]\n>>> grp.joined(a, b)\nTrue\n>>> grp.joined(a, c)\nTrue\n>>> grp.joined(a, d)\nFalse",
      "code": "class Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]",
      "instance_attributes": [
        {
          "name": "_mapping",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/GrouperView",
      "name": "GrouperView",
      "qname": "lib.matplotlib.cbook.GrouperView",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/GrouperView/__init__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Immutable view over a `.Grouper`.",
      "docstring": "Immutable view over a `.Grouper`.",
      "code": "class GrouperView:\n    \"\"\"Immutable view over a `.Grouper`.\"\"\"\n\n    def __init__(self, grouper):\n        self._grouper = grouper\n\n    class _GrouperMethodForwarder:\n        def __init__(self, deprecated_kw=None):\n            self._deprecated_kw = deprecated_kw\n\n        def __set_name__(self, owner, name):\n            wrapped = getattr(Grouper, name)\n            forwarder = functools.wraps(wrapped)(\n                lambda self, *args, **kwargs: wrapped(\n                    self._grouper, *args, **kwargs))\n            if self._deprecated_kw:\n                forwarder = _api.deprecated(**self._deprecated_kw)(forwarder)\n            setattr(owner, name, forwarder)\n\n    __contains__ = _GrouperMethodForwarder()\n    __iter__ = _GrouperMethodForwarder()\n    joined = _GrouperMethodForwarder()\n    get_siblings = _GrouperMethodForwarder()\n    clean = _GrouperMethodForwarder(deprecated_kw=dict(since=\"3.6\"))\n    join = _GrouperMethodForwarder(deprecated_kw=dict(since=\"3.6\"))\n    remove = _GrouperMethodForwarder(deprecated_kw=dict(since=\"3.6\"))",
      "instance_attributes": [
        {
          "name": "_grouper",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack",
      "name": "Stack",
      "qname": "lib.matplotlib.cbook.Stack",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/Stack/__init__",
        "matplotlib/lib.matplotlib.cbook/Stack/__call__",
        "matplotlib/lib.matplotlib.cbook/Stack/__len__",
        "matplotlib/lib.matplotlib.cbook/Stack/__getitem__",
        "matplotlib/lib.matplotlib.cbook/Stack/forward",
        "matplotlib/lib.matplotlib.cbook/Stack/back",
        "matplotlib/lib.matplotlib.cbook/Stack/push",
        "matplotlib/lib.matplotlib.cbook/Stack/home",
        "matplotlib/lib.matplotlib.cbook/Stack/empty",
        "matplotlib/lib.matplotlib.cbook/Stack/clear",
        "matplotlib/lib.matplotlib.cbook/Stack/bubble",
        "matplotlib/lib.matplotlib.cbook/Stack/remove"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "docstring": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "code": "class Stack:\n    \"\"\"\n    Stack of elements with a movable cursor.\n\n    Mimics home/back/forward in a web browser.\n    \"\"\"\n\n    def __init__(self, default=None):\n        self.clear()\n        self._default = default\n\n    def __call__(self):\n        \"\"\"Return the current element, or None.\"\"\"\n        if not self._elements:\n            return self._default\n        else:\n            return self._elements[self._pos]\n\n    def __len__(self):\n        return len(self._elements)\n\n    def __getitem__(self, ind):\n        return self._elements[ind]\n\n    def forward(self):\n        \"\"\"Move the position forward and return the current element.\"\"\"\n        self._pos = min(self._pos + 1, len(self._elements) - 1)\n        return self()\n\n    def back(self):\n        \"\"\"Move the position back and return the current element.\"\"\"\n        if self._pos > 0:\n            self._pos -= 1\n        return self()\n\n    def push(self, o):\n        \"\"\"\n        Push *o* to the stack at current position.  Discard all later elements.\n\n        *o* is returned.\n        \"\"\"\n        self._elements = self._elements[:self._pos + 1] + [o]\n        self._pos = len(self._elements) - 1\n        return self()\n\n    def home(self):\n        \"\"\"\n        Push the first element onto the top of the stack.\n\n        The first element is returned.\n        \"\"\"\n        if not self._elements:\n            return\n        self.push(self._elements[0])\n        return self()\n\n    def empty(self):\n        \"\"\"Return whether the stack is empty.\"\"\"\n        return len(self._elements) == 0\n\n    def clear(self):\n        \"\"\"Empty the stack.\"\"\"\n        self._pos = -1\n        self._elements = []\n\n    def bubble(self, o):\n        \"\"\"\n        Raise all references of *o* to the top of the stack, and return it.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        top_elements = []\n        for elem in old_elements:\n            if elem == o:\n                top_elements.append(elem)\n            else:\n                self.push(elem)\n        for _ in top_elements:\n            self.push(o)\n        return o\n\n    def remove(self, o):\n        \"\"\"\n        Remove *o* from the stack.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        for elem in old_elements:\n            if elem != o:\n                self.push(elem)",
      "instance_attributes": [
        {
          "name": "_default",
          "types": null
        },
        {
          "name": "_pos",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.cbook.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    # module-level deprecations\n    MatplotlibDeprecationWarning = _api.deprecated(\n        \"3.6\", obj_type=\"\",\n        alternative=\"matplotlib.MatplotlibDeprecationWarning\")(\n        property(lambda self: _api.deprecation.MatplotlibDeprecationWarning))\n    mplDeprecation = _api.deprecated(\n        \"3.6\", obj_type=\"\",\n        alternative=\"matplotlib.MatplotlibDeprecationWarning\")(\n        property(lambda self: _api.deprecation.MatplotlibDeprecationWarning))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/maxdict",
      "name": "maxdict",
      "qname": "lib.matplotlib.cbook.maxdict",
      "decorators": [
        "_api.deprecated('3.6', alternative='functools.lru_cache')"
      ],
      "superclasses": [
        "dict"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/maxdict/__init__",
        "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A dictionary with a maximum size.",
      "docstring": "A dictionary with a maximum size.\n\nNotes\n-----\nThis doesn't override all the relevant methods to constrain the size,\njust ``__setitem__``, so use with caution.",
      "code": "class maxdict(dict):\n    \"\"\"\n    A dictionary with a maximum size.\n\n    Notes\n    -----\n    This doesn't override all the relevant methods to constrain the size,\n    just ``__setitem__``, so use with caution.\n    \"\"\"\n\n    def __init__(self, maxsize):\n        super().__init__()\n        self.maxsize = maxsize\n\n    def __setitem__(self, k, v):\n        super().__setitem__(k, v)\n        while len(self) >= self.maxsize:\n            del self[next(iter(self))]",
      "instance_attributes": [
        {
          "name": "maxsize",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/silent_list",
      "name": "silent_list",
      "qname": "lib.matplotlib.cbook.silent_list",
      "decorators": [],
      "superclasses": [
        "list"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/silent_list/__init__",
        "matplotlib/lib.matplotlib.cbook/silent_list/__repr__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>\n\nIf ``self.type`` is None, the type name is obtained from the first item in\nthe list (if any).",
      "docstring": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>\n\nIf ``self.type`` is None, the type name is obtained from the first item in\nthe list (if any).",
      "code": "class silent_list(list):\n    \"\"\"\n    A list with a short ``repr()``.\n\n    This is meant to be used for a homogeneous list of artists, so that they\n    don't cause long, meaningless output.\n\n    Instead of ::\n\n        [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n         <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n         <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\n    one will get ::\n\n        <a list of 3 Line2D objects>\n\n    If ``self.type`` is None, the type name is obtained from the first item in\n    the list (if any).\n    \"\"\"\n\n    def __init__(self, type, seq=None):\n        self.type = type\n        if seq is not None:\n            self.extend(seq)\n\n    def __repr__(self):\n        if self.type is not None or len(self) != 0:\n            tp = self.type if self.type is not None else type(self[0]).__name__\n            return f\"<a list of {len(self)} {tp} objects>\"\n        else:\n            return \"<an empty list>\"",
      "instance_attributes": [
        {
          "name": "type",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes",
      "name": "AitoffAxes",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes",
      "decorators": [],
      "superclasses": [
        "GeoAxes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__",
        "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/_get_core_transform"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AitoffAxes(GeoAxes):\n    name = 'aitoff'\n\n    class AitoffTransform(_GeoTransform):\n        \"\"\"The base Aitoff transform.\"\"\"\n\n        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n\n            # Pre-compute some values\n            half_long = longitude / 2.0\n            cos_latitude = np.cos(latitude)\n\n            alpha = np.arccos(cos_latitude * np.cos(half_long))\n            sinc_alpha = np.sinc(alpha / np.pi)  # np.sinc is sin(pi*x)/(pi*x).\n\n            x = (cos_latitude * np.sin(half_long)) / sinc_alpha\n            y = np.sin(latitude) / sinc_alpha\n            return np.column_stack([x, y])\n\n        def inverted(self):\n            # docstring inherited\n            return AitoffAxes.InvertedAitoffTransform(self._resolution)\n\n    class InvertedAitoffTransform(_GeoTransform):\n\n        def transform_non_affine(self, xy):\n            # docstring inherited\n            # MGDTODO: Math is hard ;(\n            return np.full_like(xy, np.nan)\n\n        def inverted(self):\n            # docstring inherited\n            return AitoffAxes.AitoffTransform(self._resolution)\n\n    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        super().__init__(*args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.clear()\n\n    def _get_core_transform(self, resolution):\n        return self.AitoffTransform(resolution)",
      "instance_attributes": [
        {
          "name": "_longitude_cap",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes",
      "name": "GeoAxes",
      "qname": "lib.matplotlib.projections.geo.GeoAxes",
      "decorators": [],
      "superclasses": [
        "Axes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_init_axis",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/clear",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_set_lim_and_transforms",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_get_affine_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text1_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text2_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text1_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text2_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_gen_axes_patch",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_gen_axes_spines",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_latitude_grid",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid_ends",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_data_ratio",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_zoom",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_pan",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/end_pan",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "An abstract base class for geographic projections.",
      "docstring": "An abstract base class for geographic projections.",
      "code": "class GeoAxes(Axes):\n    \"\"\"An abstract base class for geographic projections.\"\"\"\n\n    class ThetaFormatter(Formatter):\n        \"\"\"\n        Used to format the theta tick labels.  Converts the native\n        unit of radians into degrees and adds a degree symbol.\n        \"\"\"\n        def __init__(self, round_to=1.0):\n            self._round_to = round_to\n\n        def __call__(self, x, pos=None):\n            degrees = round(np.rad2deg(x) / self._round_to) * self._round_to\n            return f\"{degrees:0.0f}\\N{DEGREE SIGN}\"\n\n    RESOLUTION = 75\n\n    def _init_axis(self):\n        self.xaxis = maxis.XAxis(self)\n        self.yaxis = maxis.YAxis(self)\n        # Do not register xaxis or yaxis with spines -- as done in\n        # Axes._init_axis() -- until GeoAxes.xaxis.clear() works.\n        # self.spines['geo'].register_axis(self.yaxis)\n        self._update_transScale()\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n\n        self.set_longitude_grid(30)\n        self.set_latitude_grid(15)\n        self.set_longitude_grid_ends(75)\n        self.xaxis.set_minor_locator(NullLocator())\n        self.yaxis.set_minor_locator(NullLocator())\n        self.xaxis.set_ticks_position('none')\n        self.yaxis.set_ticks_position('none')\n        self.yaxis.set_tick_params(label1On=True)\n        # Why do we need to turn on yaxis tick labels, but\n        # xaxis tick labels are already on?\n\n        self.grid(mpl.rcParams['axes.grid'])\n\n        Axes.set_xlim(self, -np.pi, np.pi)\n        Axes.set_ylim(self, -np.pi / 2.0, np.pi / 2.0)\n\n    def _set_lim_and_transforms(self):\n        # A (possibly non-linear) projection on the (already scaled) data\n        self.transProjection = self._get_core_transform(self.RESOLUTION)\n\n        self.transAffine = self._get_affine_transform()\n\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # The complete data transformation stack -- from data all the\n        # way to display coordinates\n        self.transData = \\\n            self.transProjection + \\\n            self.transAffine + \\\n            self.transAxes\n\n        # This is the transform for longitude ticks.\n        self._xaxis_pretransform = \\\n            Affine2D() \\\n            .scale(1, self._longitude_cap * 2) \\\n            .translate(0, -self._longitude_cap)\n        self._xaxis_transform = \\\n            self._xaxis_pretransform + \\\n            self.transData\n        self._xaxis_text1_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, 4)\n        self._xaxis_text2_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, -4)\n\n        # This is the transform for latitude ticks.\n        yaxis_stretch = Affine2D().scale(np.pi * 2, 1).translate(-np.pi, 0)\n        yaxis_space = Affine2D().scale(1, 1.1)\n        self._yaxis_transform = \\\n            yaxis_stretch + \\\n            self.transData\n        yaxis_text_base = \\\n            yaxis_stretch + \\\n            self.transProjection + \\\n            (yaxis_space +\n             self.transAffine +\n             self.transAxes)\n        self._yaxis_text1_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(-8, 0)\n        self._yaxis_text2_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(8, 0)\n\n    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\n            .translate(0.5, 0.5)\n\n    def get_xaxis_transform(self, which='grid'):\n        _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._xaxis_transform\n\n    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text1_transform, 'bottom', 'center'\n\n    def get_xaxis_text2_transform(self, pad):\n        return self._xaxis_text2_transform, 'top', 'center'\n\n    def get_yaxis_transform(self, which='grid'):\n        _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._yaxis_transform\n\n    def get_yaxis_text1_transform(self, pad):\n        return self._yaxis_text1_transform, 'center', 'right'\n\n    def get_yaxis_text2_transform(self, pad):\n        return self._yaxis_text2_transform, 'center', 'left'\n\n    def _gen_axes_patch(self):\n        return Circle((0.5, 0.5), 0.5)\n\n    def _gen_axes_spines(self):\n        return {'geo': mspines.Spine.circular_spine(self, (0.5, 0.5), 0.5)}\n\n    def set_yscale(self, *args, **kwargs):\n        if args[0] != 'linear':\n            raise NotImplementedError\n\n    set_xscale = set_yscale\n\n    def set_xlim(self, *args, **kwargs):\n        \"\"\"Not supported. Please consider using Cartopy.\"\"\"\n        raise TypeError(\"Changing axes limits of a geographic projection is \"\n                        \"not supported.  Please consider using Cartopy.\")\n\n    set_ylim = set_xlim\n\n    def format_coord(self, lon, lat):\n        \"\"\"Return a format string formatting the coordinate.\"\"\"\n        lon, lat = np.rad2deg([lon, lat])\n        ns = 'N' if lat >= 0.0 else 'S'\n        ew = 'E' if lon >= 0.0 else 'W'\n        return ('%f\\N{DEGREE SIGN}%s, %f\\N{DEGREE SIGN}%s'\n                % (abs(lat), ns, abs(lon), ew))\n\n    def set_longitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each longitude grid.\n        \"\"\"\n        # Skip -180 and 180, which are the fixed limits.\n        grid = np.arange(-180 + degrees, 180, degrees)\n        self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_latitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each latitude grid.\n        \"\"\"\n        # Skip -90 and 90, which are the fixed limits.\n        grid = np.arange(-90 + degrees, 90, degrees)\n        self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_longitude_grid_ends(self, degrees):\n        \"\"\"\n        Set the latitude(s) at which to stop drawing the longitude grids.\n        \"\"\"\n        self._longitude_cap = np.deg2rad(degrees)\n        self._xaxis_pretransform \\\n            .clear() \\\n            .scale(1.0, self._longitude_cap * 2.0) \\\n            .translate(0.0, -self._longitude_cap)\n\n    def get_data_ratio(self):\n        \"\"\"Return the aspect ratio of the data itself.\"\"\"\n        return 1.0\n\n    ### Interactive panning\n\n    def can_zoom(self):\n        \"\"\"\n        Return whether this axes supports the zoom box button functionality.\n\n        This axes object does not support interactive zoom box.\n        \"\"\"\n        return False\n\n    def can_pan(self):\n        \"\"\"\n        Return whether this axes supports the pan/zoom button functionality.\n\n        This axes object does not support interactive pan/zoom.\n        \"\"\"\n        return False\n\n    def start_pan(self, x, y, button):\n        pass\n\n    def end_pan(self):\n        pass\n\n    def drag_pan(self, button, key, x, y):\n        pass",
      "instance_attributes": [
        {
          "name": "xaxis",
          "types": null
        },
        {
          "name": "yaxis",
          "types": null
        },
        {
          "name": "transProjection",
          "types": null
        },
        {
          "name": "transAffine",
          "types": null
        },
        {
          "name": "transAxes",
          "types": null
        },
        {
          "name": "transData",
          "types": null
        },
        {
          "name": "_xaxis_pretransform",
          "types": null
        },
        {
          "name": "_xaxis_transform",
          "types": null
        },
        {
          "name": "_xaxis_text1_transform",
          "types": null
        },
        {
          "name": "_xaxis_text2_transform",
          "types": null
        },
        {
          "name": "_yaxis_transform",
          "types": null
        },
        {
          "name": "_yaxis_text1_transform",
          "types": null
        },
        {
          "name": "_yaxis_text2_transform",
          "types": null
        },
        {
          "name": "_longitude_cap",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes",
      "name": "HammerAxes",
      "qname": "lib.matplotlib.projections.geo.HammerAxes",
      "decorators": [],
      "superclasses": [
        "GeoAxes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__",
        "matplotlib/lib.matplotlib.projections.geo/HammerAxes/_get_core_transform"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HammerAxes(GeoAxes):\n    name = 'hammer'\n\n    class HammerTransform(_GeoTransform):\n        \"\"\"The base Hammer transform.\"\"\"\n\n        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n            half_long = longitude / 2.0\n            cos_latitude = np.cos(latitude)\n            sqrt2 = np.sqrt(2.0)\n            alpha = np.sqrt(1.0 + cos_latitude * np.cos(half_long))\n            x = (2.0 * sqrt2) * (cos_latitude * np.sin(half_long)) / alpha\n            y = (sqrt2 * np.sin(latitude)) / alpha\n            return np.column_stack([x, y])\n\n        def inverted(self):\n            # docstring inherited\n            return HammerAxes.InvertedHammerTransform(self._resolution)\n\n    class InvertedHammerTransform(_GeoTransform):\n\n        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            z = np.sqrt(1 - (x / 4) ** 2 - (y / 2) ** 2)\n            longitude = 2 * np.arctan((z * x) / (2 * (2 * z ** 2 - 1)))\n            latitude = np.arcsin(y*z)\n            return np.column_stack([longitude, latitude])\n\n        def inverted(self):\n            # docstring inherited\n            return HammerAxes.HammerTransform(self._resolution)\n\n    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        super().__init__(*args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.clear()\n\n    def _get_core_transform(self, resolution):\n        return self.HammerTransform(resolution)",
      "instance_attributes": [
        {
          "name": "_longitude_cap",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes",
      "name": "LambertAxes",
      "qname": "lib.matplotlib.projections.geo.LambertAxes",
      "decorators": [],
      "superclasses": [
        "GeoAxes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__",
        "matplotlib/lib.matplotlib.projections.geo/LambertAxes/clear",
        "matplotlib/lib.matplotlib.projections.geo/LambertAxes/_get_core_transform",
        "matplotlib/lib.matplotlib.projections.geo/LambertAxes/_get_affine_transform"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class LambertAxes(GeoAxes):\n    name = 'lambert'\n\n    class LambertTransform(_GeoTransform):\n        \"\"\"The base Lambert transform.\"\"\"\n\n        def __init__(self, center_longitude, center_latitude, resolution):\n            \"\"\"\n            Create a new Lambert transform.  Resolution is the number of steps\n            to interpolate between each input line segment to approximate its\n            path in curved Lambert space.\n            \"\"\"\n            _GeoTransform.__init__(self, resolution)\n            self._center_longitude = center_longitude\n            self._center_latitude = center_latitude\n\n        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n            clong = self._center_longitude\n            clat = self._center_latitude\n            cos_lat = np.cos(latitude)\n            sin_lat = np.sin(latitude)\n            diff_long = longitude - clong\n            cos_diff_long = np.cos(diff_long)\n\n            inner_k = np.maximum(  # Prevent divide-by-zero problems\n                1 + np.sin(clat)*sin_lat + np.cos(clat)*cos_lat*cos_diff_long,\n                1e-15)\n            k = np.sqrt(2 / inner_k)\n            x = k * cos_lat*np.sin(diff_long)\n            y = k * (np.cos(clat)*sin_lat - np.sin(clat)*cos_lat*cos_diff_long)\n\n            return np.column_stack([x, y])\n\n        def inverted(self):\n            # docstring inherited\n            return LambertAxes.InvertedLambertTransform(\n                self._center_longitude,\n                self._center_latitude,\n                self._resolution)\n\n    class InvertedLambertTransform(_GeoTransform):\n\n        def __init__(self, center_longitude, center_latitude, resolution):\n            _GeoTransform.__init__(self, resolution)\n            self._center_longitude = center_longitude\n            self._center_latitude = center_latitude\n\n        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            clong = self._center_longitude\n            clat = self._center_latitude\n            p = np.maximum(np.hypot(x, y), 1e-9)\n            c = 2 * np.arcsin(0.5 * p)\n            sin_c = np.sin(c)\n            cos_c = np.cos(c)\n\n            latitude = np.arcsin(cos_c*np.sin(clat) +\n                                 ((y*sin_c*np.cos(clat)) / p))\n            longitude = clong + np.arctan(\n                (x*sin_c) / (p*np.cos(clat)*cos_c - y*np.sin(clat)*sin_c))\n\n            return np.column_stack([longitude, latitude])\n\n        def inverted(self):\n            # docstring inherited\n            return LambertAxes.LambertTransform(\n                self._center_longitude,\n                self._center_latitude,\n                self._resolution)\n\n    def __init__(self, *args, center_longitude=0, center_latitude=0, **kwargs):\n        self._longitude_cap = np.pi / 2\n        self._center_longitude = center_longitude\n        self._center_latitude = center_latitude\n        super().__init__(*args, **kwargs)\n        self.set_aspect('equal', adjustable='box', anchor='C')\n        self.clear()\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n        self.yaxis.set_major_formatter(NullFormatter())\n\n    def _get_core_transform(self, resolution):\n        return self.LambertTransform(\n            self._center_longitude,\n            self._center_latitude,\n            resolution)\n\n    def _get_affine_transform(self):\n        return Affine2D() \\\n            .scale(0.25) \\\n            .translate(0.5, 0.5)",
      "instance_attributes": [
        {
          "name": "_longitude_cap",
          "types": null
        },
        {
          "name": "_center_longitude",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_center_latitude",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes",
      "name": "MollweideAxes",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes",
      "decorators": [],
      "superclasses": [
        "GeoAxes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__",
        "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/_get_core_transform"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class MollweideAxes(GeoAxes):\n    name = 'mollweide'\n\n    class MollweideTransform(_GeoTransform):\n        \"\"\"The base Mollweide transform.\"\"\"\n\n        def transform_non_affine(self, ll):\n            # docstring inherited\n            def d(theta):\n                delta = (-(theta + np.sin(theta) - pi_sin_l)\n                         / (1 + np.cos(theta)))\n                return delta, np.abs(delta) > 0.001\n\n            longitude, latitude = ll.T\n\n            clat = np.pi/2 - np.abs(latitude)\n            ihigh = clat < 0.087  # within 5 degrees of the poles\n            ilow = ~ihigh\n            aux = np.empty(latitude.shape, dtype=float)\n\n            if ilow.any():  # Newton-Raphson iteration\n                pi_sin_l = np.pi * np.sin(latitude[ilow])\n                theta = 2.0 * latitude[ilow]\n                delta, large_delta = d(theta)\n                while np.any(large_delta):\n                    theta[large_delta] += delta[large_delta]\n                    delta, large_delta = d(theta)\n                aux[ilow] = theta / 2\n\n            if ihigh.any():  # Taylor series-based approx. solution\n                e = clat[ihigh]\n                d = 0.5 * (3 * np.pi * e**2) ** (1.0/3)\n                aux[ihigh] = (np.pi/2 - d) * np.sign(latitude[ihigh])\n\n            xy = np.empty(ll.shape, dtype=float)\n            xy[:, 0] = (2.0 * np.sqrt(2.0) / np.pi) * longitude * np.cos(aux)\n            xy[:, 1] = np.sqrt(2.0) * np.sin(aux)\n\n            return xy\n\n        def inverted(self):\n            # docstring inherited\n            return MollweideAxes.InvertedMollweideTransform(self._resolution)\n\n    class InvertedMollweideTransform(_GeoTransform):\n\n        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            # from Equations (7, 8) of\n            # https://mathworld.wolfram.com/MollweideProjection.html\n            theta = np.arcsin(y / np.sqrt(2))\n            longitude = (np.pi / (2 * np.sqrt(2))) * x / np.cos(theta)\n            latitude = np.arcsin((2 * theta + np.sin(2 * theta)) / np.pi)\n            return np.column_stack([longitude, latitude])\n\n        def inverted(self):\n            # docstring inherited\n            return MollweideAxes.MollweideTransform(self._resolution)\n\n    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        super().__init__(*args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.clear()\n\n    def _get_core_transform(self, resolution):\n        return self.MollweideTransform(resolution)",
      "instance_attributes": [
        {
          "name": "_longitude_cap",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform",
      "name": "InvertedPolarTransform",
      "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform",
      "decorators": [],
      "superclasses": [
        "mtransforms.Transform"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__",
        "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/transform_non_affine",
        "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/inverted"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The inverse of the polar transform, mapping Cartesian\ncoordinate space *x* and *y* back to *theta* and *r*.",
      "docstring": "The inverse of the polar transform, mapping Cartesian\ncoordinate space *x* and *y* back to *theta* and *r*.",
      "code": "class InvertedPolarTransform(mtransforms.Transform):\n    \"\"\"\n    The inverse of the polar transform, mapping Cartesian\n    coordinate space *x* and *y* back to *theta* and *r*.\n    \"\"\"\n    input_dims = output_dims = 2\n\n    def __init__(self, axis=None, use_rmin=True,\n                 _apply_theta_transforms=True):\n        super().__init__()\n        self._axis = axis\n        self._use_rmin = use_rmin\n        self._apply_theta_transforms = _apply_theta_transforms\n\n    __str__ = mtransforms._make_str_method(\n        \"_axis\",\n        use_rmin=\"_use_rmin\",\n        _apply_theta_transforms=\"_apply_theta_transforms\")\n\n    def transform_non_affine(self, xy):\n        # docstring inherited\n        x, y = xy.T\n        r = np.hypot(x, y)\n        theta = (np.arctan2(y, x) + 2 * np.pi) % (2 * np.pi)\n        # PolarAxes does not use the theta transforms here, but apply them for\n        # backwards-compatibility if not being used by it.\n        if self._apply_theta_transforms and self._axis is not None:\n            theta -= self._axis.get_theta_offset()\n            theta *= self._axis.get_theta_direction()\n            theta %= 2 * np.pi\n        if self._use_rmin and self._axis is not None:\n            r += self._axis.get_rorigin()\n            r *= self._axis.get_rsign()\n        return np.column_stack([theta, r])\n\n    def inverted(self):\n        # docstring inherited\n        return PolarAxes.PolarTransform(self._axis, self._use_rmin,\n                                        self._apply_theta_transforms)",
      "instance_attributes": [
        {
          "name": "_axis",
          "types": null
        },
        {
          "name": "_use_rmin",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_apply_theta_transforms",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine",
      "name": "PolarAffine",
      "qname": "lib.matplotlib.projections.polar.PolarAffine",
      "decorators": [],
      "superclasses": [
        "mtransforms.Affine2DBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__",
        "matplotlib/lib.matplotlib.projections.polar/PolarAffine/get_matrix"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The affine part of the polar projection.  Scales the output so\nthat maximum radius rests on the edge of the axes circle.",
      "docstring": "The affine part of the polar projection.  Scales the output so\nthat maximum radius rests on the edge of the axes circle.",
      "code": "class PolarAffine(mtransforms.Affine2DBase):\n    \"\"\"\n    The affine part of the polar projection.  Scales the output so\n    that maximum radius rests on the edge of the axes circle.\n    \"\"\"\n    def __init__(self, scale_transform, limits):\n        \"\"\"\n        *limits* is the view limit of the data.  The only part of\n        its bounds that is used is the y limits (for the radius limits).\n        The theta range is handled by the non-affine transform.\n        \"\"\"\n        super().__init__()\n        self._scale_transform = scale_transform\n        self._limits = limits\n        self.set_children(scale_transform, limits)\n        self._mtx = None\n\n    __str__ = mtransforms._make_str_method(\"_scale_transform\", \"_limits\")\n\n    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            limits_scaled = self._limits.transformed(self._scale_transform)\n            yscale = limits_scaled.ymax - limits_scaled.ymin\n            affine = mtransforms.Affine2D() \\\n                .scale(0.5 / yscale) \\\n                .translate(0.5, 0.5)\n            self._mtx = affine.get_matrix()\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
      "instance_attributes": [
        {
          "name": "_scale_transform",
          "types": null
        },
        {
          "name": "_limits",
          "types": null
        },
        {
          "name": "_mtx",
          "types": null
        },
        {
          "name": "_inverted",
          "types": null
        },
        {
          "name": "_invalid",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes",
      "name": "PolarAxes",
      "qname": "lib.matplotlib.projections.polar.PolarAxes",
      "decorators": [],
      "superclasses": [
        "Axes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/clear",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/_init_axis",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/_set_lim_and_transforms",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text1_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text2_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text1_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text2_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/_gen_axes_patch",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/_gen_axes_spines",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamax",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamax",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_offset",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_offset",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_direction",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_direction",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmax",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmax",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rorigin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rorigin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rsign",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rlabel_position",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlabel_position",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_data_ratio",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_zoom",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_pan",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/end_pan",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A polar graph projection, where the input dimensions are *theta*, *r*.\n\nTheta starts pointing east and goes anti-clockwise.",
      "docstring": "A polar graph projection, where the input dimensions are *theta*, *r*.\n\nTheta starts pointing east and goes anti-clockwise.",
      "code": "class PolarAxes(Axes):\n    \"\"\"\n    A polar graph projection, where the input dimensions are *theta*, *r*.\n\n    Theta starts pointing east and goes anti-clockwise.\n    \"\"\"\n    name = 'polar'\n\n    def __init__(self, *args,\n                 theta_offset=0, theta_direction=1, rlabel_position=22.5,\n                 **kwargs):\n        # docstring inherited\n        self._default_theta_offset = theta_offset\n        self._default_theta_direction = theta_direction\n        self._default_rlabel_position = np.deg2rad(rlabel_position)\n        super().__init__(*args, **kwargs)\n        self.use_sticky_edges = True\n        self.set_aspect('equal', adjustable='box', anchor='C')\n        self.clear()\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n\n        self.title.set_y(1.05)\n\n        start = self.spines.get('start', None)\n        if start:\n            start.set_visible(False)\n        end = self.spines.get('end', None)\n        if end:\n            end.set_visible(False)\n        self.set_xlim(0.0, 2 * np.pi)\n\n        self.grid(mpl.rcParams['polaraxes.grid'])\n        inner = self.spines.get('inner', None)\n        if inner:\n            inner.set_visible(False)\n\n        self.set_rorigin(None)\n        self.set_theta_offset(self._default_theta_offset)\n        self.set_theta_direction(self._default_theta_direction)\n\n    def _init_axis(self):\n        # This is moved out of __init__ because non-separable axes don't use it\n        self.xaxis = ThetaAxis(self)\n        self.yaxis = RadialAxis(self)\n        # Calling polar_axes.xaxis.clear() or polar_axes.xaxis.clear()\n        # results in weird artifacts. Therefore we disable this for\n        # now.\n        # self.spines['polar'].register_axis(self.yaxis)\n        self._update_transScale()\n\n    def _set_lim_and_transforms(self):\n        # A view limit where the minimum radius can be locked if the user\n        # specifies an alternate origin.\n        self._originViewLim = mtransforms.LockableBbox(self.viewLim)\n\n        # Handle angular offset and direction.\n        self._direction = mtransforms.Affine2D() \\\n            .scale(self._default_theta_direction, 1.0)\n        self._theta_offset = mtransforms.Affine2D() \\\n            .translate(self._default_theta_offset, 0.0)\n        self.transShift = self._direction + self._theta_offset\n        # A view limit shifted to the correct location after accounting for\n        # orientation and offset.\n        self._realViewLim = mtransforms.TransformedBbox(self.viewLim,\n                                                        self.transShift)\n\n        # Transforms the x and y axis separately by a scale factor\n        # It is assumed that this part will have non-linear components\n        self.transScale = mtransforms.TransformWrapper(\n            mtransforms.IdentityTransform())\n\n        # Scale view limit into a bbox around the selected wedge. This may be\n        # smaller than the usual unit axes rectangle if not plotting the full\n        # circle.\n        self.axesLim = _WedgeBbox((0.5, 0.5),\n                                  self._realViewLim, self._originViewLim)\n\n        # Scale the wedge to fill the axes.\n        self.transWedge = mtransforms.BboxTransformFrom(self.axesLim)\n\n        # Scale the axes to fill the figure.\n        self.transAxes = mtransforms.BboxTransformTo(self.bbox)\n\n        # A (possibly non-linear) projection on the (already scaled)\n        # data.  This one is aware of rmin\n        self.transProjection = self.PolarTransform(\n            self,\n            _apply_theta_transforms=False)\n        # Add dependency on rorigin.\n        self.transProjection.set_children(self._originViewLim)\n\n        # An affine transformation on the data, generally to limit the\n        # range of the axes\n        self.transProjectionAffine = self.PolarAffine(self.transScale,\n                                                      self._originViewLim)\n\n        # The complete data transformation stack -- from data all the\n        # way to display coordinates\n        self.transData = (\n            self.transScale + self.transShift + self.transProjection +\n            (self.transProjectionAffine + self.transWedge + self.transAxes))\n\n        # This is the transform for theta-axis ticks.  It is\n        # equivalent to transData, except it always puts r == 0.0 and r == 1.0\n        # at the edge of the axis circles.\n        self._xaxis_transform = (\n            mtransforms.blended_transform_factory(\n                mtransforms.IdentityTransform(),\n                mtransforms.BboxTransformTo(self.viewLim)) +\n            self.transData)\n        # The theta labels are flipped along the radius, so that text 1 is on\n        # the outside by default. This should work the same as before.\n        flipr_transform = mtransforms.Affine2D() \\\n            .translate(0.0, -0.5) \\\n            .scale(1.0, -1.0) \\\n            .translate(0.0, 0.5)\n        self._xaxis_text_transform = flipr_transform + self._xaxis_transform\n\n        # This is the transform for r-axis ticks.  It scales the theta\n        # axis so the gridlines from 0.0 to 1.0, now go from thetamin to\n        # thetamax.\n        self._yaxis_transform = (\n            mtransforms.blended_transform_factory(\n                mtransforms.BboxTransformTo(self.viewLim),\n                mtransforms.IdentityTransform()) +\n            self.transData)\n        # The r-axis labels are put at an angle and padded in the r-direction\n        self._r_label_position = mtransforms.Affine2D() \\\n            .translate(self._default_rlabel_position, 0.0)\n        self._yaxis_text_transform = mtransforms.TransformWrapper(\n            self._r_label_position + self.transData)\n\n    def get_xaxis_transform(self, which='grid'):\n        _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._xaxis_transform\n\n    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'\n\n    def get_xaxis_text2_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'\n\n    def get_yaxis_transform(self, which='grid'):\n        if which in ('tick1', 'tick2'):\n            return self._yaxis_text_transform\n        elif which == 'grid':\n            return self._yaxis_transform\n        else:\n            _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)\n\n    def get_yaxis_text1_transform(self, pad):\n        thetamin, thetamax = self._realViewLim.intervalx\n        if _is_full_circle_rad(thetamin, thetamax):\n            return self._yaxis_text_transform, 'bottom', 'left'\n        elif self.get_theta_direction() > 0:\n            halign = 'left'\n            pad_shift = _ThetaShift(self, pad, 'min')\n        else:\n            halign = 'right'\n            pad_shift = _ThetaShift(self, pad, 'max')\n        return self._yaxis_text_transform + pad_shift, 'center', halign\n\n    def get_yaxis_text2_transform(self, pad):\n        if self.get_theta_direction() > 0:\n            halign = 'right'\n            pad_shift = _ThetaShift(self, pad, 'max')\n        else:\n            halign = 'left'\n            pad_shift = _ThetaShift(self, pad, 'min')\n        return self._yaxis_text_transform + pad_shift, 'center', halign\n\n    def draw(self, renderer):\n        self._unstale_viewLim()\n        thetamin, thetamax = np.rad2deg(self._realViewLim.intervalx)\n        if thetamin > thetamax:\n            thetamin, thetamax = thetamax, thetamin\n        rmin, rmax = ((self._realViewLim.intervaly - self.get_rorigin()) *\n                      self.get_rsign())\n        if isinstance(self.patch, mpatches.Wedge):\n            # Backwards-compatibility: Any subclassed Axes might override the\n            # patch to not be the Wedge that PolarAxes uses.\n            center = self.transWedge.transform((0.5, 0.5))\n            self.patch.set_center(center)\n            self.patch.set_theta1(thetamin)\n            self.patch.set_theta2(thetamax)\n\n            edge, _ = self.transWedge.transform((1, 0))\n            radius = edge - center[0]\n            width = min(radius * (rmax - rmin) / rmax, radius)\n            self.patch.set_radius(radius)\n            self.patch.set_width(width)\n\n            inner_width = radius - width\n            inner = self.spines.get('inner', None)\n            if inner:\n                inner.set_visible(inner_width != 0.0)\n\n        visible = not _is_full_circle_deg(thetamin, thetamax)\n        # For backwards compatibility, any subclassed Axes might override the\n        # spines to not include start/end that PolarAxes uses.\n        start = self.spines.get('start', None)\n        end = self.spines.get('end', None)\n        if start:\n            start.set_visible(visible)\n        if end:\n            end.set_visible(visible)\n        if visible:\n            yaxis_text_transform = self._yaxis_transform\n        else:\n            yaxis_text_transform = self._r_label_position + self.transData\n        if self._yaxis_text_transform != yaxis_text_transform:\n            self._yaxis_text_transform.set(yaxis_text_transform)\n            self.yaxis.reset_ticks()\n            self.yaxis.set_clip_path(self.patch)\n\n        super().draw(renderer)\n\n    def _gen_axes_patch(self):\n        return mpatches.Wedge((0.5, 0.5), 0.5, 0.0, 360.0)\n\n    def _gen_axes_spines(self):\n        spines = {\n            'polar': Spine.arc_spine(self, 'top', (0.5, 0.5), 0.5, 0, 360),\n            'start': Spine.linear_spine(self, 'left'),\n            'end': Spine.linear_spine(self, 'right'),\n            'inner': Spine.arc_spine(self, 'bottom', (0.5, 0.5), 0.0, 0, 360),\n        }\n        spines['polar'].set_transform(self.transWedge + self.transAxes)\n        spines['inner'].set_transform(self.transWedge + self.transAxes)\n        spines['start'].set_transform(self._yaxis_transform)\n        spines['end'].set_transform(self._yaxis_transform)\n        return spines\n\n    def set_thetamax(self, thetamax):\n        \"\"\"Set the maximum theta limit in degrees.\"\"\"\n        self.viewLim.x1 = np.deg2rad(thetamax)\n\n    def get_thetamax(self):\n        \"\"\"Return the maximum theta limit in degrees.\"\"\"\n        return np.rad2deg(self.viewLim.xmax)\n\n    def set_thetamin(self, thetamin):\n        \"\"\"Set the minimum theta limit in degrees.\"\"\"\n        self.viewLim.x0 = np.deg2rad(thetamin)\n\n    def get_thetamin(self):\n        \"\"\"Get the minimum theta limit in degrees.\"\"\"\n        return np.rad2deg(self.viewLim.xmin)\n\n    def set_thetalim(self, *args, **kwargs):\n        r\"\"\"\n        Set the minimum and maximum theta values.\n\n        Can take the following signatures:\n\n        - ``set_thetalim(minval, maxval)``: Set the limits in radians.\n        - ``set_thetalim(thetamin=minval, thetamax=maxval)``: Set the limits\n          in degrees.\n\n        where minval and maxval are the minimum and maximum limits. Values are\n        wrapped in to the range :math:`[0, 2\\pi]` (in radians), so for example\n        it is possible to do ``set_thetalim(-np.pi / 2, np.pi / 2)`` to have\n        an axis symmetric around 0. A ValueError is raised if the absolute\n        angle difference is larger than a full circle.\n        \"\"\"\n        orig_lim = self.get_xlim()  # in radians\n        if 'thetamin' in kwargs:\n            kwargs['xmin'] = np.deg2rad(kwargs.pop('thetamin'))\n        if 'thetamax' in kwargs:\n            kwargs['xmax'] = np.deg2rad(kwargs.pop('thetamax'))\n        new_min, new_max = self.set_xlim(*args, **kwargs)\n        # Parsing all permutations of *args, **kwargs is tricky; it is simpler\n        # to let set_xlim() do it and then validate the limits.\n        if abs(new_max - new_min) > 2 * np.pi:\n            self.set_xlim(orig_lim)  # un-accept the change\n            raise ValueError(\"The angle range must be less than a full circle\")\n        return tuple(np.rad2deg((new_min, new_max)))\n\n    def set_theta_offset(self, offset):\n        \"\"\"\n        Set the offset for the location of 0 in radians.\n        \"\"\"\n        mtx = self._theta_offset.get_matrix()\n        mtx[0, 2] = offset\n        self._theta_offset.invalidate()\n\n    def get_theta_offset(self):\n        \"\"\"\n        Get the offset for the location of 0 in radians.\n        \"\"\"\n        return self._theta_offset.get_matrix()[0, 2]\n\n    def set_theta_zero_location(self, loc, offset=0.0):\n        \"\"\"\n        Set the location of theta's zero.\n\n        This simply calls `set_theta_offset` with the correct value in radians.\n\n        Parameters\n        ----------\n        loc : str\n            May be one of \"N\", \"NW\", \"W\", \"SW\", \"S\", \"SE\", \"E\", or \"NE\".\n        offset : float, default: 0\n            An offset in degrees to apply from the specified *loc*. **Note:**\n            this offset is *always* applied counter-clockwise regardless of\n            the direction setting.\n        \"\"\"\n        mapping = {\n            'N': np.pi * 0.5,\n            'NW': np.pi * 0.75,\n            'W': np.pi,\n            'SW': np.pi * 1.25,\n            'S': np.pi * 1.5,\n            'SE': np.pi * 1.75,\n            'E': 0,\n            'NE': np.pi * 0.25}\n        return self.set_theta_offset(mapping[loc] + np.deg2rad(offset))\n\n    def set_theta_direction(self, direction):\n        \"\"\"\n        Set the direction in which theta increases.\n\n        clockwise, -1:\n           Theta increases in the clockwise direction\n\n        counterclockwise, anticlockwise, 1:\n           Theta increases in the counterclockwise direction\n        \"\"\"\n        mtx = self._direction.get_matrix()\n        if direction in ('clockwise', -1):\n            mtx[0, 0] = -1\n        elif direction in ('counterclockwise', 'anticlockwise', 1):\n            mtx[0, 0] = 1\n        else:\n            _api.check_in_list(\n                [-1, 1, 'clockwise', 'counterclockwise', 'anticlockwise'],\n                direction=direction)\n        self._direction.invalidate()\n\n    def get_theta_direction(self):\n        \"\"\"\n        Get the direction in which theta increases.\n\n        -1:\n           Theta increases in the clockwise direction\n\n        1:\n           Theta increases in the counterclockwise direction\n        \"\"\"\n        return self._direction.get_matrix()[0, 0]\n\n    def set_rmax(self, rmax):\n        \"\"\"\n        Set the outer radial limit.\n\n        Parameters\n        ----------\n        rmax : float\n        \"\"\"\n        self.viewLim.y1 = rmax\n\n    def get_rmax(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            Outer radial limit.\n        \"\"\"\n        return self.viewLim.ymax\n\n    def set_rmin(self, rmin):\n        \"\"\"\n        Set the inner radial limit.\n\n        Parameters\n        ----------\n        rmin : float\n        \"\"\"\n        self.viewLim.y0 = rmin\n\n    def get_rmin(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The inner radial limit.\n        \"\"\"\n        return self.viewLim.ymin\n\n    def set_rorigin(self, rorigin):\n        \"\"\"\n        Update the radial origin.\n\n        Parameters\n        ----------\n        rorigin : float\n        \"\"\"\n        self._originViewLim.locked_y0 = rorigin\n\n    def get_rorigin(self):\n        \"\"\"\n        Returns\n        -------\n        float\n        \"\"\"\n        return self._originViewLim.y0\n\n    def get_rsign(self):\n        return np.sign(self._originViewLim.y1 - self._originViewLim.y0)\n\n    @_api.make_keyword_only(\"3.6\", \"emit\")\n    def set_rlim(self, bottom=None, top=None, emit=True, auto=False, **kwargs):\n        \"\"\"\n        Set the radial axis view limits.\n\n        This function behaves like `.Axes.set_ylim`, but additionally supports\n        *rmin* and *rmax* as aliases for *bottom* and *top*.\n\n        See Also\n        --------\n        .Axes.set_ylim\n        \"\"\"\n        if 'rmin' in kwargs:\n            if bottom is None:\n                bottom = kwargs.pop('rmin')\n            else:\n                raise ValueError('Cannot supply both positional \"bottom\"'\n                                 'argument and kwarg \"rmin\"')\n        if 'rmax' in kwargs:\n            if top is None:\n                top = kwargs.pop('rmax')\n            else:\n                raise ValueError('Cannot supply both positional \"top\"'\n                                 'argument and kwarg \"rmax\"')\n        return self.set_ylim(bottom=bottom, top=top, emit=emit, auto=auto,\n                             **kwargs)\n\n    def get_rlabel_position(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The theta position of the radius labels in degrees.\n        \"\"\"\n        return np.rad2deg(self._r_label_position.get_matrix()[0, 2])\n\n    def set_rlabel_position(self, value):\n        \"\"\"\n        Update the theta position of the radius labels.\n\n        Parameters\n        ----------\n        value : number\n            The angular position of the radius labels in degrees.\n        \"\"\"\n        self._r_label_position.clear().translate(np.deg2rad(value), 0.0)\n\n    def set_yscale(self, *args, **kwargs):\n        super().set_yscale(*args, **kwargs)\n        self.yaxis.set_major_locator(\n            self.RadialLocator(self.yaxis.get_major_locator(), self))\n\n    def set_rscale(self, *args, **kwargs):\n        return Axes.set_yscale(self, *args, **kwargs)\n\n    def set_rticks(self, *args, **kwargs):\n        return Axes.set_yticks(self, *args, **kwargs)\n\n    def set_thetagrids(self, angles, labels=None, fmt=None, **kwargs):\n        \"\"\"\n        Set the theta gridlines in a polar plot.\n\n        Parameters\n        ----------\n        angles : tuple with floats, degrees\n            The angles of the theta gridlines.\n\n        labels : tuple with strings or None\n            The labels to use at each theta gridline. The\n            `.projections.polar.ThetaFormatter` will be used if None.\n\n        fmt : str or None\n            Format string used in `matplotlib.ticker.FormatStrFormatter`.\n            For example '%f'. Note that the angle that is used is in\n            radians.\n\n        Returns\n        -------\n        lines : list of `.lines.Line2D`\n            The theta gridlines.\n\n        labels : list of `.text.Text`\n            The tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            *kwargs* are optional `.Text` properties for the labels.\n\n        See Also\n        --------\n        .PolarAxes.set_rgrids\n        .Axis.get_gridlines\n        .Axis.get_ticklabels\n        \"\"\"\n\n        # Make sure we take into account unitized data\n        angles = self.convert_yunits(angles)\n        angles = np.deg2rad(angles)\n        self.set_xticks(angles)\n        if labels is not None:\n            self.set_xticklabels(labels)\n        elif fmt is not None:\n            self.xaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))\n        for t in self.xaxis.get_ticklabels():\n            t._internal_update(kwargs)\n        return self.xaxis.get_ticklines(), self.xaxis.get_ticklabels()\n\n    def set_rgrids(self, radii, labels=None, angle=None, fmt=None, **kwargs):\n        \"\"\"\n        Set the radial gridlines on a polar plot.\n\n        Parameters\n        ----------\n        radii : tuple with floats\n            The radii for the radial gridlines\n\n        labels : tuple with strings or None\n            The labels to use at each radial gridline. The\n            `matplotlib.ticker.ScalarFormatter` will be used if None.\n\n        angle : float\n            The angular position of the radius labels in degrees.\n\n        fmt : str or None\n            Format string used in `matplotlib.ticker.FormatStrFormatter`.\n            For example '%f'.\n\n        Returns\n        -------\n        lines : list of `.lines.Line2D`\n            The radial gridlines.\n\n        labels : list of `.text.Text`\n            The tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            *kwargs* are optional `.Text` properties for the labels.\n\n        See Also\n        --------\n        .PolarAxes.set_thetagrids\n        .Axis.get_gridlines\n        .Axis.get_ticklabels\n        \"\"\"\n        # Make sure we take into account unitized data\n        radii = self.convert_xunits(radii)\n        radii = np.asarray(radii)\n\n        self.set_yticks(radii)\n        if labels is not None:\n            self.set_yticklabels(labels)\n        elif fmt is not None:\n            self.yaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))\n        if angle is None:\n            angle = self.get_rlabel_position()\n        self.set_rlabel_position(angle)\n        for t in self.yaxis.get_ticklabels():\n            t._internal_update(kwargs)\n        return self.yaxis.get_gridlines(), self.yaxis.get_ticklabels()\n\n    def format_coord(self, theta, r):\n        # docstring inherited\n        screen_xy = self.transData.transform((theta, r))\n        screen_xys = screen_xy + np.stack(\n            np.meshgrid([-1, 0, 1], [-1, 0, 1])).reshape((2, -1)).T\n        ts, rs = self.transData.inverted().transform(screen_xys).T\n        delta_t = abs((ts - theta + np.pi) % (2 * np.pi) - np.pi).max()\n        delta_t_halfturns = delta_t / np.pi\n        delta_t_degrees = delta_t_halfturns * 180\n        delta_r = abs(rs - r).max()\n        if theta < 0:\n            theta += 2 * np.pi\n        theta_halfturns = theta / np.pi\n        theta_degrees = theta_halfturns * 180\n\n        # See ScalarFormatter.format_data_short.  For r, use #g-formatting\n        # (as for linear axes), but for theta, use f-formatting as scientific\n        # notation doesn't make sense and the trailing dot is ugly.\n        def format_sig(value, delta, opt, fmt):\n            # For \"f\", only count digits after decimal point.\n            prec = (max(0, -math.floor(math.log10(delta))) if fmt == \"f\" else\n                    cbook._g_sig_digits(value, delta))\n            return f\"{value:-{opt}.{prec}{fmt}}\"\n\n        return ('\\N{GREEK SMALL LETTER THETA}={}\\N{GREEK SMALL LETTER PI} '\n                '({}\\N{DEGREE SIGN}), r={}').format(\n                    format_sig(theta_halfturns, delta_t_halfturns, \"\", \"f\"),\n                    format_sig(theta_degrees, delta_t_degrees, \"\", \"f\"),\n                    format_sig(r, delta_r, \"#\", \"g\"),\n                )\n\n    def get_data_ratio(self):\n        \"\"\"\n        Return the aspect ratio of the data itself.  For a polar plot,\n        this should always be 1.0\n        \"\"\"\n        return 1.0\n\n    # # # Interactive panning\n\n    def can_zoom(self):\n        \"\"\"\n        Return whether this axes supports the zoom box button functionality.\n\n        Polar axes do not support zoom boxes.\n        \"\"\"\n        return False\n\n    def can_pan(self):\n        \"\"\"\n        Return whether this axes supports the pan/zoom button functionality.\n\n        For polar axes, this is slightly misleading. Both panning and\n        zooming are performed by the same button. Panning is performed\n        in azimuth while zooming is done along the radial.\n        \"\"\"\n        return True\n\n    def start_pan(self, x, y, button):\n        angle = np.deg2rad(self.get_rlabel_position())\n        mode = ''\n        if button == 1:\n            epsilon = np.pi / 45.0\n            t, r = self.transData.inverted().transform((x, y))\n            if angle - epsilon <= t <= angle + epsilon:\n                mode = 'drag_r_labels'\n        elif button == 3:\n            mode = 'zoom'\n\n        self._pan_start = types.SimpleNamespace(\n            rmax=self.get_rmax(),\n            trans=self.transData.frozen(),\n            trans_inverse=self.transData.inverted().frozen(),\n            r_label_angle=self.get_rlabel_position(),\n            x=x,\n            y=y,\n            mode=mode)\n\n    def end_pan(self):\n        del self._pan_start\n\n    def drag_pan(self, button, key, x, y):\n        p = self._pan_start\n\n        if p.mode == 'drag_r_labels':\n            (startt, startr), (t, r) = p.trans_inverse.transform(\n                [(p.x, p.y), (x, y)])\n\n            # Deal with theta\n            dt = np.rad2deg(startt - t)\n            self.set_rlabel_position(p.r_label_angle - dt)\n\n            trans, vert1, horiz1 = self.get_yaxis_text1_transform(0.0)\n            trans, vert2, horiz2 = self.get_yaxis_text2_transform(0.0)\n            for t in self.yaxis.majorTicks + self.yaxis.minorTicks:\n                t.label1.set_va(vert1)\n                t.label1.set_ha(horiz1)\n                t.label2.set_va(vert2)\n                t.label2.set_ha(horiz2)\n\n        elif p.mode == 'zoom':\n            (startt, startr), (t, r) = p.trans_inverse.transform(\n                [(p.x, p.y), (x, y)])\n\n            # Deal with r\n            scale = r / startr\n            self.set_rmax(p.rmax / scale)",
      "instance_attributes": [
        {
          "name": "_default_theta_offset",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_default_theta_direction",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_default_rlabel_position",
          "types": null
        },
        {
          "name": "use_sticky_edges",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "xaxis",
          "types": {
            "kind": "NamedType",
            "name": "ThetaAxis"
          }
        },
        {
          "name": "yaxis",
          "types": {
            "kind": "NamedType",
            "name": "RadialAxis"
          }
        },
        {
          "name": "_originViewLim",
          "types": null
        },
        {
          "name": "_direction",
          "types": null
        },
        {
          "name": "_theta_offset",
          "types": null
        },
        {
          "name": "transShift",
          "types": null
        },
        {
          "name": "_realViewLim",
          "types": null
        },
        {
          "name": "transScale",
          "types": null
        },
        {
          "name": "axesLim",
          "types": {
            "kind": "NamedType",
            "name": "_WedgeBbox"
          }
        },
        {
          "name": "transWedge",
          "types": null
        },
        {
          "name": "transAxes",
          "types": null
        },
        {
          "name": "transProjection",
          "types": {
            "kind": "NamedType",
            "name": "PolarTransform"
          }
        },
        {
          "name": "transProjectionAffine",
          "types": {
            "kind": "NamedType",
            "name": "PolarAffine"
          }
        },
        {
          "name": "transData",
          "types": null
        },
        {
          "name": "_xaxis_transform",
          "types": null
        },
        {
          "name": "_xaxis_text_transform",
          "types": null
        },
        {
          "name": "_yaxis_transform",
          "types": null
        },
        {
          "name": "_r_label_position",
          "types": null
        },
        {
          "name": "_yaxis_text_transform",
          "types": null
        },
        {
          "name": "_pan_start",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform",
      "name": "PolarTransform",
      "qname": "lib.matplotlib.projections.polar.PolarTransform",
      "decorators": [],
      "superclasses": [
        "mtransforms.Transform"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__",
        "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_non_affine",
        "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_path_non_affine",
        "matplotlib/lib.matplotlib.projections.polar/PolarTransform/inverted"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The base polar transform.\n\nThis transform maps polar coordinates ``(theta, r)`` into Cartesian\ncoordinates ``(x, y) = (r * cos(theta), r * sin(theta))`` (but does not\nhandle positioning in screen space).\n\nPath segments at a fixed radius are automatically transformed to circular\narcs as long as ``path._interpolation_steps > 1``.",
      "docstring": "The base polar transform.\n\nThis transform maps polar coordinates ``(theta, r)`` into Cartesian\ncoordinates ``(x, y) = (r * cos(theta), r * sin(theta))`` (but does not\nhandle positioning in screen space).\n\nPath segments at a fixed radius are automatically transformed to circular\narcs as long as ``path._interpolation_steps > 1``.",
      "code": "class PolarTransform(mtransforms.Transform):\n    \"\"\"\n    The base polar transform.\n\n    This transform maps polar coordinates ``(theta, r)`` into Cartesian\n    coordinates ``(x, y) = (r * cos(theta), r * sin(theta))`` (but does not\n    handle positioning in screen space).\n\n    Path segments at a fixed radius are automatically transformed to circular\n    arcs as long as ``path._interpolation_steps > 1``.\n    \"\"\"\n\n    input_dims = output_dims = 2\n\n    def __init__(self, axis=None, use_rmin=True,\n                 _apply_theta_transforms=True):\n        super().__init__()\n        self._axis = axis\n        self._use_rmin = use_rmin\n        self._apply_theta_transforms = _apply_theta_transforms\n\n    __str__ = mtransforms._make_str_method(\n        \"_axis\",\n        use_rmin=\"_use_rmin\",\n        _apply_theta_transforms=\"_apply_theta_transforms\")\n\n    def transform_non_affine(self, tr):\n        # docstring inherited\n        t, r = np.transpose(tr)\n        # PolarAxes does not use the theta transforms here, but apply them for\n        # backwards-compatibility if not being used by it.\n        if self._apply_theta_transforms and self._axis is not None:\n            t *= self._axis.get_theta_direction()\n            t += self._axis.get_theta_offset()\n        if self._use_rmin and self._axis is not None:\n            r = (r - self._axis.get_rorigin()) * self._axis.get_rsign()\n        r = np.where(r >= 0, r, np.nan)\n        return np.column_stack([r * np.cos(t), r * np.sin(t)])\n\n    def transform_path_non_affine(self, path):\n        # docstring inherited\n        if not len(path) or path._interpolation_steps == 1:\n            return Path(self.transform_non_affine(path.vertices), path.codes)\n        xys = []\n        codes = []\n        last_t = last_r = None\n        for trs, c in path.iter_segments():\n            trs = trs.reshape((-1, 2))\n            if c == Path.LINETO:\n                (t, r), = trs\n                if t == last_t:  # Same angle: draw a straight line.\n                    xys.extend(self.transform_non_affine(trs))\n                    codes.append(Path.LINETO)\n                elif r == last_r:  # Same radius: draw an arc.\n                    # The following is complicated by Path.arc() being\n                    # \"helpful\" and unwrapping the angles, but we don't want\n                    # that behavior here.\n                    last_td, td = np.rad2deg([last_t, t])\n                    if self._use_rmin and self._axis is not None:\n                        r = ((r - self._axis.get_rorigin())\n                             * self._axis.get_rsign())\n                    if last_td <= td:\n                        while td - last_td > 360:\n                            arc = Path.arc(last_td, last_td + 360)\n                            xys.extend(arc.vertices[1:] * r)\n                            codes.extend(arc.codes[1:])\n                            last_td += 360\n                        arc = Path.arc(last_td, td)\n                        xys.extend(arc.vertices[1:] * r)\n                        codes.extend(arc.codes[1:])\n                    else:\n                        # The reverse version also relies on the fact that all\n                        # codes but the first one are the same.\n                        while last_td - td > 360:\n                            arc = Path.arc(last_td - 360, last_td)\n                            xys.extend(arc.vertices[::-1][1:] * r)\n                            codes.extend(arc.codes[1:])\n                            last_td -= 360\n                        arc = Path.arc(td, last_td)\n                        xys.extend(arc.vertices[::-1][1:] * r)\n                        codes.extend(arc.codes[1:])\n                else:  # Interpolate.\n                    trs = cbook.simple_linear_interpolation(\n                        np.row_stack([(last_t, last_r), trs]),\n                        path._interpolation_steps)[1:]\n                    xys.extend(self.transform_non_affine(trs))\n                    codes.extend([Path.LINETO] * len(trs))\n            else:  # Not a straight line.\n                xys.extend(self.transform_non_affine(trs))\n                codes.extend([c] * len(trs))\n            last_t, last_r = trs[-1]\n        return Path(xys, codes)\n\n    def inverted(self):\n        # docstring inherited\n        return PolarAxes.InvertedPolarTransform(self._axis, self._use_rmin,\n                                                self._apply_theta_transforms)",
      "instance_attributes": [
        {
          "name": "_axis",
          "types": null
        },
        {
          "name": "_use_rmin",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_apply_theta_transforms",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis",
      "name": "RadialAxis",
      "qname": "lib.matplotlib.projections.polar.RadialAxis",
      "decorators": [],
      "superclasses": [
        "maxis.YAxis"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__",
        "matplotlib/lib.matplotlib.projections.polar/RadialAxis/_wrap_locator_formatter",
        "matplotlib/lib.matplotlib.projections.polar/RadialAxis/clear",
        "matplotlib/lib.matplotlib.projections.polar/RadialAxis/_set_scale"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A radial Axis.\n\nThis overrides certain properties of a `.YAxis` to provide special-casing\nfor a radial axis.",
      "docstring": "A radial Axis.\n\nThis overrides certain properties of a `.YAxis` to provide special-casing\nfor a radial axis.",
      "code": "class RadialAxis(maxis.YAxis):\n    \"\"\"\n    A radial Axis.\n\n    This overrides certain properties of a `.YAxis` to provide special-casing\n    for a radial axis.\n    \"\"\"\n    __name__ = 'radialaxis'\n    axis_name = 'radius'  #: Read-only name identifying the axis.\n    _tick_class = RadialTick\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.sticky_edges.y.append(0)\n\n    def _wrap_locator_formatter(self):\n        self.set_major_locator(RadialLocator(self.get_major_locator(),\n                                             self.axes))\n        self.isDefault_majloc = True\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()\n\n    def _set_scale(self, value, **kwargs):\n        super()._set_scale(value, **kwargs)\n        self._wrap_locator_formatter()",
      "instance_attributes": [
        {
          "name": "isDefault_majloc",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator",
      "name": "RadialLocator",
      "qname": "lib.matplotlib.projections.polar.RadialLocator",
      "decorators": [],
      "superclasses": [
        "mticker.Locator"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/set_axis",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__call__",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to locate radius ticks.\n\nEnsures that all ticks are strictly positive.  For all other tasks, it\ndelegates to the base `.Locator` (which may be different depending on the\nscale of the *r*-axis).",
      "docstring": "Used to locate radius ticks.\n\nEnsures that all ticks are strictly positive.  For all other tasks, it\ndelegates to the base `.Locator` (which may be different depending on the\nscale of the *r*-axis).",
      "code": "class RadialLocator(mticker.Locator):\n    \"\"\"\n    Used to locate radius ticks.\n\n    Ensures that all ticks are strictly positive.  For all other tasks, it\n    delegates to the base `.Locator` (which may be different depending on the\n    scale of the *r*-axis).\n    \"\"\"\n\n    def __init__(self, base, axes=None):\n        self.base = base\n        self._axes = axes\n\n    def set_axis(self, axis):\n        self.base.set_axis(axis)\n\n    def __call__(self):\n        # Ensure previous behaviour with full circle non-annular views.\n        if self._axes:\n            if _is_full_circle_rad(*self._axes.viewLim.intervalx):\n                rorigin = self._axes.get_rorigin() * self._axes.get_rsign()\n                if self._axes.get_rmin() <= rorigin:\n                    return [tick for tick in self.base() if tick > rorigin]\n        return self.base()\n\n    def nonsingular(self, vmin, vmax):\n        # docstring inherited\n        return ((0, 1) if (vmin, vmax) == (-np.inf, np.inf)  # Init. limits.\n                else self.base.nonsingular(vmin, vmax))\n\n    def view_limits(self, vmin, vmax):\n        vmin, vmax = self.base.view_limits(vmin, vmax)\n        if vmax > vmin:\n            # this allows inverted r/y-lims\n            vmin = min(0, vmin)\n        return mtransforms.nonsingular(vmin, vmax)",
      "instance_attributes": [
        {
          "name": "base",
          "types": null
        },
        {
          "name": "_axes",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick",
      "name": "RadialTick",
      "qname": "lib.matplotlib.projections.polar.RadialTick",
      "decorators": [],
      "superclasses": [
        "maxis.YTick"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__",
        "matplotlib/lib.matplotlib.projections.polar/RadialTick/_determine_anchor",
        "matplotlib/lib.matplotlib.projections.polar/RadialTick/update_position"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A radial-axis tick.\n\nThis subclass of `.YTick` provides radial ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\naxes limits.  This results in ticks that are correctly perpendicular to\nthe spine. Labels are also rotated to be perpendicular to the spine, when\n'auto' rotation is enabled.",
      "docstring": "A radial-axis tick.\n\nThis subclass of `.YTick` provides radial ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\naxes limits.  This results in ticks that are correctly perpendicular to\nthe spine. Labels are also rotated to be perpendicular to the spine, when\n'auto' rotation is enabled.",
      "code": "class RadialTick(maxis.YTick):\n    \"\"\"\n    A radial-axis tick.\n\n    This subclass of `.YTick` provides radial ticks with some small\n    modification to their re-positioning such that ticks are rotated based on\n    axes limits.  This results in ticks that are correctly perpendicular to\n    the spine. Labels are also rotated to be perpendicular to the spine, when\n    'auto' rotation is enabled.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.label1.set_rotation_mode('anchor')\n        self.label2.set_rotation_mode('anchor')\n\n    def _determine_anchor(self, mode, angle, start):\n        # Note: angle is the (spine angle - 90) because it's used for the tick\n        # & text setup, so all numbers below are -90 from (normed) spine angle.\n        if mode == 'auto':\n            if start:\n                if -90 <= angle <= 90:\n                    return 'left', 'center'\n                else:\n                    return 'right', 'center'\n            else:\n                if -90 <= angle <= 90:\n                    return 'right', 'center'\n                else:\n                    return 'left', 'center'\n        else:\n            if start:\n                if angle < -68.5:\n                    return 'center', 'top'\n                elif angle < -23.5:\n                    return 'left', 'top'\n                elif angle < 22.5:\n                    return 'left', 'center'\n                elif angle < 67.5:\n                    return 'left', 'bottom'\n                elif angle < 112.5:\n                    return 'center', 'bottom'\n                elif angle < 157.5:\n                    return 'right', 'bottom'\n                elif angle < 202.5:\n                    return 'right', 'center'\n                elif angle < 247.5:\n                    return 'right', 'top'\n                else:\n                    return 'center', 'top'\n            else:\n                if angle < -68.5:\n                    return 'center', 'bottom'\n                elif angle < -23.5:\n                    return 'right', 'bottom'\n                elif angle < 22.5:\n                    return 'right', 'center'\n                elif angle < 67.5:\n                    return 'right', 'top'\n                elif angle < 112.5:\n                    return 'center', 'top'\n                elif angle < 157.5:\n                    return 'left', 'top'\n                elif angle < 202.5:\n                    return 'left', 'center'\n                elif angle < 247.5:\n                    return 'left', 'bottom'\n                else:\n                    return 'center', 'bottom'\n\n    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        thetamin = axes.get_thetamin()\n        thetamax = axes.get_thetamax()\n        direction = axes.get_theta_direction()\n        offset_rad = axes.get_theta_offset()\n        offset = np.rad2deg(offset_rad)\n        full = _is_full_circle_deg(thetamin, thetamax)\n\n        if full:\n            angle = (axes.get_rlabel_position() * direction +\n                     offset) % 360 - 90\n            tick_angle = 0\n        else:\n            angle = (thetamin * direction + offset) % 360 - 90\n            if direction > 0:\n                tick_angle = np.deg2rad(angle)\n            else:\n                tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        if full:\n            ha = self.label1.get_horizontalalignment()\n            va = self.label1.get_verticalalignment()\n        else:\n            ha, va = self._determine_anchor(mode, angle, direction > 0)\n        self.label1.set_horizontalalignment(ha)\n        self.label1.set_verticalalignment(va)\n        self.label1.set_rotation(text_angle)\n\n        marker = self.tick1line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        if full:\n            self.label2.set_visible(False)\n            self.tick2line.set_visible(False)\n        angle = (thetamax * direction + offset) % 360 - 90\n        if direction > 0:\n            tick_angle = np.deg2rad(angle)\n        else:\n            tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        ha, va = self._determine_anchor(mode, angle, direction < 0)\n        self.label2.set_ha(ha)\n        self.label2.set_va(va)\n        self.label2.set_rotation(text_angle)\n\n        marker = self.tick2line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaAxis",
      "name": "ThetaAxis",
      "qname": "lib.matplotlib.projections.polar.ThetaAxis",
      "decorators": [],
      "superclasses": [
        "maxis.XAxis"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/_wrap_locator_formatter",
        "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/clear",
        "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/_set_scale",
        "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/_copy_tick_props"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A theta Axis.\n\nThis overrides certain properties of an `.XAxis` to provide special-casing\nfor an angular axis.",
      "docstring": "A theta Axis.\n\nThis overrides certain properties of an `.XAxis` to provide special-casing\nfor an angular axis.",
      "code": "class ThetaAxis(maxis.XAxis):\n    \"\"\"\n    A theta Axis.\n\n    This overrides certain properties of an `.XAxis` to provide special-casing\n    for an angular axis.\n    \"\"\"\n    __name__ = 'thetaaxis'\n    axis_name = 'theta'  #: Read-only name identifying the axis.\n    _tick_class = ThetaTick\n\n    def _wrap_locator_formatter(self):\n        self.set_major_locator(ThetaLocator(self.get_major_locator()))\n        self.set_major_formatter(ThetaFormatter())\n        self.isDefault_majloc = True\n        self.isDefault_majfmt = True\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()\n\n    def _set_scale(self, value, **kwargs):\n        if value != 'linear':\n            raise NotImplementedError(\n                \"The xscale cannot be set on a polar plot\")\n        super()._set_scale(value, **kwargs)\n        # LinearScale.set_default_locators_and_formatters just set the major\n        # locator to be an AutoLocator, so we customize it here to have ticks\n        # at sensible degree multiples.\n        self.get_major_locator().set_params(steps=[1, 1.5, 3, 4.5, 9, 10])\n        self._wrap_locator_formatter()\n\n    def _copy_tick_props(self, src, dest):\n        \"\"\"Copy the props from src tick to dest tick.\"\"\"\n        if src is None or dest is None:\n            return\n        super()._copy_tick_props(src, dest)\n\n        # Ensure that tick transforms are independent so that padding works.\n        trans = dest._get_text1_transform()[0]\n        dest.label1.set_transform(trans + dest._text1_translate)\n        trans = dest._get_text2_transform()[0]\n        dest.label2.set_transform(trans + dest._text2_translate)",
      "instance_attributes": [
        {
          "name": "isDefault_majloc",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "isDefault_majfmt",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter",
      "name": "ThetaFormatter",
      "qname": "lib.matplotlib.projections.polar.ThetaFormatter",
      "decorators": [],
      "superclasses": [
        "mticker.Formatter"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to format the *theta* tick labels.  Converts the native\nunit of radians into degrees and adds a degree symbol.",
      "docstring": "Used to format the *theta* tick labels.  Converts the native\nunit of radians into degrees and adds a degree symbol.",
      "code": "class ThetaFormatter(mticker.Formatter):\n    \"\"\"\n    Used to format the *theta* tick labels.  Converts the native\n    unit of radians into degrees and adds a degree symbol.\n    \"\"\"\n\n    def __call__(self, x, pos=None):\n        vmin, vmax = self.axis.get_view_interval()\n        d = np.rad2deg(abs(vmax - vmin))\n        digits = max(-int(np.log10(d) - 1.5), 0)\n        # Use Unicode rather than mathtext with \\circ, so that it will work\n        # correctly with any arbitrary font (assuming it has a degree sign),\n        # whereas $5\\circ$ will only work correctly with one of the supported\n        # math fonts (Computer Modern and STIX).\n        return (\"{value:0.{digits:d}f}\\N{DEGREE SIGN}\"\n                .format(value=np.rad2deg(x), digits=digits))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator",
      "name": "ThetaLocator",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator",
      "decorators": [],
      "superclasses": [
        "mticker.Locator"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__init__",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/set_axis",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__call__",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/refresh",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to locate theta ticks.\n\nThis will work the same as the base locator except in the case that the\nview spans the entire circle. In such cases, the previously used default\nlocations of every 45 degrees are returned.",
      "docstring": "Used to locate theta ticks.\n\nThis will work the same as the base locator except in the case that the\nview spans the entire circle. In such cases, the previously used default\nlocations of every 45 degrees are returned.",
      "code": "class ThetaLocator(mticker.Locator):\n    \"\"\"\n    Used to locate theta ticks.\n\n    This will work the same as the base locator except in the case that the\n    view spans the entire circle. In such cases, the previously used default\n    locations of every 45 degrees are returned.\n    \"\"\"\n\n    def __init__(self, base):\n        self.base = base\n        self.axis = self.base.axis = _AxisWrapper(self.base.axis)\n\n    def set_axis(self, axis):\n        self.axis = _AxisWrapper(axis)\n        self.base.set_axis(self.axis)\n\n    def __call__(self):\n        lim = self.axis.get_view_interval()\n        if _is_full_circle_deg(lim[0], lim[1]):\n            return np.arange(8) * 2 * np.pi / 8\n        else:\n            return np.deg2rad(self.base())\n\n    def refresh(self):\n        # docstring inherited\n        return self.base.refresh()\n\n    def view_limits(self, vmin, vmax):\n        vmin, vmax = np.rad2deg((vmin, vmax))\n        return np.deg2rad(self.base.view_limits(vmin, vmax))",
      "instance_attributes": [
        {
          "name": "base",
          "types": null
        },
        {
          "name": "axis",
          "types": {
            "kind": "NamedType",
            "name": "_AxisWrapper"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick",
      "name": "ThetaTick",
      "qname": "lib.matplotlib.projections.polar.ThetaTick",
      "decorators": [],
      "superclasses": [
        "maxis.XTick"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__",
        "matplotlib/lib.matplotlib.projections.polar/ThetaTick/_apply_params",
        "matplotlib/lib.matplotlib.projections.polar/ThetaTick/_update_padding",
        "matplotlib/lib.matplotlib.projections.polar/ThetaTick/update_position"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A theta-axis tick.\n\nThis subclass of `.XTick` provides angular ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\ntick location. This results in ticks that are correctly perpendicular to\nthe arc spine.\n\nWhen 'auto' rotation is enabled, labels are also rotated to be parallel to\nthe spine. The label padding is also applied here since it's not possible\nto use a generic axes transform to produce tick-specific padding.",
      "docstring": "A theta-axis tick.\n\nThis subclass of `.XTick` provides angular ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\ntick location. This results in ticks that are correctly perpendicular to\nthe arc spine.\n\nWhen 'auto' rotation is enabled, labels are also rotated to be parallel to\nthe spine. The label padding is also applied here since it's not possible\nto use a generic axes transform to produce tick-specific padding.",
      "code": "class ThetaTick(maxis.XTick):\n    \"\"\"\n    A theta-axis tick.\n\n    This subclass of `.XTick` provides angular ticks with some small\n    modification to their re-positioning such that ticks are rotated based on\n    tick location. This results in ticks that are correctly perpendicular to\n    the arc spine.\n\n    When 'auto' rotation is enabled, labels are also rotated to be parallel to\n    the spine. The label padding is also applied here since it's not possible\n    to use a generic axes transform to produce tick-specific padding.\n    \"\"\"\n\n    def __init__(self, axes, *args, **kwargs):\n        self._text1_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        self._text2_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        super().__init__(axes, *args, **kwargs)\n        self.label1.set(\n            rotation_mode='anchor',\n            transform=self.label1.get_transform() + self._text1_translate)\n        self.label2.set(\n            rotation_mode='anchor',\n            transform=self.label2.get_transform() + self._text2_translate)\n\n    def _apply_params(self, **kwargs):\n        super()._apply_params(**kwargs)\n        # Ensure transform is correct; sometimes this gets reset.\n        trans = self.label1.get_transform()\n        if not trans.contains_branch(self._text1_translate):\n            self.label1.set_transform(trans + self._text1_translate)\n        trans = self.label2.get_transform()\n        if not trans.contains_branch(self._text2_translate):\n            self.label2.set_transform(trans + self._text2_translate)\n\n    def _update_padding(self, pad, angle):\n        padx = pad * np.cos(angle) / 72\n        pady = pad * np.sin(angle) / 72\n        self._text1_translate._t = (padx, pady)\n        self._text1_translate.invalidate()\n        self._text2_translate._t = (-padx, -pady)\n        self._text2_translate.invalidate()\n\n    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        angle = loc * axes.get_theta_direction() + axes.get_theta_offset()\n        text_angle = np.rad2deg(angle) % 360 - 90\n        angle -= np.pi / 2\n\n        marker = self.tick1line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        marker = self.tick2line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans\n\n        mode, user_angle = self._labelrotation\n        if mode == 'default':\n            text_angle = user_angle\n        else:\n            if text_angle > 90:\n                text_angle -= 180\n            elif text_angle < -90:\n                text_angle += 180\n            text_angle += user_angle\n        self.label1.set_rotation(text_angle)\n        self.label2.set_rotation(text_angle)\n\n        # This extra padding helps preserve the look from previous releases but\n        # is also needed because labels are anchored to their center.\n        pad = self._pad + 7\n        self._update_padding(pad,\n                             self._loc * axes.get_theta_direction() +\n                             axes.get_theta_offset())",
      "instance_attributes": [
        {
          "name": "_text1_translate",
          "types": null
        },
        {
          "name": "_text2_translate",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry",
      "name": "ProjectionRegistry",
      "qname": "lib.matplotlib.projections.ProjectionRegistry",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.projections/ProjectionRegistry/__init__",
        "matplotlib/lib.matplotlib.projections/ProjectionRegistry/register",
        "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_class",
        "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_names"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A mapping of registered projection names to projection classes.",
      "docstring": "A mapping of registered projection names to projection classes.",
      "code": "class ProjectionRegistry:\n    \"\"\"A mapping of registered projection names to projection classes.\"\"\"\n\n    def __init__(self):\n        self._all_projection_types = {}\n\n    def register(self, *projections):\n        \"\"\"Register a new set of projections.\"\"\"\n        for projection in projections:\n            name = projection.name\n            self._all_projection_types[name] = projection\n\n    def get_projection_class(self, name):\n        \"\"\"Get a projection class from its *name*.\"\"\"\n        return self._all_projection_types[name]\n\n    def get_projection_names(self):\n        \"\"\"Return the names of all projections currently registered.\"\"\"\n        return sorted(self._all_projection_types)",
      "instance_attributes": [
        {
          "name": "_all_projection_types",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/MathDirective",
      "name": "MathDirective",
      "qname": "lib.matplotlib.sphinxext.mathmpl.MathDirective",
      "decorators": [],
      "superclasses": [
        "Directive"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.sphinxext.mathmpl/MathDirective/run"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The ``.. mathmpl::`` directive, as documented in the module's docstring.",
      "docstring": "The ``.. mathmpl::`` directive, as documented in the module's docstring.",
      "code": "class MathDirective(Directive):\n    \"\"\"\n    The ``.. mathmpl::`` directive, as documented in the module's docstring.\n    \"\"\"\n    has_content = True\n    required_arguments = 0\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec = {'fontset': fontset_choice,\n                   'fontsize': validate_float_or_None}\n\n    def run(self):\n        latex = ''.join(self.content)\n        node = latex_math(self.block_text)\n        node['latex'] = latex\n        node['fontset'] = self.options.get('fontset', 'cm')\n        node['fontsize'] = self.options.get('fontsize',\n                                            setup.app.config.mathmpl_fontsize)\n        return [node]",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex_math",
      "name": "latex_math",
      "qname": "lib.matplotlib.sphinxext.mathmpl.latex_math",
      "decorators": [],
      "superclasses": [
        "nodes.General",
        "nodes.Element"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class latex_math(nodes.General, nodes.Element):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile",
      "name": "ImageFile",
      "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/__init__",
        "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/filename",
        "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/filenames"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ImageFile:\n    def __init__(self, basename, dirname):\n        self.basename = basename\n        self.dirname = dirname\n        self.formats = []\n\n    def filename(self, format):\n        return os.path.join(self.dirname, \"%s.%s\" % (self.basename, format))\n\n    def filenames(self):\n        return [self.filename(fmt) for fmt in self.formats]",
      "instance_attributes": [
        {
          "name": "basename",
          "types": null
        },
        {
          "name": "dirname",
          "types": null
        },
        {
          "name": "formats",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/PlotDirective",
      "name": "PlotDirective",
      "qname": "lib.matplotlib.sphinxext.plot_directive.PlotDirective",
      "decorators": [],
      "superclasses": [
        "Directive"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.sphinxext.plot_directive/PlotDirective/run"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The ``.. plot::`` directive, as documented in the module's docstring.",
      "docstring": "The ``.. plot::`` directive, as documented in the module's docstring.",
      "code": "class PlotDirective(Directive):\n    \"\"\"The ``.. plot::`` directive, as documented in the module's docstring.\"\"\"\n\n    has_content = True\n    required_arguments = 0\n    optional_arguments = 2\n    final_argument_whitespace = False\n    option_spec = {\n        'alt': directives.unchanged,\n        'height': directives.length_or_unitless,\n        'width': directives.length_or_percentage_or_unitless,\n        'scale': directives.nonnegative_int,\n        'align': Image.align,\n        'class': directives.class_option,\n        'include-source': _option_boolean,\n        'format': _option_format,\n        'context': _option_context,\n        'nofigs': directives.flag,\n        'encoding': _deprecated_option_encoding,\n        'caption': directives.unchanged,\n        }\n\n    def run(self):\n        \"\"\"Run the plot directive.\"\"\"\n        try:\n            return run(self.arguments, self.content, self.options,\n                       self.state_machine, self.state, self.lineno)\n        except Exception as e:\n            raise self.error(str(e))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/PlotError",
      "name": "PlotError",
      "qname": "lib.matplotlib.sphinxext.plot_directive.PlotError",
      "decorators": [],
      "superclasses": [
        "RuntimeError"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class PlotError(RuntimeError):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.style.core/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.style.core.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    STYLE_FILE_PATTERN = _api.deprecated(\"3.5\", obj_type=\"\")(property(\n        lambda self: re.compile(r'([\\S]+).%s$' % STYLE_EXTENSION)))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.decorators/CleanupTestCase",
      "name": "CleanupTestCase",
      "qname": "lib.matplotlib.testing.decorators.CleanupTestCase",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of the existing code, including the private function _cleanup_cm')"
      ],
      "superclasses": [
        "unittest.TestCase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.testing.decorators/CleanupTestCase/setUpClass",
        "matplotlib/lib.matplotlib.testing.decorators/CleanupTestCase/tearDownClass"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A wrapper for unittest.TestCase that includes cleanup operations.",
      "docstring": "A wrapper for unittest.TestCase that includes cleanup operations.",
      "code": "class CleanupTestCase(unittest.TestCase):\n    \"\"\"A wrapper for unittest.TestCase that includes cleanup operations.\"\"\"\n    @classmethod\n    def setUpClass(cls):\n        cls._cm = _cleanup_cm().__enter__()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls._cm.__exit__(None, None, None)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.exceptions/ImageComparisonFailure",
      "name": "ImageComparisonFailure",
      "qname": "lib.matplotlib.testing.exceptions.ImageComparisonFailure",
      "decorators": [],
      "superclasses": [
        "AssertionError"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Raise this exception to mark a test as a comparison between two images.",
      "docstring": "Raise this exception to mark a test as a comparison between two images.",
      "code": "class ImageComparisonFailure(AssertionError):\n    \"\"\"\n    Raise this exception to mark a test as a comparison between two images.\n    \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration",
      "name": "Duration",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__init__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/frame",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__abs__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__neg__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/seconds",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__bool__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/_cmp",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__add__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__sub__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__mul__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__str__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__repr__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/checkSameFrame"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Class Duration in development.",
      "docstring": "Class Duration in development.",
      "code": "class Duration:\n    \"\"\"Class Duration in development.\"\"\"\n\n    allowed = [\"ET\", \"UTC\"]\n\n    def __init__(self, frame, seconds):\n        \"\"\"\n        Create a new Duration object.\n\n        = ERROR CONDITIONS\n        - If the input frame is not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - frame     The frame of the duration.  Must be 'ET' or 'UTC'\n        - seconds  The number of seconds in the Duration.\n        \"\"\"\n        _api.check_in_list(self.allowed, frame=frame)\n        self._frame = frame\n        self._seconds = seconds\n\n    def frame(self):\n        \"\"\"Return the frame the duration is in.\"\"\"\n        return self._frame\n\n    def __abs__(self):\n        \"\"\"Return the absolute value of the duration.\"\"\"\n        return Duration(self._frame, abs(self._seconds))\n\n    def __neg__(self):\n        \"\"\"Return the negative value of this Duration.\"\"\"\n        return Duration(self._frame, -self._seconds)\n\n    def seconds(self):\n        \"\"\"Return the number of seconds in the Duration.\"\"\"\n        return self._seconds\n\n    def __bool__(self):\n        return self._seconds != 0\n\n    def _cmp(self, op, rhs):\n        \"\"\"\n        Check that *self* and *rhs* share frames; compare them using *op*.\n        \"\"\"\n        self.checkSameFrame(rhs, \"compare\")\n        return op(self._seconds, rhs._seconds)\n\n    __eq__ = functools.partialmethod(_cmp, operator.eq)\n    __ne__ = functools.partialmethod(_cmp, operator.ne)\n    __lt__ = functools.partialmethod(_cmp, operator.lt)\n    __le__ = functools.partialmethod(_cmp, operator.le)\n    __gt__ = functools.partialmethod(_cmp, operator.gt)\n    __ge__ = functools.partialmethod(_cmp, operator.ge)\n\n    def __add__(self, rhs):\n        \"\"\"\n        Add two Durations.\n\n        = ERROR CONDITIONS\n        - If the input rhs is not in the same frame, an error is thrown.\n\n        = INPUT VARIABLES\n        - rhs     The Duration to add.\n\n        = RETURN VALUE\n        - Returns the sum of ourselves and the input Duration.\n        \"\"\"\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        if isinstance(rhs, U.Epoch):\n            return rhs + self\n\n        self.checkSameFrame(rhs, \"add\")\n        return Duration(self._frame, self._seconds + rhs._seconds)\n\n    def __sub__(self, rhs):\n        \"\"\"\n        Subtract two Durations.\n\n        = ERROR CONDITIONS\n        - If the input rhs is not in the same frame, an error is thrown.\n\n        = INPUT VARIABLES\n        - rhs     The Duration to subtract.\n\n        = RETURN VALUE\n        - Returns the difference of ourselves and the input Duration.\n        \"\"\"\n        self.checkSameFrame(rhs, \"sub\")\n        return Duration(self._frame, self._seconds - rhs._seconds)\n\n    def __mul__(self, rhs):\n        \"\"\"\n        Scale a UnitDbl by a value.\n\n        = INPUT VARIABLES\n        - rhs     The scalar to multiply by.\n\n        = RETURN VALUE\n        - Returns the scaled Duration.\n        \"\"\"\n        return Duration(self._frame, self._seconds * float(rhs))\n\n    __rmul__ = __mul__\n\n    def __str__(self):\n        \"\"\"Print the Duration.\"\"\"\n        return \"%g %s\" % (self._seconds, self._frame)\n\n    def __repr__(self):\n        \"\"\"Print the Duration.\"\"\"\n        return \"Duration('%s', %g)\" % (self._frame, self._seconds)\n\n    def checkSameFrame(self, rhs, func):\n        \"\"\"\n        Check to see if frames are the same.\n\n        = ERROR CONDITIONS\n        - If the frame of the rhs Duration is not the same as our frame,\n          an error is thrown.\n\n        = INPUT VARIABLES\n        - rhs     The Duration to check for the same frame\n        - func    The name of the function doing the check.\n        \"\"\"\n        if self._frame != rhs._frame:\n            raise ValueError(\n                f\"Cannot {func} Durations with different frames.\\n\"\n                f\"LHS: {self._frame}\\n\"\n                f\"RHS: {rhs._frame}\")",
      "instance_attributes": [
        {
          "name": "_frame",
          "types": null
        },
        {
          "name": "_seconds",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch",
      "name": "Epoch",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__init__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/convert",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/frame",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/julianDate",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/secondsPast",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/_cmp",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__add__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__sub__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__str__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__repr__",
        "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/range"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Epoch:\n    # Frame conversion offsets in seconds\n    # t(TO) = t(FROM) + allowed[ FROM ][ TO ]\n    allowed = {\n        \"ET\": {\n            \"UTC\": +64.1839,\n            },\n        \"UTC\": {\n            \"ET\": -64.1839,\n            },\n        }\n\n    def __init__(self, frame, sec=None, jd=None, daynum=None, dt=None):\n        \"\"\"\n        Create a new Epoch object.\n\n        Build an epoch 1 of 2 ways:\n\n        Using seconds past a Julian date:\n        #   Epoch('ET', sec=1e8, jd=2451545)\n\n        or using a matplotlib day number\n        #   Epoch('ET', daynum=730119.5)\n\n        = ERROR CONDITIONS\n        - If the input units are not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - frame     The frame of the epoch.  Must be 'ET' or 'UTC'\n        - sec        The number of seconds past the input JD.\n        - jd         The Julian date of the epoch.\n        - daynum    The matplotlib day number of the epoch.\n        - dt         A python datetime instance.\n        \"\"\"\n        if ((sec is None and jd is not None) or\n                (sec is not None and jd is None) or\n                (daynum is not None and\n                 (sec is not None or jd is not None)) or\n                (daynum is None and dt is None and\n                 (sec is None or jd is None)) or\n                (daynum is not None and dt is not None) or\n                (dt is not None and (sec is not None or jd is not None)) or\n                ((dt is not None) and not isinstance(dt, DT.datetime))):\n            raise ValueError(\n                \"Invalid inputs.  Must enter sec and jd together, \"\n                \"daynum by itself, or dt (must be a python datetime).\\n\"\n                \"Sec = %s\\n\"\n                \"JD  = %s\\n\"\n                \"dnum= %s\\n\"\n                \"dt  = %s\" % (sec, jd, daynum, dt))\n\n        _api.check_in_list(self.allowed, frame=frame)\n        self._frame = frame\n\n        if dt is not None:\n            daynum = date2num(dt)\n\n        if daynum is not None:\n            # 1-JAN-0001 in JD = 1721425.5\n            jd = float(daynum) + 1721425.5\n            self._jd = math.floor(jd)\n            self._seconds = (jd - self._jd) * 86400.0\n\n        else:\n            self._seconds = float(sec)\n            self._jd = float(jd)\n\n            # Resolve seconds down to [ 0, 86400)\n            deltaDays = math.floor(self._seconds / 86400)\n            self._jd += deltaDays\n            self._seconds -= deltaDays * 86400.0\n\n    def convert(self, frame):\n        if self._frame == frame:\n            return self\n\n        offset = self.allowed[self._frame][frame]\n\n        return Epoch(frame, self._seconds + offset, self._jd)\n\n    def frame(self):\n        return self._frame\n\n    def julianDate(self, frame):\n        t = self\n        if frame != self._frame:\n            t = self.convert(frame)\n\n        return t._jd + t._seconds / 86400.0\n\n    def secondsPast(self, frame, jd):\n        t = self\n        if frame != self._frame:\n            t = self.convert(frame)\n\n        delta = t._jd - jd\n        return t._seconds + delta * 86400\n\n    def _cmp(self, op, rhs):\n        \"\"\"Compare Epochs *self* and *rhs* using operator *op*.\"\"\"\n        t = self\n        if self._frame != rhs._frame:\n            t = self.convert(rhs._frame)\n        if t._jd != rhs._jd:\n            return op(t._jd, rhs._jd)\n        return op(t._seconds, rhs._seconds)\n\n    __eq__ = functools.partialmethod(_cmp, operator.eq)\n    __ne__ = functools.partialmethod(_cmp, operator.ne)\n    __lt__ = functools.partialmethod(_cmp, operator.lt)\n    __le__ = functools.partialmethod(_cmp, operator.le)\n    __gt__ = functools.partialmethod(_cmp, operator.gt)\n    __ge__ = functools.partialmethod(_cmp, operator.ge)\n\n    def __add__(self, rhs):\n        \"\"\"\n        Add a duration to an Epoch.\n\n        = INPUT VARIABLES\n        - rhs     The Epoch to subtract.\n\n        = RETURN VALUE\n        - Returns the difference of ourselves and the input Epoch.\n        \"\"\"\n        t = self\n        if self._frame != rhs.frame():\n            t = self.convert(rhs._frame)\n\n        sec = t._seconds + rhs.seconds()\n\n        return Epoch(t._frame, sec, t._jd)\n\n    def __sub__(self, rhs):\n        \"\"\"\n        Subtract two Epoch's or a Duration from an Epoch.\n\n        Valid:\n        Duration = Epoch - Epoch\n        Epoch = Epoch - Duration\n\n        = INPUT VARIABLES\n        - rhs     The Epoch to subtract.\n\n        = RETURN VALUE\n        - Returns either the duration between to Epoch's or the a new\n          Epoch that is the result of subtracting a duration from an epoch.\n        \"\"\"\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        # Handle Epoch - Duration\n        if isinstance(rhs, U.Duration):\n            return self + -rhs\n\n        t = self\n        if self._frame != rhs._frame:\n            t = self.convert(rhs._frame)\n\n        days = t._jd - rhs._jd\n        sec = t._seconds - rhs._seconds\n\n        return U.Duration(rhs._frame, days*86400 + sec)\n\n    def __str__(self):\n        \"\"\"Print the Epoch.\"\"\"\n        return \"%22.15e %s\" % (self.julianDate(self._frame), self._frame)\n\n    def __repr__(self):\n        \"\"\"Print the Epoch.\"\"\"\n        return str(self)\n\n    @staticmethod\n    def range(start, stop, step):\n        \"\"\"\n        Generate a range of Epoch objects.\n\n        Similar to the Python range() method.  Returns the range [\n        start, stop) at the requested step.  Each element will be a\n        Epoch object.\n\n        = INPUT VARIABLES\n        - start     The starting value of the range.\n        - stop      The stop value of the range.\n        - step      Step to use.\n\n        = RETURN VALUE\n        - Returns a list containing the requested Epoch values.\n        \"\"\"\n        elems = []\n\n        i = 0\n        while True:\n            d = start + i * step\n            if d >= stop:\n                break\n\n            elems.append(d)\n            i += 1\n\n        return elems",
      "instance_attributes": [
        {
          "name": "_frame",
          "types": null
        },
        {
          "name": "_jd",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "_seconds",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter",
      "name": "EpochConverter",
      "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter",
      "decorators": [],
      "superclasses": [
        "units.ConversionInterface"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/axisinfo",
        "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/float2epoch",
        "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/epoch2float",
        "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/duration2float",
        "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/convert",
        "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/default_units"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Provides Matplotlib conversion functionality for Monte Epoch and Duration\nclasses.",
      "docstring": "Provides Matplotlib conversion functionality for Monte Epoch and Duration\nclasses.",
      "code": "class EpochConverter(units.ConversionInterface):\n    \"\"\"\n    Provides Matplotlib conversion functionality for Monte Epoch and Duration\n    classes.\n    \"\"\"\n\n    # julian date reference for \"Jan 1, 0001\" minus 1 day because\n    # Matplotlib really wants \"Jan 0, 0001\"\n    jdRef = 1721425.5 - 1\n\n    @staticmethod\n    def axisinfo(unit, axis):\n        # docstring inherited\n        majloc = date_ticker.AutoDateLocator()\n        majfmt = date_ticker.AutoDateFormatter(majloc)\n        return units.AxisInfo(majloc=majloc, majfmt=majfmt, label=unit)\n\n    @staticmethod\n    def float2epoch(value, unit):\n        \"\"\"\n        Convert a Matplotlib floating-point date into an Epoch of the specified\n        units.\n\n        = INPUT VARIABLES\n        - value     The Matplotlib floating-point date.\n        - unit      The unit system to use for the Epoch.\n\n        = RETURN VALUE\n        - Returns the value converted to an Epoch in the specified time system.\n        \"\"\"\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        secPastRef = value * 86400.0 * U.UnitDbl(1.0, 'sec')\n        return U.Epoch(unit, secPastRef, EpochConverter.jdRef)\n\n    @staticmethod\n    def epoch2float(value, unit):\n        \"\"\"\n        Convert an Epoch value to a float suitable for plotting as a python\n        datetime object.\n\n        = INPUT VARIABLES\n        - value    An Epoch or list of Epochs that need to be converted.\n        - unit     The units to use for an axis with Epoch data.\n\n        = RETURN VALUE\n        - Returns the value parameter converted to floats.\n        \"\"\"\n        return value.julianDate(unit) - EpochConverter.jdRef\n\n    @staticmethod\n    def duration2float(value):\n        \"\"\"\n        Convert a Duration value to a float suitable for plotting as a python\n        datetime object.\n\n        = INPUT VARIABLES\n        - value    A Duration or list of Durations that need to be converted.\n\n        = RETURN VALUE\n        - Returns the value parameter converted to floats.\n        \"\"\"\n        return value.seconds() / 86400.0\n\n    @staticmethod\n    def convert(value, unit, axis):\n        # docstring inherited\n\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        if not cbook.is_scalar_or_string(value):\n            return [EpochConverter.convert(x, unit, axis) for x in value]\n        if unit is None:\n            unit = EpochConverter.default_units(value, axis)\n        if isinstance(value, U.Duration):\n            return EpochConverter.duration2float(value)\n        else:\n            return EpochConverter.epoch2float(value, unit)\n\n    @staticmethod\n    def default_units(value, axis):\n        # docstring inherited\n        if cbook.is_scalar_or_string(value):\n            return value.frame()\n        else:\n            return EpochConverter.default_units(value[0], axis)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter",
      "name": "StrConverter",
      "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter",
      "decorators": [],
      "superclasses": [
        "units.ConversionInterface"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/axisinfo",
        "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/convert",
        "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/default_units"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A Matplotlib converter class for string data values.\n\nValid units for string are:\n- 'indexed' : Values are indexed as they are specified for plotting.\n- 'sorted'  : Values are sorted alphanumerically.\n- 'inverted' : Values are inverted so that the first value is on top.\n- 'sorted-inverted' :  A combination of 'sorted' and 'inverted'",
      "docstring": "A Matplotlib converter class for string data values.\n\nValid units for string are:\n- 'indexed' : Values are indexed as they are specified for plotting.\n- 'sorted'  : Values are sorted alphanumerically.\n- 'inverted' : Values are inverted so that the first value is on top.\n- 'sorted-inverted' :  A combination of 'sorted' and 'inverted'",
      "code": "class StrConverter(units.ConversionInterface):\n    \"\"\"\n    A Matplotlib converter class for string data values.\n\n    Valid units for string are:\n    - 'indexed' : Values are indexed as they are specified for plotting.\n    - 'sorted'  : Values are sorted alphanumerically.\n    - 'inverted' : Values are inverted so that the first value is on top.\n    - 'sorted-inverted' :  A combination of 'sorted' and 'inverted'\n    \"\"\"\n\n    @staticmethod\n    def axisinfo(unit, axis):\n        # docstring inherited\n        return None\n\n    @staticmethod\n    def convert(value, unit, axis):\n        # docstring inherited\n\n        if value == []:\n            return []\n\n        # we delay loading to make matplotlib happy\n        ax = axis.axes\n        if axis is ax.xaxis:\n            isXAxis = True\n        else:\n            isXAxis = False\n\n        axis.get_major_ticks()\n        ticks = axis.get_ticklocs()\n        labels = axis.get_ticklabels()\n\n        labels = [l.get_text() for l in labels if l.get_text()]\n\n        if not labels:\n            ticks = []\n            labels = []\n\n        if not np.iterable(value):\n            value = [value]\n\n        newValues = []\n        for v in value:\n            if v not in labels and v not in newValues:\n                newValues.append(v)\n\n        labels.extend(newValues)\n\n        # DISABLED: This is disabled because matplotlib bar plots do not\n        # DISABLED: recalculate the unit conversion of the data values\n        # DISABLED: this is due to design and is not really a bug.\n        # DISABLED: If this gets changed, then we can activate the following\n        # DISABLED: block of code.  Note that this works for line plots.\n        # DISABLED if unit:\n        # DISABLED     if unit.find(\"sorted\") > -1:\n        # DISABLED         labels.sort()\n        # DISABLED     if unit.find(\"inverted\") > -1:\n        # DISABLED         labels = labels[::-1]\n\n        # add padding (so they do not appear on the axes themselves)\n        labels = [''] + labels + ['']\n        ticks = list(range(len(labels)))\n        ticks[0] = 0.5\n        ticks[-1] = ticks[-1] - 0.5\n\n        axis.set_ticks(ticks)\n        axis.set_ticklabels(labels)\n        # we have to do the following lines to make ax.autoscale_view work\n        loc = axis.get_major_locator()\n        loc.set_bounds(ticks[0], ticks[-1])\n\n        if isXAxis:\n            ax.set_xlim(ticks[0], ticks[-1])\n        else:\n            ax.set_ylim(ticks[0], ticks[-1])\n\n        result = [ticks[labels.index(v)] for v in value]\n\n        ax.viewLim.ignore(-1)\n        return result\n\n    @staticmethod\n    def default_units(value, axis):\n        # docstring inherited\n        # The default behavior for string indexing.\n        return \"indexed\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl",
      "name": "UnitDbl",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__init__",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/convert",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__abs__",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__neg__",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__bool__",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/_cmp",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/_binop_unit_unit",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/_binop_unit_scalar",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__str__",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__repr__",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/type",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/range",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/checkSameUnits"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Class UnitDbl in development.",
      "docstring": "Class UnitDbl in development.",
      "code": "class UnitDbl:\n    \"\"\"Class UnitDbl in development.\"\"\"\n\n    # Unit conversion table.  Small subset of the full one but enough\n    # to test the required functions.  First field is a scale factor to\n    # convert the input units to the units of the second field.  Only\n    # units in this table are allowed.\n    allowed = {\n        \"m\": (0.001, \"km\"),\n        \"km\": (1, \"km\"),\n        \"mile\": (1.609344, \"km\"),\n\n        \"rad\": (1, \"rad\"),\n        \"deg\": (1.745329251994330e-02, \"rad\"),\n\n        \"sec\": (1, \"sec\"),\n        \"min\": (60.0, \"sec\"),\n        \"hour\": (3600, \"sec\"),\n        }\n\n    _types = {\n        \"km\": \"distance\",\n        \"rad\": \"angle\",\n        \"sec\": \"time\",\n        }\n\n    def __init__(self, value, units):\n        \"\"\"\n        Create a new UnitDbl object.\n\n        Units are internally converted to km, rad, and sec.  The only\n        valid inputs for units are [m, km, mile, rad, deg, sec, min, hour].\n\n        The field UnitDbl.value will contain the converted value.  Use\n        the convert() method to get a specific type of units back.\n\n        = ERROR CONDITIONS\n        - If the input units are not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - value     The numeric value of the UnitDbl.\n        - units     The string name of the units the value is in.\n        \"\"\"\n        data = _api.check_getitem(self.allowed, units=units)\n        self._value = float(value * data[0])\n        self._units = data[1]\n\n    def convert(self, units):\n        \"\"\"\n        Convert the UnitDbl to a specific set of units.\n\n        = ERROR CONDITIONS\n        - If the input units are not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - units     The string name of the units to convert to.\n\n        = RETURN VALUE\n        - Returns the value of the UnitDbl in the requested units as a floating\n          point number.\n        \"\"\"\n        if self._units == units:\n            return self._value\n        data = _api.check_getitem(self.allowed, units=units)\n        if self._units != data[1]:\n            raise ValueError(f\"Error trying to convert to different units.\\n\"\n                             f\"    Invalid conversion requested.\\n\"\n                             f\"    UnitDbl: {self}\\n\"\n                             f\"    Units:   {units}\\n\")\n        return self._value / data[0]\n\n    def __abs__(self):\n        \"\"\"Return the absolute value of this UnitDbl.\"\"\"\n        return UnitDbl(abs(self._value), self._units)\n\n    def __neg__(self):\n        \"\"\"Return the negative value of this UnitDbl.\"\"\"\n        return UnitDbl(-self._value, self._units)\n\n    def __bool__(self):\n        \"\"\"Return the truth value of a UnitDbl.\"\"\"\n        return bool(self._value)\n\n    def _cmp(self, op, rhs):\n        \"\"\"Check that *self* and *rhs* share units; compare them using *op*.\"\"\"\n        self.checkSameUnits(rhs, \"compare\")\n        return op(self._value, rhs._value)\n\n    __eq__ = functools.partialmethod(_cmp, operator.eq)\n    __ne__ = functools.partialmethod(_cmp, operator.ne)\n    __lt__ = functools.partialmethod(_cmp, operator.lt)\n    __le__ = functools.partialmethod(_cmp, operator.le)\n    __gt__ = functools.partialmethod(_cmp, operator.gt)\n    __ge__ = functools.partialmethod(_cmp, operator.ge)\n\n    def _binop_unit_unit(self, op, rhs):\n        \"\"\"Check that *self* and *rhs* share units; combine them using *op*.\"\"\"\n        self.checkSameUnits(rhs, op.__name__)\n        return UnitDbl(op(self._value, rhs._value), self._units)\n\n    __add__ = functools.partialmethod(_binop_unit_unit, operator.add)\n    __sub__ = functools.partialmethod(_binop_unit_unit, operator.sub)\n\n    def _binop_unit_scalar(self, op, scalar):\n        \"\"\"Combine *self* and *scalar* using *op*.\"\"\"\n        return UnitDbl(op(self._value, scalar), self._units)\n\n    __mul__ = functools.partialmethod(_binop_unit_scalar, operator.mul)\n    __rmul__ = functools.partialmethod(_binop_unit_scalar, operator.mul)\n\n    def __str__(self):\n        \"\"\"Print the UnitDbl.\"\"\"\n        return \"%g *%s\" % (self._value, self._units)\n\n    def __repr__(self):\n        \"\"\"Print the UnitDbl.\"\"\"\n        return \"UnitDbl(%g, '%s')\" % (self._value, self._units)\n\n    def type(self):\n        \"\"\"Return the type of UnitDbl data.\"\"\"\n        return self._types[self._units]\n\n    @staticmethod\n    def range(start, stop, step=None):\n        \"\"\"\n        Generate a range of UnitDbl objects.\n\n        Similar to the Python range() method.  Returns the range [\n        start, stop) at the requested step.  Each element will be a\n        UnitDbl object.\n\n        = INPUT VARIABLES\n        - start     The starting value of the range.\n        - stop      The stop value of the range.\n        - step      Optional step to use.  If set to None, then a UnitDbl of\n                      value 1 w/ the units of the start is used.\n\n        = RETURN VALUE\n        - Returns a list containing the requested UnitDbl values.\n        \"\"\"\n        if step is None:\n            step = UnitDbl(1, start._units)\n\n        elems = []\n\n        i = 0\n        while True:\n            d = start + i * step\n            if d >= stop:\n                break\n\n            elems.append(d)\n            i += 1\n\n        return elems\n\n    def checkSameUnits(self, rhs, func):\n        \"\"\"\n        Check to see if units are the same.\n\n        = ERROR CONDITIONS\n        - If the units of the rhs UnitDbl are not the same as our units,\n          an error is thrown.\n\n        = INPUT VARIABLES\n        - rhs     The UnitDbl to check for the same units\n        - func    The name of the function doing the check.\n        \"\"\"\n        if self._units != rhs._units:\n            raise ValueError(f\"Cannot {func} units of different types.\\n\"\n                             f\"LHS: {self._units}\\n\"\n                             f\"RHS: {rhs._units}\")",
      "instance_attributes": [
        {
          "name": "_value",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "_units",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter",
      "name": "UnitDblConverter",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter",
      "decorators": [],
      "superclasses": [
        "units.ConversionInterface"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/axisinfo",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/convert",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/default_units"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Provides Matplotlib conversion functionality for the Monte UnitDbl class.",
      "docstring": "Provides Matplotlib conversion functionality for the Monte UnitDbl class.",
      "code": "class UnitDblConverter(units.ConversionInterface):\n    \"\"\"\n    Provides Matplotlib conversion functionality for the Monte UnitDbl class.\n    \"\"\"\n    # default for plotting\n    defaults = {\n       \"distance\": 'km',\n       \"angle\": 'deg',\n       \"time\": 'sec',\n       }\n\n    @staticmethod\n    def axisinfo(unit, axis):\n        # docstring inherited\n\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        # Check to see if the value used for units is a string unit value\n        # or an actual instance of a UnitDbl so that we can use the unit\n        # value for the default axis label value.\n        if unit:\n            label = unit if isinstance(unit, str) else unit.label()\n        else:\n            label = None\n\n        if label == \"deg\" and isinstance(axis.axes, polar.PolarAxes):\n            # If we want degrees for a polar plot, use the PolarPlotFormatter\n            majfmt = polar.PolarAxes.ThetaFormatter()\n        else:\n            majfmt = U.UnitDblFormatter(useOffset=False)\n\n        return units.AxisInfo(majfmt=majfmt, label=label)\n\n    @staticmethod\n    def convert(value, unit, axis):\n        # docstring inherited\n        if not cbook.is_scalar_or_string(value):\n            return [UnitDblConverter.convert(x, unit, axis) for x in value]\n        # If no units were specified, then get the default units to use.\n        if unit is None:\n            unit = UnitDblConverter.default_units(value, axis)\n        # Convert the incoming UnitDbl value/values to float/floats\n        if isinstance(axis.axes, polar.PolarAxes) and value.type() == \"angle\":\n            # Guarantee that units are radians for polar plots.\n            return value.convert(\"rad\")\n        return value.convert(unit)\n\n    @staticmethod\n    def default_units(value, axis):\n        # docstring inherited\n        # Determine the default units based on the user preferences set for\n        # default units when printing a UnitDbl.\n        if cbook.is_scalar_or_string(value):\n            return UnitDblConverter.defaults[value.type()]\n        else:\n            return UnitDblConverter.default_units(value[0], axis)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter",
      "name": "UnitDblFormatter",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter",
      "decorators": [],
      "superclasses": [
        "ticker.ScalarFormatter"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/__call__",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/format_data_short",
        "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/format_data"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The formatter for UnitDbl data types.\n\nThis allows for formatting with the unit string.",
      "docstring": "The formatter for UnitDbl data types.\n\nThis allows for formatting with the unit string.",
      "code": "class UnitDblFormatter(ticker.ScalarFormatter):\n    \"\"\"\n    The formatter for UnitDbl data types.\n\n    This allows for formatting with the unit string.\n    \"\"\"\n\n    def __call__(self, x, pos=None):\n        # docstring inherited\n        if len(self.locs) == 0:\n            return ''\n        else:\n            return '{:.12}'.format(x)\n\n    def format_data_short(self, value):\n        # docstring inherited\n        return '{:.12}'.format(value)\n\n    def format_data(self, value):\n        # docstring inherited\n        return '{:.12}'.format(value)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation",
      "name": "Triangulation",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/__init__",
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/calculate_plane_coefficients",
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/edges@getter",
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_cpp_triangulation",
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_masked_triangles",
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_from_args_and_kwargs",
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/_extract_triangulation_params",
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_trifinder",
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/neighbors@getter",
        "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/set_mask"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "An unstructured triangular grid consisting of npoints points and\nntri triangles.  The triangles can either be specified by the user\nor automatically generated using a Delaunay triangulation.",
      "docstring": "An unstructured triangular grid consisting of npoints points and\nntri triangles.  The triangles can either be specified by the user\nor automatically generated using a Delaunay triangulation.\n\nParameters\n----------\nx, y : (npoints,) array-like\n    Coordinates of grid points.\ntriangles : (ntri, 3) array-like of int, optional\n    For each triangle, the indices of the three points that make\n    up the triangle, ordered in an anticlockwise manner.  If not\n    specified, the Delaunay triangulation is calculated.\nmask : (ntri,) array-like of bool, optional\n    Which triangles are masked out.\n\nAttributes\n----------\ntriangles : (ntri, 3) array of int\n    For each triangle, the indices of the three points that make\n    up the triangle, ordered in an anticlockwise manner. If you want to\n    take the *mask* into account, use `get_masked_triangles` instead.\nmask : (ntri, 3) array of bool\n    Masked out triangles.\nis_delaunay : bool\n    Whether the Triangulation is a calculated Delaunay\n    triangulation (where *triangles* was not specified) or not.\n\nNotes\n-----\nFor a Triangulation to be valid it must not have duplicate points,\ntriangles formed from colinear points, or overlapping triangles.",
      "code": "class Triangulation:\n    \"\"\"\n    An unstructured triangular grid consisting of npoints points and\n    ntri triangles.  The triangles can either be specified by the user\n    or automatically generated using a Delaunay triangulation.\n\n    Parameters\n    ----------\n    x, y : (npoints,) array-like\n        Coordinates of grid points.\n    triangles : (ntri, 3) array-like of int, optional\n        For each triangle, the indices of the three points that make\n        up the triangle, ordered in an anticlockwise manner.  If not\n        specified, the Delaunay triangulation is calculated.\n    mask : (ntri,) array-like of bool, optional\n        Which triangles are masked out.\n\n    Attributes\n    ----------\n    triangles : (ntri, 3) array of int\n        For each triangle, the indices of the three points that make\n        up the triangle, ordered in an anticlockwise manner. If you want to\n        take the *mask* into account, use `get_masked_triangles` instead.\n    mask : (ntri, 3) array of bool\n        Masked out triangles.\n    is_delaunay : bool\n        Whether the Triangulation is a calculated Delaunay\n        triangulation (where *triangles* was not specified) or not.\n\n    Notes\n    -----\n    For a Triangulation to be valid it must not have duplicate points,\n    triangles formed from colinear points, or overlapping triangles.\n    \"\"\"\n    def __init__(self, x, y, triangles=None, mask=None):\n        from matplotlib import _qhull\n\n        self.x = np.asarray(x, dtype=np.float64)\n        self.y = np.asarray(y, dtype=np.float64)\n        if self.x.shape != self.y.shape or self.x.ndim != 1:\n            raise ValueError(\"x and y must be equal-length 1D arrays, but \"\n                             f\"found shapes {self.x.shape!r} and \"\n                             f\"{self.y.shape!r}\")\n\n        self.mask = None\n        self._edges = None\n        self._neighbors = None\n        self.is_delaunay = False\n\n        if triangles is None:\n            # No triangulation specified, so use matplotlib._qhull to obtain\n            # Delaunay triangulation.\n            self.triangles, self._neighbors = _qhull.delaunay(x, y)\n            self.is_delaunay = True\n        else:\n            # Triangulation specified. Copy, since we may correct triangle\n            # orientation.\n            try:\n                self.triangles = np.array(triangles, dtype=np.int32, order='C')\n            except ValueError as e:\n                raise ValueError('triangles must be a (N, 3) int array, not '\n                                 f'{triangles!r}') from e\n            if self.triangles.ndim != 2 or self.triangles.shape[1] != 3:\n                raise ValueError(\n                    'triangles must be a (N, 3) int array, but found shape '\n                    f'{self.triangles.shape!r}')\n            if self.triangles.max() >= len(self.x):\n                raise ValueError(\n                    'triangles are indices into the points and must be in the '\n                    f'range 0 <= i < {len(self.x)} but found value '\n                    f'{self.triangles.max()}')\n            if self.triangles.min() < 0:\n                raise ValueError(\n                    'triangles are indices into the points and must be in the '\n                    f'range 0 <= i < {len(self.x)} but found value '\n                    f'{self.triangles.min()}')\n\n        # Underlying C++ object is not created until first needed.\n        self._cpp_triangulation = None\n\n        # Default TriFinder not created until needed.\n        self._trifinder = None\n\n        self.set_mask(mask)\n\n    def calculate_plane_coefficients(self, z):\n        \"\"\"\n        Calculate plane equation coefficients for all unmasked triangles from\n        the point (x, y) coordinates and specified z-array of shape (npoints).\n        The returned array has shape (npoints, 3) and allows z-value at (x, y)\n        position in triangle tri to be calculated using\n        ``z = array[tri, 0] * x  + array[tri, 1] * y + array[tri, 2]``.\n        \"\"\"\n        return self.get_cpp_triangulation().calculate_plane_coefficients(z)\n\n    @property\n    def edges(self):\n        \"\"\"\n        Return integer array of shape (nedges, 2) containing all edges of\n        non-masked triangles.\n\n        Each row defines an edge by its start point index and end point\n        index.  Each edge appears only once, i.e. for an edge between points\n        *i*  and *j*, there will only be either *(i, j)* or *(j, i)*.\n        \"\"\"\n        if self._edges is None:\n            self._edges = self.get_cpp_triangulation().get_edges()\n        return self._edges\n\n    def get_cpp_triangulation(self):\n        \"\"\"\n        Return the underlying C++ Triangulation object, creating it\n        if necessary.\n        \"\"\"\n        from matplotlib import _tri\n        if self._cpp_triangulation is None:\n            self._cpp_triangulation = _tri.Triangulation(\n                self.x, self.y, self.triangles, self.mask, self._edges,\n                self._neighbors, not self.is_delaunay)\n        return self._cpp_triangulation\n\n    def get_masked_triangles(self):\n        \"\"\"\n        Return an array of triangles taking the mask into account.\n        \"\"\"\n        if self.mask is not None:\n            return self.triangles[~self.mask]\n        else:\n            return self.triangles\n\n    @staticmethod\n    def get_from_args_and_kwargs(*args, **kwargs):\n        \"\"\"\n        Return a Triangulation object from the args and kwargs, and\n        the remaining args and kwargs with the consumed values removed.\n\n        There are two alternatives: either the first argument is a\n        Triangulation object, in which case it is returned, or the args\n        and kwargs are sufficient to create a new Triangulation to\n        return.  In the latter case, see Triangulation.__init__ for\n        the possible args and kwargs.\n        \"\"\"\n        if isinstance(args[0], Triangulation):\n            triangulation, *args = args\n            if 'triangles' in kwargs:\n                _api.warn_external(\n                    \"Passing the keyword 'triangles' has no effect when also \"\n                    \"passing a Triangulation\")\n            if 'mask' in kwargs:\n                _api.warn_external(\n                    \"Passing the keyword 'mask' has no effect when also \"\n                    \"passing a Triangulation\")\n        else:\n            x, y, triangles, mask, args, kwargs = \\\n                Triangulation._extract_triangulation_params(args, kwargs)\n            triangulation = Triangulation(x, y, triangles, mask)\n        return triangulation, args, kwargs\n\n    @staticmethod\n    def _extract_triangulation_params(args, kwargs):\n        x, y, *args = args\n        # Check triangles in kwargs then args.\n        triangles = kwargs.pop('triangles', None)\n        from_args = False\n        if triangles is None and args:\n            triangles = args[0]\n            from_args = True\n        if triangles is not None:\n            try:\n                triangles = np.asarray(triangles, dtype=np.int32)\n            except ValueError:\n                triangles = None\n        if triangles is not None and (triangles.ndim != 2 or\n                                      triangles.shape[1] != 3):\n            triangles = None\n        if triangles is not None and from_args:\n            args = args[1:]  # Consumed first item in args.\n        # Check for mask in kwargs.\n        mask = kwargs.pop('mask', None)\n        return x, y, triangles, mask, args, kwargs\n\n    def get_trifinder(self):\n        \"\"\"\n        Return the default `matplotlib.tri.TriFinder` of this\n        triangulation, creating it if necessary.  This allows the same\n        TriFinder object to be easily shared.\n        \"\"\"\n        if self._trifinder is None:\n            # Default TriFinder class.\n            from matplotlib.tri.trifinder import TrapezoidMapTriFinder\n            self._trifinder = TrapezoidMapTriFinder(self)\n        return self._trifinder\n\n    @property\n    def neighbors(self):\n        \"\"\"\n        Return integer array of shape (ntri, 3) containing neighbor triangles.\n\n        For each triangle, the indices of the three triangles that\n        share the same edges, or -1 if there is no such neighboring\n        triangle.  ``neighbors[i, j]`` is the triangle that is the neighbor\n        to the edge from point index ``triangles[i, j]`` to point index\n        ``triangles[i, (j+1)%3]``.\n        \"\"\"\n        if self._neighbors is None:\n            self._neighbors = self.get_cpp_triangulation().get_neighbors()\n        return self._neighbors\n\n    def set_mask(self, mask):\n        \"\"\"\n        Set or clear the mask array.\n\n        Parameters\n        ----------\n        mask : None or bool array of length ntri\n        \"\"\"\n        if mask is None:\n            self.mask = None\n        else:\n            self.mask = np.asarray(mask, dtype=bool)\n            if self.mask.shape != (self.triangles.shape[0],):\n                raise ValueError('mask array must have same length as '\n                                 'triangles array')\n\n        # Set mask in C++ Triangulation.\n        if self._cpp_triangulation is not None:\n            self._cpp_triangulation.set_mask(self.mask)\n\n        # Clear derived fields so they are recalculated when needed.\n        self._edges = None\n        self._neighbors = None\n\n        # Recalculate TriFinder if it exists.\n        if self._trifinder is not None:\n            self._trifinder._initialize()",
      "instance_attributes": [
        {
          "name": "x",
          "types": null
        },
        {
          "name": "y",
          "types": null
        },
        {
          "name": "mask",
          "types": null
        },
        {
          "name": "_edges",
          "types": null
        },
        {
          "name": "_neighbors",
          "types": null
        },
        {
          "name": "is_delaunay",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "triangles",
          "types": {
            "kind": "NamedType",
            "name": "ndarray"
          }
        },
        {
          "name": "_cpp_triangulation",
          "types": null
        },
        {
          "name": "_trifinder",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tricontour/TriContourSet",
      "name": "TriContourSet",
      "qname": "lib.matplotlib.tri.tricontour.TriContourSet",
      "decorators": [
        "_docstring.dedent_interpd"
      ],
      "superclasses": [
        "ContourSet"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.tri.tricontour/TriContourSet/__init__",
        "matplotlib/lib.matplotlib.tri.tricontour/TriContourSet/_process_args",
        "matplotlib/lib.matplotlib.tri.tricontour/TriContourSet/_contour_args"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Create and store a set of contour lines or filled regions for\na triangular grid.\n\nThis class is typically not instantiated directly by the user but by\n`~.Axes.tricontour` and `~.Axes.tricontourf`.\n\n%(contour_set_attributes)s",
      "docstring": "Create and store a set of contour lines or filled regions for\na triangular grid.\n\nThis class is typically not instantiated directly by the user but by\n`~.Axes.tricontour` and `~.Axes.tricontourf`.\n\n%(contour_set_attributes)s",
      "code": "class TriContourSet(ContourSet):\n    \"\"\"\n    Create and store a set of contour lines or filled regions for\n    a triangular grid.\n\n    This class is typically not instantiated directly by the user but by\n    `~.Axes.tricontour` and `~.Axes.tricontourf`.\n\n    %(contour_set_attributes)s\n    \"\"\"\n    def __init__(self, ax, *args, **kwargs):\n        \"\"\"\n        Draw triangular grid contour lines or filled regions,\n        depending on whether keyword arg *filled* is False\n        (default) or True.\n\n        The first argument of the initializer must be an `~.axes.Axes`\n        object.  The remaining arguments and keyword arguments\n        are described in the docstring of `~.Axes.tricontour`.\n        \"\"\"\n        super().__init__(ax, *args, **kwargs)\n\n    def _process_args(self, *args, **kwargs):\n        \"\"\"\n        Process args and kwargs.\n        \"\"\"\n        if isinstance(args[0], TriContourSet):\n            C = args[0]._contour_generator\n            if self.levels is None:\n                self.levels = args[0].levels\n            self.zmin = args[0].zmin\n            self.zmax = args[0].zmax\n            self._mins = args[0]._mins\n            self._maxs = args[0]._maxs\n        else:\n            from matplotlib import _tri\n            tri, z = self._contour_args(args, kwargs)\n            C = _tri.TriContourGenerator(tri.get_cpp_triangulation(), z)\n            self._mins = [tri.x.min(), tri.y.min()]\n            self._maxs = [tri.x.max(), tri.y.max()]\n\n        self._contour_generator = C\n        return kwargs\n\n    def _contour_args(self, args, kwargs):\n        tri, args, kwargs = Triangulation.get_from_args_and_kwargs(*args,\n                                                                   **kwargs)\n        z = np.ma.asarray(args[0])\n        if z.shape != tri.x.shape:\n            raise ValueError('z array must have same length as triangulation x'\n                             ' and y arrays')\n\n        # z values must be finite, only need to check points that are included\n        # in the triangulation.\n        z_check = z[np.unique(tri.get_masked_triangles())]\n        if np.ma.is_masked(z_check):\n            raise ValueError('z must not contain masked points within the '\n                             'triangulation')\n        if not np.isfinite(z_check).all():\n            raise ValueError('z array must not contain non-finite values '\n                             'within the triangulation')\n\n        z = np.ma.masked_invalid(z, copy=False)\n        self.zmax = float(z_check.max())\n        self.zmin = float(z_check.min())\n        if self.logscale and self.zmin <= 0:\n            func = 'contourf' if self.filled else 'contour'\n            raise ValueError(f'Cannot {func} log of negative values.')\n        self._process_contour_level_args(args[1:])\n        return (tri, z)",
      "instance_attributes": [
        {
          "name": "levels",
          "types": null
        },
        {
          "name": "zmin",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "zmax",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "_mins",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_maxs",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_contour_generator",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder",
      "name": "TrapezoidMapTriFinder",
      "qname": "lib.matplotlib.tri.trifinder.TrapezoidMapTriFinder",
      "decorators": [],
      "superclasses": [
        "TriFinder"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/__init__",
        "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/__call__",
        "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/_get_tree_stats",
        "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/_initialize",
        "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/_print_tree"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "`~matplotlib.tri.TriFinder` class implemented using the trapezoid\nmap algorithm from the book \"Computational Geometry, Algorithms and\nApplications\", second edition, by M. de Berg, M. van Kreveld, M. Overmars\nand O. Schwarzkopf.\n\nThe triangulation must be valid, i.e. it must not have duplicate points,\ntriangles formed from colinear points, or overlapping triangles.  The\nalgorithm has some tolerance to triangles formed from colinear points, but\nthis should not be relied upon.",
      "docstring": "`~matplotlib.tri.TriFinder` class implemented using the trapezoid\nmap algorithm from the book \"Computational Geometry, Algorithms and\nApplications\", second edition, by M. de Berg, M. van Kreveld, M. Overmars\nand O. Schwarzkopf.\n\nThe triangulation must be valid, i.e. it must not have duplicate points,\ntriangles formed from colinear points, or overlapping triangles.  The\nalgorithm has some tolerance to triangles formed from colinear points, but\nthis should not be relied upon.",
      "code": "class TrapezoidMapTriFinder(TriFinder):\n    \"\"\"\n    `~matplotlib.tri.TriFinder` class implemented using the trapezoid\n    map algorithm from the book \"Computational Geometry, Algorithms and\n    Applications\", second edition, by M. de Berg, M. van Kreveld, M. Overmars\n    and O. Schwarzkopf.\n\n    The triangulation must be valid, i.e. it must not have duplicate points,\n    triangles formed from colinear points, or overlapping triangles.  The\n    algorithm has some tolerance to triangles formed from colinear points, but\n    this should not be relied upon.\n    \"\"\"\n\n    def __init__(self, triangulation):\n        from matplotlib import _tri\n        super().__init__(triangulation)\n        self._cpp_trifinder = _tri.TrapezoidMapTriFinder(\n            triangulation.get_cpp_triangulation())\n        self._initialize()\n\n    def __call__(self, x, y):\n        \"\"\"\n        Return an array containing the indices of the triangles in which the\n        specified *x*, *y* points lie, or -1 for points that do not lie within\n        a triangle.\n\n        *x*, *y* are array-like x and y coordinates of the same shape and any\n        number of dimensions.\n\n        Returns integer array with the same shape and *x* and *y*.\n        \"\"\"\n        x = np.asarray(x, dtype=np.float64)\n        y = np.asarray(y, dtype=np.float64)\n        if x.shape != y.shape:\n            raise ValueError(\"x and y must be array-like with the same shape\")\n\n        # C++ does the heavy lifting, and expects 1D arrays.\n        indices = (self._cpp_trifinder.find_many(x.ravel(), y.ravel())\n                   .reshape(x.shape))\n        return indices\n\n    def _get_tree_stats(self):\n        \"\"\"\n        Return a python list containing the statistics about the node tree:\n            0: number of nodes (tree size)\n            1: number of unique nodes\n            2: number of trapezoids (tree leaf nodes)\n            3: number of unique trapezoids\n            4: maximum parent count (max number of times a node is repeated in\n                   tree)\n            5: maximum depth of tree (one more than the maximum number of\n                   comparisons needed to search through the tree)\n            6: mean of all trapezoid depths (one more than the average number\n                   of comparisons needed to search through the tree)\n        \"\"\"\n        return self._cpp_trifinder.get_tree_stats()\n\n    def _initialize(self):\n        \"\"\"\n        Initialize the underlying C++ object.  Can be called multiple times if,\n        for example, the triangulation is modified.\n        \"\"\"\n        self._cpp_trifinder.initialize()\n\n    def _print_tree(self):\n        \"\"\"\n        Print a text representation of the node tree, which is useful for\n        debugging purposes.\n        \"\"\"\n        self._cpp_trifinder.print_tree()",
      "instance_attributes": [
        {
          "name": "_cpp_trifinder",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trifinder/TriFinder",
      "name": "TriFinder",
      "qname": "lib.matplotlib.tri.trifinder.TriFinder",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.tri.trifinder/TriFinder/__init__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for classes used to find the triangles of a\nTriangulation in which (x, y) points lie.\n\nRather than instantiate an object of a class derived from TriFinder, it is\nusually better to use the function `.Triangulation.get_trifinder`.\n\nDerived classes implement __call__(x, y) where x and y are array-like point\ncoordinates of the same shape.",
      "docstring": "Abstract base class for classes used to find the triangles of a\nTriangulation in which (x, y) points lie.\n\nRather than instantiate an object of a class derived from TriFinder, it is\nusually better to use the function `.Triangulation.get_trifinder`.\n\nDerived classes implement __call__(x, y) where x and y are array-like point\ncoordinates of the same shape.",
      "code": "class TriFinder:\n    \"\"\"\n    Abstract base class for classes used to find the triangles of a\n    Triangulation in which (x, y) points lie.\n\n    Rather than instantiate an object of a class derived from TriFinder, it is\n    usually better to use the function `.Triangulation.get_trifinder`.\n\n    Derived classes implement __call__(x, y) where x and y are array-like point\n    coordinates of the same shape.\n    \"\"\"\n\n    def __init__(self, triangulation):\n        _api.check_isinstance(Triangulation, triangulation=triangulation)\n        self._triangulation = triangulation",
      "instance_attributes": [
        {
          "name": "_triangulation",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator",
      "name": "CubicTriInterpolator",
      "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator",
      "decorators": [],
      "superclasses": [
        "TriInterpolator"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__init__",
        "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__call__",
        "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/gradient",
        "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/_interpolate_single_key",
        "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/_compute_dof",
        "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/_get_alpha_vec",
        "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/_get_jacobian",
        "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/_compute_tri_eccentricities"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Cubic interpolator on a triangular grid.\n\nIn one-dimension - on a segment - a cubic interpolating function is\ndefined by the values of the function and its derivative at both ends.\nThis is almost the same in 2D inside a triangle, except that the values\nof the function and its 2 derivatives have to be defined at each triangle\nnode.\n\nThe CubicTriInterpolator takes the value of the function at each node -\nprovided by the user - and internally computes the value of the\nderivatives, resulting in a smooth interpolation.\n(As a special feature, the user can also impose the value of the\nderivatives at each node, but this is not supposed to be the common\nusage.)",
      "docstring": "Cubic interpolator on a triangular grid.\n\nIn one-dimension - on a segment - a cubic interpolating function is\ndefined by the values of the function and its derivative at both ends.\nThis is almost the same in 2D inside a triangle, except that the values\nof the function and its 2 derivatives have to be defined at each triangle\nnode.\n\nThe CubicTriInterpolator takes the value of the function at each node -\nprovided by the user - and internally computes the value of the\nderivatives, resulting in a smooth interpolation.\n(As a special feature, the user can also impose the value of the\nderivatives at each node, but this is not supposed to be the common\nusage.)\n\nParameters\n----------\ntriangulation : `~matplotlib.tri.Triangulation`\n    The triangulation to interpolate over.\nz : (npoints,) array-like\n    Array of values, defined at grid points, to interpolate between.\nkind : {'min_E', 'geom', 'user'}, optional\n    Choice of the smoothing algorithm, in order to compute\n    the interpolant derivatives (defaults to 'min_E'):\n\n    - if 'min_E': (default) The derivatives at each node is computed\n      to minimize a bending energy.\n    - if 'geom': The derivatives at each node is computed as a\n      weighted average of relevant triangle normals. To be used for\n      speed optimization (large grids).\n    - if 'user': The user provides the argument *dz*, no computation\n      is hence needed.\n\ntrifinder : `~matplotlib.tri.TriFinder`, optional\n    If not specified, the Triangulation's default TriFinder will\n    be used by calling `.Triangulation.get_trifinder`.\ndz : tuple of array-likes (dzdx, dzdy), optional\n    Used only if  *kind* ='user'. In this case *dz* must be provided as\n    (dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as *z* and\n    are the interpolant first derivatives at the *triangulation* points.\n\nMethods\n-------\n`__call__` (x, y) : Returns interpolated values at (x, y) points.\n`gradient` (x, y) : Returns interpolated derivatives at (x, y) points.\n\nNotes\n-----\nThis note is a bit technical and details how the cubic interpolation is\ncomputed.\n\nThe interpolation is based on a Clough-Tocher subdivision scheme of\nthe *triangulation* mesh (to make it clearer, each triangle of the\ngrid will be divided in 3 child-triangles, and on each child triangle\nthe interpolated function is a cubic polynomial of the 2 coordinates).\nThis technique originates from FEM (Finite Element Method) analysis;\nthe element used is a reduced Hsieh-Clough-Tocher (HCT)\nelement. Its shape functions are described in [1]_.\nThe assembled function is guaranteed to be C1-smooth, i.e. it is\ncontinuous and its first derivatives are also continuous (this\nis easy to show inside the triangles but is also true when crossing the\nedges).\n\nIn the default case (*kind* ='min_E'), the interpolant minimizes a\ncurvature energy on the functional space generated by the HCT element\nshape functions - with imposed values but arbitrary derivatives at each\nnode. The minimized functional is the integral of the so-called total\ncurvature (implementation based on an algorithm from [2]_ - PCG sparse\nsolver):\n\n    .. math::\n\n        E(z) = \\frac{1}{2} \\int_{\\Omega} \\left(\n            \\left( \\frac{\\partial^2{z}}{\\partial{x}^2} \\right)^2 +\n            \\left( \\frac{\\partial^2{z}}{\\partial{y}^2} \\right)^2 +\n            2\\left( \\frac{\\partial^2{z}}{\\partial{y}\\partial{x}} \\right)^2\n        \\right) dx\\,dy\n\nIf the case *kind* ='geom' is chosen by the user, a simple geometric\napproximation is used (weighted average of the triangle normal\nvectors), which could improve speed on very large grids.\n\nReferences\n----------\n.. [1] Michel Bernadou, Kamal Hassan, \"Basis functions for general\n    Hsieh-Clough-Tocher triangles, complete or reduced.\",\n    International Journal for Numerical Methods in Engineering,\n    17(5):784 - 789. 2.01.\n.. [2] C.T. Kelley, \"Iterative Methods for Optimization\".",
      "code": "class CubicTriInterpolator(TriInterpolator):\n    r\"\"\"\n    Cubic interpolator on a triangular grid.\n\n    In one-dimension - on a segment - a cubic interpolating function is\n    defined by the values of the function and its derivative at both ends.\n    This is almost the same in 2D inside a triangle, except that the values\n    of the function and its 2 derivatives have to be defined at each triangle\n    node.\n\n    The CubicTriInterpolator takes the value of the function at each node -\n    provided by the user - and internally computes the value of the\n    derivatives, resulting in a smooth interpolation.\n    (As a special feature, the user can also impose the value of the\n    derivatives at each node, but this is not supposed to be the common\n    usage.)\n\n    Parameters\n    ----------\n    triangulation : `~matplotlib.tri.Triangulation`\n        The triangulation to interpolate over.\n    z : (npoints,) array-like\n        Array of values, defined at grid points, to interpolate between.\n    kind : {'min_E', 'geom', 'user'}, optional\n        Choice of the smoothing algorithm, in order to compute\n        the interpolant derivatives (defaults to 'min_E'):\n\n        - if 'min_E': (default) The derivatives at each node is computed\n          to minimize a bending energy.\n        - if 'geom': The derivatives at each node is computed as a\n          weighted average of relevant triangle normals. To be used for\n          speed optimization (large grids).\n        - if 'user': The user provides the argument *dz*, no computation\n          is hence needed.\n\n    trifinder : `~matplotlib.tri.TriFinder`, optional\n        If not specified, the Triangulation's default TriFinder will\n        be used by calling `.Triangulation.get_trifinder`.\n    dz : tuple of array-likes (dzdx, dzdy), optional\n        Used only if  *kind* ='user'. In this case *dz* must be provided as\n        (dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as *z* and\n        are the interpolant first derivatives at the *triangulation* points.\n\n    Methods\n    -------\n    `__call__` (x, y) : Returns interpolated values at (x, y) points.\n    `gradient` (x, y) : Returns interpolated derivatives at (x, y) points.\n\n    Notes\n    -----\n    This note is a bit technical and details how the cubic interpolation is\n    computed.\n\n    The interpolation is based on a Clough-Tocher subdivision scheme of\n    the *triangulation* mesh (to make it clearer, each triangle of the\n    grid will be divided in 3 child-triangles, and on each child triangle\n    the interpolated function is a cubic polynomial of the 2 coordinates).\n    This technique originates from FEM (Finite Element Method) analysis;\n    the element used is a reduced Hsieh-Clough-Tocher (HCT)\n    element. Its shape functions are described in [1]_.\n    The assembled function is guaranteed to be C1-smooth, i.e. it is\n    continuous and its first derivatives are also continuous (this\n    is easy to show inside the triangles but is also true when crossing the\n    edges).\n\n    In the default case (*kind* ='min_E'), the interpolant minimizes a\n    curvature energy on the functional space generated by the HCT element\n    shape functions - with imposed values but arbitrary derivatives at each\n    node. The minimized functional is the integral of the so-called total\n    curvature (implementation based on an algorithm from [2]_ - PCG sparse\n    solver):\n\n        .. math::\n\n            E(z) = \\frac{1}{2} \\int_{\\Omega} \\left(\n                \\left( \\frac{\\partial^2{z}}{\\partial{x}^2} \\right)^2 +\n                \\left( \\frac{\\partial^2{z}}{\\partial{y}^2} \\right)^2 +\n                2\\left( \\frac{\\partial^2{z}}{\\partial{y}\\partial{x}} \\right)^2\n            \\right) dx\\,dy\n\n    If the case *kind* ='geom' is chosen by the user, a simple geometric\n    approximation is used (weighted average of the triangle normal\n    vectors), which could improve speed on very large grids.\n\n    References\n    ----------\n    .. [1] Michel Bernadou, Kamal Hassan, \"Basis functions for general\n        Hsieh-Clough-Tocher triangles, complete or reduced.\",\n        International Journal for Numerical Methods in Engineering,\n        17(5):784 - 789. 2.01.\n    .. [2] C.T. Kelley, \"Iterative Methods for Optimization\".\n\n    \"\"\"\n    def __init__(self, triangulation, z, kind='min_E', trifinder=None,\n                 dz=None):\n        super().__init__(triangulation, z, trifinder)\n\n        # Loads the underlying c++ _triangulation.\n        # (During loading, reordering of triangulation._triangles may occur so\n        # that all final triangles are now anti-clockwise)\n        self._triangulation.get_cpp_triangulation()\n\n        # To build the stiffness matrix and avoid zero-energy spurious modes\n        # we will only store internally the valid (unmasked) triangles and\n        # the necessary (used) points coordinates.\n        # 2 renumbering tables need to be computed and stored:\n        #  - a triangle renum table in order to translate the result from a\n        #    TriFinder instance into the internal stored triangle number.\n        #  - a node renum table to overwrite the self._z values into the new\n        #    (used) node numbering.\n        tri_analyzer = TriAnalyzer(self._triangulation)\n        (compressed_triangles, compressed_x, compressed_y, tri_renum,\n         node_renum) = tri_analyzer._get_compressed_triangulation()\n        self._triangles = compressed_triangles\n        self._tri_renum = tri_renum\n        # Taking into account the node renumbering in self._z:\n        valid_node = (node_renum != -1)\n        self._z[node_renum[valid_node]] = self._z[valid_node]\n\n        # Computing scale factors\n        self._unit_x = np.ptp(compressed_x)\n        self._unit_y = np.ptp(compressed_y)\n        self._pts = np.column_stack([compressed_x / self._unit_x,\n                                     compressed_y / self._unit_y])\n        # Computing triangle points\n        self._tris_pts = self._pts[self._triangles]\n        # Computing eccentricities\n        self._eccs = self._compute_tri_eccentricities(self._tris_pts)\n        # Computing dof estimations for HCT triangle shape function\n        _api.check_in_list(['user', 'geom', 'min_E'], kind=kind)\n        self._dof = self._compute_dof(kind, dz=dz)\n        # Loading HCT element\n        self._ReferenceElement = _ReducedHCT_Element()\n\n    def __call__(self, x, y):\n        return self._interpolate_multikeys(x, y, tri_index=None,\n                                           return_keys=('z',))[0]\n    __call__.__doc__ = TriInterpolator._docstring__call__\n\n    def gradient(self, x, y):\n        return self._interpolate_multikeys(x, y, tri_index=None,\n                                           return_keys=('dzdx', 'dzdy'))\n    gradient.__doc__ = TriInterpolator._docstringgradient\n\n    def _interpolate_single_key(self, return_key, tri_index, x, y):\n        _api.check_in_list(['z', 'dzdx', 'dzdy'], return_key=return_key)\n        tris_pts = self._tris_pts[tri_index]\n        alpha = self._get_alpha_vec(x, y, tris_pts)\n        ecc = self._eccs[tri_index]\n        dof = np.expand_dims(self._dof[tri_index], axis=1)\n        if return_key == 'z':\n            return self._ReferenceElement.get_function_values(\n                alpha, ecc, dof)\n        else:  # 'dzdx', 'dzdy'\n            J = self._get_jacobian(tris_pts)\n            dzdx = self._ReferenceElement.get_function_derivatives(\n                alpha, J, ecc, dof)\n            if return_key == 'dzdx':\n                return dzdx[:, 0, 0]\n            else:\n                return dzdx[:, 1, 0]\n\n    def _compute_dof(self, kind, dz=None):\n        \"\"\"\n        Compute and return nodal dofs according to kind.\n\n        Parameters\n        ----------\n        kind : {'min_E', 'geom', 'user'}\n            Choice of the _DOF_estimator subclass to estimate the gradient.\n        dz : tuple of array-likes (dzdx, dzdy), optional\n            Used only if *kind*=user; in this case passed to the\n            :class:`_DOF_estimator_user`.\n\n        Returns\n        -------\n        array-like, shape (npts, 2)\n            Estimation of the gradient at triangulation nodes (stored as\n            degree of freedoms of reduced-HCT triangle elements).\n        \"\"\"\n        if kind == 'user':\n            if dz is None:\n                raise ValueError(\"For a CubicTriInterpolator with \"\n                                 \"*kind*='user', a valid *dz* \"\n                                 \"argument is expected.\")\n            TE = _DOF_estimator_user(self, dz=dz)\n        elif kind == 'geom':\n            TE = _DOF_estimator_geom(self)\n        else:  # 'min_E', checked in __init__\n            TE = _DOF_estimator_min_E(self)\n        return TE.compute_dof_from_df()\n\n    @staticmethod\n    def _get_alpha_vec(x, y, tris_pts):\n        \"\"\"\n        Fast (vectorized) function to compute barycentric coordinates alpha.\n\n        Parameters\n        ----------\n        x, y : array-like of dim 1 (shape (nx,))\n            Coordinates of the points whose points barycentric coordinates are\n            requested.\n        tris_pts : array like of dim 3 (shape: (nx, 3, 2))\n            Coordinates of the containing triangles apexes.\n\n        Returns\n        -------\n        array of dim 2 (shape (nx, 3))\n            Barycentric coordinates of the points inside the containing\n            triangles.\n        \"\"\"\n        ndim = tris_pts.ndim-2\n\n        a = tris_pts[:, 1, :] - tris_pts[:, 0, :]\n        b = tris_pts[:, 2, :] - tris_pts[:, 0, :]\n        abT = np.stack([a, b], axis=-1)\n        ab = _transpose_vectorized(abT)\n        OM = np.stack([x, y], axis=1) - tris_pts[:, 0, :]\n\n        metric = ab @ abT\n        # Here we try to deal with the colinear cases.\n        # metric_inv is in this case set to the Moore-Penrose pseudo-inverse\n        # meaning that we will still return a set of valid barycentric\n        # coordinates.\n        metric_inv = _pseudo_inv22sym_vectorized(metric)\n        Covar = ab @ _transpose_vectorized(np.expand_dims(OM, ndim))\n        ksi = metric_inv @ Covar\n        alpha = _to_matrix_vectorized([\n            [1-ksi[:, 0, 0]-ksi[:, 1, 0]], [ksi[:, 0, 0]], [ksi[:, 1, 0]]])\n        return alpha\n\n    @staticmethod\n    def _get_jacobian(tris_pts):\n        \"\"\"\n        Fast (vectorized) function to compute triangle jacobian matrix.\n\n        Parameters\n        ----------\n        tris_pts : array like of dim 3 (shape: (nx, 3, 2))\n            Coordinates of the containing triangles apexes.\n\n        Returns\n        -------\n        array of dim 3 (shape (nx, 2, 2))\n            Barycentric coordinates of the points inside the containing\n            triangles.\n            J[itri, :, :] is the jacobian matrix at apex 0 of the triangle\n            itri, so that the following (matrix) relationship holds:\n               [dz/dksi] = [J] x [dz/dx]\n            with x: global coordinates\n                 ksi: element parametric coordinates in triangle first apex\n                 local basis.\n        \"\"\"\n        a = np.array(tris_pts[:, 1, :] - tris_pts[:, 0, :])\n        b = np.array(tris_pts[:, 2, :] - tris_pts[:, 0, :])\n        J = _to_matrix_vectorized([[a[:, 0], a[:, 1]],\n                                   [b[:, 0], b[:, 1]]])\n        return J\n\n    @staticmethod\n    def _compute_tri_eccentricities(tris_pts):\n        \"\"\"\n        Compute triangle eccentricities.\n\n        Parameters\n        ----------\n        tris_pts : array like of dim 3 (shape: (nx, 3, 2))\n            Coordinates of the triangles apexes.\n\n        Returns\n        -------\n        array like of dim 2 (shape: (nx, 3))\n            The so-called eccentricity parameters [1] needed for HCT triangular\n            element.\n        \"\"\"\n        a = np.expand_dims(tris_pts[:, 2, :] - tris_pts[:, 1, :], axis=2)\n        b = np.expand_dims(tris_pts[:, 0, :] - tris_pts[:, 2, :], axis=2)\n        c = np.expand_dims(tris_pts[:, 1, :] - tris_pts[:, 0, :], axis=2)\n        # Do not use np.squeeze, this is dangerous if only one triangle\n        # in the triangulation...\n        dot_a = (_transpose_vectorized(a) @ a)[:, 0, 0]\n        dot_b = (_transpose_vectorized(b) @ b)[:, 0, 0]\n        dot_c = (_transpose_vectorized(c) @ c)[:, 0, 0]\n        # Note that this line will raise a warning for dot_a, dot_b or dot_c\n        # zeros, but we choose not to support triangles with duplicate points.\n        return _to_matrix_vectorized([[(dot_c-dot_b) / dot_a],\n                                      [(dot_a-dot_c) / dot_b],\n                                      [(dot_b-dot_a) / dot_c]])",
      "instance_attributes": [
        {
          "name": "_triangles",
          "types": null
        },
        {
          "name": "_tri_renum",
          "types": null
        },
        {
          "name": "_unit_x",
          "types": null
        },
        {
          "name": "_unit_y",
          "types": null
        },
        {
          "name": "_pts",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_tris_pts",
          "types": null
        },
        {
          "name": "_eccs",
          "types": {
            "kind": "NamedType",
            "name": "ndarray"
          }
        },
        {
          "name": "_dof",
          "types": {
            "kind": "NamedType",
            "name": "ndarray"
          }
        },
        {
          "name": "_ReferenceElement",
          "types": {
            "kind": "NamedType",
            "name": "_ReducedHCT_Element"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator",
      "name": "LinearTriInterpolator",
      "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator",
      "decorators": [],
      "superclasses": [
        "TriInterpolator"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__init__",
        "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__call__",
        "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/gradient",
        "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/_interpolate_single_key"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Linear interpolator on a triangular grid.\n\nEach triangle is represented by a plane so that an interpolated value at\npoint (x, y) lies on the plane of the triangle containing (x, y).\nInterpolated values are therefore continuous across the triangulation, but\ntheir first derivatives are discontinuous at edges between triangles.",
      "docstring": "Linear interpolator on a triangular grid.\n\nEach triangle is represented by a plane so that an interpolated value at\npoint (x, y) lies on the plane of the triangle containing (x, y).\nInterpolated values are therefore continuous across the triangulation, but\ntheir first derivatives are discontinuous at edges between triangles.\n\nParameters\n----------\ntriangulation : `~matplotlib.tri.Triangulation`\n    The triangulation to interpolate over.\nz : (npoints,) array-like\n    Array of values, defined at grid points, to interpolate between.\ntrifinder : `~matplotlib.tri.TriFinder`, optional\n    If this is not specified, the Triangulation's default TriFinder will\n    be used by calling `.Triangulation.get_trifinder`.\n\nMethods\n-------\n`__call__` (x, y) : Returns interpolated values at (x, y) points.\n`gradient` (x, y) : Returns interpolated derivatives at (x, y) points.",
      "code": "class LinearTriInterpolator(TriInterpolator):\n    \"\"\"\n    Linear interpolator on a triangular grid.\n\n    Each triangle is represented by a plane so that an interpolated value at\n    point (x, y) lies on the plane of the triangle containing (x, y).\n    Interpolated values are therefore continuous across the triangulation, but\n    their first derivatives are discontinuous at edges between triangles.\n\n    Parameters\n    ----------\n    triangulation : `~matplotlib.tri.Triangulation`\n        The triangulation to interpolate over.\n    z : (npoints,) array-like\n        Array of values, defined at grid points, to interpolate between.\n    trifinder : `~matplotlib.tri.TriFinder`, optional\n        If this is not specified, the Triangulation's default TriFinder will\n        be used by calling `.Triangulation.get_trifinder`.\n\n    Methods\n    -------\n    `__call__` (x, y) : Returns interpolated values at (x, y) points.\n    `gradient` (x, y) : Returns interpolated derivatives at (x, y) points.\n\n    \"\"\"\n    def __init__(self, triangulation, z, trifinder=None):\n        super().__init__(triangulation, z, trifinder)\n\n        # Store plane coefficients for fast interpolation calculations.\n        self._plane_coefficients = \\\n            self._triangulation.calculate_plane_coefficients(self._z)\n\n    def __call__(self, x, y):\n        return self._interpolate_multikeys(x, y, tri_index=None,\n                                           return_keys=('z',))[0]\n    __call__.__doc__ = TriInterpolator._docstring__call__\n\n    def gradient(self, x, y):\n        return self._interpolate_multikeys(x, y, tri_index=None,\n                                           return_keys=('dzdx', 'dzdy'))\n    gradient.__doc__ = TriInterpolator._docstringgradient\n\n    def _interpolate_single_key(self, return_key, tri_index, x, y):\n        _api.check_in_list(['z', 'dzdx', 'dzdy'], return_key=return_key)\n        if return_key == 'z':\n            return (self._plane_coefficients[tri_index, 0]*x +\n                    self._plane_coefficients[tri_index, 1]*y +\n                    self._plane_coefficients[tri_index, 2])\n        elif return_key == 'dzdx':\n            return self._plane_coefficients[tri_index, 0]\n        else:  # 'dzdy'\n            return self._plane_coefficients[tri_index, 1]",
      "instance_attributes": [
        {
          "name": "_plane_coefficients",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/TriInterpolator",
      "name": "TriInterpolator",
      "qname": "lib.matplotlib.tri.triinterpolate.TriInterpolator",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.tri.triinterpolate/TriInterpolator/__init__",
        "matplotlib/lib.matplotlib.tri.triinterpolate/TriInterpolator/_interpolate_multikeys",
        "matplotlib/lib.matplotlib.tri.triinterpolate/TriInterpolator/_interpolate_single_key"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for classes used to interpolate on a triangular grid.\n\nDerived classes implement the following methods:\n\n- ``__call__(x, y)``,\n  where x, y are array-like point coordinates of the same shape, and\n  that returns a masked array of the same shape containing the\n  interpolated z-values.\n\n- ``gradient(x, y)``,\n  where x, y are array-like point coordinates of the same\n  shape, and that returns a list of 2 masked arrays of the same shape\n  containing the 2 derivatives of the interpolator (derivatives of\n  interpolated z values with respect to x and y).",
      "docstring": "Abstract base class for classes used to interpolate on a triangular grid.\n\nDerived classes implement the following methods:\n\n- ``__call__(x, y)``,\n  where x, y are array-like point coordinates of the same shape, and\n  that returns a masked array of the same shape containing the\n  interpolated z-values.\n\n- ``gradient(x, y)``,\n  where x, y are array-like point coordinates of the same\n  shape, and that returns a list of 2 masked arrays of the same shape\n  containing the 2 derivatives of the interpolator (derivatives of\n  interpolated z values with respect to x and y).",
      "code": "class TriInterpolator:\n    \"\"\"\n    Abstract base class for classes used to interpolate on a triangular grid.\n\n    Derived classes implement the following methods:\n\n    - ``__call__(x, y)``,\n      where x, y are array-like point coordinates of the same shape, and\n      that returns a masked array of the same shape containing the\n      interpolated z-values.\n\n    - ``gradient(x, y)``,\n      where x, y are array-like point coordinates of the same\n      shape, and that returns a list of 2 masked arrays of the same shape\n      containing the 2 derivatives of the interpolator (derivatives of\n      interpolated z values with respect to x and y).\n    \"\"\"\n\n    def __init__(self, triangulation, z, trifinder=None):\n        _api.check_isinstance(Triangulation, triangulation=triangulation)\n        self._triangulation = triangulation\n\n        self._z = np.asarray(z)\n        if self._z.shape != self._triangulation.x.shape:\n            raise ValueError(\"z array must have same length as triangulation x\"\n                             \" and y arrays\")\n\n        _api.check_isinstance((TriFinder, None), trifinder=trifinder)\n        self._trifinder = trifinder or self._triangulation.get_trifinder()\n\n        # Default scaling factors : 1.0 (= no scaling)\n        # Scaling may be used for interpolations for which the order of\n        # magnitude of x, y has an impact on the interpolant definition.\n        # Please refer to :meth:`_interpolate_multikeys` for details.\n        self._unit_x = 1.0\n        self._unit_y = 1.0\n\n        # Default triangle renumbering: None (= no renumbering)\n        # Renumbering may be used to avoid unnecessary computations\n        # if complex calculations are done inside the Interpolator.\n        # Please refer to :meth:`_interpolate_multikeys` for details.\n        self._tri_renum = None\n\n    # __call__ and gradient docstrings are shared by all subclasses\n    # (except, if needed, relevant additions).\n    # However these methods are only implemented in subclasses to avoid\n    # confusion in the documentation.\n    _docstring__call__ = \"\"\"\n        Returns a masked array containing interpolated values at the specified\n        (x, y) points.\n\n        Parameters\n        ----------\n        x, y : array-like\n            x and y coordinates of the same shape and any number of\n            dimensions.\n\n        Returns\n        -------\n        np.ma.array\n            Masked array of the same shape as *x* and *y*; values corresponding\n            to (*x*, *y*) points outside of the triangulation are masked out.\n\n        \"\"\"\n\n    _docstringgradient = r\"\"\"\n        Returns a list of 2 masked arrays containing interpolated derivatives\n        at the specified (x, y) points.\n\n        Parameters\n        ----------\n        x, y : array-like\n            x and y coordinates of the same shape and any number of\n            dimensions.\n\n        Returns\n        -------\n        dzdx, dzdy : np.ma.array\n            2 masked arrays of the same shape as *x* and *y*; values\n            corresponding to (x, y) points outside of the triangulation\n            are masked out.\n            The first returned array contains the values of\n            :math:`\\frac{\\partial z}{\\partial x}` and the second those of\n            :math:`\\frac{\\partial z}{\\partial y}`.\n\n        \"\"\"\n\n    def _interpolate_multikeys(self, x, y, tri_index=None,\n                               return_keys=('z',)):\n        \"\"\"\n        Versatile (private) method defined for all TriInterpolators.\n\n        :meth:`_interpolate_multikeys` is a wrapper around method\n        :meth:`_interpolate_single_key` (to be defined in the child\n        subclasses).\n        :meth:`_interpolate_single_key actually performs the interpolation,\n        but only for 1-dimensional inputs and at valid locations (inside\n        unmasked triangles of the triangulation).\n\n        The purpose of :meth:`_interpolate_multikeys` is to implement the\n        following common tasks needed in all subclasses implementations:\n\n        - calculation of containing triangles\n        - dealing with more than one interpolation request at the same\n          location (e.g., if the 2 derivatives are requested, it is\n          unnecessary to compute the containing triangles twice)\n        - scaling according to self._unit_x, self._unit_y\n        - dealing with points outside of the grid (with fill value np.nan)\n        - dealing with multi-dimensional *x*, *y* arrays: flattening for\n          :meth:`_interpolate_params` call and final reshaping.\n\n        (Note that np.vectorize could do most of those things very well for\n        you, but it does it by function evaluations over successive tuples of\n        the input arrays. Therefore, this tends to be more time consuming than\n        using optimized numpy functions - e.g., np.dot - which can be used\n        easily on the flattened inputs, in the child-subclass methods\n        :meth:`_interpolate_single_key`.)\n\n        It is guaranteed that the calls to :meth:`_interpolate_single_key`\n        will be done with flattened (1-d) array-like input parameters *x*, *y*\n        and with flattened, valid `tri_index` arrays (no -1 index allowed).\n\n        Parameters\n        ----------\n        x, y : array-like\n            x and y coordinates where interpolated values are requested.\n        tri_index : array-like of int, optional\n            Array of the containing triangle indices, same shape as\n            *x* and *y*. Defaults to None. If None, these indices\n            will be computed by a TriFinder instance.\n            (Note: For point outside the grid, tri_index[ipt] shall be -1).\n        return_keys : tuple of keys from {'z', 'dzdx', 'dzdy'}\n            Defines the interpolation arrays to return, and in which order.\n\n        Returns\n        -------\n        list of arrays\n            Each array-like contains the expected interpolated values in the\n            order defined by *return_keys* parameter.\n        \"\"\"\n        # Flattening and rescaling inputs arrays x, y\n        # (initial shape is stored for output)\n        x = np.asarray(x, dtype=np.float64)\n        y = np.asarray(y, dtype=np.float64)\n        sh_ret = x.shape\n        if x.shape != y.shape:\n            raise ValueError(\"x and y shall have same shapes.\"\n                             \" Given: {0} and {1}\".format(x.shape, y.shape))\n        x = np.ravel(x)\n        y = np.ravel(y)\n        x_scaled = x/self._unit_x\n        y_scaled = y/self._unit_y\n        size_ret = np.size(x_scaled)\n\n        # Computes & ravels the element indexes, extract the valid ones.\n        if tri_index is None:\n            tri_index = self._trifinder(x, y)\n        else:\n            if tri_index.shape != sh_ret:\n                raise ValueError(\n                    \"tri_index array is provided and shall\"\n                    \" have same shape as x and y. Given: \"\n                    \"{0} and {1}\".format(tri_index.shape, sh_ret))\n            tri_index = np.ravel(tri_index)\n\n        mask_in = (tri_index != -1)\n        if self._tri_renum is None:\n            valid_tri_index = tri_index[mask_in]\n        else:\n            valid_tri_index = self._tri_renum[tri_index[mask_in]]\n        valid_x = x_scaled[mask_in]\n        valid_y = y_scaled[mask_in]\n\n        ret = []\n        for return_key in return_keys:\n            # Find the return index associated with the key.\n            try:\n                return_index = {'z': 0, 'dzdx': 1, 'dzdy': 2}[return_key]\n            except KeyError as err:\n                raise ValueError(\"return_keys items shall take values in\"\n                                 \" {'z', 'dzdx', 'dzdy'}\") from err\n\n            # Sets the scale factor for f & df components\n            scale = [1., 1./self._unit_x, 1./self._unit_y][return_index]\n\n            # Computes the interpolation\n            ret_loc = np.empty(size_ret, dtype=np.float64)\n            ret_loc[~mask_in] = np.nan\n            ret_loc[mask_in] = self._interpolate_single_key(\n                return_key, valid_tri_index, valid_x, valid_y) * scale\n            ret += [np.ma.masked_invalid(ret_loc.reshape(sh_ret), copy=False)]\n\n        return ret\n\n    def _interpolate_single_key(self, return_key, tri_index, x, y):\n        \"\"\"\n        Interpolate at points belonging to the triangulation\n        (inside an unmasked triangles).\n\n        Parameters\n        ----------\n        return_key : {'z', 'dzdx', 'dzdy'}\n            The requested values (z or its derivatives).\n        tri_index : 1D int array\n            Valid triangle index (cannot be -1).\n        x, y : 1D arrays, same shape as `tri_index`\n            Valid locations where interpolation is requested.\n\n        Returns\n        -------\n        1-d array\n            Returned array of the same size as *tri_index*\n        \"\"\"\n        raise NotImplementedError(\"TriInterpolator subclasses\" +\n                                  \"should implement _interpolate_single_key!\")",
      "instance_attributes": [
        {
          "name": "_triangulation",
          "types": null
        },
        {
          "name": "_z",
          "types": null
        },
        {
          "name": "_trifinder",
          "types": null
        },
        {
          "name": "_unit_x",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "_unit_y",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "_tri_renum",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trirefine/TriRefiner",
      "name": "TriRefiner",
      "qname": "lib.matplotlib.tri.trirefine.TriRefiner",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.tri.trirefine/TriRefiner/__init__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for classes implementing mesh refinement.\n\nA TriRefiner encapsulates a Triangulation object and provides tools for\nmesh refinement and interpolation.\n\nDerived classes must implement:\n\n- ``refine_triangulation(return_tri_index=False, **kwargs)`` , where\n  the optional keyword arguments *kwargs* are defined in each\n  TriRefiner concrete implementation, and which returns:\n\n  - a refined triangulation,\n  - optionally (depending on *return_tri_index*), for each\n    point of the refined triangulation: the index of\n    the initial triangulation triangle to which it belongs.\n\n- ``refine_field(z, triinterpolator=None, **kwargs)``, where:\n\n  - *z* array of field values (to refine) defined at the base\n    triangulation nodes,\n  - *triinterpolator* is an optional `~matplotlib.tri.TriInterpolator`,\n  - the other optional keyword arguments *kwargs* are defined in\n    each TriRefiner concrete implementation;\n\n  and which returns (as a tuple) a refined triangular mesh and the\n  interpolated values of the field at the refined triangulation nodes.",
      "docstring": "Abstract base class for classes implementing mesh refinement.\n\nA TriRefiner encapsulates a Triangulation object and provides tools for\nmesh refinement and interpolation.\n\nDerived classes must implement:\n\n- ``refine_triangulation(return_tri_index=False, **kwargs)`` , where\n  the optional keyword arguments *kwargs* are defined in each\n  TriRefiner concrete implementation, and which returns:\n\n  - a refined triangulation,\n  - optionally (depending on *return_tri_index*), for each\n    point of the refined triangulation: the index of\n    the initial triangulation triangle to which it belongs.\n\n- ``refine_field(z, triinterpolator=None, **kwargs)``, where:\n\n  - *z* array of field values (to refine) defined at the base\n    triangulation nodes,\n  - *triinterpolator* is an optional `~matplotlib.tri.TriInterpolator`,\n  - the other optional keyword arguments *kwargs* are defined in\n    each TriRefiner concrete implementation;\n\n  and which returns (as a tuple) a refined triangular mesh and the\n  interpolated values of the field at the refined triangulation nodes.",
      "code": "class TriRefiner:\n    \"\"\"\n    Abstract base class for classes implementing mesh refinement.\n\n    A TriRefiner encapsulates a Triangulation object and provides tools for\n    mesh refinement and interpolation.\n\n    Derived classes must implement:\n\n    - ``refine_triangulation(return_tri_index=False, **kwargs)`` , where\n      the optional keyword arguments *kwargs* are defined in each\n      TriRefiner concrete implementation, and which returns:\n\n      - a refined triangulation,\n      - optionally (depending on *return_tri_index*), for each\n        point of the refined triangulation: the index of\n        the initial triangulation triangle to which it belongs.\n\n    - ``refine_field(z, triinterpolator=None, **kwargs)``, where:\n\n      - *z* array of field values (to refine) defined at the base\n        triangulation nodes,\n      - *triinterpolator* is an optional `~matplotlib.tri.TriInterpolator`,\n      - the other optional keyword arguments *kwargs* are defined in\n        each TriRefiner concrete implementation;\n\n      and which returns (as a tuple) a refined triangular mesh and the\n      interpolated values of the field at the refined triangulation nodes.\n    \"\"\"\n\n    def __init__(self, triangulation):\n        _api.check_isinstance(Triangulation, triangulation=triangulation)\n        self._triangulation = triangulation",
      "instance_attributes": [
        {
          "name": "_triangulation",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner",
      "name": "UniformTriRefiner",
      "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner",
      "decorators": [],
      "superclasses": [
        "TriRefiner"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/__init__",
        "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_triangulation",
        "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_field",
        "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/_refine_triangulation_once"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Uniform mesh refinement by recursive subdivisions.",
      "docstring": "Uniform mesh refinement by recursive subdivisions.\n\nParameters\n----------\ntriangulation : `~matplotlib.tri.Triangulation`\n    The encapsulated triangulation (to be refined)",
      "code": "class UniformTriRefiner(TriRefiner):\n    \"\"\"\n    Uniform mesh refinement by recursive subdivisions.\n\n    Parameters\n    ----------\n    triangulation : `~matplotlib.tri.Triangulation`\n        The encapsulated triangulation (to be refined)\n    \"\"\"\n#    See Also\n#    --------\n#    :class:`~matplotlib.tri.CubicTriInterpolator` and\n#    :class:`~matplotlib.tri.TriAnalyzer`.\n#    \"\"\"\n    def __init__(self, triangulation):\n        super().__init__(triangulation)\n\n    def refine_triangulation(self, return_tri_index=False, subdiv=3):\n        \"\"\"\n        Compute an uniformly refined triangulation *refi_triangulation* of\n        the encapsulated :attr:`triangulation`.\n\n        This function refines the encapsulated triangulation by splitting each\n        father triangle into 4 child sub-triangles built on the edges midside\n        nodes, recursing *subdiv* times.  In the end, each triangle is hence\n        divided into ``4**subdiv`` child triangles.\n\n        Parameters\n        ----------\n        return_tri_index : bool, default: False\n            Whether an index table indicating the father triangle index of each\n            point is returned.\n        subdiv : int, default: 3\n            Recursion level for the subdivision.\n            Each triangle is divided into ``4**subdiv`` child triangles;\n            hence, the default results in 64 refined subtriangles for each\n            triangle of the initial triangulation.\n\n        Returns\n        -------\n        refi_triangulation : `~matplotlib.tri.Triangulation`\n            The refined triangulation.\n        found_index : int array\n            Index of the initial triangulation containing triangle, for each\n            point of *refi_triangulation*.\n            Returned only if *return_tri_index* is set to True.\n        \"\"\"\n        refi_triangulation = self._triangulation\n        ntri = refi_triangulation.triangles.shape[0]\n\n        # Computes the triangulation ancestors numbers in the reference\n        # triangulation.\n        ancestors = np.arange(ntri, dtype=np.int32)\n        for _ in range(subdiv):\n            refi_triangulation, ancestors = self._refine_triangulation_once(\n                refi_triangulation, ancestors)\n        refi_npts = refi_triangulation.x.shape[0]\n        refi_triangles = refi_triangulation.triangles\n\n        # Now we compute found_index table if needed\n        if return_tri_index:\n            # We have to initialize found_index with -1 because some nodes\n            # may very well belong to no triangle at all, e.g., in case of\n            # Delaunay Triangulation with DuplicatePointWarning.\n            found_index = np.full(refi_npts, -1, dtype=np.int32)\n            tri_mask = self._triangulation.mask\n            if tri_mask is None:\n                found_index[refi_triangles] = np.repeat(ancestors,\n                                                        3).reshape(-1, 3)\n            else:\n                # There is a subtlety here: we want to avoid whenever possible\n                # that refined points container is a masked triangle (which\n                # would result in artifacts in plots).\n                # So we impose the numbering from masked ancestors first,\n                # then overwrite it with unmasked ancestor numbers.\n                ancestor_mask = tri_mask[ancestors]\n                found_index[refi_triangles[ancestor_mask, :]\n                            ] = np.repeat(ancestors[ancestor_mask],\n                                          3).reshape(-1, 3)\n                found_index[refi_triangles[~ancestor_mask, :]\n                            ] = np.repeat(ancestors[~ancestor_mask],\n                                          3).reshape(-1, 3)\n            return refi_triangulation, found_index\n        else:\n            return refi_triangulation\n\n    def refine_field(self, z, triinterpolator=None, subdiv=3):\n        \"\"\"\n        Refine a field defined on the encapsulated triangulation.\n\n        Parameters\n        ----------\n        z : (npoints,) array-like\n            Values of the field to refine, defined at the nodes of the\n            encapsulated triangulation. (``n_points`` is the number of points\n            in the initial triangulation)\n        triinterpolator : `~matplotlib.tri.TriInterpolator`, optional\n            Interpolator used for field interpolation. If not specified,\n            a `~matplotlib.tri.CubicTriInterpolator` will be used.\n        subdiv : int, default: 3\n            Recursion level for the subdivision.\n            Each triangle is divided into ``4**subdiv`` child triangles.\n\n        Returns\n        -------\n        refi_tri : `~matplotlib.tri.Triangulation`\n             The returned refined triangulation.\n        refi_z : 1D array of length: *refi_tri* node count.\n             The returned interpolated field (at *refi_tri* nodes).\n        \"\"\"\n        if triinterpolator is None:\n            interp = matplotlib.tri.CubicTriInterpolator(\n                self._triangulation, z)\n        else:\n            _api.check_isinstance(matplotlib.tri.TriInterpolator,\n                                  triinterpolator=triinterpolator)\n            interp = triinterpolator\n\n        refi_tri, found_index = self.refine_triangulation(\n            subdiv=subdiv, return_tri_index=True)\n        refi_z = interp._interpolate_multikeys(\n            refi_tri.x, refi_tri.y, tri_index=found_index)[0]\n        return refi_tri, refi_z\n\n    @staticmethod\n    def _refine_triangulation_once(triangulation, ancestors=None):\n        \"\"\"\n        Refine a `.Triangulation` by splitting each triangle into 4\n        child-masked_triangles built on the edges midside nodes.\n\n        Masked triangles, if present, are also split, but their children\n        returned masked.\n\n        If *ancestors* is not provided, returns only a new triangulation:\n        child_triangulation.\n\n        If the array-like key table *ancestor* is given, it shall be of shape\n        (ntri,) where ntri is the number of *triangulation* masked_triangles.\n        In this case, the function returns\n        (child_triangulation, child_ancestors)\n        child_ancestors is defined so that the 4 child masked_triangles share\n        the same index as their father: child_ancestors.shape = (4 * ntri,).\n        \"\"\"\n\n        x = triangulation.x\n        y = triangulation.y\n\n        #    According to tri.triangulation doc:\n        #         neighbors[i, j] is the triangle that is the neighbor\n        #         to the edge from point index masked_triangles[i, j] to point\n        #         index masked_triangles[i, (j+1)%3].\n        neighbors = triangulation.neighbors\n        triangles = triangulation.triangles\n        npts = np.shape(x)[0]\n        ntri = np.shape(triangles)[0]\n        if ancestors is not None:\n            ancestors = np.asarray(ancestors)\n            if np.shape(ancestors) != (ntri,):\n                raise ValueError(\n                    \"Incompatible shapes provide for triangulation\"\n                    \".masked_triangles and ancestors: {0} and {1}\".format(\n                        np.shape(triangles), np.shape(ancestors)))\n\n        # Initiating tables refi_x and refi_y of the refined triangulation\n        # points\n        # hint: each apex is shared by 2 masked_triangles except the borders.\n        borders = np.sum(neighbors == -1)\n        added_pts = (3*ntri + borders) // 2\n        refi_npts = npts + added_pts\n        refi_x = np.zeros(refi_npts)\n        refi_y = np.zeros(refi_npts)\n\n        # First part of refi_x, refi_y is just the initial points\n        refi_x[:npts] = x\n        refi_y[:npts] = y\n\n        # Second part contains the edge midside nodes.\n        # Each edge belongs to 1 triangle (if border edge) or is shared by 2\n        # masked_triangles (interior edge).\n        # We first build 2 * ntri arrays of edge starting nodes (edge_elems,\n        # edge_apexes); we then extract only the masters to avoid overlaps.\n        # The so-called 'master' is the triangle with biggest index\n        # The 'slave' is the triangle with lower index\n        # (can be -1 if border edge)\n        # For slave and master we will identify the apex pointing to the edge\n        # start\n        edge_elems = np.tile(np.arange(ntri, dtype=np.int32), 3)\n        edge_apexes = np.repeat(np.arange(3, dtype=np.int32), ntri)\n        edge_neighbors = neighbors[edge_elems, edge_apexes]\n        mask_masters = (edge_elems > edge_neighbors)\n\n        # Identifying the \"masters\" and adding to refi_x, refi_y vec\n        masters = edge_elems[mask_masters]\n        apex_masters = edge_apexes[mask_masters]\n        x_add = (x[triangles[masters, apex_masters]] +\n                 x[triangles[masters, (apex_masters+1) % 3]]) * 0.5\n        y_add = (y[triangles[masters, apex_masters]] +\n                 y[triangles[masters, (apex_masters+1) % 3]]) * 0.5\n        refi_x[npts:] = x_add\n        refi_y[npts:] = y_add\n\n        # Building the new masked_triangles; each old masked_triangles hosts\n        # 4 new masked_triangles\n        # there are 6 pts to identify per 'old' triangle, 3 new_pt_corner and\n        # 3 new_pt_midside\n        new_pt_corner = triangles\n\n        # What is the index in refi_x, refi_y of point at middle of apex iapex\n        #  of elem ielem ?\n        # If ielem is the apex master: simple count, given the way refi_x was\n        #  built.\n        # If ielem is the apex slave: yet we do not know; but we will soon\n        # using the neighbors table.\n        new_pt_midside = np.empty([ntri, 3], dtype=np.int32)\n        cum_sum = npts\n        for imid in range(3):\n            mask_st_loc = (imid == apex_masters)\n            n_masters_loc = np.sum(mask_st_loc)\n            elem_masters_loc = masters[mask_st_loc]\n            new_pt_midside[:, imid][elem_masters_loc] = np.arange(\n                n_masters_loc, dtype=np.int32) + cum_sum\n            cum_sum += n_masters_loc\n\n        # Now dealing with slave elems.\n        # for each slave element we identify the master and then the inode\n        # once slave_masters is identified, slave_masters_apex is such that:\n        # neighbors[slaves_masters, slave_masters_apex] == slaves\n        mask_slaves = np.logical_not(mask_masters)\n        slaves = edge_elems[mask_slaves]\n        slaves_masters = edge_neighbors[mask_slaves]\n        diff_table = np.abs(neighbors[slaves_masters, :] -\n                            np.outer(slaves, np.ones(3, dtype=np.int32)))\n        slave_masters_apex = np.argmin(diff_table, axis=1)\n        slaves_apex = edge_apexes[mask_slaves]\n        new_pt_midside[slaves, slaves_apex] = new_pt_midside[\n            slaves_masters, slave_masters_apex]\n\n        # Builds the 4 child masked_triangles\n        child_triangles = np.empty([ntri*4, 3], dtype=np.int32)\n        child_triangles[0::4, :] = np.vstack([\n            new_pt_corner[:, 0], new_pt_midside[:, 0],\n            new_pt_midside[:, 2]]).T\n        child_triangles[1::4, :] = np.vstack([\n            new_pt_corner[:, 1], new_pt_midside[:, 1],\n            new_pt_midside[:, 0]]).T\n        child_triangles[2::4, :] = np.vstack([\n            new_pt_corner[:, 2], new_pt_midside[:, 2],\n            new_pt_midside[:, 1]]).T\n        child_triangles[3::4, :] = np.vstack([\n            new_pt_midside[:, 0], new_pt_midside[:, 1],\n            new_pt_midside[:, 2]]).T\n        child_triangulation = Triangulation(refi_x, refi_y, child_triangles)\n\n        # Builds the child mask\n        if triangulation.mask is not None:\n            child_triangulation.set_mask(np.repeat(triangulation.mask, 4))\n\n        if ancestors is None:\n            return child_triangulation\n        else:\n            return child_triangulation, np.repeat(ancestors, 4)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer",
      "name": "TriAnalyzer",
      "qname": "lib.matplotlib.tri.tritools.TriAnalyzer",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/__init__",
        "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/scale_factors@getter",
        "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/circle_ratios",
        "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/get_flat_tri_mask",
        "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/_get_compressed_triangulation",
        "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/_total_to_compress_renum"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Define basic tools for triangular mesh analysis and improvement.\n\nA TriAnalyzer encapsulates a `.Triangulation` object and provides basic\ntools for mesh analysis and mesh improvement.",
      "docstring": "Define basic tools for triangular mesh analysis and improvement.\n\nA TriAnalyzer encapsulates a `.Triangulation` object and provides basic\ntools for mesh analysis and mesh improvement.\n\nAttributes\n----------\nscale_factors\n\nParameters\n----------\ntriangulation : `~matplotlib.tri.Triangulation`\n    The encapsulated triangulation to analyze.",
      "code": "class TriAnalyzer:\n    \"\"\"\n    Define basic tools for triangular mesh analysis and improvement.\n\n    A TriAnalyzer encapsulates a `.Triangulation` object and provides basic\n    tools for mesh analysis and mesh improvement.\n\n    Attributes\n    ----------\n    scale_factors\n\n    Parameters\n    ----------\n    triangulation : `~matplotlib.tri.Triangulation`\n        The encapsulated triangulation to analyze.\n    \"\"\"\n\n    def __init__(self, triangulation):\n        _api.check_isinstance(Triangulation, triangulation=triangulation)\n        self._triangulation = triangulation\n\n    @property\n    def scale_factors(self):\n        \"\"\"\n        Factors to rescale the triangulation into a unit square.\n\n        Returns\n        -------\n        (float, float)\n            Scaling factors (kx, ky) so that the triangulation\n            ``[triangulation.x * kx, triangulation.y * ky]``\n            fits exactly inside a unit square.\n        \"\"\"\n        compressed_triangles = self._triangulation.get_masked_triangles()\n        node_used = (np.bincount(np.ravel(compressed_triangles),\n                                 minlength=self._triangulation.x.size) != 0)\n        return (1 / np.ptp(self._triangulation.x[node_used]),\n                1 / np.ptp(self._triangulation.y[node_used]))\n\n    def circle_ratios(self, rescale=True):\n        \"\"\"\n        Return a measure of the triangulation triangles flatness.\n\n        The ratio of the incircle radius over the circumcircle radius is a\n        widely used indicator of a triangle flatness.\n        It is always ``<= 0.5`` and ``== 0.5`` only for equilateral\n        triangles. Circle ratios below 0.01 denote very flat triangles.\n\n        To avoid unduly low values due to a difference of scale between the 2\n        axis, the triangular mesh can first be rescaled to fit inside a unit\n        square with `scale_factors` (Only if *rescale* is True, which is\n        its default value).\n\n        Parameters\n        ----------\n        rescale : bool, default: True\n            If True, internally rescale (based on `scale_factors`), so that the\n            (unmasked) triangles fit exactly inside a unit square mesh.\n\n        Returns\n        -------\n        masked array\n            Ratio of the incircle radius over the circumcircle radius, for\n            each 'rescaled' triangle of the encapsulated triangulation.\n            Values corresponding to masked triangles are masked out.\n\n        \"\"\"\n        # Coords rescaling\n        if rescale:\n            (kx, ky) = self.scale_factors\n        else:\n            (kx, ky) = (1.0, 1.0)\n        pts = np.vstack([self._triangulation.x*kx,\n                         self._triangulation.y*ky]).T\n        tri_pts = pts[self._triangulation.triangles]\n        # Computes the 3 side lengths\n        a = tri_pts[:, 1, :] - tri_pts[:, 0, :]\n        b = tri_pts[:, 2, :] - tri_pts[:, 1, :]\n        c = tri_pts[:, 0, :] - tri_pts[:, 2, :]\n        a = np.hypot(a[:, 0], a[:, 1])\n        b = np.hypot(b[:, 0], b[:, 1])\n        c = np.hypot(c[:, 0], c[:, 1])\n        # circumcircle and incircle radii\n        s = (a+b+c)*0.5\n        prod = s*(a+b-s)*(a+c-s)*(b+c-s)\n        # We have to deal with flat triangles with infinite circum_radius\n        bool_flat = (prod == 0.)\n        if np.any(bool_flat):\n            # Pathologic flow\n            ntri = tri_pts.shape[0]\n            circum_radius = np.empty(ntri, dtype=np.float64)\n            circum_radius[bool_flat] = np.inf\n            abc = a*b*c\n            circum_radius[~bool_flat] = abc[~bool_flat] / (\n                4.0*np.sqrt(prod[~bool_flat]))\n        else:\n            # Normal optimized flow\n            circum_radius = (a*b*c) / (4.0*np.sqrt(prod))\n        in_radius = (a*b*c) / (4.0*circum_radius*s)\n        circle_ratio = in_radius/circum_radius\n        mask = self._triangulation.mask\n        if mask is None:\n            return circle_ratio\n        else:\n            return np.ma.array(circle_ratio, mask=mask)\n\n    def get_flat_tri_mask(self, min_circle_ratio=0.01, rescale=True):\n        \"\"\"\n        Eliminate excessively flat border triangles from the triangulation.\n\n        Returns a mask *new_mask* which allows to clean the encapsulated\n        triangulation from its border-located flat triangles\n        (according to their :meth:`circle_ratios`).\n        This mask is meant to be subsequently applied to the triangulation\n        using `.Triangulation.set_mask`.\n        *new_mask* is an extension of the initial triangulation mask\n        in the sense that an initially masked triangle will remain masked.\n\n        The *new_mask* array is computed recursively; at each step flat\n        triangles are removed only if they share a side with the current mesh\n        border. Thus no new holes in the triangulated domain will be created.\n\n        Parameters\n        ----------\n        min_circle_ratio : float, default: 0.01\n            Border triangles with incircle/circumcircle radii ratio r/R will\n            be removed if r/R < *min_circle_ratio*.\n        rescale : bool, default: True\n            If True, first, internally rescale (based on `scale_factors`) so\n            that the (unmasked) triangles fit exactly inside a unit square\n            mesh.  This rescaling accounts for the difference of scale which\n            might exist between the 2 axis.\n\n        Returns\n        -------\n        array of bool\n            Mask to apply to encapsulated triangulation.\n            All the initially masked triangles remain masked in the\n            *new_mask*.\n\n        Notes\n        -----\n        The rationale behind this function is that a Delaunay\n        triangulation - of an unstructured set of points - sometimes contains\n        almost flat triangles at its border, leading to artifacts in plots\n        (especially for high-resolution contouring).\n        Masked with computed *new_mask*, the encapsulated\n        triangulation would contain no more unmasked border triangles\n        with a circle ratio below *min_circle_ratio*, thus improving the\n        mesh quality for subsequent plots or interpolation.\n        \"\"\"\n        # Recursively computes the mask_current_borders, true if a triangle is\n        # at the border of the mesh OR touching the border through a chain of\n        # invalid aspect ratio masked_triangles.\n        ntri = self._triangulation.triangles.shape[0]\n        mask_bad_ratio = self.circle_ratios(rescale) < min_circle_ratio\n\n        current_mask = self._triangulation.mask\n        if current_mask is None:\n            current_mask = np.zeros(ntri, dtype=bool)\n        valid_neighbors = np.copy(self._triangulation.neighbors)\n        renum_neighbors = np.arange(ntri, dtype=np.int32)\n        nadd = -1\n        while nadd != 0:\n            # The active wavefront is the triangles from the border (unmasked\n            # but with a least 1 neighbor equal to -1\n            wavefront = (np.min(valid_neighbors, axis=1) == -1) & ~current_mask\n            # The element from the active wavefront will be masked if their\n            # circle ratio is bad.\n            added_mask = wavefront & mask_bad_ratio\n            current_mask = added_mask | current_mask\n            nadd = np.sum(added_mask)\n\n            # now we have to update the tables valid_neighbors\n            valid_neighbors[added_mask, :] = -1\n            renum_neighbors[added_mask] = -1\n            valid_neighbors = np.where(valid_neighbors == -1, -1,\n                                       renum_neighbors[valid_neighbors])\n\n        return np.ma.filled(current_mask, True)\n\n    def _get_compressed_triangulation(self):\n        \"\"\"\n        Compress (if masked) the encapsulated triangulation.\n\n        Returns minimal-length triangles array (*compressed_triangles*) and\n        coordinates arrays (*compressed_x*, *compressed_y*) that can still\n        describe the unmasked triangles of the encapsulated triangulation.\n\n        Returns\n        -------\n        compressed_triangles : array-like\n            the returned compressed triangulation triangles\n        compressed_x : array-like\n            the returned compressed triangulation 1st coordinate\n        compressed_y : array-like\n            the returned compressed triangulation 2nd coordinate\n        tri_renum : int array\n            renumbering table to translate the triangle numbers from the\n            encapsulated triangulation into the new (compressed) renumbering.\n            -1 for masked triangles (deleted from *compressed_triangles*).\n        node_renum : int array\n            renumbering table to translate the point numbers from the\n            encapsulated triangulation into the new (compressed) renumbering.\n            -1 for unused points (i.e. those deleted from *compressed_x* and\n            *compressed_y*).\n\n        \"\"\"\n        # Valid triangles and renumbering\n        tri_mask = self._triangulation.mask\n        compressed_triangles = self._triangulation.get_masked_triangles()\n        ntri = self._triangulation.triangles.shape[0]\n        if tri_mask is not None:\n            tri_renum = self._total_to_compress_renum(~tri_mask)\n        else:\n            tri_renum = np.arange(ntri, dtype=np.int32)\n\n        # Valid nodes and renumbering\n        valid_node = (np.bincount(np.ravel(compressed_triangles),\n                                  minlength=self._triangulation.x.size) != 0)\n        compressed_x = self._triangulation.x[valid_node]\n        compressed_y = self._triangulation.y[valid_node]\n        node_renum = self._total_to_compress_renum(valid_node)\n\n        # Now renumbering the valid triangles nodes\n        compressed_triangles = node_renum[compressed_triangles]\n\n        return (compressed_triangles, compressed_x, compressed_y, tri_renum,\n                node_renum)\n\n    @staticmethod\n    def _total_to_compress_renum(valid):\n        \"\"\"\n        Parameters\n        ----------\n        valid : 1D bool array\n            Validity mask.\n\n        Returns\n        -------\n        int array\n            Array so that (`valid_array` being a compressed array\n            based on a `masked_array` with mask ~*valid*):\n\n            - For all i with valid[i] = True:\n              valid_array[renum[i]] = masked_array[i]\n            - For all i with valid[i] = False:\n              renum[i] = -1 (invalid value)\n        \"\"\"\n        renum = np.full(np.size(valid), -1, dtype=np.int32)\n        n_valid = np.sum(valid)\n        renum[valid] = np.arange(n_valid, dtype=np.int32)\n        return renum",
      "instance_attributes": [
        {
          "name": "_triangulation",
          "types": null
        }
      ]
    }
  ],
  "functions": [
    {
      "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.animation.AbstractMovieWriter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/__init__/fps",
          "name": "fps",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.__init__.fps",
          "default_value": "5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.__init__.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/__init__/codec",
          "name": "codec",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.__init__.codec",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/__init__/bitrate",
          "name": "bitrate",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.__init__.bitrate",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for writing movies, providing a way to grab frames by\ncalling `~AbstractMovieWriter.grab_frame`.\n\n`setup` is called to start the process and `finish` is called afterwards.\n`saving` is provided as a context manager to facilitate this process as ::\n\n    with moviewriter.saving(fig, outfile='myfile.mp4', dpi=100):\n        # Iterate over frames\n        moviewriter.grab_frame(**savefig_kwargs)\n\nThe use of the context manager ensures that `setup` and `finish` are\nperformed as necessary.\n\nAn instance of a concrete subclass of this class can be given as the\n``writer`` argument of `Animation.save()`.",
      "docstring": "",
      "code": "    def __init__(self, fps=5, metadata=None, codec=None, bitrate=None):\n        self.fps = fps\n        self.metadata = metadata if metadata is not None else {}\n        self.codec = (\n            mpl.rcParams['animation.codec'] if codec is None else codec)\n        self.bitrate = (\n            mpl.rcParams['animation.bitrate'] if bitrate is None else bitrate)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/finish",
      "name": "finish",
      "qname": "lib.matplotlib.animation.AbstractMovieWriter.finish",
      "decorators": [
        "abc.abstractmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/finish/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.finish.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finish any processing for writing the movie.",
      "docstring": "Finish any processing for writing the movie.",
      "code": "    @abc.abstractmethod\n    def finish(self):\n        \"\"\"Finish any processing for writing the movie.\"\"\""
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/frame_size@getter",
      "name": "frame_size",
      "qname": "lib.matplotlib.animation.AbstractMovieWriter.frame_size",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/frame_size@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.frame_size.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A tuple ``(width, height)`` in pixels of a movie frame.",
      "docstring": "A tuple ``(width, height)`` in pixels of a movie frame.",
      "code": "    @property\n    def frame_size(self):\n        \"\"\"A tuple ``(width, height)`` in pixels of a movie frame.\"\"\"\n        w, h = self.fig.get_size_inches()\n        return int(w * self.dpi), int(h * self.dpi)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/grab_frame",
      "name": "grab_frame",
      "qname": "lib.matplotlib.animation.AbstractMovieWriter.grab_frame",
      "decorators": [
        "abc.abstractmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/grab_frame/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.grab_frame.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/grab_frame/savefig_kwargs",
          "name": "savefig_kwargs",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.grab_frame.savefig_kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Grab the image information from the figure and save as a movie frame.\n\nAll keyword arguments in *savefig_kwargs* are passed on to the\n`~.Figure.savefig` call that saves the figure.",
      "docstring": "Grab the image information from the figure and save as a movie frame.\n\nAll keyword arguments in *savefig_kwargs* are passed on to the\n`~.Figure.savefig` call that saves the figure.",
      "code": "    @abc.abstractmethod\n    def grab_frame(self, **savefig_kwargs):\n        \"\"\"\n        Grab the image information from the figure and save as a movie frame.\n\n        All keyword arguments in *savefig_kwargs* are passed on to the\n        `~.Figure.savefig` call that saves the figure.\n        \"\"\""
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/saving",
      "name": "saving",
      "qname": "lib.matplotlib.animation.AbstractMovieWriter.saving",
      "decorators": [
        "contextlib.contextmanager"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/saving/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.saving.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/saving/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.saving.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/saving/outfile",
          "name": "outfile",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.saving.outfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/saving/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.saving.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/saving/args",
          "name": "args",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.saving.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/saving/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.saving.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Context manager to facilitate writing the movie file.\n\n``*args, **kw`` are any parameters that should be passed to `setup`.",
      "docstring": "Context manager to facilitate writing the movie file.\n\n``*args, **kw`` are any parameters that should be passed to `setup`.",
      "code": "    @contextlib.contextmanager\n    def saving(self, fig, outfile, dpi, *args, **kwargs):\n        \"\"\"\n        Context manager to facilitate writing the movie file.\n\n        ``*args, **kw`` are any parameters that should be passed to `setup`.\n        \"\"\"\n        # This particular sequence is what contextlib.contextmanager wants\n        self.setup(fig, outfile, dpi, *args, **kwargs)\n        try:\n            yield self\n        finally:\n            self.finish()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/setup",
      "name": "setup",
      "qname": "lib.matplotlib.animation.AbstractMovieWriter.setup",
      "decorators": [
        "abc.abstractmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/setup/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.setup.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/setup/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.setup.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.figure.Figure`",
            "default_value": "",
            "description": "The figure object that contains the information for frames."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.figure.Figure`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/setup/outfile",
          "name": "outfile",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.setup.outfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The filename of the resulting movie file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/AbstractMovieWriter/setup/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.animation.AbstractMovieWriter.setup.dpi",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "``fig.dpi``",
            "description": "The DPI (or resolution) for the file.  This controls the size\nin pixels of the resulting movie file."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Setup for writing the movie file.",
      "docstring": "Setup for writing the movie file.\n\nParameters\n----------\nfig : `~matplotlib.figure.Figure`\n    The figure object that contains the information for frames.\noutfile : str\n    The filename of the resulting movie file.\ndpi : float, default: ``fig.dpi``\n    The DPI (or resolution) for the file.  This controls the size\n    in pixels of the resulting movie file.",
      "code": "    @abc.abstractmethod\n    def setup(self, fig, outfile, dpi=None):\n        \"\"\"\n        Setup for writing the movie file.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The figure object that contains the information for frames.\n        outfile : str\n            The filename of the resulting movie file.\n        dpi : float, default: ``fig.dpi``\n            The DPI (or resolution) for the file.  This controls the size\n            in pixels of the resulting movie file.\n        \"\"\"\n        self.outfile = outfile\n        self.fig = fig\n        if dpi is None:\n            dpi = self.fig.dpi\n        self.dpi = dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation/__del__",
      "name": "__del__",
      "qname": "lib.matplotlib.animation.Animation.__del__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/__del__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.Animation.__del__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __del__(self):\n        if not getattr(self, '_draw_was_started', True):\n            warnings.warn(\n                'Animation was deleted without rendering anything. This is '\n                'most likely not intended. To prevent deletion, assign the '\n                'Animation to a variable, e.g. `anim`, that exists until you '\n                'output the Animation using `plt.show()` or '\n                '`anim.save()`.'\n            )"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.animation.Animation.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.Animation.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/__init__/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.Animation.__init__.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.figure.Figure`",
            "default_value": "",
            "description": "The figure object used to get needed events, such as draw or resize."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.figure.Figure`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/__init__/event_source",
          "name": "event_source",
          "qname": "lib.matplotlib.animation.Animation.__init__.event_source",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "object",
            "default_value": "",
            "description": "A class that can run a callback when desired events\nare generated, as well as be stopped and started.\n\nExamples include timers (see `TimedAnimation`) and file\nsystem notifications."
          },
          "type": {
            "kind": "NamedType",
            "name": "object"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/__init__/blit",
          "name": "blit",
          "qname": "lib.matplotlib.animation.Animation.__init__.blit",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether blitting is used to optimize drawing."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A base class for Animations.\n\nThis class is not usable as is, and should be subclassed to provide needed\nbehavior.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.",
      "docstring": "",
      "code": "    def __init__(self, fig, event_source=None, blit=False):\n        self._draw_was_started = False\n\n        self._fig = fig\n        # Disables blitting for backends that don't support it.  This\n        # allows users to request it if available, but still have a\n        # fallback that works if it is not.\n        self._blit = blit and fig.canvas.supports_blit\n\n        # These are the basics of the animation.  The frame sequence represents\n        # information for each frame of the animation and depends on how the\n        # drawing is handled by the subclasses. The event source fires events\n        # that cause the frame sequence to be iterated.\n        self.frame_seq = self.new_frame_seq()\n        self.event_source = event_source\n\n        # Instead of starting the event source now, we connect to the figure's\n        # draw_event, so that we only start once the figure has been drawn.\n        self._first_draw_id = fig.canvas.mpl_connect('draw_event', self._start)\n\n        # Connect to the figure's close_event so that we don't continue to\n        # fire events and try to draw to a deleted figure.\n        self._close_id = self._fig.canvas.mpl_connect('close_event',\n                                                      self._stop)\n        if self._blit:\n            self._setup_blit()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation/new_frame_seq",
      "name": "new_frame_seq",
      "qname": "lib.matplotlib.animation.Animation.new_frame_seq",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/new_frame_seq/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.Animation.new_frame_seq.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a new sequence of frame information.",
      "docstring": "Return a new sequence of frame information.",
      "code": "    def new_frame_seq(self):\n        \"\"\"Return a new sequence of frame information.\"\"\"\n        # Default implementation is just an iterator over self._framedata\n        return iter(self._framedata)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation/new_saved_frame_seq",
      "name": "new_saved_frame_seq",
      "qname": "lib.matplotlib.animation.Animation.new_saved_frame_seq",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/new_saved_frame_seq/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.Animation.new_saved_frame_seq.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a new sequence of saved/cached frame information.",
      "docstring": "Return a new sequence of saved/cached frame information.",
      "code": "    def new_saved_frame_seq(self):\n        \"\"\"Return a new sequence of saved/cached frame information.\"\"\"\n        # Default is the same as the regular frame sequence\n        return self.new_frame_seq()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation/pause",
      "name": "pause",
      "qname": "lib.matplotlib.animation.Animation.pause",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/pause/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.Animation.pause.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Pause the animation.",
      "docstring": "Pause the animation.",
      "code": "    def pause(self):\n        \"\"\"Pause the animation.\"\"\"\n        self.event_source.stop()\n        if self._blit:\n            for artist in self._drawn_artists:\n                artist.set_animated(False)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation/resume",
      "name": "resume",
      "qname": "lib.matplotlib.animation.Animation.resume",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/resume/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.Animation.resume.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Resume the animation.",
      "docstring": "Resume the animation.",
      "code": "    def resume(self):\n        \"\"\"Resume the animation.\"\"\"\n        self.event_source.start()\n        if self._blit:\n            for artist in self._drawn_artists:\n                artist.set_animated(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation/save",
      "name": "save",
      "qname": "lib.matplotlib.animation.Animation.save",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.Animation.save.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/filename",
          "name": "filename",
          "qname": "lib.matplotlib.animation.Animation.save.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The output filename, e.g., :file:`mymovie.mp4`."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/writer",
          "name": "writer",
          "qname": "lib.matplotlib.animation.Animation.save.writer",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`MovieWriter` or str",
            "default_value": ":rc:`animation.writer`",
            "description": "A `MovieWriter` instance to use or a key that identifies a\nclass to use, such as 'ffmpeg'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`MovieWriter`"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/fps",
          "name": "fps",
          "qname": "lib.matplotlib.animation.Animation.save.fps",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Movie frame rate (per second).  If not set, the frame rate from the\nanimation's frame interval."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.animation.Animation.save.dpi",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": ":rc:`savefig.dpi`",
            "description": "Controls the dots per inch for the movie frames.  Together with\nthe figure's size in inches, this controls the size of the movie."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/codec",
          "name": "codec",
          "qname": "lib.matplotlib.animation.Animation.save.codec",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": ":rc:`animation.codec`.",
            "description": "The video codec to use.  Not all codecs are supported by a given\n`MovieWriter`."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/bitrate",
          "name": "bitrate",
          "qname": "lib.matplotlib.animation.Animation.save.bitrate",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": ":rc:`animation.bitrate`",
            "description": "The bitrate of the movie, in kilobits per second.  Higher values\nmeans higher quality movies, but increase the file size.  A value\nof -1 lets the underlying movie encoder select the bitrate."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/extra_args",
          "name": "extra_args",
          "qname": "lib.matplotlib.animation.Animation.save.extra_args",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "list of str or None",
            "default_value": "",
            "description": "Extra command-line arguments passed to the underlying movie\nencoder.  The default, None, means to use\n:rc:`animation.[name-of-encoder]_args` for the builtin writers."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "list of str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.animation.Animation.save.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict[str, str]",
            "default_value": "{}",
            "description": "Dictionary of keys and values for metadata to include in\nthe output file. Some keys that may be of use include:\ntitle, artist, genre, subject, copyright, srcform, comment."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "str]"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/extra_anim",
          "name": "extra_anim",
          "qname": "lib.matplotlib.animation.Animation.save.extra_anim",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "list",
            "default_value": "[]",
            "description": "Additional `Animation` objects that should be included\nin the saved movie file. These need to be from the same\n`matplotlib.figure.Figure` instance. Also, animation frames will\njust be simply combined, so there should be a 1:1 correspondence\nbetween the frames from the different animations."
          },
          "type": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/savefig_kwargs",
          "name": "savefig_kwargs",
          "qname": "lib.matplotlib.animation.Animation.save.savefig_kwargs",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "{}",
            "description": "Keyword arguments passed to each `~.Figure.savefig` call used to\nsave the individual frames."
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/save/progress_callback",
          "name": "progress_callback",
          "qname": "lib.matplotlib.animation.Animation.save.progress_callback",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "function",
            "default_value": "",
            "description": "A callback function that will be called for every frame to notify\nthe saving progress. It must have the signature ::\n\n    def func(current_frame: int, total_frames: int) -> Any\n\nwhere *current_frame* is the current frame number and\n*total_frames* is the total number of frames to be saved.\n*total_frames* is set to None, if the total number of frames can\nnot be determined. Return values may exist but are ignored.\n\nExample code to write the progress to stdout::\n\n    progress_callback =                    lambda i, n: print(f'Saving frame {i} of {n}')"
          },
          "type": {
            "kind": "NamedType",
            "name": "function"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save the animation as a movie file by drawing every frame.",
      "docstring": "Save the animation as a movie file by drawing every frame.\n\nParameters\n----------\nfilename : str\n    The output filename, e.g., :file:`mymovie.mp4`.\n\nwriter : `MovieWriter` or str, default: :rc:`animation.writer`\n    A `MovieWriter` instance to use or a key that identifies a\n    class to use, such as 'ffmpeg'.\n\nfps : int, optional\n    Movie frame rate (per second).  If not set, the frame rate from the\n    animation's frame interval.\n\ndpi : float, default: :rc:`savefig.dpi`\n    Controls the dots per inch for the movie frames.  Together with\n    the figure's size in inches, this controls the size of the movie.\n\ncodec : str, default: :rc:`animation.codec`.\n    The video codec to use.  Not all codecs are supported by a given\n    `MovieWriter`.\n\nbitrate : int, default: :rc:`animation.bitrate`\n    The bitrate of the movie, in kilobits per second.  Higher values\n    means higher quality movies, but increase the file size.  A value\n    of -1 lets the underlying movie encoder select the bitrate.\n\nextra_args : list of str or None, optional\n    Extra command-line arguments passed to the underlying movie\n    encoder.  The default, None, means to use\n    :rc:`animation.[name-of-encoder]_args` for the builtin writers.\n\nmetadata : dict[str, str], default: {}\n    Dictionary of keys and values for metadata to include in\n    the output file. Some keys that may be of use include:\n    title, artist, genre, subject, copyright, srcform, comment.\n\nextra_anim : list, default: []\n    Additional `Animation` objects that should be included\n    in the saved movie file. These need to be from the same\n    `matplotlib.figure.Figure` instance. Also, animation frames will\n    just be simply combined, so there should be a 1:1 correspondence\n    between the frames from the different animations.\n\nsavefig_kwargs : dict, default: {}\n    Keyword arguments passed to each `~.Figure.savefig` call used to\n    save the individual frames.\n\nprogress_callback : function, optional\n    A callback function that will be called for every frame to notify\n    the saving progress. It must have the signature ::\n\n        def func(current_frame: int, total_frames: int) -> Any\n\n    where *current_frame* is the current frame number and\n    *total_frames* is the total number of frames to be saved.\n    *total_frames* is set to None, if the total number of frames can\n    not be determined. Return values may exist but are ignored.\n\n    Example code to write the progress to stdout::\n\n        progress_callback =                    lambda i, n: print(f'Saving frame {i} of {n}')\n\nNotes\n-----\n*fps*, *codec*, *bitrate*, *extra_args* and *metadata* are used to\nconstruct a `.MovieWriter` instance and can only be passed if\n*writer* is a string.  If they are passed as non-*None* and *writer*\nis a `.MovieWriter`, a `RuntimeError` will be raised.",
      "code": "    def save(self, filename, writer=None, fps=None, dpi=None, codec=None,\n             bitrate=None, extra_args=None, metadata=None, extra_anim=None,\n             savefig_kwargs=None, *, progress_callback=None):\n        \"\"\"\n        Save the animation as a movie file by drawing every frame.\n\n        Parameters\n        ----------\n        filename : str\n            The output filename, e.g., :file:`mymovie.mp4`.\n\n        writer : `MovieWriter` or str, default: :rc:`animation.writer`\n            A `MovieWriter` instance to use or a key that identifies a\n            class to use, such as 'ffmpeg'.\n\n        fps : int, optional\n            Movie frame rate (per second).  If not set, the frame rate from the\n            animation's frame interval.\n\n        dpi : float, default: :rc:`savefig.dpi`\n            Controls the dots per inch for the movie frames.  Together with\n            the figure's size in inches, this controls the size of the movie.\n\n        codec : str, default: :rc:`animation.codec`.\n            The video codec to use.  Not all codecs are supported by a given\n            `MovieWriter`.\n\n        bitrate : int, default: :rc:`animation.bitrate`\n            The bitrate of the movie, in kilobits per second.  Higher values\n            means higher quality movies, but increase the file size.  A value\n            of -1 lets the underlying movie encoder select the bitrate.\n\n        extra_args : list of str or None, optional\n            Extra command-line arguments passed to the underlying movie\n            encoder.  The default, None, means to use\n            :rc:`animation.[name-of-encoder]_args` for the builtin writers.\n\n        metadata : dict[str, str], default: {}\n            Dictionary of keys and values for metadata to include in\n            the output file. Some keys that may be of use include:\n            title, artist, genre, subject, copyright, srcform, comment.\n\n        extra_anim : list, default: []\n            Additional `Animation` objects that should be included\n            in the saved movie file. These need to be from the same\n            `matplotlib.figure.Figure` instance. Also, animation frames will\n            just be simply combined, so there should be a 1:1 correspondence\n            between the frames from the different animations.\n\n        savefig_kwargs : dict, default: {}\n            Keyword arguments passed to each `~.Figure.savefig` call used to\n            save the individual frames.\n\n        progress_callback : function, optional\n            A callback function that will be called for every frame to notify\n            the saving progress. It must have the signature ::\n\n                def func(current_frame: int, total_frames: int) -> Any\n\n            where *current_frame* is the current frame number and\n            *total_frames* is the total number of frames to be saved.\n            *total_frames* is set to None, if the total number of frames can\n            not be determined. Return values may exist but are ignored.\n\n            Example code to write the progress to stdout::\n\n                progress_callback =\\\n                    lambda i, n: print(f'Saving frame {i} of {n}')\n\n        Notes\n        -----\n        *fps*, *codec*, *bitrate*, *extra_args* and *metadata* are used to\n        construct a `.MovieWriter` instance and can only be passed if\n        *writer* is a string.  If they are passed as non-*None* and *writer*\n        is a `.MovieWriter`, a `RuntimeError` will be raised.\n        \"\"\"\n\n        if writer is None:\n            writer = mpl.rcParams['animation.writer']\n        elif (not isinstance(writer, str) and\n              any(arg is not None\n                  for arg in (fps, codec, bitrate, extra_args, metadata))):\n            raise RuntimeError('Passing in values for arguments '\n                               'fps, codec, bitrate, extra_args, or metadata '\n                               'is not supported when writer is an existing '\n                               'MovieWriter instance. These should instead be '\n                               'passed as arguments when creating the '\n                               'MovieWriter instance.')\n\n        if savefig_kwargs is None:\n            savefig_kwargs = {}\n\n        if fps is None and hasattr(self, '_interval'):\n            # Convert interval in ms to frames per second\n            fps = 1000. / self._interval\n\n        # Re-use the savefig DPI for ours if none is given\n        if dpi is None:\n            dpi = mpl.rcParams['savefig.dpi']\n        if dpi == 'figure':\n            dpi = self._fig.dpi\n\n        writer_kwargs = {}\n        if codec is not None:\n            writer_kwargs['codec'] = codec\n        if bitrate is not None:\n            writer_kwargs['bitrate'] = bitrate\n        if extra_args is not None:\n            writer_kwargs['extra_args'] = extra_args\n        if metadata is not None:\n            writer_kwargs['metadata'] = metadata\n\n        all_anim = [self]\n        if extra_anim is not None:\n            all_anim.extend(anim\n                            for anim\n                            in extra_anim if anim._fig is self._fig)\n\n        # If we have the name of a writer, instantiate an instance of the\n        # registered class.\n        if isinstance(writer, str):\n            try:\n                writer_cls = writers[writer]\n            except RuntimeError:  # Raised if not available.\n                writer_cls = PillowWriter  # Always available.\n                _log.warning(\"MovieWriter %s unavailable; using Pillow \"\n                             \"instead.\", writer)\n            writer = writer_cls(fps, **writer_kwargs)\n        _log.info('Animation.save using %s', type(writer))\n\n        if 'bbox_inches' in savefig_kwargs:\n            _log.warning(\"Warning: discarding the 'bbox_inches' argument in \"\n                         \"'savefig_kwargs' as it may cause frame size \"\n                         \"to vary, which is inappropriate for animation.\")\n            savefig_kwargs.pop('bbox_inches')\n\n        # Create a new sequence of frames for saved data. This is different\n        # from new_frame_seq() to give the ability to save 'live' generated\n        # frame information to be saved later.\n        # TODO: Right now, after closing the figure, saving a movie won't work\n        # since GUI widgets are gone. Either need to remove extra code to\n        # allow for this non-existent use case or find a way to make it work.\n        if mpl.rcParams['savefig.bbox'] == 'tight':\n            _log.info(\"Disabling savefig.bbox = 'tight', as it may cause \"\n                      \"frame size to vary, which is inappropriate for \"\n                      \"animation.\")\n        # canvas._is_saving = True makes the draw_event animation-starting\n        # callback a no-op; canvas.manager = None prevents resizing the GUI\n        # widget (both are likewise done in savefig()).\n        with mpl.rc_context({'savefig.bbox': None}), \\\n             writer.saving(self._fig, filename, dpi), \\\n             cbook._setattr_cm(self._fig.canvas,\n                               _is_saving=True, manager=None):\n            for anim in all_anim:\n                anim._init_draw()  # Clear the initial frame\n            frame_number = 0\n            # TODO: Currently only FuncAnimation has a save_count\n            #       attribute. Can we generalize this to all Animations?\n            save_count_list = [getattr(a, 'save_count', None)\n                               for a in all_anim]\n            if None in save_count_list:\n                total_frames = None\n            else:\n                total_frames = sum(save_count_list)\n            for data in zip(*[a.new_saved_frame_seq() for a in all_anim]):\n                for anim, d in zip(all_anim, data):\n                    # TODO: See if turning off blit is really necessary\n                    anim._draw_next_frame(d, blit=False)\n                    if progress_callback is not None:\n                        progress_callback(frame_number, total_frames)\n                        frame_number += 1\n                writer.grab_frame(**savefig_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation/to_html5_video",
      "name": "to_html5_video",
      "qname": "lib.matplotlib.animation.Animation.to_html5_video",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/to_html5_video/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.Animation.to_html5_video.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/to_html5_video/embed_limit",
          "name": "embed_limit",
          "qname": "lib.matplotlib.animation.Animation.to_html5_video.embed_limit",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "Limit, in MB, of the returned animation. No animation is created\nif the limit is exceeded.\nDefaults to :rc:`animation.embed_limit` = 20.0."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert the animation to an HTML5 ``<video>`` tag.\n\nThis saves the animation as an h264 video, encoded in base64\ndirectly into the HTML5 video tag. This respects :rc:`animation.writer`\nand :rc:`animation.bitrate`. This also makes use of the\n``interval`` to control the speed, and uses the ``repeat``\nparameter to decide whether to loop.",
      "docstring": "Convert the animation to an HTML5 ``<video>`` tag.\n\nThis saves the animation as an h264 video, encoded in base64\ndirectly into the HTML5 video tag. This respects :rc:`animation.writer`\nand :rc:`animation.bitrate`. This also makes use of the\n``interval`` to control the speed, and uses the ``repeat``\nparameter to decide whether to loop.\n\nParameters\n----------\nembed_limit : float, optional\n    Limit, in MB, of the returned animation. No animation is created\n    if the limit is exceeded.\n    Defaults to :rc:`animation.embed_limit` = 20.0.\n\nReturns\n-------\nstr\n    An HTML5 video tag with the animation embedded as base64 encoded\n    h264 video.\n    If the *embed_limit* is exceeded, this returns the string\n    \"Video too large to embed.\"",
      "code": "    def to_html5_video(self, embed_limit=None):\n        \"\"\"\n        Convert the animation to an HTML5 ``<video>`` tag.\n\n        This saves the animation as an h264 video, encoded in base64\n        directly into the HTML5 video tag. This respects :rc:`animation.writer`\n        and :rc:`animation.bitrate`. This also makes use of the\n        ``interval`` to control the speed, and uses the ``repeat``\n        parameter to decide whether to loop.\n\n        Parameters\n        ----------\n        embed_limit : float, optional\n            Limit, in MB, of the returned animation. No animation is created\n            if the limit is exceeded.\n            Defaults to :rc:`animation.embed_limit` = 20.0.\n\n        Returns\n        -------\n        str\n            An HTML5 video tag with the animation embedded as base64 encoded\n            h264 video.\n            If the *embed_limit* is exceeded, this returns the string\n            \"Video too large to embed.\"\n        \"\"\"\n        VIDEO_TAG = r'''<video {size} {options}>\n  <source type=\"video/mp4\" src=\"data:video/mp4;base64,{video}\">\n  Your browser does not support the video tag.\n</video>'''\n        # Cache the rendering of the video as HTML\n        if not hasattr(self, '_base64_video'):\n            # Save embed limit, which is given in MB\n            if embed_limit is None:\n                embed_limit = mpl.rcParams['animation.embed_limit']\n\n            # Convert from MB to bytes\n            embed_limit *= 1024 * 1024\n\n            # Can't open a NamedTemporaryFile twice on Windows, so use a\n            # TemporaryDirectory instead.\n            with TemporaryDirectory() as tmpdir:\n                path = Path(tmpdir, \"temp.m4v\")\n                # We create a writer manually so that we can get the\n                # appropriate size for the tag\n                Writer = writers[mpl.rcParams['animation.writer']]\n                writer = Writer(codec='h264',\n                                bitrate=mpl.rcParams['animation.bitrate'],\n                                fps=1000. / self._interval)\n                self.save(str(path), writer=writer)\n                # Now open and base64 encode.\n                vid64 = base64.encodebytes(path.read_bytes())\n\n            vid_len = len(vid64)\n            if vid_len >= embed_limit:\n                _log.warning(\n                    \"Animation movie is %s bytes, exceeding the limit of %s. \"\n                    \"If you're sure you want a large animation embedded, set \"\n                    \"the animation.embed_limit rc parameter to a larger value \"\n                    \"(in MB).\", vid_len, embed_limit)\n            else:\n                self._base64_video = vid64.decode('ascii')\n                self._video_size = 'width=\"{}\" height=\"{}\"'.format(\n                        *writer.frame_size)\n\n        # If we exceeded the size, this attribute won't exist\n        if hasattr(self, '_base64_video'):\n            # Default HTML5 options are to autoplay and display video controls\n            options = ['controls', 'autoplay']\n\n            # If we're set to repeat, make it loop\n            if hasattr(self, 'repeat') and self.repeat:\n                options.append('loop')\n\n            return VIDEO_TAG.format(video=self._base64_video,\n                                    size=self._video_size,\n                                    options=' '.join(options))\n        else:\n            return 'Video too large to embed.'"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/Animation/to_jshtml",
      "name": "to_jshtml",
      "qname": "lib.matplotlib.animation.Animation.to_jshtml",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/to_jshtml/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.Animation.to_jshtml.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/to_jshtml/fps",
          "name": "fps",
          "qname": "lib.matplotlib.animation.Animation.to_jshtml.fps",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Movie frame rate (per second). If not set, the frame rate from\nthe animation's frame interval."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/to_jshtml/embed_frames",
          "name": "embed_frames",
          "qname": "lib.matplotlib.animation.Animation.to_jshtml.embed_frames",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/Animation/to_jshtml/default_mode",
          "name": "default_mode",
          "qname": "lib.matplotlib.animation.Animation.to_jshtml.default_mode",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "What to do when the animation ends. Must be one of ``{'loop',\n'once', 'reflect'}``. Defaults to ``'loop'`` if ``self.repeat``\nis True, otherwise ``'once'``."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Generate HTML representation of the animation.",
      "docstring": "Generate HTML representation of the animation.\n\nParameters\n----------\nfps : int, optional\n    Movie frame rate (per second). If not set, the frame rate from\n    the animation's frame interval.\nembed_frames : bool, optional\ndefault_mode : str, optional\n    What to do when the animation ends. Must be one of ``{'loop',\n    'once', 'reflect'}``. Defaults to ``'loop'`` if ``self.repeat``\n    is True, otherwise ``'once'``.",
      "code": "    def to_jshtml(self, fps=None, embed_frames=True, default_mode=None):\n        \"\"\"\n        Generate HTML representation of the animation.\n\n        Parameters\n        ----------\n        fps : int, optional\n            Movie frame rate (per second). If not set, the frame rate from\n            the animation's frame interval.\n        embed_frames : bool, optional\n        default_mode : str, optional\n            What to do when the animation ends. Must be one of ``{'loop',\n            'once', 'reflect'}``. Defaults to ``'loop'`` if ``self.repeat``\n            is True, otherwise ``'once'``.\n        \"\"\"\n        if fps is None and hasattr(self, '_interval'):\n            # Convert interval in ms to frames per second\n            fps = 1000 / self._interval\n\n        # If we're not given a default mode, choose one base on the value of\n        # the repeat attribute\n        if default_mode is None:\n            default_mode = 'loop' if self.repeat else 'once'\n\n        if not hasattr(self, \"_html_representation\"):\n            # Can't open a NamedTemporaryFile twice on Windows, so use a\n            # TemporaryDirectory instead.\n            with TemporaryDirectory() as tmpdir:\n                path = Path(tmpdir, \"temp.html\")\n                writer = HTMLWriter(fps=fps,\n                                    embed_frames=embed_frames,\n                                    default_mode=default_mode)\n                self.save(str(path), writer=writer)\n                self._html_representation = path.read_text()\n\n        return self._html_representation"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/ArtistAnimation/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.animation.ArtistAnimation.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/ArtistAnimation/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.ArtistAnimation.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/ArtistAnimation/__init__/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.ArtistAnimation.__init__.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.figure.Figure`",
            "default_value": "",
            "description": "The figure object used to get needed events, such as draw or resize."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.figure.Figure`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/ArtistAnimation/__init__/artists",
          "name": "artists",
          "qname": "lib.matplotlib.animation.ArtistAnimation.__init__.artists",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "list",
            "default_value": "",
            "description": "Each list entry is a collection of `.Artist` objects that are made\nvisible on the corresponding frame.  Other artists are made invisible."
          },
          "type": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/ArtistAnimation/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.animation.ArtistAnimation.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/ArtistAnimation/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.animation.ArtistAnimation.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Animation using a fixed set of `.Artist` objects.\n\nBefore creating an instance, all plotting should have taken place\nand the relevant artists saved.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.",
      "docstring": "",
      "code": "    def __init__(self, fig, artists, *args, **kwargs):\n        # Internal list of artists drawn in the most recent frame.\n        self._drawn_artists = []\n\n        # Use the list of artists as the framedata, which will be iterated\n        # over by the machinery.\n        self._framedata = artists\n        super().__init__(fig, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FFMpegBase/output_args@getter",
      "name": "output_args",
      "qname": "lib.matplotlib.animation.FFMpegBase.output_args",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FFMpegBase/output_args@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FFMpegBase.output_args.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def output_args(self):\n        args = []\n        if Path(self.outfile).suffix == '.gif':\n            self.codec = 'gif'\n        else:\n            args.extend(['-vcodec', self.codec])\n        extra_args = (self.extra_args if self.extra_args is not None\n                      else mpl.rcParams[self._args_key])\n        # For h264, the default format is yuv444p, which is not compatible\n        # with quicktime (and others). Specifying yuv420p fixes playback on\n        # iOS, as well as HTML5 video in firefox and safari (on both Win and\n        # OSX). Also fixes internet explorer. This is as of 2015/10/29.\n        if self.codec == 'h264' and '-pix_fmt' not in extra_args:\n            args.extend(['-pix_fmt', 'yuv420p'])\n        # For GIF, we're telling FFMPEG to split the video stream, to generate\n        # a palette, and then use it for encoding.\n        elif self.codec == 'gif' and '-filter_complex' not in extra_args:\n            args.extend(['-filter_complex',\n                         'split [a][b];[a] palettegen [p];[b][p] paletteuse'])\n        if self.bitrate > 0:\n            args.extend(['-b', '%dk' % self.bitrate])  # %dk: bitrate in kbps.\n        args.extend(extra_args)\n        for k, v in self.metadata.items():\n            args.extend(['-metadata', '%s=%s' % (k, v)])\n\n        return args + ['-y', self.outfile]"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/__del__",
      "name": "__del__",
      "qname": "lib.matplotlib.animation.FileMovieWriter.__del__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/__del__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FileMovieWriter.__del__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __del__(self):\n        if self._tmpdir:\n            self._tmpdir.cleanup()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.animation.FileMovieWriter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FileMovieWriter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.animation.FileMovieWriter.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.animation.FileMovieWriter.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "`MovieWriter` for writing to individual files and stitching at the end.\n\nThis must be sub-classed to be useful.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.frame_format = mpl.rcParams['animation.frame_format']"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/finish",
      "name": "finish",
      "qname": "lib.matplotlib.animation.FileMovieWriter.finish",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/finish/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FileMovieWriter.finish.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def finish(self):\n        # Call run here now that all frame grabbing is done. All temp files\n        # are available to be assembled.\n        try:\n            self._run()\n            super().finish()\n        finally:\n            if self._tmpdir:\n                _log.debug(\n                    'MovieWriter: clearing temporary path=%s', self._tmpdir\n                )\n                self._tmpdir.cleanup()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/frame_format@getter",
      "name": "frame_format",
      "qname": "lib.matplotlib.animation.FileMovieWriter.frame_format",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/frame_format@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FileMovieWriter.frame_format.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Format (png, jpeg, etc.) to use for saving the frames, which can be\ndecided by the individual subclasses.",
      "docstring": "Format (png, jpeg, etc.) to use for saving the frames, which can be\ndecided by the individual subclasses.",
      "code": "    @property\n    def frame_format(self):\n        \"\"\"\n        Format (png, jpeg, etc.) to use for saving the frames, which can be\n        decided by the individual subclasses.\n        \"\"\"\n        return self._frame_format"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/frame_format@setter",
      "name": "frame_format",
      "qname": "lib.matplotlib.animation.FileMovieWriter.frame_format",
      "decorators": [
        "frame_format.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/frame_format@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FileMovieWriter.frame_format.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/frame_format@setter/frame_format",
          "name": "frame_format",
          "qname": "lib.matplotlib.animation.FileMovieWriter.frame_format.frame_format",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @frame_format.setter\n    def frame_format(self, frame_format):\n        if frame_format in self.supported_formats:\n            self._frame_format = frame_format\n        else:\n            _api.warn_external(\n                f\"Ignoring file format {frame_format!r} which is not \"\n                f\"supported by {type(self).__name__}; using \"\n                f\"{self.supported_formats[0]} instead.\")\n            self._frame_format = self.supported_formats[0]"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/grab_frame",
      "name": "grab_frame",
      "qname": "lib.matplotlib.animation.FileMovieWriter.grab_frame",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/grab_frame/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FileMovieWriter.grab_frame.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/grab_frame/savefig_kwargs",
          "name": "savefig_kwargs",
          "qname": "lib.matplotlib.animation.FileMovieWriter.grab_frame.savefig_kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def grab_frame(self, **savefig_kwargs):\n        # docstring inherited\n        # Creates a filename for saving using basename and counter.\n        path = Path(self._base_temp_name() % self._frame_counter)\n        self._temp_paths.append(path)  # Record the filename for later use.\n        self._frame_counter += 1  # Ensures each created name is unique.\n        _log.debug('FileMovieWriter.grab_frame: Grabbing frame %d to path=%s',\n                   self._frame_counter, path)\n        with open(path, 'wb') as sink:  # Save figure to the sink.\n            self.fig.savefig(sink, format=self.frame_format, dpi=self.dpi,\n                             **savefig_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/setup",
      "name": "setup",
      "qname": "lib.matplotlib.animation.FileMovieWriter.setup",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/setup/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FileMovieWriter.setup.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/setup/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.FileMovieWriter.setup.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.figure.Figure`",
            "default_value": "",
            "description": "The figure to grab the rendered frames from."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.figure.Figure`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/setup/outfile",
          "name": "outfile",
          "qname": "lib.matplotlib.animation.FileMovieWriter.setup.outfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The filename of the resulting movie file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/setup/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.animation.FileMovieWriter.setup.dpi",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "``fig.dpi``",
            "description": "The dpi of the output file. This, with the figure size,\ncontrols the size in pixels of the resulting movie file."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FileMovieWriter/setup/frame_prefix",
          "name": "frame_prefix",
          "qname": "lib.matplotlib.animation.FileMovieWriter.setup.frame_prefix",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The filename prefix to use for temporary files.  If *None* (the\ndefault), files are written to a temporary directory which is\ndeleted by `cleanup`; if not *None*, no temporary files are\ndeleted."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Setup for writing the movie file.",
      "docstring": "Setup for writing the movie file.\n\nParameters\n----------\nfig : `~matplotlib.figure.Figure`\n    The figure to grab the rendered frames from.\noutfile : str\n    The filename of the resulting movie file.\ndpi : float, default: ``fig.dpi``\n    The dpi of the output file. This, with the figure size,\n    controls the size in pixels of the resulting movie file.\nframe_prefix : str, optional\n    The filename prefix to use for temporary files.  If *None* (the\n    default), files are written to a temporary directory which is\n    deleted by `cleanup`; if not *None*, no temporary files are\n    deleted.",
      "code": "    def setup(self, fig, outfile, dpi=None, frame_prefix=None):\n        \"\"\"\n        Setup for writing the movie file.\n\n        Parameters\n        ----------\n        fig : `~matplotlib.figure.Figure`\n            The figure to grab the rendered frames from.\n        outfile : str\n            The filename of the resulting movie file.\n        dpi : float, default: ``fig.dpi``\n            The dpi of the output file. This, with the figure size,\n            controls the size in pixels of the resulting movie file.\n        frame_prefix : str, optional\n            The filename prefix to use for temporary files.  If *None* (the\n            default), files are written to a temporary directory which is\n            deleted by `cleanup`; if not *None*, no temporary files are\n            deleted.\n        \"\"\"\n        self.fig = fig\n        self.outfile = outfile\n        if dpi is None:\n            dpi = self.fig.dpi\n        self.dpi = dpi\n        self._adjust_frame_size()\n\n        if frame_prefix is None:\n            self._tmpdir = TemporaryDirectory()\n            self.temp_prefix = str(Path(self._tmpdir.name, 'tmp'))\n        else:\n            self._tmpdir = None\n            self.temp_prefix = frame_prefix\n        self._frame_counter = 0  # used for generating sequential file names\n        self._temp_paths = list()\n        self.fname_format_str = '%s%%07d.%s'"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.animation.FuncAnimation.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FuncAnimation.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.FuncAnimation.__init__.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.figure.Figure`",
            "default_value": "",
            "description": "The figure object used to get needed events, such as draw or resize."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.figure.Figure`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__/func",
          "name": "func",
          "qname": "lib.matplotlib.animation.FuncAnimation.__init__.func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "The function to call at each frame.  The first argument will\nbe the next value in *frames*.   Any additional positional\narguments can be supplied via the *fargs* parameter.\n\nThe required signature is::\n\n    def func(frame, *fargs) -> iterable_of_artists\n\nIf ``blit == True``, *func* must return an iterable of all artists\nthat were modified or created. This information is used by the blitting\nalgorithm to determine which parts of the figure have to be updated.\nThe return value is unused if ``blit == False`` and may be omitted in\nthat case."
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__/frames",
          "name": "frames",
          "qname": "lib.matplotlib.animation.FuncAnimation.__init__.frames",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "iterable, int, generator function, or None",
            "default_value": "",
            "description": "Source of data to pass *func* and each frame of the animation\n\n- If an iterable, then simply use the values provided.  If the\n  iterable has a length, it will override the *save_count* kwarg.\n\n- If an integer, then equivalent to passing ``range(frames)``\n\n- If a generator function, then must have the signature::\n\n     def gen_function() -> obj\n\n- If *None*, then equivalent to passing ``itertools.count``.\n\nIn all of these cases, the values in *frames* is simply passed through\nto the user-supplied *func* and thus can be of any type."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "iterable"
              },
              {
                "kind": "NamedType",
                "name": "int"
              },
              {
                "kind": "NamedType",
                "name": "generator function"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__/init_func",
          "name": "init_func",
          "qname": "lib.matplotlib.animation.FuncAnimation.__init__.init_func",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "A function used to draw a clear frame. If not given, the results of\ndrawing from the first item in the frames sequence will be used. This\nfunction will be called once before the first frame.\n\nThe required signature is::\n\n    def init_func() -> iterable_of_artists\n\nIf ``blit == True``, *init_func* must return an iterable of artists\nto be re-drawn. This information is used by the blitting algorithm to\ndetermine which parts of the figure have to be updated.  The return\nvalue is unused if ``blit == False`` and may be omitted in that case."
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__/fargs",
          "name": "fargs",
          "qname": "lib.matplotlib.animation.FuncAnimation.__init__.fargs",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple or None",
            "default_value": "",
            "description": "Additional arguments to pass to each call to *func*."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "tuple"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__/save_count",
          "name": "save_count",
          "qname": "lib.matplotlib.animation.FuncAnimation.__init__.save_count",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "100",
            "description": "Fallback for the number of values from *frames* to cache. This is\nonly used if the number of frames cannot be inferred from *frames*,\ni.e. when it's an iterator without length or a generator."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__/cache_frame_data",
          "name": "cache_frame_data",
          "qname": "lib.matplotlib.animation.FuncAnimation.__init__.cache_frame_data",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether frame data is cached.  Disabling cache might be helpful when\nframes contain large objects."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.animation.FuncAnimation.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Makes an animation by repeatedly calling a function *func*.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.",
      "docstring": "",
      "code": "    def __init__(self, fig, func, frames=None, init_func=None, fargs=None,\n                 save_count=None, *, cache_frame_data=True, **kwargs):\n        if fargs:\n            self._args = fargs\n        else:\n            self._args = ()\n        self._func = func\n        self._init_func = init_func\n\n        # Amount of framedata to keep around for saving movies. This is only\n        # used if we don't know how many frames there will be: in the case\n        # of no generator or in the case of a callable.\n        self.save_count = save_count\n        # Set up a function that creates a new iterable when needed. If nothing\n        # is passed in for frames, just use itertools.count, which will just\n        # keep counting from 0. A callable passed in for frames is assumed to\n        # be a generator. An iterable will be used as is, and anything else\n        # will be treated as a number of frames.\n        if frames is None:\n            self._iter_gen = itertools.count\n        elif callable(frames):\n            self._iter_gen = frames\n        elif np.iterable(frames):\n            if kwargs.get('repeat', True):\n                self._tee_from = frames\n                def iter_frames(frames=frames):\n                    this, self._tee_from = itertools.tee(self._tee_from, 2)\n                    yield from this\n                self._iter_gen = iter_frames\n            else:\n                self._iter_gen = lambda: iter(frames)\n            if hasattr(frames, '__len__'):\n                self.save_count = len(frames)\n        else:\n            self._iter_gen = lambda: iter(range(frames))\n            self.save_count = frames\n\n        if self.save_count is None:\n            # If we're passed in and using the default, set save_count to 100.\n            self.save_count = 100\n        else:\n            # itertools.islice returns an error when passed a numpy int instead\n            # of a native python int (https://bugs.python.org/issue30537).\n            # As a workaround, convert save_count to a native python int.\n            self.save_count = int(self.save_count)\n\n        self._cache_frame_data = cache_frame_data\n\n        # Needs to be initialized so the draw functions work without checking\n        self._save_seq = []\n\n        super().__init__(fig, **kwargs)\n\n        # Need to reset the saved seq, since right now it will contain data\n        # for a single frame from init, which is not what we want.\n        self._save_seq = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/new_frame_seq",
      "name": "new_frame_seq",
      "qname": "lib.matplotlib.animation.FuncAnimation.new_frame_seq",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/new_frame_seq/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FuncAnimation.new_frame_seq.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_frame_seq(self):\n        # Use the generating function to generate a new frame sequence\n        return self._iter_gen()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/new_saved_frame_seq",
      "name": "new_saved_frame_seq",
      "qname": "lib.matplotlib.animation.FuncAnimation.new_saved_frame_seq",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/FuncAnimation/new_saved_frame_seq/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.FuncAnimation.new_saved_frame_seq.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_saved_frame_seq(self):\n        # Generate an iterator for the sequence of saved data. If there are\n        # no saved frames, generate a new frame sequence and take the first\n        # save_count entries in it.\n        if self._save_seq:\n            # While iterating we are going to update _save_seq\n            # so make a copy to safely iterate over\n            self._old_saved_seq = list(self._save_seq)\n            return iter(self._old_saved_seq)\n        else:\n            if self.save_count is not None:\n                return itertools.islice(self.new_frame_seq(), self.save_count)\n\n            else:\n                frame_seq = self.new_frame_seq()\n\n                def gen():\n                    try:\n                        for _ in range(100):\n                            yield next(frame_seq)\n                    except StopIteration:\n                        pass\n                    else:\n                        _api.warn_deprecated(\n                            \"2.2\", message=\"FuncAnimation.save has truncated \"\n                            \"your animation to 100 frames.  In the future, no \"\n                            \"such truncation will occur; please pass \"\n                            \"'save_count' accordingly.\")\n\n                return gen()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.animation.HTMLWriter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.HTMLWriter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__/fps",
          "name": "fps",
          "qname": "lib.matplotlib.animation.HTMLWriter.__init__.fps",
          "default_value": "30",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__/codec",
          "name": "codec",
          "qname": "lib.matplotlib.animation.HTMLWriter.__init__.codec",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__/bitrate",
          "name": "bitrate",
          "qname": "lib.matplotlib.animation.HTMLWriter.__init__.bitrate",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__/extra_args",
          "name": "extra_args",
          "qname": "lib.matplotlib.animation.HTMLWriter.__init__.extra_args",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.animation.HTMLWriter.__init__.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__/embed_frames",
          "name": "embed_frames",
          "qname": "lib.matplotlib.animation.HTMLWriter.__init__.embed_frames",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__/default_mode",
          "name": "default_mode",
          "qname": "lib.matplotlib.animation.HTMLWriter.__init__.default_mode",
          "default_value": "'loop'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/__init__/embed_limit",
          "name": "embed_limit",
          "qname": "lib.matplotlib.animation.HTMLWriter.__init__.embed_limit",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Writer for JavaScript-based HTML movies.",
      "docstring": "",
      "code": "    def __init__(self, fps=30, codec=None, bitrate=None, extra_args=None,\n                 metadata=None, embed_frames=False, default_mode='loop',\n                 embed_limit=None):\n\n        if extra_args:\n            _log.warning(\"HTMLWriter ignores 'extra_args'\")\n        extra_args = ()  # Don't lookup nonexistent rcParam[args_key].\n        self.embed_frames = embed_frames\n        self.default_mode = default_mode.lower()\n        _api.check_in_list(['loop', 'once', 'reflect'],\n                           default_mode=self.default_mode)\n\n        # Save embed limit, which is given in MB\n        if embed_limit is None:\n            self._bytes_limit = mpl.rcParams['animation.embed_limit']\n        else:\n            self._bytes_limit = embed_limit\n        # Convert from MB to bytes\n        self._bytes_limit *= 1024 * 1024\n\n        super().__init__(fps, codec, bitrate, extra_args, metadata)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/finish",
      "name": "finish",
      "qname": "lib.matplotlib.animation.HTMLWriter.finish",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/finish/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.HTMLWriter.finish.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def finish(self):\n        # save the frames to an html file\n        if self.embed_frames:\n            fill_frames = _embedded_frames(self._saved_frames,\n                                           self.frame_format)\n            Nframes = len(self._saved_frames)\n        else:\n            # temp names is filled by FileMovieWriter\n            fill_frames = _included_frames(self._temp_paths, self.frame_format)\n            Nframes = len(self._temp_paths)\n        mode_dict = dict(once_checked='',\n                         loop_checked='',\n                         reflect_checked='')\n        mode_dict[self.default_mode + '_checked'] = 'checked'\n\n        interval = 1000 // self.fps\n\n        with open(self.outfile, 'w') as of:\n            of.write(JS_INCLUDE + STYLE_INCLUDE)\n            of.write(DISPLAY_TEMPLATE.format(id=uuid.uuid4().hex,\n                                             Nframes=Nframes,\n                                             fill_frames=fill_frames,\n                                             interval=interval,\n                                             **mode_dict))\n\n        # duplicate the temporary file clean up logic from\n        # FileMovieWriter.cleanup.  We can not call the inherited\n        # versions of finish or cleanup because both assume that\n        # there is a subprocess that we either need to call to merge\n        # many frames together or that there is a subprocess call that\n        # we need to clean up.\n        if self._tmpdir:\n            _log.debug('MovieWriter: clearing temporary path=%s', self._tmpdir)\n            self._tmpdir.cleanup()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/grab_frame",
      "name": "grab_frame",
      "qname": "lib.matplotlib.animation.HTMLWriter.grab_frame",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/grab_frame/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.HTMLWriter.grab_frame.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/grab_frame/savefig_kwargs",
          "name": "savefig_kwargs",
          "qname": "lib.matplotlib.animation.HTMLWriter.grab_frame.savefig_kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def grab_frame(self, **savefig_kwargs):\n        if self.embed_frames:\n            # Just stop processing if we hit the limit\n            if self._hit_limit:\n                return\n            f = BytesIO()\n            self.fig.savefig(f, format=self.frame_format,\n                             dpi=self.dpi, **savefig_kwargs)\n            imgdata64 = base64.encodebytes(f.getvalue()).decode('ascii')\n            self._total_bytes += len(imgdata64)\n            if self._total_bytes >= self._bytes_limit:\n                _log.warning(\n                    \"Animation size has reached %s bytes, exceeding the limit \"\n                    \"of %s. If you're sure you want a larger animation \"\n                    \"embedded, set the animation.embed_limit rc parameter to \"\n                    \"a larger value (in MB). This and further frames will be \"\n                    \"dropped.\", self._total_bytes, self._bytes_limit)\n                self._hit_limit = True\n            else:\n                self._saved_frames.append(imgdata64)\n        else:\n            return super().grab_frame(**savefig_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/isAvailable",
      "name": "isAvailable",
      "qname": "lib.matplotlib.animation.HTMLWriter.isAvailable",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/isAvailable/cls",
          "name": "cls",
          "qname": "lib.matplotlib.animation.HTMLWriter.isAvailable.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def isAvailable(cls):\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/setup",
      "name": "setup",
      "qname": "lib.matplotlib.animation.HTMLWriter.setup",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/setup/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.HTMLWriter.setup.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/setup/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.HTMLWriter.setup.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/setup/outfile",
          "name": "outfile",
          "qname": "lib.matplotlib.animation.HTMLWriter.setup.outfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/setup/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.animation.HTMLWriter.setup.dpi",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/HTMLWriter/setup/frame_dir",
          "name": "frame_dir",
          "qname": "lib.matplotlib.animation.HTMLWriter.setup.frame_dir",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def setup(self, fig, outfile, dpi=None, frame_dir=None):\n        outfile = Path(outfile)\n        _api.check_in_list(['.html', '.htm'], outfile_extension=outfile.suffix)\n\n        self._saved_frames = []\n        self._total_bytes = 0\n        self._hit_limit = False\n\n        if not self.embed_frames:\n            if frame_dir is None:\n                frame_dir = outfile.with_name(outfile.stem + '_frames')\n            frame_dir.mkdir(parents=True, exist_ok=True)\n            frame_prefix = frame_dir / 'frame'\n        else:\n            frame_prefix = None\n\n        super().setup(fig, outfile, dpi, frame_prefix)\n        self._clear_temp = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/ImageMagickBase/bin_path",
      "name": "bin_path",
      "qname": "lib.matplotlib.animation.ImageMagickBase.bin_path",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/ImageMagickBase/bin_path/cls",
          "name": "cls",
          "qname": "lib.matplotlib.animation.ImageMagickBase.bin_path.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def bin_path(cls):\n        binpath = super().bin_path()\n        if binpath == 'convert':\n            binpath = mpl._get_executable_info('magick').executable\n        return binpath"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/ImageMagickBase/delay@getter",
      "name": "delay",
      "qname": "lib.matplotlib.animation.ImageMagickBase.delay",
      "decorators": [
        "_api.deprecated('3.6')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/ImageMagickBase/delay@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.ImageMagickBase.delay.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    @property\n    def delay(self):\n        return 100. / self.fps"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/ImageMagickBase/isAvailable",
      "name": "isAvailable",
      "qname": "lib.matplotlib.animation.ImageMagickBase.isAvailable",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/ImageMagickBase/isAvailable/cls",
          "name": "cls",
          "qname": "lib.matplotlib.animation.ImageMagickBase.isAvailable.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def isAvailable(cls):\n        try:\n            return super().isAvailable()\n        except mpl.ExecutableNotFoundError as _enf:\n            # May be raised by get_executable_info.\n            _log.debug('ImageMagick unavailable due to: %s', _enf)\n            return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/ImageMagickBase/output_args@getter",
      "name": "output_args",
      "qname": "lib.matplotlib.animation.ImageMagickBase.output_args",
      "decorators": [
        "_api.deprecated('3.6')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/ImageMagickBase/output_args@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.ImageMagickBase.output_args.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    @property\n    def output_args(self):\n        extra_args = (self.extra_args if self.extra_args is not None\n                      else mpl.rcParams[self._args_key])\n        return [*extra_args, self.outfile]"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriter/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.animation.MovieWriter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/__init__/fps",
          "name": "fps",
          "qname": "lib.matplotlib.animation.MovieWriter.__init__.fps",
          "default_value": "5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/__init__/codec",
          "name": "codec",
          "qname": "lib.matplotlib.animation.MovieWriter.__init__.codec",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/__init__/bitrate",
          "name": "bitrate",
          "qname": "lib.matplotlib.animation.MovieWriter.__init__.bitrate",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/__init__/extra_args",
          "name": "extra_args",
          "qname": "lib.matplotlib.animation.MovieWriter.__init__.extra_args",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.animation.MovieWriter.__init__.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Base class for writing movies.\n\nThis is a base class for MovieWriter subclasses that write a movie frame\ndata to a pipe. You cannot instantiate this class directly.\nSee examples for how to use its subclasses.",
      "docstring": "Parameters\n----------\nfps : int, default: 5\n    Movie frame rate (per second).\ncodec : str or None, default: :rc:`animation.codec`\n    The codec to use.\nbitrate : int, default: :rc:`animation.bitrate`\n    The bitrate of the movie, in kilobits per second.  Higher values\n    means higher quality movies, but increase the file size.  A value\n    of -1 lets the underlying movie encoder select the bitrate.\nextra_args : list of str or None, optional\n    Extra command-line arguments passed to the underlying movie\n    encoder.  The default, None, means to use\n    :rc:`animation.[name-of-encoder]_args` for the builtin writers.\nmetadata : dict[str, str], default: {}\n    A dictionary of keys and values for metadata to include in the\n    output file. Some keys that may be of use include:\n    title, artist, genre, subject, copyright, srcform, comment.",
      "code": "    def __init__(self, fps=5, codec=None, bitrate=None, extra_args=None,\n                 metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        fps : int, default: 5\n            Movie frame rate (per second).\n        codec : str or None, default: :rc:`animation.codec`\n            The codec to use.\n        bitrate : int, default: :rc:`animation.bitrate`\n            The bitrate of the movie, in kilobits per second.  Higher values\n            means higher quality movies, but increase the file size.  A value\n            of -1 lets the underlying movie encoder select the bitrate.\n        extra_args : list of str or None, optional\n            Extra command-line arguments passed to the underlying movie\n            encoder.  The default, None, means to use\n            :rc:`animation.[name-of-encoder]_args` for the builtin writers.\n        metadata : dict[str, str], default: {}\n            A dictionary of keys and values for metadata to include in the\n            output file. Some keys that may be of use include:\n            title, artist, genre, subject, copyright, srcform, comment.\n        \"\"\"\n        if type(self) is MovieWriter:\n            # TODO MovieWriter is still an abstract class and needs to be\n            #      extended with a mixin. This should be clearer in naming\n            #      and description. For now, just give a reasonable error\n            #      message to users.\n            raise TypeError(\n                'MovieWriter cannot be instantiated directly. Please use one '\n                'of its subclasses.')\n\n        super().__init__(fps=fps, metadata=metadata, codec=codec,\n                         bitrate=bitrate)\n        self.frame_format = self.supported_formats[0]\n        self.extra_args = extra_args"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriter/bin_path",
      "name": "bin_path",
      "qname": "lib.matplotlib.animation.MovieWriter.bin_path",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/bin_path/cls",
          "name": "cls",
          "qname": "lib.matplotlib.animation.MovieWriter.bin_path.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the binary path to the commandline tool used by a specific\nsubclass. This is a class method so that the tool can be looked for\nbefore making a particular MovieWriter subclass available.",
      "docstring": "Return the binary path to the commandline tool used by a specific\nsubclass. This is a class method so that the tool can be looked for\nbefore making a particular MovieWriter subclass available.",
      "code": "    @classmethod\n    def bin_path(cls):\n        \"\"\"\n        Return the binary path to the commandline tool used by a specific\n        subclass. This is a class method so that the tool can be looked for\n        before making a particular MovieWriter subclass available.\n        \"\"\"\n        return str(mpl.rcParams[cls._exec_key])"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriter/finish",
      "name": "finish",
      "qname": "lib.matplotlib.animation.MovieWriter.finish",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/finish/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriter.finish.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finish any processing for writing the movie.",
      "docstring": "Finish any processing for writing the movie.",
      "code": "    def finish(self):\n        \"\"\"Finish any processing for writing the movie.\"\"\"\n        out, err = self._proc.communicate()\n        # Use the encoding/errors that universal_newlines would use.\n        out = TextIOWrapper(BytesIO(out)).read()\n        err = TextIOWrapper(BytesIO(err)).read()\n        if out:\n            _log.log(\n                logging.WARNING if self._proc.returncode else logging.DEBUG,\n                \"MovieWriter stdout:\\n%s\", out)\n        if err:\n            _log.log(\n                logging.WARNING if self._proc.returncode else logging.DEBUG,\n                \"MovieWriter stderr:\\n%s\", err)\n        if self._proc.returncode:\n            raise subprocess.CalledProcessError(\n                self._proc.returncode, self._proc.args, out, err)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriter/grab_frame",
      "name": "grab_frame",
      "qname": "lib.matplotlib.animation.MovieWriter.grab_frame",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/grab_frame/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriter.grab_frame.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/grab_frame/savefig_kwargs",
          "name": "savefig_kwargs",
          "qname": "lib.matplotlib.animation.MovieWriter.grab_frame.savefig_kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def grab_frame(self, **savefig_kwargs):\n        # docstring inherited\n        _log.debug('MovieWriter.grab_frame: Grabbing frame.')\n        # Readjust the figure size in case it has been changed by the user.\n        # All frames must have the same size to save the movie correctly.\n        self.fig.set_size_inches(self._w, self._h)\n        # Save the figure data to the sink, using the frame format and dpi.\n        self.fig.savefig(self._proc.stdin, format=self.frame_format,\n                         dpi=self.dpi, **savefig_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriter/isAvailable",
      "name": "isAvailable",
      "qname": "lib.matplotlib.animation.MovieWriter.isAvailable",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/isAvailable/cls",
          "name": "cls",
          "qname": "lib.matplotlib.animation.MovieWriter.isAvailable.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether a MovieWriter subclass is actually available.",
      "docstring": "Return whether a MovieWriter subclass is actually available.",
      "code": "    @classmethod\n    def isAvailable(cls):\n        \"\"\"Return whether a MovieWriter subclass is actually available.\"\"\"\n        return shutil.which(cls.bin_path()) is not None"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriter/setup",
      "name": "setup",
      "qname": "lib.matplotlib.animation.MovieWriter.setup",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/setup/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriter.setup.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/setup/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.MovieWriter.setup.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/setup/outfile",
          "name": "outfile",
          "qname": "lib.matplotlib.animation.MovieWriter.setup.outfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriter/setup/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.animation.MovieWriter.setup.dpi",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def setup(self, fig, outfile, dpi=None):\n        # docstring inherited\n        super().setup(fig, outfile, dpi=dpi)\n        self._w, self._h = self._adjust_frame_size()\n        # Run here so that grab_frame() can write the data to a pipe. This\n        # eliminates the need for temp files.\n        self._run()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__getitem__",
      "name": "__getitem__",
      "qname": "lib.matplotlib.animation.MovieWriterRegistry.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__getitem__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriterRegistry.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__getitem__/name",
          "name": "name",
          "qname": "lib.matplotlib.animation.MovieWriterRegistry.__getitem__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get an available writer class from its name.",
      "docstring": "Get an available writer class from its name.",
      "code": "    def __getitem__(self, name):\n        \"\"\"Get an available writer class from its name.\"\"\"\n        if self.is_available(name):\n            return self._registered[name]\n        raise RuntimeError(f\"Requested MovieWriter ({name}) not available\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.animation.MovieWriterRegistry.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriterRegistry.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Registry of available writer classes by human readable name.",
      "docstring": "",
      "code": "    def __init__(self):\n        self._registered = dict()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__iter__",
      "name": "__iter__",
      "qname": "lib.matplotlib.animation.MovieWriterRegistry.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/__iter__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriterRegistry.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Iterate over names of available writer class.",
      "docstring": "Iterate over names of available writer class.",
      "code": "    def __iter__(self):\n        \"\"\"Iterate over names of available writer class.\"\"\"\n        for name in self._registered:\n            if self.is_available(name):\n                yield name"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/is_available",
      "name": "is_available",
      "qname": "lib.matplotlib.animation.MovieWriterRegistry.is_available",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/is_available/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriterRegistry.is_available.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/is_available/name",
          "name": "name",
          "qname": "lib.matplotlib.animation.MovieWriterRegistry.is_available.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Check if given writer is available by name.",
      "docstring": "Check if given writer is available by name.\n\nParameters\n----------\nname : str\n\nReturns\n-------\nbool",
      "code": "    def is_available(self, name):\n        \"\"\"\n        Check if given writer is available by name.\n\n        Parameters\n        ----------\n        name : str\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        try:\n            cls = self._registered[name]\n        except KeyError:\n            return False\n        return cls.isAvailable()"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/list",
      "name": "list",
      "qname": "lib.matplotlib.animation.MovieWriterRegistry.list",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/list/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriterRegistry.list.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get a list of available MovieWriters.",
      "docstring": "Get a list of available MovieWriters.",
      "code": "    def list(self):\n        \"\"\"Get a list of available MovieWriters.\"\"\"\n        return [*self]"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/register",
      "name": "register",
      "qname": "lib.matplotlib.animation.MovieWriterRegistry.register",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/register/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.MovieWriterRegistry.register.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/MovieWriterRegistry/register/name",
          "name": "name",
          "qname": "lib.matplotlib.animation.MovieWriterRegistry.register.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Decorator for registering a class under a name.\n\nExample use::\n\n    @registry.register(name)\n    class Foo:\n        pass",
      "docstring": "Decorator for registering a class under a name.\n\nExample use::\n\n    @registry.register(name)\n    class Foo:\n        pass",
      "code": "    def register(self, name):\n        \"\"\"\n        Decorator for registering a class under a name.\n\n        Example use::\n\n            @registry.register(name)\n            class Foo:\n                pass\n        \"\"\"\n        def wrapper(writer_cls):\n            self._registered[name] = writer_cls\n            return writer_cls\n        return wrapper"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/PillowWriter/finish",
      "name": "finish",
      "qname": "lib.matplotlib.animation.PillowWriter.finish",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/PillowWriter/finish/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.PillowWriter.finish.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def finish(self):\n        self._frames[0].save(\n            self.outfile, save_all=True, append_images=self._frames[1:],\n            duration=int(1000 / self.fps), loop=0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/PillowWriter/grab_frame",
      "name": "grab_frame",
      "qname": "lib.matplotlib.animation.PillowWriter.grab_frame",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/PillowWriter/grab_frame/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.PillowWriter.grab_frame.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/PillowWriter/grab_frame/savefig_kwargs",
          "name": "savefig_kwargs",
          "qname": "lib.matplotlib.animation.PillowWriter.grab_frame.savefig_kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def grab_frame(self, **savefig_kwargs):\n        buf = BytesIO()\n        self.fig.savefig(\n            buf, **{**savefig_kwargs, \"format\": \"rgba\", \"dpi\": self.dpi})\n        self._frames.append(Image.frombuffer(\n            \"RGBA\", self.frame_size, buf.getbuffer(), \"raw\", \"RGBA\", 0, 1))"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/PillowWriter/isAvailable",
      "name": "isAvailable",
      "qname": "lib.matplotlib.animation.PillowWriter.isAvailable",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/PillowWriter/isAvailable/cls",
          "name": "cls",
          "qname": "lib.matplotlib.animation.PillowWriter.isAvailable.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def isAvailable(cls):\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/PillowWriter/setup",
      "name": "setup",
      "qname": "lib.matplotlib.animation.PillowWriter.setup",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/PillowWriter/setup/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.PillowWriter.setup.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/PillowWriter/setup/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.PillowWriter.setup.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/PillowWriter/setup/outfile",
          "name": "outfile",
          "qname": "lib.matplotlib.animation.PillowWriter.setup.outfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/PillowWriter/setup/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.animation.PillowWriter.setup.dpi",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def setup(self, fig, outfile, dpi=None):\n        super().setup(fig, outfile, dpi=dpi)\n        self._frames = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.animation.TimedAnimation.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.animation.TimedAnimation.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__/fig",
          "name": "fig",
          "qname": "lib.matplotlib.animation.TimedAnimation.__init__.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.figure.Figure`",
            "default_value": "",
            "description": "The figure object used to get needed events, such as draw or resize."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.figure.Figure`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__/interval",
          "name": "interval",
          "qname": "lib.matplotlib.animation.TimedAnimation.__init__.interval",
          "default_value": "200",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "200",
            "description": "Delay between frames in milliseconds."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__/repeat_delay",
          "name": "repeat_delay",
          "qname": "lib.matplotlib.animation.TimedAnimation.__init__.repeat_delay",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "0",
            "description": "The delay in milliseconds between consecutive animation runs, if\n*repeat* is True."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__/repeat",
          "name": "repeat",
          "qname": "lib.matplotlib.animation.TimedAnimation.__init__.repeat",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether the animation repeats when the sequence of frames is completed."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__/event_source",
          "name": "event_source",
          "qname": "lib.matplotlib.animation.TimedAnimation.__init__.event_source",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.animation.TimedAnimation.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/TimedAnimation/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.animation.TimedAnimation.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "`Animation` subclass for time-based animation.\n\nA new frame is drawn every *interval* milliseconds.\n\n.. note::\n\n    You must store the created Animation in a variable that lives as long\n    as the animation should run. Otherwise, the Animation object will be\n    garbage-collected and the animation stops.",
      "docstring": "",
      "code": "    def __init__(self, fig, interval=200, repeat_delay=0, repeat=True,\n                 event_source=None, *args, **kwargs):\n        self._interval = interval\n        # Undocumented support for repeat_delay = None as backcompat.\n        self._repeat_delay = repeat_delay if repeat_delay is not None else 0\n        self.repeat = repeat\n        # If we're not given an event source, create a new timer. This permits\n        # sharing timers between animation objects for syncing animations.\n        if event_source is None:\n            event_source = fig.canvas.new_timer(interval=self._interval)\n        super().__init__(fig, event_source=event_source, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.animation/adjusted_figsize",
      "name": "adjusted_figsize",
      "qname": "lib.matplotlib.animation.adjusted_figsize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.animation/adjusted_figsize/w",
          "name": "w",
          "qname": "lib.matplotlib.animation.adjusted_figsize.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "Size in inches."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/adjusted_figsize/h",
          "name": "h",
          "qname": "lib.matplotlib.animation.adjusted_figsize.h",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "Size in inches."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/adjusted_figsize/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.animation.adjusted_figsize.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The dpi."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.animation/adjusted_figsize/n",
          "name": "n",
          "qname": "lib.matplotlib.animation.adjusted_figsize.n",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The target multiple."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Compute figure size so that pixels are a multiple of n.",
      "docstring": "Compute figure size so that pixels are a multiple of n.\n\nParameters\n----------\nw, h : float\n    Size in inches.\n\ndpi : float\n    The dpi.\n\nn : int\n    The target multiple.\n\nReturns\n-------\nwnew, hnew : float\n    The new figure size in inches.",
      "code": "def adjusted_figsize(w, h, dpi, n):\n    \"\"\"\n    Compute figure size so that pixels are a multiple of n.\n\n    Parameters\n    ----------\n    w, h : float\n        Size in inches.\n\n    dpi : float\n        The dpi.\n\n    n : int\n        The target multiple.\n\n    Returns\n    -------\n    wnew, hnew : float\n        The new figure size in inches.\n    \"\"\"\n\n    # this maybe simplified if / when we adopt consistent rounding for\n    # pixel size across the whole library\n    def correct_roundoff(x, dpi, n):\n        if int(x*dpi) % n != 0:\n            if int(np.nextafter(x, np.inf)*dpi) % n == 0:\n                x = np.nextafter(x, np.inf)\n            elif int(np.nextafter(x, -np.inf)*dpi) % n == 0:\n                x = np.nextafter(x, -np.inf)\n        return x\n\n    wnew = int(w * dpi / n) * n / dpi\n    hnew = int(h * dpi / n) * n / dpi\n    return correct_roundoff(wnew, dpi, n), correct_roundoff(hnew, dpi, n)"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/__getstate__",
      "name": "__getstate__",
      "qname": "lib.matplotlib.artist.Artist.__getstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/__getstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.__getstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getstate__(self):\n        d = self.__dict__.copy()\n        # remove the unpicklable remove method, this will get re-added on load\n        # (by the Axes) if the artist lives on an Axes.\n        d['stale_callback'] = None\n        return d"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.artist.Artist.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for objects that render into a FigureCanvas.\n\nTypically, all visible elements in a figure are subclasses of Artist.",
      "docstring": "",
      "code": "    def __init__(self):\n        self._stale = True\n        self.stale_callback = None\n        self._axes = None\n        self.figure = None\n\n        self._transform = None\n        self._transformSet = False\n        self._visible = True\n        self._animated = False\n        self._alpha = None\n        self.clipbox = None\n        self._clippath = None\n        self._clipon = True\n        self._label = ''\n        self._picker = None\n        self._rasterized = False\n        self._agg_filter = None\n        # Normally, artist classes need to be queried for mouseover info if and\n        # only if they override get_cursor_data.\n        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n        try:\n            self.axes = None\n        except AttributeError:\n            # Handle self.axes as a read-only property, as in Figure.\n            pass\n        self._remove_method = None\n        self._url = None\n        self._gid = None\n        self._snap = None\n        self._sketch = mpl.rcParams['path.sketch']\n        self._path_effects = mpl.rcParams['path.effects']\n        self._sticky_edges = _XYPair([], [])\n        self._in_layout = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/__init_subclass__",
      "name": "__init_subclass__",
      "qname": "lib.matplotlib.artist.Artist.__init_subclass__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/__init_subclass__/cls",
          "name": "cls",
          "qname": "lib.matplotlib.artist.Artist.__init_subclass__.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init_subclass__(cls):\n        # Inject custom set() methods into the subclass with signature and\n        # docstring based on the subclasses' properties.\n\n        if not hasattr(cls.set, '_autogenerated_signature'):\n            # Don't overwrite cls.set if the subclass or one of its parents\n            # has defined a set method set itself.\n            # If there was no explicit definition, cls.set is inherited from\n            # the hierarchy of auto-generated set methods, which hold the\n            # flag _autogenerated_signature.\n            return\n\n        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n        cls.set.__name__ = \"set\"\n        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n        cls._update_set_signature_and_docstring()"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/add_callback",
      "name": "add_callback",
      "qname": "lib.matplotlib.artist.Artist.add_callback",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/add_callback/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.add_callback.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/add_callback/func",
          "name": "func",
          "qname": "lib.matplotlib.artist.Artist.add_callback.func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "The callback function. It must have the signature::\n\n    def func(artist: Artist) -> Any\n\nwhere *artist* is the calling `.Artist`. Return values may exist\nbut are ignored."
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a callback function that will be called whenever one of the\n`.Artist`'s properties changes.",
      "docstring": "Add a callback function that will be called whenever one of the\n`.Artist`'s properties changes.\n\nParameters\n----------\nfunc : callable\n    The callback function. It must have the signature::\n\n        def func(artist: Artist) -> Any\n\n    where *artist* is the calling `.Artist`. Return values may exist\n    but are ignored.\n\nReturns\n-------\nint\n    The observer id associated with the callback. This id can be\n    used for removing the callback with `.remove_callback` later.\n\nSee Also\n--------\nremove_callback",
      "code": "    def add_callback(self, func):\n        \"\"\"\n        Add a callback function that will be called whenever one of the\n        `.Artist`'s properties changes.\n\n        Parameters\n        ----------\n        func : callable\n            The callback function. It must have the signature::\n\n                def func(artist: Artist) -> Any\n\n            where *artist* is the calling `.Artist`. Return values may exist\n            but are ignored.\n\n        Returns\n        -------\n        int\n            The observer id associated with the callback. This id can be\n            used for removing the callback with `.remove_callback` later.\n\n        See Also\n        --------\n        remove_callback\n        \"\"\"\n        # Wrapping func in a lambda ensures it can be connected multiple times\n        # and never gets weakref-gc'ed.\n        return self._callbacks.connect(\"pchanged\", lambda: func(self))"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/axes@getter",
      "name": "axes",
      "qname": "lib.matplotlib.artist.Artist.axes",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/axes@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.axes.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The `~.axes.Axes` instance the artist resides in, or *None*.",
      "docstring": "The `~.axes.Axes` instance the artist resides in, or *None*.",
      "code": "    @property\n    def axes(self):\n        \"\"\"The `~.axes.Axes` instance the artist resides in, or *None*.\"\"\"\n        return self._axes"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/axes@setter",
      "name": "axes",
      "qname": "lib.matplotlib.artist.Artist.axes",
      "decorators": [
        "axes.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/axes@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.axes.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/axes@setter/new_axes",
          "name": "new_axes",
          "qname": "lib.matplotlib.artist.Artist.axes.new_axes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @axes.setter\n    def axes(self, new_axes):\n        if (new_axes is not None and self._axes is not None\n                and new_axes != self._axes):\n            raise ValueError(\"Can not reset the axes.  You are probably \"\n                             \"trying to re-use an artist in more than one \"\n                             \"Axes which is not supported\")\n        self._axes = new_axes\n        if new_axes is not None and new_axes is not self:\n            self.stale_callback = _stale_axes_callback"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/contains",
      "name": "contains",
      "qname": "lib.matplotlib.artist.Artist.contains",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/contains/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.contains.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/contains/mouseevent",
          "name": "mouseevent",
          "qname": "lib.matplotlib.artist.Artist.contains.mouseevent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`matplotlib.backend_bases.MouseEvent`",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`matplotlib.backend_bases.MouseEvent`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Test whether the artist contains the mouse event.",
      "docstring": "Test whether the artist contains the mouse event.\n\nParameters\n----------\nmouseevent : `matplotlib.backend_bases.MouseEvent`\n\nReturns\n-------\ncontains : bool\n    Whether any values are within the radius.\ndetails : dict\n    An artist-specific dictionary of details of the event context,\n    such as which points are contained in the pick radius. See the\n    individual Artist subclasses for details.",
      "code": "    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the artist contains the mouse event.\n\n        Parameters\n        ----------\n        mouseevent : `matplotlib.backend_bases.MouseEvent`\n\n        Returns\n        -------\n        contains : bool\n            Whether any values are within the radius.\n        details : dict\n            An artist-specific dictionary of details of the event context,\n            such as which points are contained in the pick radius. See the\n            individual Artist subclasses for details.\n        \"\"\"\n        inside, info = self._default_contains(mouseevent)\n        if inside is not None:\n            return inside, info\n        _log.warning(\"%r needs 'contains' method\", self.__class__.__name__)\n        return False, {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/convert_xunits",
      "name": "convert_xunits",
      "qname": "lib.matplotlib.artist.Artist.convert_xunits",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/convert_xunits/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.convert_xunits.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/convert_xunits/x",
          "name": "x",
          "qname": "lib.matplotlib.artist.Artist.convert_xunits.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert *x* using the unit type of the xaxis.\n\nIf the artist is not contained in an Axes or if the xaxis does not\nhave units, *x* itself is returned.",
      "docstring": "Convert *x* using the unit type of the xaxis.\n\nIf the artist is not contained in an Axes or if the xaxis does not\nhave units, *x* itself is returned.",
      "code": "    def convert_xunits(self, x):\n        \"\"\"\n        Convert *x* using the unit type of the xaxis.\n\n        If the artist is not contained in an Axes or if the xaxis does not\n        have units, *x* itself is returned.\n        \"\"\"\n        ax = getattr(self, 'axes', None)\n        if ax is None or ax.xaxis is None:\n            return x\n        return ax.xaxis.convert_units(x)"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/convert_yunits",
      "name": "convert_yunits",
      "qname": "lib.matplotlib.artist.Artist.convert_yunits",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/convert_yunits/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.convert_yunits.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/convert_yunits/y",
          "name": "y",
          "qname": "lib.matplotlib.artist.Artist.convert_yunits.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert *y* using the unit type of the yaxis.\n\nIf the artist is not contained in an Axes or if the yaxis does not\nhave units, *y* itself is returned.",
      "docstring": "Convert *y* using the unit type of the yaxis.\n\nIf the artist is not contained in an Axes or if the yaxis does not\nhave units, *y* itself is returned.",
      "code": "    def convert_yunits(self, y):\n        \"\"\"\n        Convert *y* using the unit type of the yaxis.\n\n        If the artist is not contained in an Axes or if the yaxis does not\n        have units, *y* itself is returned.\n        \"\"\"\n        ax = getattr(self, 'axes', None)\n        if ax is None or ax.yaxis is None:\n            return y\n        return ax.yaxis.convert_units(y)"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/draw",
      "name": "draw",
      "qname": "lib.matplotlib.artist.Artist.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/draw/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.artist.Artist.draw.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.RendererBase` subclass.",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`.RendererBase` subclass."
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw the Artist (and its children) using the given renderer.\n\nThis has no effect if the artist is not visible (`.Artist.get_visible`\nreturns False).",
      "docstring": "Draw the Artist (and its children) using the given renderer.\n\nThis has no effect if the artist is not visible (`.Artist.get_visible`\nreturns False).\n\nParameters\n----------\nrenderer : `.RendererBase` subclass.\n\nNotes\n-----\nThis method is overridden in the Artist subclasses.",
      "code": "    def draw(self, renderer):\n        \"\"\"\n        Draw the Artist (and its children) using the given renderer.\n\n        This has no effect if the artist is not visible (`.Artist.get_visible`\n        returns False).\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass.\n\n        Notes\n        -----\n        This method is overridden in the Artist subclasses.\n        \"\"\"\n        if not self.get_visible():\n            return\n        self.stale = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/findobj",
      "name": "findobj",
      "qname": "lib.matplotlib.artist.Artist.findobj",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/findobj/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.findobj.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/findobj/match",
          "name": "match",
          "qname": "lib.matplotlib.artist.Artist.findobj.match",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "A filter criterion for the matches. This can be\n\n- *None*: Return all objects contained in artist.\n- A function with signature ``def match(artist: Artist) -> bool``.\n  The result will only contain artists for which the function\n  returns *True*.\n- A class instance: e.g., `.Line2D`. The result will only contain\n  artists of this class or its subclasses (``isinstance`` check)."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/findobj/include_self",
          "name": "include_self",
          "qname": "lib.matplotlib.artist.Artist.findobj.include_self",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Include *self* in the list to be checked for a match."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Find artist objects.\n\nRecursively find all `.Artist` instances contained in the artist.",
      "docstring": "Find artist objects.\n\nRecursively find all `.Artist` instances contained in the artist.\n\nParameters\n----------\nmatch\n    A filter criterion for the matches. This can be\n\n    - *None*: Return all objects contained in artist.\n    - A function with signature ``def match(artist: Artist) -> bool``.\n      The result will only contain artists for which the function\n      returns *True*.\n    - A class instance: e.g., `.Line2D`. The result will only contain\n      artists of this class or its subclasses (``isinstance`` check).\n\ninclude_self : bool\n    Include *self* in the list to be checked for a match.\n\nReturns\n-------\nlist of `.Artist`",
      "code": "    def findobj(self, match=None, include_self=True):\n        \"\"\"\n        Find artist objects.\n\n        Recursively find all `.Artist` instances contained in the artist.\n\n        Parameters\n        ----------\n        match\n            A filter criterion for the matches. This can be\n\n            - *None*: Return all objects contained in artist.\n            - A function with signature ``def match(artist: Artist) -> bool``.\n              The result will only contain artists for which the function\n              returns *True*.\n            - A class instance: e.g., `.Line2D`. The result will only contain\n              artists of this class or its subclasses (``isinstance`` check).\n\n        include_self : bool\n            Include *self* in the list to be checked for a match.\n\n        Returns\n        -------\n        list of `.Artist`\n\n        \"\"\"\n        if match is None:  # always return True\n            def matchfunc(x):\n                return True\n        elif isinstance(match, type) and issubclass(match, Artist):\n            def matchfunc(x):\n                return isinstance(x, match)\n        elif callable(match):\n            matchfunc = match\n        else:\n            raise ValueError('match must be None, a matplotlib.artist.Artist '\n                             'subclass, or a callable')\n\n        artists = sum([c.findobj(matchfunc) for c in self.get_children()], [])\n        if include_self and matchfunc(self):\n            artists.append(self)\n        return artists"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/format_cursor_data",
      "name": "format_cursor_data",
      "qname": "lib.matplotlib.artist.Artist.format_cursor_data",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/format_cursor_data/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.format_cursor_data.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/format_cursor_data/data",
          "name": "data",
          "qname": "lib.matplotlib.artist.Artist.format_cursor_data.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a string representation of *data*.\n\n.. note::\n    This method is intended to be overridden by artist subclasses.\n    As an end-user of Matplotlib you will most likely not call this\n    method yourself.\n\nThe default implementation converts ints and floats and arrays of ints\nand floats into a comma-separated string enclosed in square brackets,\nunless the artist has an associated colorbar, in which case scalar\nvalues are formatted using the colorbar's formatter.",
      "docstring": "Return a string representation of *data*.\n\n.. note::\n    This method is intended to be overridden by artist subclasses.\n    As an end-user of Matplotlib you will most likely not call this\n    method yourself.\n\nThe default implementation converts ints and floats and arrays of ints\nand floats into a comma-separated string enclosed in square brackets,\nunless the artist has an associated colorbar, in which case scalar\nvalues are formatted using the colorbar's formatter.\n\nSee Also\n--------\nget_cursor_data",
      "code": "    def format_cursor_data(self, data):\n        \"\"\"\n        Return a string representation of *data*.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        The default implementation converts ints and floats and arrays of ints\n        and floats into a comma-separated string enclosed in square brackets,\n        unless the artist has an associated colorbar, in which case scalar\n        values are formatted using the colorbar's formatter.\n\n        See Also\n        --------\n        get_cursor_data\n        \"\"\"\n        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n            # This block logically belongs to ScalarMappable, but can't be\n            # implemented in it because most ScalarMappable subclasses inherit\n            # from Artist first and from ScalarMappable second, so\n            # Artist.format_cursor_data would always have precedence over\n            # ScalarMappable.format_cursor_data.\n            n = self.cmap.N\n            if np.ma.getmask(data):\n                return \"[]\"\n            normed = self.norm(data)\n            if np.isfinite(normed):\n                if isinstance(self.norm, BoundaryNorm):\n                    # not an invertible normalization mapping\n                    cur_idx = np.argmin(np.abs(self.norm.boundaries - data))\n                    neigh_idx = max(0, cur_idx - 1)\n                    # use max diff to prevent delta == 0\n                    delta = np.diff(\n                        self.norm.boundaries[neigh_idx:cur_idx + 2]\n                    ).max()\n\n                else:\n                    # Midpoints of neighboring color intervals.\n                    neighbors = self.norm.inverse(\n                        (int(normed * n) + np.array([0, 1])) / n)\n                    delta = abs(neighbors - data).max()\n                g_sig_digits = cbook._g_sig_digits(data, delta)\n            else:\n                g_sig_digits = 3  # Consistent with default below.\n            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n        else:\n            try:\n                data[0]\n            except (TypeError, IndexError):\n                data = [data]\n            data_str = ', '.join('{:0.3g}'.format(item) for item in data\n                                 if isinstance(item, Number))\n            return \"[\" + data_str + \"]\""
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_agg_filter",
      "name": "get_agg_filter",
      "qname": "lib.matplotlib.artist.Artist.get_agg_filter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_agg_filter/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_agg_filter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return filter function to be used for agg filter.",
      "docstring": "Return filter function to be used for agg filter.",
      "code": "    def get_agg_filter(self):\n        \"\"\"Return filter function to be used for agg filter.\"\"\"\n        return self._agg_filter"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_alpha",
      "name": "get_alpha",
      "qname": "lib.matplotlib.artist.Artist.get_alpha",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_alpha/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_alpha.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the alpha value used for blending - not supported on all\nbackends.",
      "docstring": "Return the alpha value used for blending - not supported on all\nbackends.",
      "code": "    def get_alpha(self):\n        \"\"\"\n        Return the alpha value used for blending - not supported on all\n        backends.\n        \"\"\"\n        return self._alpha"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_animated",
      "name": "get_animated",
      "qname": "lib.matplotlib.artist.Artist.get_animated",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_animated/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_animated.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the artist is animated.",
      "docstring": "Return whether the artist is animated.",
      "code": "    def get_animated(self):\n        \"\"\"Return whether the artist is animated.\"\"\"\n        return self._animated"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_children",
      "name": "get_children",
      "qname": "lib.matplotlib.artist.Artist.get_children",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_children/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_children.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of the child `.Artist`\\s of this `.Artist`.",
      "docstring": "Return a list of the child `.Artist`\\s of this `.Artist`.",
      "code": "    def get_children(self):\n        r\"\"\"Return a list of the child `.Artist`\\s of this `.Artist`.\"\"\"\n        return []"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_clip_box",
      "name": "get_clip_box",
      "qname": "lib.matplotlib.artist.Artist.get_clip_box",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_clip_box/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_clip_box.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the clipbox.",
      "docstring": "Return the clipbox.",
      "code": "    def get_clip_box(self):\n        \"\"\"Return the clipbox.\"\"\"\n        return self.clipbox"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_clip_on",
      "name": "get_clip_on",
      "qname": "lib.matplotlib.artist.Artist.get_clip_on",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_clip_on/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_clip_on.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the artist uses clipping.",
      "docstring": "Return whether the artist uses clipping.",
      "code": "    def get_clip_on(self):\n        \"\"\"Return whether the artist uses clipping.\"\"\"\n        return self._clipon"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_clip_path",
      "name": "get_clip_path",
      "qname": "lib.matplotlib.artist.Artist.get_clip_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_clip_path/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_clip_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the clip path.",
      "docstring": "Return the clip path.",
      "code": "    def get_clip_path(self):\n        \"\"\"Return the clip path.\"\"\"\n        return self._clippath"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_cursor_data",
      "name": "get_cursor_data",
      "qname": "lib.matplotlib.artist.Artist.get_cursor_data",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_cursor_data/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_cursor_data.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_cursor_data/event",
          "name": "event",
          "qname": "lib.matplotlib.artist.Artist.get_cursor_data.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`matplotlib.backend_bases.MouseEvent`",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`matplotlib.backend_bases.MouseEvent`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the cursor data for a given event.\n\n.. note::\n    This method is intended to be overridden by artist subclasses.\n    As an end-user of Matplotlib you will most likely not call this\n    method yourself.\n\nCursor data can be used by Artists to provide additional context\ninformation for a given event. The default implementation just returns\n*None*.\n\nSubclasses can override the method and return arbitrary data. However,\nwhen doing so, they must ensure that `.format_cursor_data` can convert\nthe data to a string representation.\n\nThe only current use case is displaying the z-value of an `.AxesImage`\nin the status bar of a plot window, while moving the mouse.",
      "docstring": "Return the cursor data for a given event.\n\n.. note::\n    This method is intended to be overridden by artist subclasses.\n    As an end-user of Matplotlib you will most likely not call this\n    method yourself.\n\nCursor data can be used by Artists to provide additional context\ninformation for a given event. The default implementation just returns\n*None*.\n\nSubclasses can override the method and return arbitrary data. However,\nwhen doing so, they must ensure that `.format_cursor_data` can convert\nthe data to a string representation.\n\nThe only current use case is displaying the z-value of an `.AxesImage`\nin the status bar of a plot window, while moving the mouse.\n\nParameters\n----------\nevent : `matplotlib.backend_bases.MouseEvent`\n\nSee Also\n--------\nformat_cursor_data",
      "code": "    def get_cursor_data(self, event):\n        \"\"\"\n        Return the cursor data for a given event.\n\n        .. note::\n            This method is intended to be overridden by artist subclasses.\n            As an end-user of Matplotlib you will most likely not call this\n            method yourself.\n\n        Cursor data can be used by Artists to provide additional context\n        information for a given event. The default implementation just returns\n        *None*.\n\n        Subclasses can override the method and return arbitrary data. However,\n        when doing so, they must ensure that `.format_cursor_data` can convert\n        the data to a string representation.\n\n        The only current use case is displaying the z-value of an `.AxesImage`\n        in the status bar of a plot window, while moving the mouse.\n\n        Parameters\n        ----------\n        event : `matplotlib.backend_bases.MouseEvent`\n\n        See Also\n        --------\n        format_cursor_data\n\n        \"\"\"\n        return None"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_figure",
      "name": "get_figure",
      "qname": "lib.matplotlib.artist.Artist.get_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the `.Figure` instance the artist belongs to.",
      "docstring": "Return the `.Figure` instance the artist belongs to.",
      "code": "    def get_figure(self):\n        \"\"\"Return the `.Figure` instance the artist belongs to.\"\"\"\n        return self.figure"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_gid",
      "name": "get_gid",
      "qname": "lib.matplotlib.artist.Artist.get_gid",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_gid/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_gid.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the group id.",
      "docstring": "Return the group id.",
      "code": "    def get_gid(self):\n        \"\"\"Return the group id.\"\"\"\n        return self._gid"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_in_layout",
      "name": "get_in_layout",
      "qname": "lib.matplotlib.artist.Artist.get_in_layout",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_in_layout/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_in_layout.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return boolean flag, ``True`` if artist is included in layout\ncalculations.\n\nE.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n`.Figure.tight_layout()`, and\n``fig.savefig(fname, bbox_inches='tight')``.",
      "docstring": "Return boolean flag, ``True`` if artist is included in layout\ncalculations.\n\nE.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n`.Figure.tight_layout()`, and\n``fig.savefig(fname, bbox_inches='tight')``.",
      "code": "    def get_in_layout(self):\n        \"\"\"\n        Return boolean flag, ``True`` if artist is included in layout\n        calculations.\n\n        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n        `.Figure.tight_layout()`, and\n        ``fig.savefig(fname, bbox_inches='tight')``.\n        \"\"\"\n        return self._in_layout"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_label",
      "name": "get_label",
      "qname": "lib.matplotlib.artist.Artist.get_label",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_label/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_label.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the label used for this artist in the legend.",
      "docstring": "Return the label used for this artist in the legend.",
      "code": "    def get_label(self):\n        \"\"\"Return the label used for this artist in the legend.\"\"\"\n        return self._label"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_mouseover",
      "name": "get_mouseover",
      "qname": "lib.matplotlib.artist.Artist.get_mouseover",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_mouseover/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_mouseover.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether this artist is queried for custom context information\nwhen the mouse cursor moves over it.",
      "docstring": "Return whether this artist is queried for custom context information\nwhen the mouse cursor moves over it.",
      "code": "    def get_mouseover(self):\n        \"\"\"\n        Return whether this artist is queried for custom context information\n        when the mouse cursor moves over it.\n        \"\"\"\n        return self._mouseover"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_path_effects",
      "name": "get_path_effects",
      "qname": "lib.matplotlib.artist.Artist.get_path_effects",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_path_effects/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_path_effects.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_path_effects(self):\n        return self._path_effects"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_picker",
      "name": "get_picker",
      "qname": "lib.matplotlib.artist.Artist.get_picker",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_picker/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_picker.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the picking behavior of the artist.\n\nThe possible values are described in `.set_picker`.",
      "docstring": "Return the picking behavior of the artist.\n\nThe possible values are described in `.set_picker`.\n\nSee Also\n--------\nset_picker, pickable, pick",
      "code": "    def get_picker(self):\n        \"\"\"\n        Return the picking behavior of the artist.\n\n        The possible values are described in `.set_picker`.\n\n        See Also\n        --------\n        set_picker, pickable, pick\n        \"\"\"\n        return self._picker"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_rasterized",
      "name": "get_rasterized",
      "qname": "lib.matplotlib.artist.Artist.get_rasterized",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_rasterized/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_rasterized.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the artist is to be rasterized.",
      "docstring": "Return whether the artist is to be rasterized.",
      "code": "    def get_rasterized(self):\n        \"\"\"Return whether the artist is to be rasterized.\"\"\"\n        return self._rasterized"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_sketch_params",
      "name": "get_sketch_params",
      "qname": "lib.matplotlib.artist.Artist.get_sketch_params",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_sketch_params/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_sketch_params.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the sketch parameters for the artist.",
      "docstring": "Return the sketch parameters for the artist.\n\nReturns\n-------\ntuple or None\n\n    A 3-tuple with the following elements:\n\n    - *scale*: The amplitude of the wiggle perpendicular to the\n      source line.\n    - *length*: The length of the wiggle along the line.\n    - *randomness*: The scale factor by which the length is\n      shrunken or expanded.\n\n    Returns *None* if no sketch parameters were set.",
      "code": "    def get_sketch_params(self):\n        \"\"\"\n        Return the sketch parameters for the artist.\n\n        Returns\n        -------\n        tuple or None\n\n            A 3-tuple with the following elements:\n\n            - *scale*: The amplitude of the wiggle perpendicular to the\n              source line.\n            - *length*: The length of the wiggle along the line.\n            - *randomness*: The scale factor by which the length is\n              shrunken or expanded.\n\n            Returns *None* if no sketch parameters were set.\n        \"\"\"\n        return self._sketch"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_snap",
      "name": "get_snap",
      "qname": "lib.matplotlib.artist.Artist.get_snap",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_snap/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_snap.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the snap setting.\n\nSee `.set_snap` for details.",
      "docstring": "Return the snap setting.\n\nSee `.set_snap` for details.",
      "code": "    def get_snap(self):\n        \"\"\"\n        Return the snap setting.\n\n        See `.set_snap` for details.\n        \"\"\"\n        if mpl.rcParams['path.snap']:\n            return self._snap\n        else:\n            return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_tightbbox",
      "name": "get_tightbbox",
      "qname": "lib.matplotlib.artist.Artist.get_tightbbox",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_tightbbox/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_tightbbox.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_tightbbox/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.artist.Artist.get_tightbbox.renderer",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.RendererBase` subclass",
            "default_value": "",
            "description": "renderer that will be used to draw the figures (i.e.\n``fig.canvas.get_renderer()``)"
          },
          "type": {
            "kind": "NamedType",
            "name": "`.RendererBase` subclass"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Like `.Artist.get_window_extent`, but includes any clipping.",
      "docstring": "Like `.Artist.get_window_extent`, but includes any clipping.\n\nParameters\n----------\nrenderer : `.RendererBase` subclass\n    renderer that will be used to draw the figures (i.e.\n    ``fig.canvas.get_renderer()``)\n\nReturns\n-------\n`.Bbox`\n    The enclosing bounding box (in figure pixel coordinates).",
      "code": "    def get_tightbbox(self, renderer=None):\n        \"\"\"\n        Like `.Artist.get_window_extent`, but includes any clipping.\n\n        Parameters\n        ----------\n        renderer : `.RendererBase` subclass\n            renderer that will be used to draw the figures (i.e.\n            ``fig.canvas.get_renderer()``)\n\n        Returns\n        -------\n        `.Bbox`\n            The enclosing bounding box (in figure pixel coordinates).\n        \"\"\"\n        bbox = self.get_window_extent(renderer)\n        if self.get_clip_on():\n            clip_box = self.get_clip_box()\n            if clip_box is not None:\n                bbox = Bbox.intersection(bbox, clip_box)\n            clip_path = self.get_clip_path()\n            if clip_path is not None:\n                clip_path = clip_path.get_fully_transformed_path()\n                bbox = Bbox.intersection(bbox, clip_path.get_extents())\n        return bbox"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_transform",
      "name": "get_transform",
      "qname": "lib.matplotlib.artist.Artist.get_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the `.Transform` instance used by this artist.",
      "docstring": "Return the `.Transform` instance used by this artist.",
      "code": "    def get_transform(self):\n        \"\"\"Return the `.Transform` instance used by this artist.\"\"\"\n        if self._transform is None:\n            self._transform = IdentityTransform()\n        elif (not isinstance(self._transform, Transform)\n              and hasattr(self._transform, '_as_mpl_transform')):\n            self._transform = self._transform._as_mpl_transform(self.axes)\n        return self._transform"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_transformed_clip_path_and_affine",
      "name": "get_transformed_clip_path_and_affine",
      "qname": "lib.matplotlib.artist.Artist.get_transformed_clip_path_and_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_transformed_clip_path_and_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_transformed_clip_path_and_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the clip path with the non-affine part of its\ntransformation applied, and the remaining affine part of its\ntransformation.",
      "docstring": "Return the clip path with the non-affine part of its\ntransformation applied, and the remaining affine part of its\ntransformation.",
      "code": "    def get_transformed_clip_path_and_affine(self):\n        \"\"\"\n        Return the clip path with the non-affine part of its\n        transformation applied, and the remaining affine part of its\n        transformation.\n        \"\"\"\n        if self._clippath is not None:\n            return self._clippath.get_transformed_path_and_affine()\n        return None, None"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_url",
      "name": "get_url",
      "qname": "lib.matplotlib.artist.Artist.get_url",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_url/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_url.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the url.",
      "docstring": "Return the url.",
      "code": "    def get_url(self):\n        \"\"\"Return the url.\"\"\"\n        return self._url"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_visible",
      "name": "get_visible",
      "qname": "lib.matplotlib.artist.Artist.get_visible",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_visible/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_visible.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the visibility.",
      "docstring": "Return the visibility.",
      "code": "    def get_visible(self):\n        \"\"\"Return the visibility.\"\"\"\n        return self._visible"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_window_extent",
      "name": "get_window_extent",
      "qname": "lib.matplotlib.artist.Artist.get_window_extent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_window_extent/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_window_extent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_window_extent/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.artist.Artist.get_window_extent.renderer",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the artist's bounding box in display space.\n\nThe bounding box' width and height are nonnegative.\n\nSubclasses should override for inclusion in the bounding box\n\"tight\" calculation. Default is to return an empty bounding\nbox at 0, 0.\n\nBe careful when using this function, the results will not update\nif the artist window extent of the artist changes.  The extent\ncan change due to any changes in the transform stack, such as\nchanging the axes limits, the figure size, or the canvas used\n(as is done when saving a figure).  This can lead to unexpected\nbehavior where interactive figures will look fine on the screen,\nbut will save incorrectly.",
      "docstring": "Get the artist's bounding box in display space.\n\nThe bounding box' width and height are nonnegative.\n\nSubclasses should override for inclusion in the bounding box\n\"tight\" calculation. Default is to return an empty bounding\nbox at 0, 0.\n\nBe careful when using this function, the results will not update\nif the artist window extent of the artist changes.  The extent\ncan change due to any changes in the transform stack, such as\nchanging the axes limits, the figure size, or the canvas used\n(as is done when saving a figure).  This can lead to unexpected\nbehavior where interactive figures will look fine on the screen,\nbut will save incorrectly.",
      "code": "    def get_window_extent(self, renderer=None):\n        \"\"\"\n        Get the artist's bounding box in display space.\n\n        The bounding box' width and height are nonnegative.\n\n        Subclasses should override for inclusion in the bounding box\n        \"tight\" calculation. Default is to return an empty bounding\n        box at 0, 0.\n\n        Be careful when using this function, the results will not update\n        if the artist window extent of the artist changes.  The extent\n        can change due to any changes in the transform stack, such as\n        changing the axes limits, the figure size, or the canvas used\n        (as is done when saving a figure).  This can lead to unexpected\n        behavior where interactive figures will look fine on the screen,\n        but will save incorrectly.\n        \"\"\"\n        return Bbox([[0, 0], [0, 0]])"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/get_zorder",
      "name": "get_zorder",
      "qname": "lib.matplotlib.artist.Artist.get_zorder",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/get_zorder/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.get_zorder.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the artist's zorder.",
      "docstring": "Return the artist's zorder.",
      "code": "    def get_zorder(self):\n        \"\"\"Return the artist's zorder.\"\"\"\n        return self.zorder"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/have_units",
      "name": "have_units",
      "qname": "lib.matplotlib.artist.Artist.have_units",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/have_units/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.have_units.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether units are set on any axis.",
      "docstring": "Return whether units are set on any axis.",
      "code": "    def have_units(self):\n        \"\"\"Return whether units are set on any axis.\"\"\"\n        ax = self.axes\n        return ax and any(axis.have_units() for axis in ax._axis_map.values())"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/is_transform_set",
      "name": "is_transform_set",
      "qname": "lib.matplotlib.artist.Artist.is_transform_set",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/is_transform_set/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.is_transform_set.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the Artist has an explicitly set transform.\n\nThis is *True* after `.set_transform` has been called.",
      "docstring": "Return whether the Artist has an explicitly set transform.\n\nThis is *True* after `.set_transform` has been called.",
      "code": "    def is_transform_set(self):\n        \"\"\"\n        Return whether the Artist has an explicitly set transform.\n\n        This is *True* after `.set_transform` has been called.\n        \"\"\"\n        return self._transformSet"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/pchanged",
      "name": "pchanged",
      "qname": "lib.matplotlib.artist.Artist.pchanged",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/pchanged/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.pchanged.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Call all of the registered callbacks.\n\nThis function is triggered internally when a property is changed.",
      "docstring": "Call all of the registered callbacks.\n\nThis function is triggered internally when a property is changed.\n\nSee Also\n--------\nadd_callback\nremove_callback",
      "code": "    def pchanged(self):\n        \"\"\"\n        Call all of the registered callbacks.\n\n        This function is triggered internally when a property is changed.\n\n        See Also\n        --------\n        add_callback\n        remove_callback\n        \"\"\"\n        self._callbacks.process(\"pchanged\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/pick",
      "name": "pick",
      "qname": "lib.matplotlib.artist.Artist.pick",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/pick/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.pick.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/pick/mouseevent",
          "name": "mouseevent",
          "qname": "lib.matplotlib.artist.Artist.pick.mouseevent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Process a pick event.\n\nEach child artist will fire a pick event if *mouseevent* is over\nthe artist and the artist has picker set.",
      "docstring": "Process a pick event.\n\nEach child artist will fire a pick event if *mouseevent* is over\nthe artist and the artist has picker set.\n\nSee Also\n--------\nset_picker, get_picker, pickable",
      "code": "    def pick(self, mouseevent):\n        \"\"\"\n        Process a pick event.\n\n        Each child artist will fire a pick event if *mouseevent* is over\n        the artist and the artist has picker set.\n\n        See Also\n        --------\n        set_picker, get_picker, pickable\n        \"\"\"\n        from .backend_bases import PickEvent  # Circular import.\n        # Pick self\n        if self.pickable():\n            picker = self.get_picker()\n            if callable(picker):\n                inside, prop = picker(self, mouseevent)\n            else:\n                inside, prop = self.contains(mouseevent)\n            if inside:\n                PickEvent(\"pick_event\", self.figure.canvas,\n                          mouseevent, self, **prop)._process()\n\n        # Pick children\n        for a in self.get_children():\n            # make sure the event happened in the same Axes\n            ax = getattr(a, 'axes', None)\n            if (mouseevent.inaxes is None or ax is None\n                    or mouseevent.inaxes == ax):\n                # we need to check if mouseevent.inaxes is None\n                # because some objects associated with an Axes (e.g., a\n                # tick label) can be outside the bounding box of the\n                # Axes and inaxes will be None\n                # also check that ax is None so that it traverse objects\n                # which do no have an axes property but children might\n                a.pick(mouseevent)"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/pickable",
      "name": "pickable",
      "qname": "lib.matplotlib.artist.Artist.pickable",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/pickable/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.pickable.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the artist is pickable.",
      "docstring": "Return whether the artist is pickable.\n\nSee Also\n--------\nset_picker, get_picker, pick",
      "code": "    def pickable(self):\n        \"\"\"\n        Return whether the artist is pickable.\n\n        See Also\n        --------\n        set_picker, get_picker, pick\n        \"\"\"\n        return self.figure is not None and self._picker is not None"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/properties",
      "name": "properties",
      "qname": "lib.matplotlib.artist.Artist.properties",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/properties/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.properties.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a dictionary of all the properties of the artist.",
      "docstring": "Return a dictionary of all the properties of the artist.",
      "code": "    def properties(self):\n        \"\"\"Return a dictionary of all the properties of the artist.\"\"\"\n        return ArtistInspector(self).properties()"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/remove",
      "name": "remove",
      "qname": "lib.matplotlib.artist.Artist.remove",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/remove/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.remove.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Remove the artist from the figure if possible.\n\nThe effect will not be visible until the figure is redrawn, e.g.,\nwith `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\nupdate the axes limits if desired.\n\nNote: `~.axes.Axes.relim` will not see collections even if the\ncollection was added to the axes with *autolim* = True.\n\nNote: there is no support for removing the artist's legend entry.",
      "docstring": "Remove the artist from the figure if possible.\n\nThe effect will not be visible until the figure is redrawn, e.g.,\nwith `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\nupdate the axes limits if desired.\n\nNote: `~.axes.Axes.relim` will not see collections even if the\ncollection was added to the axes with *autolim* = True.\n\nNote: there is no support for removing the artist's legend entry.",
      "code": "    def remove(self):\n        \"\"\"\n        Remove the artist from the figure if possible.\n\n        The effect will not be visible until the figure is redrawn, e.g.,\n        with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n        update the axes limits if desired.\n\n        Note: `~.axes.Axes.relim` will not see collections even if the\n        collection was added to the axes with *autolim* = True.\n\n        Note: there is no support for removing the artist's legend entry.\n        \"\"\"\n\n        # There is no method to set the callback.  Instead the parent should\n        # set the _remove_method attribute directly.  This would be a\n        # protected attribute if Python supported that sort of thing.  The\n        # callback has one parameter, which is the child to be removed.\n        if self._remove_method is not None:\n            self._remove_method(self)\n            # clear stale callback\n            self.stale_callback = None\n            _ax_flag = False\n            if hasattr(self, 'axes') and self.axes:\n                # remove from the mouse hit list\n                self.axes._mouseover_set.discard(self)\n                self.axes.stale = True\n                self.axes = None  # decouple the artist from the Axes\n                _ax_flag = True\n\n            if self.figure:\n                self.figure = None\n                if not _ax_flag:\n                    self.figure = True\n\n        else:\n            raise NotImplementedError('cannot remove artist')"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/remove_callback",
      "name": "remove_callback",
      "qname": "lib.matplotlib.artist.Artist.remove_callback",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/remove_callback/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.remove_callback.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/remove_callback/oid",
          "name": "oid",
          "qname": "lib.matplotlib.artist.Artist.remove_callback.oid",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Remove a callback based on its observer id.",
      "docstring": "Remove a callback based on its observer id.\n\nSee Also\n--------\nadd_callback",
      "code": "    def remove_callback(self, oid):\n        \"\"\"\n        Remove a callback based on its observer id.\n\n        See Also\n        --------\n        add_callback\n        \"\"\"\n        self._callbacks.disconnect(oid)"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set",
      "name": "set",
      "qname": "lib.matplotlib.artist.Artist.set",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.artist.Artist.set.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set(self, **kwargs):\n        # docstring and signature are auto-generated via\n        # Artist._update_set_signature_and_docstring() at the end of the\n        # module.\n        return self._internal_update(cbook.normalize_kwargs(kwargs, self))"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_agg_filter",
      "name": "set_agg_filter",
      "qname": "lib.matplotlib.artist.Artist.set_agg_filter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_agg_filter/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_agg_filter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_agg_filter/filter_func",
          "name": "filter_func",
          "qname": "lib.matplotlib.artist.Artist.set_agg_filter.filter_func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "A filter function, which takes a (m, n, depth) float array\nand a dpi value, and returns a (m, n, depth) array and two\noffsets from the bottom left corner of the image\n\n.. ACCEPTS: a filter function, which takes a (m, n, 3) float array\n    and a dpi value, and returns a (m, n, 3) array and two offsets\n    from the bottom left corner of the image"
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the agg filter.",
      "docstring": "Set the agg filter.\n\nParameters\n----------\nfilter_func : callable\n    A filter function, which takes a (m, n, depth) float array\n    and a dpi value, and returns a (m, n, depth) array and two\n    offsets from the bottom left corner of the image\n\n    .. ACCEPTS: a filter function, which takes a (m, n, 3) float array\n        and a dpi value, and returns a (m, n, 3) array and two offsets\n        from the bottom left corner of the image",
      "code": "    def set_agg_filter(self, filter_func):\n        \"\"\"\n        Set the agg filter.\n\n        Parameters\n        ----------\n        filter_func : callable\n            A filter function, which takes a (m, n, depth) float array\n            and a dpi value, and returns a (m, n, depth) array and two\n            offsets from the bottom left corner of the image\n\n            .. ACCEPTS: a filter function, which takes a (m, n, 3) float array\n                and a dpi value, and returns a (m, n, 3) array and two offsets\n                from the bottom left corner of the image\n        \"\"\"\n        self._agg_filter = filter_func\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_alpha",
      "name": "set_alpha",
      "qname": "lib.matplotlib.artist.Artist.set_alpha",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_alpha/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_alpha.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_alpha/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.artist.Artist.set_alpha.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "scalar or None",
            "default_value": "",
            "description": "*alpha* must be within the 0-1 range, inclusive."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "scalar"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the alpha value used for blending - not supported on all backends.",
      "docstring": "Set the alpha value used for blending - not supported on all backends.\n\nParameters\n----------\nalpha : scalar or None\n    *alpha* must be within the 0-1 range, inclusive.",
      "code": "    def set_alpha(self, alpha):\n        \"\"\"\n        Set the alpha value used for blending - not supported on all backends.\n\n        Parameters\n        ----------\n        alpha : scalar or None\n            *alpha* must be within the 0-1 range, inclusive.\n        \"\"\"\n        if alpha is not None and not isinstance(alpha, Number):\n            raise TypeError(\n                f'alpha must be numeric or None, not {type(alpha)}')\n        if alpha is not None and not (0 <= alpha <= 1):\n            raise ValueError(f'alpha ({alpha}) is outside 0-1 range')\n        self._alpha = alpha\n        self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_animated",
      "name": "set_animated",
      "qname": "lib.matplotlib.artist.Artist.set_animated",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_animated/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_animated.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_animated/b",
          "name": "b",
          "qname": "lib.matplotlib.artist.Artist.set_animated.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set whether the artist is intended to be used in an animation.\n\nIf True, the artist is excluded from regular drawing of the figure.\nYou have to call `.Figure.draw_artist` / `.Axes.draw_artist`\nexplicitly on the artist. This approach is used to speed up animations\nusing blitting.\n\nSee also `matplotlib.animation` and\n:doc:`/tutorials/advanced/blitting`.",
      "docstring": "Set whether the artist is intended to be used in an animation.\n\nIf True, the artist is excluded from regular drawing of the figure.\nYou have to call `.Figure.draw_artist` / `.Axes.draw_artist`\nexplicitly on the artist. This approach is used to speed up animations\nusing blitting.\n\nSee also `matplotlib.animation` and\n:doc:`/tutorials/advanced/blitting`.\n\nParameters\n----------\nb : bool",
      "code": "    def set_animated(self, b):\n        \"\"\"\n        Set whether the artist is intended to be used in an animation.\n\n        If True, the artist is excluded from regular drawing of the figure.\n        You have to call `.Figure.draw_artist` / `.Axes.draw_artist`\n        explicitly on the artist. This approach is used to speed up animations\n        using blitting.\n\n        See also `matplotlib.animation` and\n        :doc:`/tutorials/advanced/blitting`.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        if self._animated != b:\n            self._animated = b\n            self.pchanged()"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_box",
      "name": "set_clip_box",
      "qname": "lib.matplotlib.artist.Artist.set_clip_box",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_box/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_clip_box.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_box/clipbox",
          "name": "clipbox",
          "qname": "lib.matplotlib.artist.Artist.set_clip_box.clipbox",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Bbox`",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`.Bbox`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the artist's clip `.Bbox`.",
      "docstring": "Set the artist's clip `.Bbox`.\n\nParameters\n----------\nclipbox : `.Bbox`",
      "code": "    def set_clip_box(self, clipbox):\n        \"\"\"\n        Set the artist's clip `.Bbox`.\n\n        Parameters\n        ----------\n        clipbox : `.Bbox`\n        \"\"\"\n        self.clipbox = clipbox\n        self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_on",
      "name": "set_clip_on",
      "qname": "lib.matplotlib.artist.Artist.set_clip_on",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_on/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_clip_on.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_on/b",
          "name": "b",
          "qname": "lib.matplotlib.artist.Artist.set_clip_on.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set whether the artist uses clipping.\n\nWhen False artists will be visible outside of the Axes which\ncan lead to unexpected results.",
      "docstring": "Set whether the artist uses clipping.\n\nWhen False artists will be visible outside of the Axes which\ncan lead to unexpected results.\n\nParameters\n----------\nb : bool",
      "code": "    def set_clip_on(self, b):\n        \"\"\"\n        Set whether the artist uses clipping.\n\n        When False artists will be visible outside of the Axes which\n        can lead to unexpected results.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._clipon = b\n        # This may result in the callbacks being hit twice, but ensures they\n        # are hit at least once\n        self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_path",
      "name": "set_clip_path",
      "qname": "lib.matplotlib.artist.Artist.set_clip_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_path/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_clip_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_path/path",
          "name": "path",
          "qname": "lib.matplotlib.artist.Artist.set_clip_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Patch` or `.Path` or `.TransformedPath` or None",
            "default_value": "",
            "description": "The clip path. If given a `.Path`, *transform* must be provided as\nwell. If *None*, a previously set clip path is removed."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`.Patch`"
              },
              {
                "kind": "NamedType",
                "name": "`.Path`"
              },
              {
                "kind": "NamedType",
                "name": "`.TransformedPath`"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_clip_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.artist.Artist.set_clip_path.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.transforms.Transform`",
            "default_value": "",
            "description": "Only used if *path* is a `.Path`, in which case the given `.Path`\nis converted to a `.TransformedPath` using *transform*."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.transforms.Transform`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the artist's clip path.",
      "docstring": "Set the artist's clip path.\n\nParameters\n----------\npath : `.Patch` or `.Path` or `.TransformedPath` or None\n    The clip path. If given a `.Path`, *transform* must be provided as\n    well. If *None*, a previously set clip path is removed.\ntransform : `~matplotlib.transforms.Transform`, optional\n    Only used if *path* is a `.Path`, in which case the given `.Path`\n    is converted to a `.TransformedPath` using *transform*.\n\nNotes\n-----\nFor efficiency, if *path* is a `.Rectangle` this method will set the\nclipping box to the corresponding rectangle and set the clipping path\nto ``None``.\n\nFor technical reasons (support of `~.Artist.set`), a tuple\n(*path*, *transform*) is also accepted as a single positional\nparameter.\n\n.. ACCEPTS: Patch or (Path, Transform) or None",
      "code": "    def set_clip_path(self, path, transform=None):\n        \"\"\"\n        Set the artist's clip path.\n\n        Parameters\n        ----------\n        path : `.Patch` or `.Path` or `.TransformedPath` or None\n            The clip path. If given a `.Path`, *transform* must be provided as\n            well. If *None*, a previously set clip path is removed.\n        transform : `~matplotlib.transforms.Transform`, optional\n            Only used if *path* is a `.Path`, in which case the given `.Path`\n            is converted to a `.TransformedPath` using *transform*.\n\n        Notes\n        -----\n        For efficiency, if *path* is a `.Rectangle` this method will set the\n        clipping box to the corresponding rectangle and set the clipping path\n        to ``None``.\n\n        For technical reasons (support of `~.Artist.set`), a tuple\n        (*path*, *transform*) is also accepted as a single positional\n        parameter.\n\n        .. ACCEPTS: Patch or (Path, Transform) or None\n        \"\"\"\n        from matplotlib.patches import Patch, Rectangle\n\n        success = False\n        if transform is None:\n            if isinstance(path, Rectangle):\n                self.clipbox = TransformedBbox(Bbox.unit(),\n                                               path.get_transform())\n                self._clippath = None\n                success = True\n            elif isinstance(path, Patch):\n                self._clippath = TransformedPatchPath(path)\n                success = True\n            elif isinstance(path, tuple):\n                path, transform = path\n\n        if path is None:\n            self._clippath = None\n            success = True\n        elif isinstance(path, Path):\n            self._clippath = TransformedPath(path, transform)\n            success = True\n        elif isinstance(path, TransformedPatchPath):\n            self._clippath = path\n            success = True\n        elif isinstance(path, TransformedPath):\n            self._clippath = path\n            success = True\n\n        if not success:\n            raise TypeError(\n                \"Invalid arguments to set_clip_path, of type {} and {}\"\n                .format(type(path).__name__, type(transform).__name__))\n        # This may result in the callbacks being hit twice, but guarantees they\n        # will be hit at least once.\n        self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_figure",
      "name": "set_figure",
      "qname": "lib.matplotlib.artist.Artist.set_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_figure/fig",
          "name": "fig",
          "qname": "lib.matplotlib.artist.Artist.set_figure.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Figure`",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`.Figure`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the `.Figure` instance the artist belongs to.",
      "docstring": "Set the `.Figure` instance the artist belongs to.\n\nParameters\n----------\nfig : `.Figure`",
      "code": "    def set_figure(self, fig):\n        \"\"\"\n        Set the `.Figure` instance the artist belongs to.\n\n        Parameters\n        ----------\n        fig : `.Figure`\n        \"\"\"\n        # if this is a no-op just return\n        if self.figure is fig:\n            return\n        # if we currently have a figure (the case of both `self.figure`\n        # and *fig* being none is taken care of above) we then user is\n        # trying to change the figure an artist is associated with which\n        # is not allowed for the same reason as adding the same instance\n        # to more than one Axes\n        if self.figure is not None:\n            raise RuntimeError(\"Can not put single artist in \"\n                               \"more than one figure\")\n        self.figure = fig\n        if self.figure and self.figure is not self:\n            self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_gid",
      "name": "set_gid",
      "qname": "lib.matplotlib.artist.Artist.set_gid",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_gid/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_gid.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_gid/gid",
          "name": "gid",
          "qname": "lib.matplotlib.artist.Artist.set_gid.gid",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the (group) id for the artist.",
      "docstring": "Set the (group) id for the artist.\n\nParameters\n----------\ngid : str",
      "code": "    def set_gid(self, gid):\n        \"\"\"\n        Set the (group) id for the artist.\n\n        Parameters\n        ----------\n        gid : str\n        \"\"\"\n        self._gid = gid"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_in_layout",
      "name": "set_in_layout",
      "qname": "lib.matplotlib.artist.Artist.set_in_layout",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_in_layout/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_in_layout.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_in_layout/in_layout",
          "name": "in_layout",
          "qname": "lib.matplotlib.artist.Artist.set_in_layout.in_layout",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set if artist is to be included in layout calculations,\nE.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n`.Figure.tight_layout()`, and\n``fig.savefig(fname, bbox_inches='tight')``.",
      "docstring": "Set if artist is to be included in layout calculations,\nE.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n`.Figure.tight_layout()`, and\n``fig.savefig(fname, bbox_inches='tight')``.\n\nParameters\n----------\nin_layout : bool",
      "code": "    def set_in_layout(self, in_layout):\n        \"\"\"\n        Set if artist is to be included in layout calculations,\n        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n        `.Figure.tight_layout()`, and\n        ``fig.savefig(fname, bbox_inches='tight')``.\n\n        Parameters\n        ----------\n        in_layout : bool\n        \"\"\"\n        self._in_layout = in_layout"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_label",
      "name": "set_label",
      "qname": "lib.matplotlib.artist.Artist.set_label",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_label/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_label.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_label/s",
          "name": "s",
          "qname": "lib.matplotlib.artist.Artist.set_label.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "object",
            "default_value": "",
            "description": "*s* will be converted to a string by calling `str`."
          },
          "type": {
            "kind": "NamedType",
            "name": "object"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set a label that will be displayed in the legend.",
      "docstring": "Set a label that will be displayed in the legend.\n\nParameters\n----------\ns : object\n    *s* will be converted to a string by calling `str`.",
      "code": "    def set_label(self, s):\n        \"\"\"\n        Set a label that will be displayed in the legend.\n\n        Parameters\n        ----------\n        s : object\n            *s* will be converted to a string by calling `str`.\n        \"\"\"\n        if s is not None:\n            self._label = str(s)\n        else:\n            self._label = None\n        self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_mouseover",
      "name": "set_mouseover",
      "qname": "lib.matplotlib.artist.Artist.set_mouseover",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_mouseover/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_mouseover.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_mouseover/mouseover",
          "name": "mouseover",
          "qname": "lib.matplotlib.artist.Artist.set_mouseover.mouseover",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set whether this artist is queried for custom context information when\nthe mouse cursor moves over it.",
      "docstring": "Set whether this artist is queried for custom context information when\nthe mouse cursor moves over it.\n\nParameters\n----------\nmouseover : bool\n\nSee Also\n--------\nget_cursor_data\n.ToolCursorPosition\n.NavigationToolbar2",
      "code": "    def set_mouseover(self, mouseover):\n        \"\"\"\n        Set whether this artist is queried for custom context information when\n        the mouse cursor moves over it.\n\n        Parameters\n        ----------\n        mouseover : bool\n\n        See Also\n        --------\n        get_cursor_data\n        .ToolCursorPosition\n        .NavigationToolbar2\n        \"\"\"\n        self._mouseover = bool(mouseover)\n        ax = self.axes\n        if ax:\n            if self._mouseover:\n                ax._mouseover_set.add(self)\n            else:\n                ax._mouseover_set.discard(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_path_effects",
      "name": "set_path_effects",
      "qname": "lib.matplotlib.artist.Artist.set_path_effects",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_path_effects/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_path_effects.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_path_effects/path_effects",
          "name": "path_effects",
          "qname": "lib.matplotlib.artist.Artist.set_path_effects.path_effects",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.AbstractPathEffect`",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`.AbstractPathEffect`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the path effects.",
      "docstring": "Set the path effects.\n\nParameters\n----------\npath_effects : `.AbstractPathEffect`",
      "code": "    def set_path_effects(self, path_effects):\n        \"\"\"\n        Set the path effects.\n\n        Parameters\n        ----------\n        path_effects : `.AbstractPathEffect`\n        \"\"\"\n        self._path_effects = path_effects\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_picker",
      "name": "set_picker",
      "qname": "lib.matplotlib.artist.Artist.set_picker",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_picker/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_picker.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_picker/picker",
          "name": "picker",
          "qname": "lib.matplotlib.artist.Artist.set_picker.picker",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or bool or float or callable",
            "default_value": "",
            "description": "This can be one of the following:\n\n- *None*: Picking is disabled for this artist (default).\n\n- A boolean: If *True* then picking will be enabled and the\n  artist will fire a pick event if the mouse event is over\n  the artist.\n\n- A float: If picker is a number it is interpreted as an\n  epsilon tolerance in points and the artist will fire\n  off an event if its data is within epsilon of the mouse\n  event.  For some artists like lines and patch collections,\n  the artist may provide additional data to the pick event\n  that is generated, e.g., the indices of the data within\n  epsilon of the pick event\n\n- A function: If picker is callable, it is a user supplied\n  function which determines whether the artist is hit by the\n  mouse event::\n\n    hit, props = picker(artist, mouseevent)\n\n  to determine the hit test.  if the mouse event is over the\n  artist, return *hit=True* and props is a dictionary of\n  properties you want added to the PickEvent attributes."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "bool"
              },
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "callable"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Define the picking behavior of the artist.",
      "docstring": "Define the picking behavior of the artist.\n\nParameters\n----------\npicker : None or bool or float or callable\n    This can be one of the following:\n\n    - *None*: Picking is disabled for this artist (default).\n\n    - A boolean: If *True* then picking will be enabled and the\n      artist will fire a pick event if the mouse event is over\n      the artist.\n\n    - A float: If picker is a number it is interpreted as an\n      epsilon tolerance in points and the artist will fire\n      off an event if its data is within epsilon of the mouse\n      event.  For some artists like lines and patch collections,\n      the artist may provide additional data to the pick event\n      that is generated, e.g., the indices of the data within\n      epsilon of the pick event\n\n    - A function: If picker is callable, it is a user supplied\n      function which determines whether the artist is hit by the\n      mouse event::\n\n        hit, props = picker(artist, mouseevent)\n\n      to determine the hit test.  if the mouse event is over the\n      artist, return *hit=True* and props is a dictionary of\n      properties you want added to the PickEvent attributes.",
      "code": "    def set_picker(self, picker):\n        \"\"\"\n        Define the picking behavior of the artist.\n\n        Parameters\n        ----------\n        picker : None or bool or float or callable\n            This can be one of the following:\n\n            - *None*: Picking is disabled for this artist (default).\n\n            - A boolean: If *True* then picking will be enabled and the\n              artist will fire a pick event if the mouse event is over\n              the artist.\n\n            - A float: If picker is a number it is interpreted as an\n              epsilon tolerance in points and the artist will fire\n              off an event if its data is within epsilon of the mouse\n              event.  For some artists like lines and patch collections,\n              the artist may provide additional data to the pick event\n              that is generated, e.g., the indices of the data within\n              epsilon of the pick event\n\n            - A function: If picker is callable, it is a user supplied\n              function which determines whether the artist is hit by the\n              mouse event::\n\n                hit, props = picker(artist, mouseevent)\n\n              to determine the hit test.  if the mouse event is over the\n              artist, return *hit=True* and props is a dictionary of\n              properties you want added to the PickEvent attributes.\n        \"\"\"\n        self._picker = picker"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_rasterized",
      "name": "set_rasterized",
      "qname": "lib.matplotlib.artist.Artist.set_rasterized",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_rasterized/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_rasterized.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_rasterized/rasterized",
          "name": "rasterized",
          "qname": "lib.matplotlib.artist.Artist.set_rasterized.rasterized",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Force rasterized (bitmap) drawing for vector graphics output.\n\nRasterized drawing is not supported by all artists. If you try to\nenable this on an artist that does not support it, the command has no\neffect and a warning will be issued.\n\nThis setting is ignored for pixel-based output.\n\nSee also :doc:`/gallery/misc/rasterization_demo`.",
      "docstring": "Force rasterized (bitmap) drawing for vector graphics output.\n\nRasterized drawing is not supported by all artists. If you try to\nenable this on an artist that does not support it, the command has no\neffect and a warning will be issued.\n\nThis setting is ignored for pixel-based output.\n\nSee also :doc:`/gallery/misc/rasterization_demo`.\n\nParameters\n----------\nrasterized : bool",
      "code": "    def set_rasterized(self, rasterized):\n        \"\"\"\n        Force rasterized (bitmap) drawing for vector graphics output.\n\n        Rasterized drawing is not supported by all artists. If you try to\n        enable this on an artist that does not support it, the command has no\n        effect and a warning will be issued.\n\n        This setting is ignored for pixel-based output.\n\n        See also :doc:`/gallery/misc/rasterization_demo`.\n\n        Parameters\n        ----------\n        rasterized : bool\n        \"\"\"\n        if rasterized and not hasattr(self.draw, \"_supports_rasterization\"):\n            _api.warn_external(f\"Rasterization of '{self}' will be ignored\")\n\n        self._rasterized = rasterized"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_sketch_params",
      "name": "set_sketch_params",
      "qname": "lib.matplotlib.artist.Artist.set_sketch_params",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_sketch_params/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_sketch_params.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_sketch_params/scale",
          "name": "scale",
          "qname": "lib.matplotlib.artist.Artist.set_sketch_params.scale",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The amplitude of the wiggle perpendicular to the source\nline, in pixels.  If scale is `None`, or not provided, no\nsketch filter will be provided."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_sketch_params/length",
          "name": "length",
          "qname": "lib.matplotlib.artist.Artist.set_sketch_params.length",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The length of the wiggle along the line, in pixels\n(default 128.0)"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_sketch_params/randomness",
          "name": "randomness",
          "qname": "lib.matplotlib.artist.Artist.set_sketch_params.randomness",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The scale factor by which the length is shrunken or\nexpanded (default 16.0)\n\nThe PGF backend uses this argument as an RNG seed and not as\ndescribed above. Using the same seed yields the same random shape.\n\n.. ACCEPTS: (scale: float, length: float, randomness: float)"
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the sketch parameters.",
      "docstring": "Set the sketch parameters.\n\nParameters\n----------\nscale : float, optional\n    The amplitude of the wiggle perpendicular to the source\n    line, in pixels.  If scale is `None`, or not provided, no\n    sketch filter will be provided.\nlength : float, optional\n     The length of the wiggle along the line, in pixels\n     (default 128.0)\nrandomness : float, optional\n    The scale factor by which the length is shrunken or\n    expanded (default 16.0)\n\n    The PGF backend uses this argument as an RNG seed and not as\n    described above. Using the same seed yields the same random shape.\n\n    .. ACCEPTS: (scale: float, length: float, randomness: float)",
      "code": "    def set_sketch_params(self, scale=None, length=None, randomness=None):\n        \"\"\"\n        Set the sketch parameters.\n\n        Parameters\n        ----------\n        scale : float, optional\n            The amplitude of the wiggle perpendicular to the source\n            line, in pixels.  If scale is `None`, or not provided, no\n            sketch filter will be provided.\n        length : float, optional\n             The length of the wiggle along the line, in pixels\n             (default 128.0)\n        randomness : float, optional\n            The scale factor by which the length is shrunken or\n            expanded (default 16.0)\n\n            The PGF backend uses this argument as an RNG seed and not as\n            described above. Using the same seed yields the same random shape.\n\n            .. ACCEPTS: (scale: float, length: float, randomness: float)\n        \"\"\"\n        if scale is None:\n            self._sketch = None\n        else:\n            self._sketch = (scale, length or 128.0, randomness or 16.0)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_snap",
      "name": "set_snap",
      "qname": "lib.matplotlib.artist.Artist.set_snap",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_snap/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_snap.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_snap/snap",
          "name": "snap",
          "qname": "lib.matplotlib.artist.Artist.set_snap.snap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool or None",
            "default_value": "",
            "description": "Possible values:\n\n- *True*: Snap vertices to the nearest pixel center.\n- *False*: Do not modify vertex positions.\n- *None*: (auto) If the path contains only rectilinear line\n  segments, round to the nearest pixel center."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "bool"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the snapping behavior.\n\nSnapping aligns positions with the pixel grid, which results in\nclearer images. For example, if a black line of 1px width was\ndefined at a position in between two pixels, the resulting image\nwould contain the interpolated value of that line in the pixel grid,\nwhich would be a grey value on both adjacent pixel positions. In\ncontrast, snapping will move the line to the nearest integer pixel\nvalue, so that the resulting image will really contain a 1px wide\nblack line.\n\nSnapping is currently only supported by the Agg and MacOSX backends.",
      "docstring": "Set the snapping behavior.\n\nSnapping aligns positions with the pixel grid, which results in\nclearer images. For example, if a black line of 1px width was\ndefined at a position in between two pixels, the resulting image\nwould contain the interpolated value of that line in the pixel grid,\nwhich would be a grey value on both adjacent pixel positions. In\ncontrast, snapping will move the line to the nearest integer pixel\nvalue, so that the resulting image will really contain a 1px wide\nblack line.\n\nSnapping is currently only supported by the Agg and MacOSX backends.\n\nParameters\n----------\nsnap : bool or None\n    Possible values:\n\n    - *True*: Snap vertices to the nearest pixel center.\n    - *False*: Do not modify vertex positions.\n    - *None*: (auto) If the path contains only rectilinear line\n      segments, round to the nearest pixel center.",
      "code": "    def set_snap(self, snap):\n        \"\"\"\n        Set the snapping behavior.\n\n        Snapping aligns positions with the pixel grid, which results in\n        clearer images. For example, if a black line of 1px width was\n        defined at a position in between two pixels, the resulting image\n        would contain the interpolated value of that line in the pixel grid,\n        which would be a grey value on both adjacent pixel positions. In\n        contrast, snapping will move the line to the nearest integer pixel\n        value, so that the resulting image will really contain a 1px wide\n        black line.\n\n        Snapping is currently only supported by the Agg and MacOSX backends.\n\n        Parameters\n        ----------\n        snap : bool or None\n            Possible values:\n\n            - *True*: Snap vertices to the nearest pixel center.\n            - *False*: Do not modify vertex positions.\n            - *None*: (auto) If the path contains only rectilinear line\n              segments, round to the nearest pixel center.\n        \"\"\"\n        self._snap = snap\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_transform",
      "name": "set_transform",
      "qname": "lib.matplotlib.artist.Artist.set_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_transform/t",
          "name": "t",
          "qname": "lib.matplotlib.artist.Artist.set_transform.t",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Transform`",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`.Transform`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the artist transform.",
      "docstring": "Set the artist transform.\n\nParameters\n----------\nt : `.Transform`",
      "code": "    def set_transform(self, t):\n        \"\"\"\n        Set the artist transform.\n\n        Parameters\n        ----------\n        t : `.Transform`\n        \"\"\"\n        self._transform = t\n        self._transformSet = True\n        self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_url",
      "name": "set_url",
      "qname": "lib.matplotlib.artist.Artist.set_url",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_url/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_url.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_url/url",
          "name": "url",
          "qname": "lib.matplotlib.artist.Artist.set_url.url",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the url for the artist.",
      "docstring": "Set the url for the artist.\n\nParameters\n----------\nurl : str",
      "code": "    def set_url(self, url):\n        \"\"\"\n        Set the url for the artist.\n\n        Parameters\n        ----------\n        url : str\n        \"\"\"\n        self._url = url"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_visible",
      "name": "set_visible",
      "qname": "lib.matplotlib.artist.Artist.set_visible",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_visible/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_visible.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_visible/b",
          "name": "b",
          "qname": "lib.matplotlib.artist.Artist.set_visible.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the artist's visibility.",
      "docstring": "Set the artist's visibility.\n\nParameters\n----------\nb : bool",
      "code": "    def set_visible(self, b):\n        \"\"\"\n        Set the artist's visibility.\n\n        Parameters\n        ----------\n        b : bool\n        \"\"\"\n        self._visible = b\n        self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/set_zorder",
      "name": "set_zorder",
      "qname": "lib.matplotlib.artist.Artist.set_zorder",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_zorder/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.set_zorder.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/set_zorder/level",
          "name": "level",
          "qname": "lib.matplotlib.artist.Artist.set_zorder.level",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the zorder for the artist.  Artists with lower zorder\nvalues are drawn first.",
      "docstring": "Set the zorder for the artist.  Artists with lower zorder\nvalues are drawn first.\n\nParameters\n----------\nlevel : float",
      "code": "    def set_zorder(self, level):\n        \"\"\"\n        Set the zorder for the artist.  Artists with lower zorder\n        values are drawn first.\n\n        Parameters\n        ----------\n        level : float\n        \"\"\"\n        if level is None:\n            level = self.__class__.zorder\n        self.zorder = level\n        self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/stale@getter",
      "name": "stale",
      "qname": "lib.matplotlib.artist.Artist.stale",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/stale@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.stale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Whether the artist is 'stale' and needs to be re-drawn for the output\nto match the internal state of the artist.",
      "docstring": "Whether the artist is 'stale' and needs to be re-drawn for the output\nto match the internal state of the artist.",
      "code": "    @property\n    def stale(self):\n        \"\"\"\n        Whether the artist is 'stale' and needs to be re-drawn for the output\n        to match the internal state of the artist.\n        \"\"\"\n        return self._stale"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/stale@setter",
      "name": "stale",
      "qname": "lib.matplotlib.artist.Artist.stale",
      "decorators": [
        "stale.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/stale@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.stale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/stale@setter/val",
          "name": "val",
          "qname": "lib.matplotlib.artist.Artist.stale.val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @stale.setter\n    def stale(self, val):\n        self._stale = val\n\n        # if the artist is animated it does not take normal part in the\n        # draw stack and is not expected to be drawn as part of the normal\n        # draw loop (when not saving) so do not propagate this change\n        if self.get_animated():\n            return\n\n        if val and self.stale_callback is not None:\n            self.stale_callback(self, val)"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/sticky_edges@getter",
      "name": "sticky_edges",
      "qname": "lib.matplotlib.artist.Artist.sticky_edges",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/sticky_edges@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.sticky_edges.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "``x`` and ``y`` sticky edge lists for autoscaling.\n\nWhen performing autoscaling, if a data limit coincides with a value in\nthe corresponding sticky_edges list, then no margin will be added--the\nview limit \"sticks\" to the edge. A typical use case is histograms,\nwhere one usually expects no margin on the bottom edge (0) of the\nhistogram.\n\nMoreover, margin expansion \"bumps\" against sticky edges and cannot\ncross them.  For example, if the upper data limit is 1.0, the upper\nview limit computed by simple margin application is 1.2, but there is a\nsticky edge at 1.1, then the actual upper view limit will be 1.1.\n\nThis attribute cannot be assigned to; however, the ``x`` and ``y``\nlists can be modified in place as needed.",
      "docstring": "``x`` and ``y`` sticky edge lists for autoscaling.\n\nWhen performing autoscaling, if a data limit coincides with a value in\nthe corresponding sticky_edges list, then no margin will be added--the\nview limit \"sticks\" to the edge. A typical use case is histograms,\nwhere one usually expects no margin on the bottom edge (0) of the\nhistogram.\n\nMoreover, margin expansion \"bumps\" against sticky edges and cannot\ncross them.  For example, if the upper data limit is 1.0, the upper\nview limit computed by simple margin application is 1.2, but there is a\nsticky edge at 1.1, then the actual upper view limit will be 1.1.\n\nThis attribute cannot be assigned to; however, the ``x`` and ``y``\nlists can be modified in place as needed.\n\nExamples\n--------\n>>> artist.sticky_edges.x[:] = (xmin, xmax)\n>>> artist.sticky_edges.y[:] = (ymin, ymax)",
      "code": "    @property\n    def sticky_edges(self):\n        \"\"\"\n        ``x`` and ``y`` sticky edge lists for autoscaling.\n\n        When performing autoscaling, if a data limit coincides with a value in\n        the corresponding sticky_edges list, then no margin will be added--the\n        view limit \"sticks\" to the edge. A typical use case is histograms,\n        where one usually expects no margin on the bottom edge (0) of the\n        histogram.\n\n        Moreover, margin expansion \"bumps\" against sticky edges and cannot\n        cross them.  For example, if the upper data limit is 1.0, the upper\n        view limit computed by simple margin application is 1.2, but there is a\n        sticky edge at 1.1, then the actual upper view limit will be 1.1.\n\n        This attribute cannot be assigned to; however, the ``x`` and ``y``\n        lists can be modified in place as needed.\n\n        Examples\n        --------\n        >>> artist.sticky_edges.x[:] = (xmin, xmax)\n        >>> artist.sticky_edges.y[:] = (ymin, ymax)\n\n        \"\"\"\n        return self._sticky_edges"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/update",
      "name": "update",
      "qname": "lib.matplotlib.artist.Artist.update",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/update/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.update.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/update/props",
          "name": "props",
          "qname": "lib.matplotlib.artist.Artist.update.props",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Update this artist's properties from the dict *props*.",
      "docstring": "Update this artist's properties from the dict *props*.\n\nParameters\n----------\nprops : dict",
      "code": "    def update(self, props):\n        \"\"\"\n        Update this artist's properties from the dict *props*.\n\n        Parameters\n        ----------\n        props : dict\n        \"\"\"\n        return self._update_props(\n            props, \"{cls.__name__!r} object has no property {prop_name!r}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/Artist/update_from",
      "name": "update_from",
      "qname": "lib.matplotlib.artist.Artist.update_from",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/update_from/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.Artist.update_from.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/Artist/update_from/other",
          "name": "other",
          "qname": "lib.matplotlib.artist.Artist.update_from.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy properties from *other* to *self*.",
      "docstring": "Copy properties from *other* to *self*.",
      "code": "    def update_from(self, other):\n        \"\"\"Copy properties from *other* to *self*.\"\"\"\n        self._transform = other._transform\n        self._transformSet = other._transformSet\n        self._visible = other._visible\n        self._alpha = other._alpha\n        self.clipbox = other.clipbox\n        self._clipon = other._clipon\n        self._clippath = other._clippath\n        self._label = other._label\n        self._sketch = other._sketch\n        self._path_effects = other._path_effects\n        self.sticky_edges.x[:] = other.sticky_edges.x.copy()\n        self.sticky_edges.y[:] = other.sticky_edges.y.copy()\n        self.pchanged()\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.artist.ArtistInspector.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/__init__/o",
          "name": "o",
          "qname": "lib.matplotlib.artist.ArtistInspector.__init__.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper class to inspect an `~matplotlib.artist.Artist` and return\ninformation about its settable properties and their current values.",
      "docstring": "Initialize the artist inspector with an `Artist` or an iterable of\n`Artist`\\s.  If an iterable is used, we assume it is a homogeneous\nsequence (all `Artist`\\s are of the same type) and it is your\nresponsibility to make sure this is so.",
      "code": "    def __init__(self, o):\n        r\"\"\"\n        Initialize the artist inspector with an `Artist` or an iterable of\n        `Artist`\\s.  If an iterable is used, we assume it is a homogeneous\n        sequence (all `Artist`\\s are of the same type) and it is your\n        responsibility to make sure this is so.\n        \"\"\"\n        if not isinstance(o, Artist):\n            if np.iterable(o):\n                o = list(o)\n                if len(o):\n                    o = o[0]\n\n        self.oorig = o\n        if not isinstance(o, type):\n            o = type(o)\n        self.o = o\n\n        self.aliasd = self.get_aliases()"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/aliased_name",
      "name": "aliased_name",
      "qname": "lib.matplotlib.artist.ArtistInspector.aliased_name",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/aliased_name/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.aliased_name.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/aliased_name/s",
          "name": "s",
          "qname": "lib.matplotlib.artist.ArtistInspector.aliased_name.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'.\n\ne.g., for the line markerfacecolor property, which has an\nalias, return 'markerfacecolor or mfc' and for the transform\nproperty, which does not, return 'transform'.",
      "docstring": "Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'.\n\ne.g., for the line markerfacecolor property, which has an\nalias, return 'markerfacecolor or mfc' and for the transform\nproperty, which does not, return 'transform'.",
      "code": "    def aliased_name(self, s):\n        \"\"\"\n        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'.\n\n        e.g., for the line markerfacecolor property, which has an\n        alias, return 'markerfacecolor or mfc' and for the transform\n        property, which does not, return 'transform'.\n        \"\"\"\n        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n        return s + aliases"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/aliased_name_rest",
      "name": "aliased_name_rest",
      "qname": "lib.matplotlib.artist.ArtistInspector.aliased_name_rest",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/aliased_name_rest/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.aliased_name_rest.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/aliased_name_rest/s",
          "name": "s",
          "qname": "lib.matplotlib.artist.ArtistInspector.aliased_name_rest.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/aliased_name_rest/target",
          "name": "target",
          "qname": "lib.matplotlib.artist.ArtistInspector.aliased_name_rest.target",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME',\nformatted for reST.\n\ne.g., for the line markerfacecolor property, which has an\nalias, return 'markerfacecolor or mfc' and for the transform\nproperty, which does not, return 'transform'.",
      "docstring": "Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME',\nformatted for reST.\n\ne.g., for the line markerfacecolor property, which has an\nalias, return 'markerfacecolor or mfc' and for the transform\nproperty, which does not, return 'transform'.",
      "code": "    def aliased_name_rest(self, s, target):\n        \"\"\"\n        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME',\n        formatted for reST.\n\n        e.g., for the line markerfacecolor property, which has an\n        alias, return 'markerfacecolor or mfc' and for the transform\n        property, which does not, return 'transform'.\n        \"\"\"\n        # workaround to prevent \"reference target not found\"\n        if target in self._NOT_LINKABLE:\n            return f'``{s}``'\n\n        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n        return ':meth:`%s <%s>`%s' % (s, target, aliases)"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/get_aliases",
      "name": "get_aliases",
      "qname": "lib.matplotlib.artist.ArtistInspector.get_aliases",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/get_aliases/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.get_aliases.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get a dict mapping property fullnames to sets of aliases for each alias\nin the :class:`~matplotlib.artist.ArtistInspector`.\n\ne.g., for lines::\n\n  {'markerfacecolor': {'mfc'},\n   'linewidth'      : {'lw'},\n  }",
      "docstring": "Get a dict mapping property fullnames to sets of aliases for each alias\nin the :class:`~matplotlib.artist.ArtistInspector`.\n\ne.g., for lines::\n\n  {'markerfacecolor': {'mfc'},\n   'linewidth'      : {'lw'},\n  }",
      "code": "    def get_aliases(self):\n        \"\"\"\n        Get a dict mapping property fullnames to sets of aliases for each alias\n        in the :class:`~matplotlib.artist.ArtistInspector`.\n\n        e.g., for lines::\n\n          {'markerfacecolor': {'mfc'},\n           'linewidth'      : {'lw'},\n          }\n        \"\"\"\n        names = [name for name in dir(self.o)\n                 if name.startswith(('set_', 'get_'))\n                    and callable(getattr(self.o, name))]\n        aliases = {}\n        for name in names:\n            func = getattr(self.o, name)\n            if not self.is_alias(func):\n                continue\n            propname = re.search(\"`({}.*)`\".format(name[:4]),  # get_.*/set_.*\n                                 inspect.getdoc(func)).group(1)\n            aliases.setdefault(propname[4:], set()).add(name[4:])\n        return aliases"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/get_setters",
      "name": "get_setters",
      "qname": "lib.matplotlib.artist.ArtistInspector.get_setters",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/get_setters/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.get_setters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the attribute strings with setters for object.\n\nFor example, for a line, return ``['markerfacecolor', 'linewidth',\n....]``.",
      "docstring": "Get the attribute strings with setters for object.\n\nFor example, for a line, return ``['markerfacecolor', 'linewidth',\n....]``.",
      "code": "    def get_setters(self):\n        \"\"\"\n        Get the attribute strings with setters for object.\n\n        For example, for a line, return ``['markerfacecolor', 'linewidth',\n        ....]``.\n        \"\"\"\n        setters = []\n        for name in dir(self.o):\n            if not name.startswith('set_'):\n                continue\n            func = getattr(self.o, name)\n            if (not callable(func)\n                    or self.number_of_parameters(func) < 2\n                    or self.is_alias(func)):\n                continue\n            setters.append(name[4:])\n        return setters"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/get_valid_values",
      "name": "get_valid_values",
      "qname": "lib.matplotlib.artist.ArtistInspector.get_valid_values",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/get_valid_values/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.get_valid_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/get_valid_values/attr",
          "name": "attr",
          "qname": "lib.matplotlib.artist.ArtistInspector.get_valid_values.attr",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the legal arguments for the setter associated with *attr*.\n\nThis is done by querying the docstring of the setter for a line that\nbegins with \"ACCEPTS:\" or \".. ACCEPTS:\", and then by looking for a\nnumpydoc-style documentation for the setter's first argument.",
      "docstring": "Get the legal arguments for the setter associated with *attr*.\n\nThis is done by querying the docstring of the setter for a line that\nbegins with \"ACCEPTS:\" or \".. ACCEPTS:\", and then by looking for a\nnumpydoc-style documentation for the setter's first argument.",
      "code": "    def get_valid_values(self, attr):\n        \"\"\"\n        Get the legal arguments for the setter associated with *attr*.\n\n        This is done by querying the docstring of the setter for a line that\n        begins with \"ACCEPTS:\" or \".. ACCEPTS:\", and then by looking for a\n        numpydoc-style documentation for the setter's first argument.\n        \"\"\"\n\n        name = 'set_%s' % attr\n        if not hasattr(self.o, name):\n            raise AttributeError('%s has no function %s' % (self.o, name))\n        func = getattr(self.o, name)\n\n        docstring = inspect.getdoc(func)\n        if docstring is None:\n            return 'unknown'\n\n        if docstring.startswith('Alias for '):\n            return None\n\n        match = self._get_valid_values_regex.search(docstring)\n        if match is not None:\n            return re.sub(\"\\n *\", \" \", match.group(1))\n\n        # Much faster than list(inspect.signature(func).parameters)[1],\n        # although barely relevant wrt. matplotlib's total import time.\n        param_name = func.__code__.co_varnames[1]\n        # We could set the presence * based on whether the parameter is a\n        # varargs (it can't be a varkwargs) but it's not really worth the it.\n        match = re.search(r\"(?m)^ *\\*?{} : (.+)\".format(param_name), docstring)\n        if match:\n            return match.group(1)\n\n        return 'unknown'"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/is_alias",
      "name": "is_alias",
      "qname": "lib.matplotlib.artist.ArtistInspector.is_alias",
      "decorators": [
        "staticmethod",
        "lru_cache(maxsize=None)"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/is_alias/method",
          "name": "method",
          "qname": "lib.matplotlib.artist.ArtistInspector.is_alias.method",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the object *method* is an alias for another method.",
      "docstring": "Return whether the object *method* is an alias for another method.",
      "code": "    @staticmethod\n    @lru_cache(maxsize=None)\n    def is_alias(method):\n        \"\"\"\n        Return whether the object *method* is an alias for another method.\n        \"\"\"\n\n        ds = inspect.getdoc(method)\n        if ds is None:\n            return False\n\n        return ds.startswith('Alias for ')"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/number_of_parameters",
      "name": "number_of_parameters",
      "qname": "lib.matplotlib.artist.ArtistInspector.number_of_parameters",
      "decorators": [
        "staticmethod",
        "lru_cache(maxsize=None)"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/number_of_parameters/func",
          "name": "func",
          "qname": "lib.matplotlib.artist.ArtistInspector.number_of_parameters.func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return number of parameters of the callable *func*.",
      "docstring": "Return number of parameters of the callable *func*.",
      "code": "    @staticmethod\n    @lru_cache(maxsize=None)\n    def number_of_parameters(func):\n        \"\"\"Return number of parameters of the callable *func*.\"\"\"\n        return len(inspect.signature(func).parameters)"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_getters",
      "name": "pprint_getters",
      "qname": "lib.matplotlib.artist.ArtistInspector.pprint_getters",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_getters/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.pprint_getters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the getters and actual values as list of strings.",
      "docstring": "Return the getters and actual values as list of strings.",
      "code": "    def pprint_getters(self):\n        \"\"\"Return the getters and actual values as list of strings.\"\"\"\n        lines = []\n        for name, val in sorted(self.properties().items()):\n            if getattr(val, 'shape', ()) != () and len(val) > 6:\n                s = str(val[:6]) + '...'\n            else:\n                s = str(val)\n            s = s.replace('\\n', ' ')\n            if len(s) > 50:\n                s = s[:50] + '...'\n            name = self.aliased_name(name)\n            lines.append('    %s = %s' % (name, s))\n        return lines"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters",
      "name": "pprint_setters",
      "qname": "lib.matplotlib.artist.ArtistInspector.pprint_setters",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.pprint_setters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters/prop",
          "name": "prop",
          "qname": "lib.matplotlib.artist.ArtistInspector.pprint_setters.prop",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters/leadingspace",
          "name": "leadingspace",
          "qname": "lib.matplotlib.artist.ArtistInspector.pprint_setters.leadingspace",
          "default_value": "2",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "If *prop* is *None*, return a list of strings of all settable\nproperties and their valid values.\n\nIf *prop* is not *None*, it is a valid property name and that\nproperty will be returned as a string of property : valid\nvalues.",
      "docstring": "If *prop* is *None*, return a list of strings of all settable\nproperties and their valid values.\n\nIf *prop* is not *None*, it is a valid property name and that\nproperty will be returned as a string of property : valid\nvalues.",
      "code": "    def pprint_setters(self, prop=None, leadingspace=2):\n        \"\"\"\n        If *prop* is *None*, return a list of strings of all settable\n        properties and their valid values.\n\n        If *prop* is not *None*, it is a valid property name and that\n        property will be returned as a string of property : valid\n        values.\n        \"\"\"\n        if leadingspace:\n            pad = ' ' * leadingspace\n        else:\n            pad = ''\n        if prop is not None:\n            accepts = self.get_valid_values(prop)\n            return '%s%s: %s' % (pad, prop, accepts)\n\n        lines = []\n        for prop in sorted(self.get_setters()):\n            accepts = self.get_valid_values(prop)\n            name = self.aliased_name(prop)\n            lines.append('%s%s: %s' % (pad, name, accepts))\n        return lines"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters_rest",
      "name": "pprint_setters_rest",
      "qname": "lib.matplotlib.artist.ArtistInspector.pprint_setters_rest",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters_rest/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.pprint_setters_rest.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters_rest/prop",
          "name": "prop",
          "qname": "lib.matplotlib.artist.ArtistInspector.pprint_setters_rest.prop",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/pprint_setters_rest/leadingspace",
          "name": "leadingspace",
          "qname": "lib.matplotlib.artist.ArtistInspector.pprint_setters_rest.leadingspace",
          "default_value": "4",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "If *prop* is *None*, return a list of reST-formatted strings of all\nsettable properties and their valid values.\n\nIf *prop* is not *None*, it is a valid property name and that\nproperty will be returned as a string of \"property : valid\"\nvalues.",
      "docstring": "If *prop* is *None*, return a list of reST-formatted strings of all\nsettable properties and their valid values.\n\nIf *prop* is not *None*, it is a valid property name and that\nproperty will be returned as a string of \"property : valid\"\nvalues.",
      "code": "    def pprint_setters_rest(self, prop=None, leadingspace=4):\n        \"\"\"\n        If *prop* is *None*, return a list of reST-formatted strings of all\n        settable properties and their valid values.\n\n        If *prop* is not *None*, it is a valid property name and that\n        property will be returned as a string of \"property : valid\"\n        values.\n        \"\"\"\n        if leadingspace:\n            pad = ' ' * leadingspace\n        else:\n            pad = ''\n        if prop is not None:\n            accepts = self.get_valid_values(prop)\n            return '%s%s: %s' % (pad, prop, accepts)\n\n        prop_and_qualnames = []\n        for prop in sorted(self.get_setters()):\n            # Find the parent method which actually provides the docstring.\n            for cls in self.o.__mro__:\n                method = getattr(cls, f\"set_{prop}\", None)\n                if method and method.__doc__ is not None:\n                    break\n            else:  # No docstring available.\n                method = getattr(self.o, f\"set_{prop}\")\n            prop_and_qualnames.append(\n                (prop, f\"{method.__module__}.{method.__qualname__}\"))\n\n        names = [self.aliased_name_rest(prop, target)\n                 .replace('_base._AxesBase', 'Axes')\n                 .replace('_axes.Axes', 'Axes')\n                 for prop, target in prop_and_qualnames]\n        accepts = [self.get_valid_values(prop)\n                   for prop, _ in prop_and_qualnames]\n\n        col0_len = max(len(n) for n in names)\n        col1_len = max(len(a) for a in accepts)\n        table_formatstr = pad + '   ' + '=' * col0_len + '   ' + '=' * col1_len\n\n        return [\n            '',\n            pad + '.. table::',\n            pad + '   :class: property-table',\n            '',\n            table_formatstr,\n            pad + '   ' + 'Property'.ljust(col0_len)\n            + '   ' + 'Description'.ljust(col1_len),\n            table_formatstr,\n            *[pad + '   ' + n.ljust(col0_len) + '   ' + a.ljust(col1_len)\n              for n, a in zip(names, accepts)],\n            table_formatstr,\n            '',\n        ]"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/properties",
      "name": "properties",
      "qname": "lib.matplotlib.artist.ArtistInspector.properties",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/ArtistInspector/properties/self",
          "name": "self",
          "qname": "lib.matplotlib.artist.ArtistInspector.properties.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a dictionary mapping property name -> value.",
      "docstring": "Return a dictionary mapping property name -> value.",
      "code": "    def properties(self):\n        \"\"\"Return a dictionary mapping property name -> value.\"\"\"\n        o = self.oorig\n        getters = [name for name in dir(o)\n                   if name.startswith('get_') and callable(getattr(o, name))]\n        getters.sort()\n        d = {}\n        for name in getters:\n            func = getattr(o, name)\n            if self.is_alias(func):\n                continue\n            try:\n                with warnings.catch_warnings():\n                    warnings.simplefilter('ignore')\n                    val = func()\n            except Exception:\n                continue\n            else:\n                d[name[4:]] = val\n        return d"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/allow_rasterization",
      "name": "allow_rasterization",
      "qname": "lib.matplotlib.artist.allow_rasterization",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/allow_rasterization/draw",
          "name": "draw",
          "qname": "lib.matplotlib.artist.allow_rasterization.draw",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Decorator for Artist.draw method. Provides routines\nthat run before and after the draw call. The before and after functions\nare useful for changing artist-dependent renderer attributes or making\nother setup function calls, such as starting and flushing a mixed-mode\nrenderer.",
      "docstring": "Decorator for Artist.draw method. Provides routines\nthat run before and after the draw call. The before and after functions\nare useful for changing artist-dependent renderer attributes or making\nother setup function calls, such as starting and flushing a mixed-mode\nrenderer.",
      "code": "def allow_rasterization(draw):\n    \"\"\"\n    Decorator for Artist.draw method. Provides routines\n    that run before and after the draw call. The before and after functions\n    are useful for changing artist-dependent renderer attributes or making\n    other setup function calls, such as starting and flushing a mixed-mode\n    renderer.\n    \"\"\"\n\n    @wraps(draw)\n    def draw_wrapper(artist, renderer):\n        try:\n            if artist.get_rasterized():\n                if renderer._raster_depth == 0 and not renderer._rasterizing:\n                    renderer.start_rasterizing()\n                    renderer._rasterizing = True\n                renderer._raster_depth += 1\n            else:\n                if renderer._raster_depth == 0 and renderer._rasterizing:\n                    # Only stop when we are not in a rasterized parent\n                    # and something has be rasterized since last stop\n                    renderer.stop_rasterizing()\n                    renderer._rasterizing = False\n\n            if artist.get_agg_filter() is not None:\n                renderer.start_filter()\n\n            return draw(artist, renderer)\n        finally:\n            if artist.get_agg_filter() is not None:\n                renderer.stop_filter(artist.get_agg_filter())\n            if artist.get_rasterized():\n                renderer._raster_depth -= 1\n            if (renderer._rasterizing and artist.figure and\n                    artist.figure.suppressComposite):\n                # restart rasterizing to prevent merging\n                renderer.stop_rasterizing()\n                renderer.start_rasterizing()\n\n    draw_wrapper._supports_rasterization = True\n    return draw_wrapper"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/getp",
      "name": "getp",
      "qname": "lib.matplotlib.artist.getp",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/getp/obj",
          "name": "obj",
          "qname": "lib.matplotlib.artist.getp.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Artist`",
            "default_value": "",
            "description": "The queried artist; e.g., a `.Line2D`, a `.Text`, or an `~.axes.Axes`."
          },
          "type": {
            "kind": "NamedType",
            "name": "`.Artist`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/getp/property",
          "name": "property",
          "qname": "lib.matplotlib.artist.getp.property",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or None",
            "default_value": "None",
            "description": "If *property* is 'somename', this function returns\n``obj.get_somename()``.\n\nIf it's None (or unset), it *prints* all gettable properties from\n*obj*.  Many properties have aliases for shorter typing, e.g. 'lw' is\nan alias for 'linewidth'.  In the output, aliases and full property\nnames will be listed as:\n\n  property or alias = value\n\ne.g.:\n\n  linewidth or lw = 2"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the value of an `.Artist`'s *property*, or print all of them.",
      "docstring": "Return the value of an `.Artist`'s *property*, or print all of them.\n\nParameters\n----------\nobj : `.Artist`\n    The queried artist; e.g., a `.Line2D`, a `.Text`, or an `~.axes.Axes`.\n\nproperty : str or None, default: None\n    If *property* is 'somename', this function returns\n    ``obj.get_somename()``.\n\n    If it's None (or unset), it *prints* all gettable properties from\n    *obj*.  Many properties have aliases for shorter typing, e.g. 'lw' is\n    an alias for 'linewidth'.  In the output, aliases and full property\n    names will be listed as:\n\n      property or alias = value\n\n    e.g.:\n\n      linewidth or lw = 2\n\nSee Also\n--------\nsetp",
      "code": "def getp(obj, property=None):\n    \"\"\"\n    Return the value of an `.Artist`'s *property*, or print all of them.\n\n    Parameters\n    ----------\n    obj : `.Artist`\n        The queried artist; e.g., a `.Line2D`, a `.Text`, or an `~.axes.Axes`.\n\n    property : str or None, default: None\n        If *property* is 'somename', this function returns\n        ``obj.get_somename()``.\n\n        If it's None (or unset), it *prints* all gettable properties from\n        *obj*.  Many properties have aliases for shorter typing, e.g. 'lw' is\n        an alias for 'linewidth'.  In the output, aliases and full property\n        names will be listed as:\n\n          property or alias = value\n\n        e.g.:\n\n          linewidth or lw = 2\n\n    See Also\n    --------\n    setp\n    \"\"\"\n    if property is None:\n        insp = ArtistInspector(obj)\n        ret = insp.pprint_getters()\n        print('\\n'.join(ret))\n        return\n    return getattr(obj, 'get_' + property)()"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/kwdoc",
      "name": "kwdoc",
      "qname": "lib.matplotlib.artist.kwdoc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/kwdoc/artist",
          "name": "artist",
          "qname": "lib.matplotlib.artist.kwdoc.artist",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.artist.Artist` or an iterable of `Artist`\\s",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`~matplotlib.artist.Artist`"
              },
              {
                "kind": "NamedType",
                "name": "an iterable of `Artist`\\s"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Inspect an `~matplotlib.artist.Artist` class (using `.ArtistInspector`) and\nreturn information about its settable properties and their current values.",
      "docstring": "Inspect an `~matplotlib.artist.Artist` class (using `.ArtistInspector`) and\nreturn information about its settable properties and their current values.\n\nParameters\n----------\nartist : `~matplotlib.artist.Artist` or an iterable of `Artist`\\s\n\nReturns\n-------\nstr\n    The settable properties of *artist*, as plain text if\n    :rc:`docstring.hardcopy` is False and as a rst table (intended for\n    use in Sphinx) if it is True.",
      "code": "def kwdoc(artist):\n    r\"\"\"\n    Inspect an `~matplotlib.artist.Artist` class (using `.ArtistInspector`) and\n    return information about its settable properties and their current values.\n\n    Parameters\n    ----------\n    artist : `~matplotlib.artist.Artist` or an iterable of `Artist`\\s\n\n    Returns\n    -------\n    str\n        The settable properties of *artist*, as plain text if\n        :rc:`docstring.hardcopy` is False and as a rst table (intended for\n        use in Sphinx) if it is True.\n    \"\"\"\n    ai = ArtistInspector(artist)\n    return ('\\n'.join(ai.pprint_setters_rest(leadingspace=4))\n            if mpl.rcParams['docstring.hardcopy'] else\n            'Properties:\\n' + '\\n'.join(ai.pprint_setters(leadingspace=4)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.artist/setp",
      "name": "setp",
      "qname": "lib.matplotlib.artist.setp",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.artist/setp/obj",
          "name": "obj",
          "qname": "lib.matplotlib.artist.setp.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Artist` or list of `.Artist`",
            "default_value": "",
            "description": "The artist(s) whose properties are being set or queried.  When setting\nproperties, all artists are affected; when querying the allowed values,\nonly the first instance in the sequence is queried.\n\nFor example, two lines can be made thicker and red with a single call:\n\n>>> x = arange(0, 1, 0.01)\n>>> lines = plot(x, sin(2*pi*x), x, sin(4*pi*x))\n>>> setp(lines, linewidth=2, color='r')"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`.Artist`"
              },
              {
                "kind": "NamedType",
                "name": "list of `.Artist`"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/setp/args",
          "name": "args",
          "qname": "lib.matplotlib.artist.setp.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "The properties to set.  The following combinations are supported:\n\n- Set the linestyle of a line to be dashed:\n\n  >>> line, = plot([1, 2, 3])\n  >>> setp(line, linestyle='--')\n\n- Set multiple properties at once:\n\n  >>> setp(line, linewidth=2, color='r')\n\n- List allowed values for a line's linestyle:\n\n  >>> setp(line, 'linestyle')\n  linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n\n- List all properties that can be set, and their allowed values:\n\n  >>> setp(line)\n  agg_filter: a filter function, ...\n  [long output listing omitted]\n\n`setp` also supports MATLAB style string/value pairs.  For example, the\nfollowing are equivalent:\n\n>>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style\n>>> setp(lines, linewidth=2, color='r')        # Python style"
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/setp/file",
          "name": "file",
          "qname": "lib.matplotlib.artist.setp.file",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "file-like",
            "default_value": "`sys.stdout`",
            "description": "Where `setp` writes its output when asked to list allowed values.\n\n>>> with open('output.log') as file:\n...     setp(line, file=file)\n\nThe default, ``None``, means `sys.stdout`."
          },
          "type": {
            "kind": "NamedType",
            "name": "file-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.artist/setp/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.artist.setp.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "The properties to set.  The following combinations are supported:\n\n- Set the linestyle of a line to be dashed:\n\n  >>> line, = plot([1, 2, 3])\n  >>> setp(line, linestyle='--')\n\n- Set multiple properties at once:\n\n  >>> setp(line, linewidth=2, color='r')\n\n- List allowed values for a line's linestyle:\n\n  >>> setp(line, 'linestyle')\n  linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n\n- List all properties that can be set, and their allowed values:\n\n  >>> setp(line)\n  agg_filter: a filter function, ...\n  [long output listing omitted]\n\n`setp` also supports MATLAB style string/value pairs.  For example, the\nfollowing are equivalent:\n\n>>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style\n>>> setp(lines, linewidth=2, color='r')        # Python style"
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set one or more properties on an `.Artist`, or list allowed values.",
      "docstring": "Set one or more properties on an `.Artist`, or list allowed values.\n\nParameters\n----------\nobj : `.Artist` or list of `.Artist`\n    The artist(s) whose properties are being set or queried.  When setting\n    properties, all artists are affected; when querying the allowed values,\n    only the first instance in the sequence is queried.\n\n    For example, two lines can be made thicker and red with a single call:\n\n    >>> x = arange(0, 1, 0.01)\n    >>> lines = plot(x, sin(2*pi*x), x, sin(4*pi*x))\n    >>> setp(lines, linewidth=2, color='r')\n\nfile : file-like, default: `sys.stdout`\n    Where `setp` writes its output when asked to list allowed values.\n\n    >>> with open('output.log') as file:\n    ...     setp(line, file=file)\n\n    The default, ``None``, means `sys.stdout`.\n\n*args, **kwargs\n    The properties to set.  The following combinations are supported:\n\n    - Set the linestyle of a line to be dashed:\n\n      >>> line, = plot([1, 2, 3])\n      >>> setp(line, linestyle='--')\n\n    - Set multiple properties at once:\n\n      >>> setp(line, linewidth=2, color='r')\n\n    - List allowed values for a line's linestyle:\n\n      >>> setp(line, 'linestyle')\n      linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n\n    - List all properties that can be set, and their allowed values:\n\n      >>> setp(line)\n      agg_filter: a filter function, ...\n      [long output listing omitted]\n\n    `setp` also supports MATLAB style string/value pairs.  For example, the\n    following are equivalent:\n\n    >>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style\n    >>> setp(lines, linewidth=2, color='r')        # Python style\n\nSee Also\n--------\ngetp",
      "code": "def setp(obj, *args, file=None, **kwargs):\n    \"\"\"\n    Set one or more properties on an `.Artist`, or list allowed values.\n\n    Parameters\n    ----------\n    obj : `.Artist` or list of `.Artist`\n        The artist(s) whose properties are being set or queried.  When setting\n        properties, all artists are affected; when querying the allowed values,\n        only the first instance in the sequence is queried.\n\n        For example, two lines can be made thicker and red with a single call:\n\n        >>> x = arange(0, 1, 0.01)\n        >>> lines = plot(x, sin(2*pi*x), x, sin(4*pi*x))\n        >>> setp(lines, linewidth=2, color='r')\n\n    file : file-like, default: `sys.stdout`\n        Where `setp` writes its output when asked to list allowed values.\n\n        >>> with open('output.log') as file:\n        ...     setp(line, file=file)\n\n        The default, ``None``, means `sys.stdout`.\n\n    *args, **kwargs\n        The properties to set.  The following combinations are supported:\n\n        - Set the linestyle of a line to be dashed:\n\n          >>> line, = plot([1, 2, 3])\n          >>> setp(line, linestyle='--')\n\n        - Set multiple properties at once:\n\n          >>> setp(line, linewidth=2, color='r')\n\n        - List allowed values for a line's linestyle:\n\n          >>> setp(line, 'linestyle')\n          linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n\n        - List all properties that can be set, and their allowed values:\n\n          >>> setp(line)\n          agg_filter: a filter function, ...\n          [long output listing omitted]\n\n        `setp` also supports MATLAB style string/value pairs.  For example, the\n        following are equivalent:\n\n        >>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style\n        >>> setp(lines, linewidth=2, color='r')        # Python style\n\n    See Also\n    --------\n    getp\n    \"\"\"\n\n    if isinstance(obj, Artist):\n        objs = [obj]\n    else:\n        objs = list(cbook.flatten(obj))\n\n    if not objs:\n        return\n\n    insp = ArtistInspector(objs[0])\n\n    if not kwargs and len(args) < 2:\n        if args:\n            print(insp.pprint_setters(prop=args[0]), file=file)\n        else:\n            print('\\n'.join(insp.pprint_setters()), file=file)\n        return\n\n    if len(args) % 2:\n        raise ValueError('The set args must be string, value pairs')\n\n    funcvals = dict(zip(args[::2], args[1::2]))\n    ret = [o.update(funcvals) for o in objs] + [o.set(**kwargs) for o in objs]\n    return list(cbook.flatten(ret))"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.axis.Axis.__init__",
      "decorators": [
        "_api.make_keyword_only('3.6', name='pickradius')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/__init__/axes",
          "name": "axes",
          "qname": "lib.matplotlib.axis.Axis.__init__.axes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/__init__/pickradius",
          "name": "pickradius",
          "qname": "lib.matplotlib.axis.Axis.__init__.pickradius",
          "default_value": "15",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Base class for `.XAxis` and `.YAxis`.",
      "docstring": "Parameters\n----------\naxes : `matplotlib.axes.Axes`\n    The `~.axes.Axes` to which the created Axis belongs.\npickradius : float\n    The acceptance radius for containment tests. See also\n    `.Axis.contains`.",
      "code": "    @_api.make_keyword_only(\"3.6\", name=\"pickradius\")\n    def __init__(self, axes, pickradius=15):\n        \"\"\"\n        Parameters\n        ----------\n        axes : `matplotlib.axes.Axes`\n            The `~.axes.Axes` to which the created Axis belongs.\n        pickradius : float\n            The acceptance radius for containment tests. See also\n            `.Axis.contains`.\n        \"\"\"\n        super().__init__()\n        self._remove_overlapping_locs = True\n\n        self.set_figure(axes.figure)\n\n        self.isDefault_label = True\n\n        self.axes = axes\n        self.major = Ticker()\n        self.minor = Ticker()\n        self.callbacks = cbook.CallbackRegistry(\n            signals=[\"units\", \"units finalize\"])\n\n        self._autolabelpos = True\n\n        self.label = mtext.Text(\n            np.nan, np.nan,\n            fontsize=mpl.rcParams['axes.labelsize'],\n            fontweight=mpl.rcParams['axes.labelweight'],\n            color=mpl.rcParams['axes.labelcolor'],\n        )\n        self._set_artist_props(self.label)\n        self.offsetText = mtext.Text(np.nan, np.nan)\n        self._set_artist_props(self.offsetText)\n\n        self.labelpad = mpl.rcParams['axes.labelpad']\n\n        self.pickradius = pickradius\n\n        # Initialize here for testing; later add API\n        self._major_tick_kw = dict()\n        self._minor_tick_kw = dict()\n\n        self.clear()\n        self._autoscale_on = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/__str__",
      "name": "__str__",
      "qname": "lib.matplotlib.axis.Axis.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/__str__/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self):\n        return \"{}({},{})\".format(\n            type(self).__name__, *self.axes.transAxes.transform((0, 0)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/axis_date",
      "name": "axis_date",
      "qname": "lib.matplotlib.axis.Axis.axis_date",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/axis_date/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.axis_date.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/axis_date/tz",
          "name": "tz",
          "qname": "lib.matplotlib.axis.Axis.axis_date.tz",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or `datetime.tzinfo`",
            "default_value": ":rc:`timezone`",
            "description": "The timezone used to create date labels."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "`datetime.tzinfo`"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set up axis ticks and labels to treat data along this Axis as dates.",
      "docstring": "Set up axis ticks and labels to treat data along this Axis as dates.\n\nParameters\n----------\ntz : str or `datetime.tzinfo`, default: :rc:`timezone`\n    The timezone used to create date labels.",
      "code": "    def axis_date(self, tz=None):\n        \"\"\"\n        Set up axis ticks and labels to treat data along this Axis as dates.\n\n        Parameters\n        ----------\n        tz : str or `datetime.tzinfo`, default: :rc:`timezone`\n            The timezone used to create date labels.\n        \"\"\"\n        # By providing a sample datetime instance with the desired timezone,\n        # the registered converter can be selected, and the \"units\" attribute,\n        # which is the timezone, can be set.\n        if isinstance(tz, str):\n            import dateutil.tz\n            tz = dateutil.tz.gettz(tz)\n        self.update_units(datetime.datetime(2009, 1, 1, 0, 0, 0, 0, tz))"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/clear",
      "name": "clear",
      "qname": "lib.matplotlib.axis.Axis.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Clear the axis.\n\nThis resets axis properties to their default values:\n\n- the label\n- the scale\n- locators, formatters and ticks\n- major and minor grid\n- units\n- registered callbacks",
      "docstring": "Clear the axis.\n\nThis resets axis properties to their default values:\n\n- the label\n- the scale\n- locators, formatters and ticks\n- major and minor grid\n- units\n- registered callbacks",
      "code": "    def clear(self):\n        \"\"\"\n        Clear the axis.\n\n        This resets axis properties to their default values:\n\n        - the label\n        - the scale\n        - locators, formatters and ticks\n        - major and minor grid\n        - units\n        - registered callbacks\n        \"\"\"\n\n        self.label.set_text('')  # self.set_label_text would change isDefault_\n\n        self._set_scale('linear')\n\n        # Clear the callback registry for this axis, or it may \"leak\"\n        self.callbacks = cbook.CallbackRegistry(\n            signals=[\"units\", \"units finalize\"])\n\n        # whether the grids are on\n        self._major_tick_kw['gridOn'] = (\n                mpl.rcParams['axes.grid'] and\n                mpl.rcParams['axes.grid.which'] in ('both', 'major'))\n        self._minor_tick_kw['gridOn'] = (\n                mpl.rcParams['axes.grid'] and\n                mpl.rcParams['axes.grid.which'] in ('both', 'minor'))\n        self.reset_ticks()\n\n        self.converter = None\n        self.units = None\n        self.set_units(None)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/convert_units",
      "name": "convert_units",
      "qname": "lib.matplotlib.axis.Axis.convert_units",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/convert_units/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.convert_units.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/convert_units/x",
          "name": "x",
          "qname": "lib.matplotlib.axis.Axis.convert_units.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def convert_units(self, x):\n        # If x is natively supported by Matplotlib, doesn't need converting\n        if munits._is_natively_supported(x):\n            return x\n\n        if self.converter is None:\n            self.converter = munits.registry.get_converter(x)\n\n        if self.converter is None:\n            return x\n        try:\n            ret = self.converter.convert(x, self.units, self)\n        except Exception as e:\n            raise munits.ConversionError('Failed to convert value(s) to axis '\n                                         f'units: {x!r}') from e\n        return ret"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/draw",
      "name": "draw",
      "qname": "lib.matplotlib.axis.Axis.draw",
      "decorators": [
        "martist.allow_rasterization"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/draw/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.axis.Axis.draw.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/draw/args",
          "name": "args",
          "qname": "lib.matplotlib.axis.Axis.draw.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/draw/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.Axis.draw.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @martist.allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        # docstring inherited\n\n        if not self.get_visible():\n            return\n        renderer.open_group(__name__, gid=self.get_gid())\n\n        ticks_to_draw = self._update_ticks()\n        tlb1, tlb2 = self._get_ticklabel_bboxes(ticks_to_draw, renderer)\n\n        for tick in ticks_to_draw:\n            tick.draw(renderer)\n\n        # Scale up the axis label box to also find the neighbors, not just the\n        # tick labels that actually overlap.  We need a *copy* of the axis\n        # label box because we don't want to scale the actual bbox.\n\n        self._update_label_position(renderer)\n\n        self.label.draw(renderer)\n\n        self._update_offset_text_position(tlb1, tlb2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n        self.offsetText.draw(renderer)\n\n        renderer.close_group(__name__)\n        self.stale = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_children",
      "name": "get_children",
      "qname": "lib.matplotlib.axis.Axis.get_children",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_children/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_children.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_children(self):\n        return [self.label, self.offsetText,\n                *self.get_major_ticks(), *self.get_minor_ticks()]"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_data_interval",
      "name": "get_data_interval",
      "qname": "lib.matplotlib.axis.Axis.get_data_interval",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_data_interval/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_data_interval.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the ``(min, max)`` data limits of this axis.",
      "docstring": "Return the ``(min, max)`` data limits of this axis.",
      "code": "    def get_data_interval(self):\n        \"\"\"Return the ``(min, max)`` data limits of this axis.\"\"\"\n        raise NotImplementedError('Derived must override')"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_gridlines",
      "name": "get_gridlines",
      "qname": "lib.matplotlib.axis.Axis.get_gridlines",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_gridlines/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_gridlines.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' grid lines as a list of `.Line2D`\\s.",
      "docstring": "Return this Axis' grid lines as a list of `.Line2D`\\s.",
      "code": "    def get_gridlines(self):\n        r\"\"\"Return this Axis' grid lines as a list of `.Line2D`\\s.\"\"\"\n        ticks = self.get_major_ticks()\n        return cbook.silent_list('Line2D gridline',\n                                 [tick.gridline for tick in ticks])"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_inverted",
      "name": "get_inverted",
      "qname": "lib.matplotlib.axis.Axis.get_inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether this Axis is oriented in the \"inverse\" direction.\n\nThe \"normal\" direction is increasing to the right for the x-axis and to\nthe top for the y-axis; the \"inverse\" direction is increasing to the\nleft for the x-axis and to the bottom for the y-axis.",
      "docstring": "Return whether this Axis is oriented in the \"inverse\" direction.\n\nThe \"normal\" direction is increasing to the right for the x-axis and to\nthe top for the y-axis; the \"inverse\" direction is increasing to the\nleft for the x-axis and to the bottom for the y-axis.",
      "code": "    def get_inverted(self):\n        \"\"\"\n        Return whether this Axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        low, high = self.get_view_interval()\n        return high < low"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_label",
      "name": "get_label",
      "qname": "lib.matplotlib.axis.Axis.get_label",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_label/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_label.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the axis label as a Text instance.",
      "docstring": "Return the axis label as a Text instance.",
      "code": "    def get_label(self):\n        \"\"\"Return the axis label as a Text instance.\"\"\"\n        return self.label"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_label_position",
      "name": "get_label_position",
      "qname": "lib.matplotlib.axis.Axis.get_label_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_label_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_label_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the label position (top or bottom)",
      "docstring": "Return the label position (top or bottom)",
      "code": "    def get_label_position(self):\n        \"\"\"\n        Return the label position (top or bottom)\n        \"\"\"\n        return self.label_position"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_label_text",
      "name": "get_label_text",
      "qname": "lib.matplotlib.axis.Axis.get_label_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_label_text/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_label_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the text of the label.",
      "docstring": "Get the text of the label.",
      "code": "    def get_label_text(self):\n        \"\"\"Get the text of the label.\"\"\"\n        return self.label.get_text()"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_major_formatter",
      "name": "get_major_formatter",
      "qname": "lib.matplotlib.axis.Axis.get_major_formatter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_major_formatter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_major_formatter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the formatter of the major ticker.",
      "docstring": "Get the formatter of the major ticker.",
      "code": "    def get_major_formatter(self):\n        \"\"\"Get the formatter of the major ticker.\"\"\"\n        return self.major.formatter"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_major_locator",
      "name": "get_major_locator",
      "qname": "lib.matplotlib.axis.Axis.get_major_locator",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_major_locator/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_major_locator.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the locator of the major ticker.",
      "docstring": "Get the locator of the major ticker.",
      "code": "    def get_major_locator(self):\n        \"\"\"Get the locator of the major ticker.\"\"\"\n        return self.major.locator"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_major_ticks",
      "name": "get_major_ticks",
      "qname": "lib.matplotlib.axis.Axis.get_major_ticks",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_major_ticks/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_major_ticks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_major_ticks/numticks",
          "name": "numticks",
          "qname": "lib.matplotlib.axis.Axis.get_major_ticks.numticks",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the list of major `.Tick`\\s.",
      "docstring": "Return the list of major `.Tick`\\s.",
      "code": "    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_majorticklabels",
      "name": "get_majorticklabels",
      "qname": "lib.matplotlib.axis.Axis.get_majorticklabels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_majorticklabels/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_majorticklabels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' major tick labels, as a list of `~.text.Text`.",
      "docstring": "Return this Axis' major tick labels, as a list of `~.text.Text`.",
      "code": "    def get_majorticklabels(self):\n        \"\"\"Return this Axis' major tick labels, as a list of `~.text.Text`.\"\"\"\n        self._update_ticks()\n        ticks = self.get_major_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return labels1 + labels2"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_majorticklines",
      "name": "get_majorticklines",
      "qname": "lib.matplotlib.axis.Axis.get_majorticklines",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_majorticklines/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_majorticklines.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' major tick lines as a list of `.Line2D`\\s.",
      "docstring": "Return this Axis' major tick lines as a list of `.Line2D`\\s.",
      "code": "    def get_majorticklines(self):\n        r\"\"\"Return this Axis' major tick lines as a list of `.Line2D`\\s.\"\"\"\n        lines = []\n        ticks = self.get_major_ticks()\n        for tick in ticks:\n            lines.append(tick.tick1line)\n            lines.append(tick.tick2line)\n        return cbook.silent_list('Line2D ticklines', lines)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_majorticklocs",
      "name": "get_majorticklocs",
      "qname": "lib.matplotlib.axis.Axis.get_majorticklocs",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_majorticklocs/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_majorticklocs.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' major tick locations in data coordinates.",
      "docstring": "Return this Axis' major tick locations in data coordinates.",
      "code": "    def get_majorticklocs(self):\n        \"\"\"Return this Axis' major tick locations in data coordinates.\"\"\"\n        return self.major.locator()"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_minor_formatter",
      "name": "get_minor_formatter",
      "qname": "lib.matplotlib.axis.Axis.get_minor_formatter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_minor_formatter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_minor_formatter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the formatter of the minor ticker.",
      "docstring": "Get the formatter of the minor ticker.",
      "code": "    def get_minor_formatter(self):\n        \"\"\"Get the formatter of the minor ticker.\"\"\"\n        return self.minor.formatter"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_minor_locator",
      "name": "get_minor_locator",
      "qname": "lib.matplotlib.axis.Axis.get_minor_locator",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_minor_locator/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_minor_locator.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the locator of the minor ticker.",
      "docstring": "Get the locator of the minor ticker.",
      "code": "    def get_minor_locator(self):\n        \"\"\"Get the locator of the minor ticker.\"\"\"\n        return self.minor.locator"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_minor_ticks",
      "name": "get_minor_ticks",
      "qname": "lib.matplotlib.axis.Axis.get_minor_ticks",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_minor_ticks/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_minor_ticks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_minor_ticks/numticks",
          "name": "numticks",
          "qname": "lib.matplotlib.axis.Axis.get_minor_ticks.numticks",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the list of minor `.Tick`\\s.",
      "docstring": "Return the list of minor `.Tick`\\s.",
      "code": "    def get_minor_ticks(self, numticks=None):\n        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_minorticklabels",
      "name": "get_minorticklabels",
      "qname": "lib.matplotlib.axis.Axis.get_minorticklabels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_minorticklabels/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_minorticklabels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' minor tick labels, as a list of `~.text.Text`.",
      "docstring": "Return this Axis' minor tick labels, as a list of `~.text.Text`.",
      "code": "    def get_minorticklabels(self):\n        \"\"\"Return this Axis' minor tick labels, as a list of `~.text.Text`.\"\"\"\n        self._update_ticks()\n        ticks = self.get_minor_ticks()\n        labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n        labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n        return labels1 + labels2"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_minorticklines",
      "name": "get_minorticklines",
      "qname": "lib.matplotlib.axis.Axis.get_minorticklines",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_minorticklines/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_minorticklines.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' minor tick lines as a list of `.Line2D`\\s.",
      "docstring": "Return this Axis' minor tick lines as a list of `.Line2D`\\s.",
      "code": "    def get_minorticklines(self):\n        r\"\"\"Return this Axis' minor tick lines as a list of `.Line2D`\\s.\"\"\"\n        lines = []\n        ticks = self.get_minor_ticks()\n        for tick in ticks:\n            lines.append(tick.tick1line)\n            lines.append(tick.tick2line)\n        return cbook.silent_list('Line2D ticklines', lines)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_minorticklocs",
      "name": "get_minorticklocs",
      "qname": "lib.matplotlib.axis.Axis.get_minorticklocs",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_minorticklocs/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_minorticklocs.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' minor tick locations in data coordinates.",
      "docstring": "Return this Axis' minor tick locations in data coordinates.",
      "code": "    def get_minorticklocs(self):\n        \"\"\"Return this Axis' minor tick locations in data coordinates.\"\"\"\n        # Remove minor ticks duplicating major ticks.\n        minor_locs = np.asarray(self.minor.locator())\n        if self.remove_overlapping_locs:\n            major_locs = self.major.locator()\n            transform = self._scale.get_transform()\n            tr_minor_locs = transform.transform(minor_locs)\n            tr_major_locs = transform.transform(major_locs)\n            lo, hi = sorted(transform.transform(self.get_view_interval()))\n            # Use the transformed view limits as scale.  1e-5 is the default\n            # rtol for np.isclose.\n            tol = (hi - lo) * 1e-5\n            mask = np.isclose(tr_minor_locs[:, None], tr_major_locs[None, :],\n                              atol=tol, rtol=0).any(axis=1)\n            minor_locs = minor_locs[~mask]\n        return minor_locs"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_minpos",
      "name": "get_minpos",
      "qname": "lib.matplotlib.axis.Axis.get_minpos",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_minpos/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_minpos.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_minpos(self):\n        raise NotImplementedError()"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_offset_text",
      "name": "get_offset_text",
      "qname": "lib.matplotlib.axis.Axis.get_offset_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_offset_text/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_offset_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the axis offsetText as a Text instance.",
      "docstring": "Return the axis offsetText as a Text instance.",
      "code": "    def get_offset_text(self):\n        \"\"\"Return the axis offsetText as a Text instance.\"\"\"\n        return self.offsetText"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_pickradius",
      "name": "get_pickradius",
      "qname": "lib.matplotlib.axis.Axis.get_pickradius",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_pickradius/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_pickradius.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the depth of the axis used by the picker.",
      "docstring": "Return the depth of the axis used by the picker.",
      "code": "    def get_pickradius(self):\n        \"\"\"Return the depth of the axis used by the picker.\"\"\"\n        return self._pickradius"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_remove_overlapping_locs",
      "name": "get_remove_overlapping_locs",
      "qname": "lib.matplotlib.axis.Axis.get_remove_overlapping_locs",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_remove_overlapping_locs/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_remove_overlapping_locs.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_remove_overlapping_locs(self):\n        return self._remove_overlapping_locs"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_scale",
      "name": "get_scale",
      "qname": "lib.matplotlib.axis.Axis.get_scale",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_scale/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_scale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' scale (as a str).",
      "docstring": "Return this Axis' scale (as a str).",
      "code": "    def get_scale(self):\n        \"\"\"Return this Axis' scale (as a str).\"\"\"\n        return self._scale.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_tick_padding",
      "name": "get_tick_padding",
      "qname": "lib.matplotlib.axis.Axis.get_tick_padding",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_tick_padding/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_tick_padding.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_tick_padding(self):\n        values = []\n        if len(self.majorTicks):\n            values.append(self.majorTicks[0].get_tick_padding())\n        if len(self.minorTicks):\n            values.append(self.minorTicks[0].get_tick_padding())\n        return max(values, default=0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_tick_space",
      "name": "get_tick_space",
      "qname": "lib.matplotlib.axis.Axis.get_tick_space",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_tick_space/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_tick_space.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the estimated number of ticks that can fit on the axis.",
      "docstring": "Return the estimated number of ticks that can fit on the axis.",
      "code": "    def get_tick_space(self):\n        \"\"\"Return the estimated number of ticks that can fit on the axis.\"\"\"\n        # Must be overridden in the subclass\n        raise NotImplementedError()"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklabel_extents",
      "name": "get_ticklabel_extents",
      "qname": "lib.matplotlib.axis.Axis.get_ticklabel_extents",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklabel_extents/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_ticklabel_extents.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklabel_extents/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.axis.Axis.get_ticklabel_extents.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the extents of the tick labels on either side of the axes.",
      "docstring": "Get the extents of the tick labels on either side of the axes.",
      "code": "    @_api.deprecated(\"3.6\")\n    def get_ticklabel_extents(self, renderer):\n        \"\"\"Get the extents of the tick labels on either side of the axes.\"\"\"\n        ticks_to_draw = self._update_ticks()\n        tlb1, tlb2 = self._get_ticklabel_bboxes(ticks_to_draw, renderer)\n        if len(tlb1):\n            bbox1 = mtransforms.Bbox.union(tlb1)\n        else:\n            bbox1 = mtransforms.Bbox.from_extents(0, 0, 0, 0)\n        if len(tlb2):\n            bbox2 = mtransforms.Bbox.union(tlb2)\n        else:\n            bbox2 = mtransforms.Bbox.from_extents(0, 0, 0, 0)\n        return bbox1, bbox2"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklabels",
      "name": "get_ticklabels",
      "qname": "lib.matplotlib.axis.Axis.get_ticklabels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklabels/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_ticklabels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklabels/minor",
          "name": "minor",
          "qname": "lib.matplotlib.axis.Axis.get_ticklabels.minor",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether to return the minor or the major ticklabels."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklabels/which",
          "name": "which",
          "qname": "lib.matplotlib.axis.Axis.get_ticklabels.which",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None, ('minor', 'major', 'both')",
            "default_value": "",
            "description": "Overrides *minor*.\n\nSelects which ticklabels to return"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "('minor', 'major', 'both')"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get this Axis' tick labels.",
      "docstring": "Get this Axis' tick labels.\n\nParameters\n----------\nminor : bool\n   Whether to return the minor or the major ticklabels.\n\nwhich : None, ('minor', 'major', 'both')\n   Overrides *minor*.\n\n   Selects which ticklabels to return\n\nReturns\n-------\nlist of `~matplotlib.text.Text`",
      "code": "    def get_ticklabels(self, minor=False, which=None):\n        \"\"\"\n        Get this Axis' tick labels.\n\n        Parameters\n        ----------\n        minor : bool\n           Whether to return the minor or the major ticklabels.\n\n        which : None, ('minor', 'major', 'both')\n           Overrides *minor*.\n\n           Selects which ticklabels to return\n\n        Returns\n        -------\n        list of `~matplotlib.text.Text`\n        \"\"\"\n        if which is not None:\n            if which == 'minor':\n                return self.get_minorticklabels()\n            elif which == 'major':\n                return self.get_majorticklabels()\n            elif which == 'both':\n                return self.get_majorticklabels() + self.get_minorticklabels()\n            else:\n                _api.check_in_list(['major', 'minor', 'both'], which=which)\n        if minor:\n            return self.get_minorticklabels()\n        return self.get_majorticklabels()"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklines",
      "name": "get_ticklines",
      "qname": "lib.matplotlib.axis.Axis.get_ticklines",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklines/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_ticklines.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklines/minor",
          "name": "minor",
          "qname": "lib.matplotlib.axis.Axis.get_ticklines.minor",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' tick lines as a list of `.Line2D`\\s.",
      "docstring": "Return this Axis' tick lines as a list of `.Line2D`\\s.",
      "code": "    def get_ticklines(self, minor=False):\n        r\"\"\"Return this Axis' tick lines as a list of `.Line2D`\\s.\"\"\"\n        if minor:\n            return self.get_minorticklines()\n        return self.get_majorticklines()"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklocs",
      "name": "get_ticklocs",
      "qname": "lib.matplotlib.axis.Axis.get_ticklocs",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklocs/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_ticklocs.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticklocs/minor",
          "name": "minor",
          "qname": "lib.matplotlib.axis.Axis.get_ticklocs.minor",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "True to return the minor tick directions,\nFalse to return the major tick directions."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return this Axis' tick locations in data coordinates.\n\nThe locations are not clipped to the current axis limits and hence\nmay contain locations that are not visible in the output.",
      "docstring": "Return this Axis' tick locations in data coordinates.\n\nThe locations are not clipped to the current axis limits and hence\nmay contain locations that are not visible in the output.\n\nParameters\n----------\nminor : bool, default: False\n    True to return the minor tick directions,\n    False to return the major tick directions.\n\nReturns\n-------\nnumpy array of tick locations",
      "code": "    def get_ticklocs(self, *, minor=False):\n        \"\"\"\n        Return this Axis' tick locations in data coordinates.\n\n        The locations are not clipped to the current axis limits and hence\n        may contain locations that are not visible in the output.\n\n        Parameters\n        ----------\n        minor : bool, default: False\n            True to return the minor tick directions,\n            False to return the major tick directions.\n\n        Returns\n        -------\n        numpy array of tick locations\n        \"\"\"\n        return self.get_minorticklocs() if minor else self.get_majorticklocs()"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticks_direction",
      "name": "get_ticks_direction",
      "qname": "lib.matplotlib.axis.Axis.get_ticks_direction",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticks_direction/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_ticks_direction.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_ticks_direction/minor",
          "name": "minor",
          "qname": "lib.matplotlib.axis.Axis.get_ticks_direction.minor",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "True to return the minor tick directions,\nFalse to return the major tick directions."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the tick directions as a numpy array",
      "docstring": "Get the tick directions as a numpy array\n\nParameters\n----------\nminor : bool, default: False\n    True to return the minor tick directions,\n    False to return the major tick directions.\n\nReturns\n-------\nnumpy array of tick directions",
      "code": "    def get_ticks_direction(self, minor=False):\n        \"\"\"\n        Get the tick directions as a numpy array\n\n        Parameters\n        ----------\n        minor : bool, default: False\n            True to return the minor tick directions,\n            False to return the major tick directions.\n\n        Returns\n        -------\n        numpy array of tick directions\n        \"\"\"\n        if minor:\n            return np.array(\n                [tick._tickdir for tick in self.get_minor_ticks()])\n        else:\n            return np.array(\n                [tick._tickdir for tick in self.get_major_ticks()])"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_tightbbox",
      "name": "get_tightbbox",
      "qname": "lib.matplotlib.axis.Axis.get_tightbbox",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_tightbbox/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_tightbbox.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_tightbbox/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.axis.Axis.get_tightbbox.renderer",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_tightbbox/for_layout_only",
          "name": "for_layout_only",
          "qname": "lib.matplotlib.axis.Axis.get_tightbbox.for_layout_only",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a bounding box that encloses the axis. It only accounts\ntick labels, axis label, and offsetText.\n\nIf *for_layout_only* is True, then the width of the label (if this\nis an x-axis) or the height of the label (if this is a y-axis) is\ncollapsed to near zero.  This allows tight/constrained_layout to ignore\ntoo-long labels when doing their layout.",
      "docstring": "Return a bounding box that encloses the axis. It only accounts\ntick labels, axis label, and offsetText.\n\nIf *for_layout_only* is True, then the width of the label (if this\nis an x-axis) or the height of the label (if this is a y-axis) is\ncollapsed to near zero.  This allows tight/constrained_layout to ignore\ntoo-long labels when doing their layout.",
      "code": "    def get_tightbbox(self, renderer=None, *, for_layout_only=False):\n        \"\"\"\n        Return a bounding box that encloses the axis. It only accounts\n        tick labels, axis label, and offsetText.\n\n        If *for_layout_only* is True, then the width of the label (if this\n        is an x-axis) or the height of the label (if this is a y-axis) is\n        collapsed to near zero.  This allows tight/constrained_layout to ignore\n        too-long labels when doing their layout.\n        \"\"\"\n        if not self.get_visible():\n            return\n        if renderer is None:\n            renderer = self.figure._get_renderer()\n        ticks_to_draw = self._update_ticks()\n\n        self._update_label_position(renderer)\n\n        # go back to just this axis's tick labels\n        tlb1, tlb2 = self._get_ticklabel_bboxes(ticks_to_draw, renderer)\n\n        self._update_offset_text_position(tlb1, tlb2)\n        self.offsetText.set_text(self.major.formatter.get_offset())\n\n        bboxes = [\n            *(a.get_window_extent(renderer)\n              for a in [self.offsetText]\n              if a.get_visible()),\n            *tlb1, *tlb2,\n        ]\n        # take care of label\n        if self.label.get_visible():\n            bb = self.label.get_window_extent(renderer)\n            # for constrained/tight_layout, we want to ignore the label's\n            # width/height because the adjustments they make can't be improved.\n            # this code collapses the relevant direction\n            if for_layout_only:\n                if self.axis_name == \"x\" and bb.width > 0:\n                    bb.x0 = (bb.x0 + bb.x1) / 2 - 0.5\n                    bb.x1 = bb.x0 + 1.0\n                if self.axis_name == \"y\" and bb.height > 0:\n                    bb.y0 = (bb.y0 + bb.y1) / 2 - 0.5\n                    bb.y1 = bb.y0 + 1.0\n            bboxes.append(bb)\n        bboxes = [b for b in bboxes\n                  if 0 < b.width < np.inf and 0 < b.height < np.inf]\n        if bboxes:\n            return mtransforms.Bbox.union(bboxes)\n        else:\n            return None"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_transform",
      "name": "get_transform",
      "qname": "lib.matplotlib.axis.Axis.get_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_transform(self):\n        return self._scale.get_transform()"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_units",
      "name": "get_units",
      "qname": "lib.matplotlib.axis.Axis.get_units",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_units/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_units.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the units for axis.",
      "docstring": "Return the units for axis.",
      "code": "    def get_units(self):\n        \"\"\"Return the units for axis.\"\"\"\n        return self.units"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/get_view_interval",
      "name": "get_view_interval",
      "qname": "lib.matplotlib.axis.Axis.get_view_interval",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/get_view_interval/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.get_view_interval.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the ``(min, max)`` view limits of this axis.",
      "docstring": "Return the ``(min, max)`` view limits of this axis.",
      "code": "    def get_view_interval(self):\n        \"\"\"Return the ``(min, max)`` view limits of this axis.\"\"\"\n        raise NotImplementedError('Derived must override')"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/grid",
      "name": "grid",
      "qname": "lib.matplotlib.axis.Axis.grid",
      "decorators": [
        "_api.rename_parameter('3.5', 'b', 'visible')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/grid/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.grid.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/grid/visible",
          "name": "visible",
          "qname": "lib.matplotlib.axis.Axis.grid.visible",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool or None",
            "default_value": "",
            "description": "Whether to show the grid lines.  If any *kwargs* are supplied, it\nis assumed you want the grid on and *visible* will be set to True.\n\nIf *visible* is *None* and there are no *kwargs*, this toggles the\nvisibility of the lines."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "bool"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/grid/which",
          "name": "which",
          "qname": "lib.matplotlib.axis.Axis.grid.which",
          "default_value": "'major'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'major', 'minor', 'both'}",
            "default_value": "",
            "description": "The grid lines to apply the changes on."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "major",
              "minor",
              "both"
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/grid/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.Axis.grid.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "`.Line2D` properties",
            "default_value": "",
            "description": "Define the line properties of the grid, e.g.::\n\n    grid(color='r', linestyle='-', linewidth=2)"
          },
          "type": {
            "kind": "NamedType",
            "name": "`.Line2D` properties"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Configure the grid lines.",
      "docstring": "Configure the grid lines.\n\nParameters\n----------\nvisible : bool or None\n    Whether to show the grid lines.  If any *kwargs* are supplied, it\n    is assumed you want the grid on and *visible* will be set to True.\n\n    If *visible* is *None* and there are no *kwargs*, this toggles the\n    visibility of the lines.\n\nwhich : {'major', 'minor', 'both'}\n    The grid lines to apply the changes on.\n\n**kwargs : `.Line2D` properties\n    Define the line properties of the grid, e.g.::\n\n        grid(color='r', linestyle='-', linewidth=2)",
      "code": "    @_api.rename_parameter(\"3.5\", \"b\", \"visible\")\n    def grid(self, visible=None, which='major', **kwargs):\n        \"\"\"\n        Configure the grid lines.\n\n        Parameters\n        ----------\n        visible : bool or None\n            Whether to show the grid lines.  If any *kwargs* are supplied, it\n            is assumed you want the grid on and *visible* will be set to True.\n\n            If *visible* is *None* and there are no *kwargs*, this toggles the\n            visibility of the lines.\n\n        which : {'major', 'minor', 'both'}\n            The grid lines to apply the changes on.\n\n        **kwargs : `.Line2D` properties\n            Define the line properties of the grid, e.g.::\n\n                grid(color='r', linestyle='-', linewidth=2)\n        \"\"\"\n        if kwargs:\n            if visible is None:\n                visible = True\n            elif not visible:  # something false-like but not None\n                _api.warn_external('First parameter to grid() is false, '\n                                   'but line properties are supplied. The '\n                                   'grid will be enabled.')\n                visible = True\n        which = which.lower()\n        _api.check_in_list(['major', 'minor', 'both'], which=which)\n        gridkw = {f'grid_{name}': value for name, value in kwargs.items()}\n        if which in ['minor', 'both']:\n            gridkw['gridOn'] = (not self._minor_tick_kw['gridOn']\n                                if visible is None else visible)\n            self.set_tick_params(which='minor', **gridkw)\n        if which in ['major', 'both']:\n            gridkw['gridOn'] = (not self._major_tick_kw['gridOn']\n                                if visible is None else visible)\n            self.set_tick_params(which='major', **gridkw)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/have_units",
      "name": "have_units",
      "qname": "lib.matplotlib.axis.Axis.have_units",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/have_units/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.have_units.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def have_units(self):\n        return self.converter is not None or self.units is not None"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majfmt@getter",
      "name": "isDefault_majfmt",
      "qname": "lib.matplotlib.axis.Axis.isDefault_majfmt",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majfmt@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.isDefault_majfmt.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def isDefault_majfmt(self):\n        return self.major._formatter_is_default"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majfmt@setter",
      "name": "isDefault_majfmt",
      "qname": "lib.matplotlib.axis.Axis.isDefault_majfmt",
      "decorators": [
        "isDefault_majfmt.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majfmt@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.isDefault_majfmt.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majfmt@setter/value",
          "name": "value",
          "qname": "lib.matplotlib.axis.Axis.isDefault_majfmt.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @isDefault_majfmt.setter\n    def isDefault_majfmt(self, value):\n        self.major._formatter_is_default = value"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majloc@getter",
      "name": "isDefault_majloc",
      "qname": "lib.matplotlib.axis.Axis.isDefault_majloc",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majloc@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.isDefault_majloc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def isDefault_majloc(self):\n        return self.major._locator_is_default"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majloc@setter",
      "name": "isDefault_majloc",
      "qname": "lib.matplotlib.axis.Axis.isDefault_majloc",
      "decorators": [
        "isDefault_majloc.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majloc@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.isDefault_majloc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_majloc@setter/value",
          "name": "value",
          "qname": "lib.matplotlib.axis.Axis.isDefault_majloc.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @isDefault_majloc.setter\n    def isDefault_majloc(self, value):\n        self.major._locator_is_default = value"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minfmt@getter",
      "name": "isDefault_minfmt",
      "qname": "lib.matplotlib.axis.Axis.isDefault_minfmt",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minfmt@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.isDefault_minfmt.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def isDefault_minfmt(self):\n        return self.minor._formatter_is_default"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minfmt@setter",
      "name": "isDefault_minfmt",
      "qname": "lib.matplotlib.axis.Axis.isDefault_minfmt",
      "decorators": [
        "isDefault_minfmt.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minfmt@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.isDefault_minfmt.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minfmt@setter/value",
          "name": "value",
          "qname": "lib.matplotlib.axis.Axis.isDefault_minfmt.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @isDefault_minfmt.setter\n    def isDefault_minfmt(self, value):\n        self.minor._formatter_is_default = value"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minloc@getter",
      "name": "isDefault_minloc",
      "qname": "lib.matplotlib.axis.Axis.isDefault_minloc",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minloc@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.isDefault_minloc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def isDefault_minloc(self):\n        return self.minor._locator_is_default"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minloc@setter",
      "name": "isDefault_minloc",
      "qname": "lib.matplotlib.axis.Axis.isDefault_minloc",
      "decorators": [
        "isDefault_minloc.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minloc@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.isDefault_minloc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/isDefault_minloc@setter/value",
          "name": "value",
          "qname": "lib.matplotlib.axis.Axis.isDefault_minloc.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @isDefault_minloc.setter\n    def isDefault_minloc(self, value):\n        self.minor._locator_is_default = value"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/limit_range_for_scale",
      "name": "limit_range_for_scale",
      "qname": "lib.matplotlib.axis.Axis.limit_range_for_scale",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/limit_range_for_scale/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.limit_range_for_scale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/limit_range_for_scale/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.axis.Axis.limit_range_for_scale.vmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/limit_range_for_scale/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.axis.Axis.limit_range_for_scale.vmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def limit_range_for_scale(self, vmin, vmax):\n        return self._scale.limit_range_for_scale(vmin, vmax, self.get_minpos())"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/reset_ticks",
      "name": "reset_ticks",
      "qname": "lib.matplotlib.axis.Axis.reset_ticks",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/reset_ticks/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.reset_ticks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Re-initialize the major and minor Tick lists.\n\nEach list starts with a single fresh Tick.",
      "docstring": "Re-initialize the major and minor Tick lists.\n\nEach list starts with a single fresh Tick.",
      "code": "    def reset_ticks(self):\n        \"\"\"\n        Re-initialize the major and minor Tick lists.\n\n        Each list starts with a single fresh Tick.\n        \"\"\"\n        # Restore the lazy tick lists.\n        try:\n            del self.majorTicks\n        except AttributeError:\n            pass\n        try:\n            del self.minorTicks\n        except AttributeError:\n            pass\n        try:\n            self.set_clip_path(self.axes.patch)\n        except AttributeError:\n            pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_clip_path",
      "name": "set_clip_path",
      "qname": "lib.matplotlib.axis.Axis.set_clip_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_clip_path/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_clip_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_clip_path/clippath",
          "name": "clippath",
          "qname": "lib.matplotlib.axis.Axis.set_clip_path.clippath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_clip_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.axis.Axis.set_clip_path.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_clip_path(self, clippath, transform=None):\n        super().set_clip_path(clippath, transform)\n        for child in self.majorTicks + self.minorTicks:\n            child.set_clip_path(clippath, transform)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_data_interval",
      "name": "set_data_interval",
      "qname": "lib.matplotlib.axis.Axis.set_data_interval",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_data_interval/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_data_interval.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_data_interval/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.axis.Axis.set_data_interval.vmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_data_interval/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.axis.Axis.set_data_interval.vmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_data_interval/ignore",
          "name": "ignore",
          "qname": "lib.matplotlib.axis.Axis.set_data_interval.ignore",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the axis data limits.  This method is for internal use.\n\nIf *ignore* is False (the default), this method will never reduce the\npreexisting data limits, only expand them if *vmin* or *vmax* are not\nwithin them.  Moreover, the order of *vmin* and *vmax* does not matter;\nthe orientation of the axis will not change.\n\nIf *ignore* is True, the data limits will be set exactly to ``(vmin,\nvmax)`` in that order.",
      "docstring": "Set the axis data limits.  This method is for internal use.\n\nIf *ignore* is False (the default), this method will never reduce the\npreexisting data limits, only expand them if *vmin* or *vmax* are not\nwithin them.  Moreover, the order of *vmin* and *vmax* does not matter;\nthe orientation of the axis will not change.\n\nIf *ignore* is True, the data limits will be set exactly to ``(vmin,\nvmax)`` in that order.",
      "code": "    def set_data_interval(self, vmin, vmax, ignore=False):\n        \"\"\"\n        Set the axis data limits.  This method is for internal use.\n\n        If *ignore* is False (the default), this method will never reduce the\n        preexisting data limits, only expand them if *vmin* or *vmax* are not\n        within them.  Moreover, the order of *vmin* and *vmax* does not matter;\n        the orientation of the axis will not change.\n\n        If *ignore* is True, the data limits will be set exactly to ``(vmin,\n        vmax)`` in that order.\n        \"\"\"\n        raise NotImplementedError('Derived must override')"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_default_intervals",
      "name": "set_default_intervals",
      "qname": "lib.matplotlib.axis.Axis.set_default_intervals",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_default_intervals/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_default_intervals.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the default limits for the axis data and view interval if they\nhave not been not mutated yet.",
      "docstring": "Set the default limits for the axis data and view interval if they\nhave not been not mutated yet.",
      "code": "    def set_default_intervals(self):\n        \"\"\"\n        Set the default limits for the axis data and view interval if they\n        have not been not mutated yet.\n        \"\"\""
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_inverted",
      "name": "set_inverted",
      "qname": "lib.matplotlib.axis.Axis.set_inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_inverted/inverted",
          "name": "inverted",
          "qname": "lib.matplotlib.axis.Axis.set_inverted.inverted",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set whether this Axis is oriented in the \"inverse\" direction.\n\nThe \"normal\" direction is increasing to the right for the x-axis and to\nthe top for the y-axis; the \"inverse\" direction is increasing to the\nleft for the x-axis and to the bottom for the y-axis.",
      "docstring": "Set whether this Axis is oriented in the \"inverse\" direction.\n\nThe \"normal\" direction is increasing to the right for the x-axis and to\nthe top for the y-axis; the \"inverse\" direction is increasing to the\nleft for the x-axis and to the bottom for the y-axis.",
      "code": "    def set_inverted(self, inverted):\n        \"\"\"\n        Set whether this Axis is oriented in the \"inverse\" direction.\n\n        The \"normal\" direction is increasing to the right for the x-axis and to\n        the top for the y-axis; the \"inverse\" direction is increasing to the\n        left for the x-axis and to the bottom for the y-axis.\n        \"\"\"\n        a, b = self.get_view_interval()\n        # cast to bool to avoid bad interaction between python 3.8 and np.bool_\n        self._set_lim(*sorted((a, b), reverse=bool(inverted)), auto=None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_coords",
      "name": "set_label_coords",
      "qname": "lib.matplotlib.axis.Axis.set_label_coords",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_coords/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_label_coords.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_coords/x",
          "name": "x",
          "qname": "lib.matplotlib.axis.Axis.set_label_coords.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_coords/y",
          "name": "y",
          "qname": "lib.matplotlib.axis.Axis.set_label_coords.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_coords/transform",
          "name": "transform",
          "qname": "lib.matplotlib.axis.Axis.set_label_coords.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the coordinates of the label.\n\nBy default, the x coordinate of the y label and the y coordinate of the\nx label are determined by the tick label bounding boxes, but this can\nlead to poor alignment of multiple labels if there are multiple axes.\n\nYou can also specify the coordinate system of the label with the\ntransform.  If None, the default coordinate system will be the axes\ncoordinate system: (0, 0) is bottom left, (0.5, 0.5) is center, etc.",
      "docstring": "Set the coordinates of the label.\n\nBy default, the x coordinate of the y label and the y coordinate of the\nx label are determined by the tick label bounding boxes, but this can\nlead to poor alignment of multiple labels if there are multiple axes.\n\nYou can also specify the coordinate system of the label with the\ntransform.  If None, the default coordinate system will be the axes\ncoordinate system: (0, 0) is bottom left, (0.5, 0.5) is center, etc.",
      "code": "    def set_label_coords(self, x, y, transform=None):\n        \"\"\"\n        Set the coordinates of the label.\n\n        By default, the x coordinate of the y label and the y coordinate of the\n        x label are determined by the tick label bounding boxes, but this can\n        lead to poor alignment of multiple labels if there are multiple axes.\n\n        You can also specify the coordinate system of the label with the\n        transform.  If None, the default coordinate system will be the axes\n        coordinate system: (0, 0) is bottom left, (0.5, 0.5) is center, etc.\n        \"\"\"\n        self._autolabelpos = False\n        if transform is None:\n            transform = self.axes.transAxes\n\n        self.label.set_transform(transform)\n        self.label.set_position((x, y))\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_position",
      "name": "set_label_position",
      "qname": "lib.matplotlib.axis.Axis.set_label_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_label_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_position/position",
          "name": "position",
          "qname": "lib.matplotlib.axis.Axis.set_label_position.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'top', 'bottom'}",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "bottom",
              "top"
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the label position (top or bottom)",
      "docstring": "Set the label position (top or bottom)\n\nParameters\n----------\nposition : {'top', 'bottom'}",
      "code": "    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        raise NotImplementedError()"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_text",
      "name": "set_label_text",
      "qname": "lib.matplotlib.axis.Axis.set_label_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_text/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_label_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_text/label",
          "name": "label",
          "qname": "lib.matplotlib.axis.Axis.set_label_text.label",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Text string."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_text/fontdict",
          "name": "fontdict",
          "qname": "lib.matplotlib.axis.Axis.set_label_text.fontdict",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "Text properties."
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_label_text/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.Axis.set_label_text.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Merged into fontdict."
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the text value of the axis label.",
      "docstring": "Set the text value of the axis label.\n\nParameters\n----------\nlabel : str\n    Text string.\nfontdict : dict\n    Text properties.\n**kwargs\n    Merged into fontdict.",
      "code": "    def set_label_text(self, label, fontdict=None, **kwargs):\n        \"\"\"\n        Set the text value of the axis label.\n\n        Parameters\n        ----------\n        label : str\n            Text string.\n        fontdict : dict\n            Text properties.\n        **kwargs\n            Merged into fontdict.\n        \"\"\"\n        self.isDefault_label = False\n        self.label.set_text(label)\n        if fontdict is not None:\n            self.label.update(fontdict)\n        self.label.update(kwargs)\n        self.stale = True\n        return self.label"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_major_formatter",
      "name": "set_major_formatter",
      "qname": "lib.matplotlib.axis.Axis.set_major_formatter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_major_formatter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_major_formatter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_major_formatter/formatter",
          "name": "formatter",
          "qname": "lib.matplotlib.axis.Axis.set_major_formatter.formatter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.ticker.Formatter`, ``str``, or function",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`~matplotlib.ticker.Formatter`"
              },
              {
                "kind": "NamedType",
                "name": "``str``"
              },
              {
                "kind": "NamedType",
                "name": "function"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the formatter of the major ticker.\n\nIn addition to a `~matplotlib.ticker.Formatter` instance,\nthis also accepts a ``str`` or function.\n\nFor a ``str`` a `~matplotlib.ticker.StrMethodFormatter` is used.\nThe field used for the value must be labeled ``'x'`` and the field used\nfor the position must be labeled ``'pos'``.\nSee the  `~matplotlib.ticker.StrMethodFormatter` documentation for\nmore information.\n\nFor a function, a `~matplotlib.ticker.FuncFormatter` is used.\nThe function must take two inputs (a tick value ``x`` and a\nposition ``pos``), and return a string containing the corresponding\ntick label.\nSee the  `~matplotlib.ticker.FuncFormatter` documentation for\nmore information.",
      "docstring": "Set the formatter of the major ticker.\n\nIn addition to a `~matplotlib.ticker.Formatter` instance,\nthis also accepts a ``str`` or function.\n\nFor a ``str`` a `~matplotlib.ticker.StrMethodFormatter` is used.\nThe field used for the value must be labeled ``'x'`` and the field used\nfor the position must be labeled ``'pos'``.\nSee the  `~matplotlib.ticker.StrMethodFormatter` documentation for\nmore information.\n\nFor a function, a `~matplotlib.ticker.FuncFormatter` is used.\nThe function must take two inputs (a tick value ``x`` and a\nposition ``pos``), and return a string containing the corresponding\ntick label.\nSee the  `~matplotlib.ticker.FuncFormatter` documentation for\nmore information.\n\nParameters\n----------\nformatter : `~matplotlib.ticker.Formatter`, ``str``, or function",
      "code": "    def set_major_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the major ticker.\n\n        In addition to a `~matplotlib.ticker.Formatter` instance,\n        this also accepts a ``str`` or function.\n\n        For a ``str`` a `~matplotlib.ticker.StrMethodFormatter` is used.\n        The field used for the value must be labeled ``'x'`` and the field used\n        for the position must be labeled ``'pos'``.\n        See the  `~matplotlib.ticker.StrMethodFormatter` documentation for\n        more information.\n\n        For a function, a `~matplotlib.ticker.FuncFormatter` is used.\n        The function must take two inputs (a tick value ``x`` and a\n        position ``pos``), and return a string containing the corresponding\n        tick label.\n        See the  `~matplotlib.ticker.FuncFormatter` documentation for\n        more information.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`, ``str``, or function\n        \"\"\"\n        self._set_formatter(formatter, self.major)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_major_locator",
      "name": "set_major_locator",
      "qname": "lib.matplotlib.axis.Axis.set_major_locator",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_major_locator/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_major_locator.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_major_locator/locator",
          "name": "locator",
          "qname": "lib.matplotlib.axis.Axis.set_major_locator.locator",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.ticker.Locator`",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.ticker.Locator`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the locator of the major ticker.",
      "docstring": "Set the locator of the major ticker.\n\nParameters\n----------\nlocator : `~matplotlib.ticker.Locator`",
      "code": "    def set_major_locator(self, locator):\n        \"\"\"\n        Set the locator of the major ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        _api.check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_majloc = False\n        self.major.locator = locator\n        if self.major.formatter:\n            self.major.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_minor_formatter",
      "name": "set_minor_formatter",
      "qname": "lib.matplotlib.axis.Axis.set_minor_formatter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_minor_formatter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_minor_formatter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_minor_formatter/formatter",
          "name": "formatter",
          "qname": "lib.matplotlib.axis.Axis.set_minor_formatter.formatter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.ticker.Formatter`, ``str``, or function",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`~matplotlib.ticker.Formatter`"
              },
              {
                "kind": "NamedType",
                "name": "``str``"
              },
              {
                "kind": "NamedType",
                "name": "function"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the formatter of the minor ticker.\n\nIn addition to a `~matplotlib.ticker.Formatter` instance,\nthis also accepts a ``str`` or function.\nSee `.Axis.set_major_formatter` for more information.",
      "docstring": "Set the formatter of the minor ticker.\n\nIn addition to a `~matplotlib.ticker.Formatter` instance,\nthis also accepts a ``str`` or function.\nSee `.Axis.set_major_formatter` for more information.\n\nParameters\n----------\nformatter : `~matplotlib.ticker.Formatter`, ``str``, or function",
      "code": "    def set_minor_formatter(self, formatter):\n        \"\"\"\n        Set the formatter of the minor ticker.\n\n        In addition to a `~matplotlib.ticker.Formatter` instance,\n        this also accepts a ``str`` or function.\n        See `.Axis.set_major_formatter` for more information.\n\n        Parameters\n        ----------\n        formatter : `~matplotlib.ticker.Formatter`, ``str``, or function\n        \"\"\"\n        self._set_formatter(formatter, self.minor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_minor_locator",
      "name": "set_minor_locator",
      "qname": "lib.matplotlib.axis.Axis.set_minor_locator",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_minor_locator/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_minor_locator.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_minor_locator/locator",
          "name": "locator",
          "qname": "lib.matplotlib.axis.Axis.set_minor_locator.locator",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.ticker.Locator`",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.ticker.Locator`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the locator of the minor ticker.",
      "docstring": "Set the locator of the minor ticker.\n\nParameters\n----------\nlocator : `~matplotlib.ticker.Locator`",
      "code": "    def set_minor_locator(self, locator):\n        \"\"\"\n        Set the locator of the minor ticker.\n\n        Parameters\n        ----------\n        locator : `~matplotlib.ticker.Locator`\n        \"\"\"\n        _api.check_isinstance(mticker.Locator, locator=locator)\n        self.isDefault_minloc = False\n        self.minor.locator = locator\n        if self.minor.formatter:\n            self.minor.formatter._set_locator(locator)\n        locator.set_axis(self)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_pickradius",
      "name": "set_pickradius",
      "qname": "lib.matplotlib.axis.Axis.set_pickradius",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_pickradius/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_pickradius.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_pickradius/pickradius",
          "name": "pickradius",
          "qname": "lib.matplotlib.axis.Axis.set_pickradius.pickradius",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The acceptance radius for containment tests.\nSee also `.Axis.contains`."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the depth of the axis used by the picker.",
      "docstring": "Set the depth of the axis used by the picker.\n\nParameters\n----------\npickradius : float\n    The acceptance radius for containment tests.\n    See also `.Axis.contains`.",
      "code": "    def set_pickradius(self, pickradius):\n        \"\"\"\n        Set the depth of the axis used by the picker.\n\n        Parameters\n        ----------\n        pickradius : float\n            The acceptance radius for containment tests.\n            See also `.Axis.contains`.\n        \"\"\"\n        if not isinstance(pickradius, Number) or pickradius < 0:\n            raise ValueError(\"pick radius should be a distance\")\n        self._pickradius = pickradius"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_remove_overlapping_locs",
      "name": "set_remove_overlapping_locs",
      "qname": "lib.matplotlib.axis.Axis.set_remove_overlapping_locs",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_remove_overlapping_locs/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_remove_overlapping_locs.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_remove_overlapping_locs/val",
          "name": "val",
          "qname": "lib.matplotlib.axis.Axis.set_remove_overlapping_locs.val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_remove_overlapping_locs(self, val):\n        self._remove_overlapping_locs = bool(val)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_tick_params",
      "name": "set_tick_params",
      "qname": "lib.matplotlib.axis.Axis.set_tick_params",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_tick_params/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_tick_params.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_tick_params/which",
          "name": "which",
          "qname": "lib.matplotlib.axis.Axis.set_tick_params.which",
          "default_value": "'major'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_tick_params/reset",
          "name": "reset",
          "qname": "lib.matplotlib.axis.Axis.set_tick_params.reset",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_tick_params/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.Axis.set_tick_params.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set appearance parameters for ticks, ticklabels, and gridlines.\n\nFor documentation of keyword arguments, see\n:meth:`matplotlib.axes.Axes.tick_params`.",
      "docstring": "Set appearance parameters for ticks, ticklabels, and gridlines.\n\nFor documentation of keyword arguments, see\n:meth:`matplotlib.axes.Axes.tick_params`.",
      "code": "    def set_tick_params(self, which='major', reset=False, **kwargs):\n        \"\"\"\n        Set appearance parameters for ticks, ticklabels, and gridlines.\n\n        For documentation of keyword arguments, see\n        :meth:`matplotlib.axes.Axes.tick_params`.\n        \"\"\"\n        _api.check_in_list(['major', 'minor', 'both'], which=which)\n        kwtrans = self._translate_tick_params(kwargs)\n\n        # the kwargs are stored in self._major/minor_tick_kw so that any\n        # future new ticks will automatically get them\n        if reset:\n            if which in ['major', 'both']:\n                self._reset_major_tick_kw()\n                self._major_tick_kw.update(kwtrans)\n            if which in ['minor', 'both']:\n                self._reset_minor_tick_kw()\n                self._minor_tick_kw.update(kwtrans)\n            self.reset_ticks()\n        else:\n            if which in ['major', 'both']:\n                self._major_tick_kw.update(kwtrans)\n                for tick in self.majorTicks:\n                    tick._apply_params(**kwtrans)\n            if which in ['minor', 'both']:\n                self._minor_tick_kw.update(kwtrans)\n                for tick in self.minorTicks:\n                    tick._apply_params(**kwtrans)\n            # labelOn and labelcolor also apply to the offset text.\n            if 'label1On' in kwtrans or 'label2On' in kwtrans:\n                self.offsetText.set_visible(\n                    self._major_tick_kw.get('label1On', False)\n                    or self._major_tick_kw.get('label2On', False))\n            if 'labelcolor' in kwtrans:\n                self.offsetText.set_color(kwtrans['labelcolor'])\n\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticklabels",
      "name": "set_ticklabels",
      "qname": "lib.matplotlib.axis.Axis.set_ticklabels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticklabels/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_ticklabels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticklabels/ticklabels",
          "name": "ticklabels",
          "qname": "lib.matplotlib.axis.Axis.set_ticklabels.ticklabels",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "sequence of str or of `.Text`\\s",
            "default_value": "",
            "description": "Texts for labeling each tick location in the sequence set by\n`.Axis.set_ticks`; the number of labels must match the number of\nlocations."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "sequence of str"
              },
              {
                "kind": "NamedType",
                "name": "of `.Text`\\s"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticklabels/minor",
          "name": "minor",
          "qname": "lib.matplotlib.axis.Axis.set_ticklabels.minor",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "If True, set minor ticks instead of major ticks."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticklabels/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.Axis.set_ticklabels.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Text properties."
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "[*Discouraged*] Set the text values of the tick labels.\n\n.. admonition:: Discouraged\n\n    The use of this method is discouraged, because of the dependency\n    on tick positions. In most cases, you'll want to use\n    ``set_[x/y]ticks(positions, labels)`` instead.\n\n    If you are using this method, you should always fix the tick\n    positions before, e.g. by using `.Axis.set_ticks` or by explicitly\n    setting a `~.ticker.FixedLocator`. Otherwise, ticks are free to\n    move and the labels may end up in unexpected positions.",
      "docstring": "[*Discouraged*] Set the text values of the tick labels.\n\n.. admonition:: Discouraged\n\n    The use of this method is discouraged, because of the dependency\n    on tick positions. In most cases, you'll want to use\n    ``set_[x/y]ticks(positions, labels)`` instead.\n\n    If you are using this method, you should always fix the tick\n    positions before, e.g. by using `.Axis.set_ticks` or by explicitly\n    setting a `~.ticker.FixedLocator`. Otherwise, ticks are free to\n    move and the labels may end up in unexpected positions.\n\nParameters\n----------\nticklabels : sequence of str or of `.Text`\\s\n    Texts for labeling each tick location in the sequence set by\n    `.Axis.set_ticks`; the number of labels must match the number of\n    locations.\nminor : bool\n    If True, set minor ticks instead of major ticks.\n**kwargs\n    Text properties.\n\nReturns\n-------\nlist of `.Text`\\s\n    For each tick, includes ``tick.label1`` if it is visible, then\n    ``tick.label2`` if it is visible, in that order.",
      "code": "    def set_ticklabels(self, ticklabels, *, minor=False, **kwargs):\n        r\"\"\"\n        [*Discouraged*] Set the text values of the tick labels.\n\n        .. admonition:: Discouraged\n\n            The use of this method is discouraged, because of the dependency\n            on tick positions. In most cases, you'll want to use\n            ``set_[x/y]ticks(positions, labels)`` instead.\n\n            If you are using this method, you should always fix the tick\n            positions before, e.g. by using `.Axis.set_ticks` or by explicitly\n            setting a `~.ticker.FixedLocator`. Otherwise, ticks are free to\n            move and the labels may end up in unexpected positions.\n\n        Parameters\n        ----------\n        ticklabels : sequence of str or of `.Text`\\s\n            Texts for labeling each tick location in the sequence set by\n            `.Axis.set_ticks`; the number of labels must match the number of\n            locations.\n        minor : bool\n            If True, set minor ticks instead of major ticks.\n        **kwargs\n            Text properties.\n\n        Returns\n        -------\n        list of `.Text`\\s\n            For each tick, includes ``tick.label1`` if it is visible, then\n            ``tick.label2`` if it is visible, in that order.\n        \"\"\"\n        try:\n            ticklabels = [t.get_text() if hasattr(t, 'get_text') else t\n                          for t in ticklabels]\n        except TypeError:\n            raise TypeError(f\"{ticklabels:=} must be a sequence\") from None\n        locator = (self.get_minor_locator() if minor\n                   else self.get_major_locator())\n        if isinstance(locator, mticker.FixedLocator):\n            # Passing [] as a list of ticklabels is often used as a way to\n            # remove all tick labels, so only error for > 0 ticklabels\n            if len(locator.locs) != len(ticklabels) and len(ticklabels) != 0:\n                raise ValueError(\n                    \"The number of FixedLocator locations\"\n                    f\" ({len(locator.locs)}), usually from a call to\"\n                    \" set_ticks, does not match\"\n                    f\" the number of ticklabels ({len(ticklabels)}).\")\n            tickd = {loc: lab for loc, lab in zip(locator.locs, ticklabels)}\n            func = functools.partial(self._format_with_dict, tickd)\n            formatter = mticker.FuncFormatter(func)\n        else:\n            formatter = mticker.FixedFormatter(ticklabels)\n\n        if minor:\n            self.set_minor_formatter(formatter)\n            locs = self.get_minorticklocs()\n            ticks = self.get_minor_ticks(len(locs))\n        else:\n            self.set_major_formatter(formatter)\n            locs = self.get_majorticklocs()\n            ticks = self.get_major_ticks(len(locs))\n\n        ret = []\n        for pos, (loc, tick) in enumerate(zip(locs, ticks)):\n            tick.update_position(loc)\n            tick_label = formatter(loc, pos)\n            # deal with label1\n            tick.label1.set_text(tick_label)\n            tick.label1._internal_update(kwargs)\n            # deal with label2\n            tick.label2.set_text(tick_label)\n            tick.label2._internal_update(kwargs)\n            # only return visible tick labels\n            if tick.label1.get_visible():\n                ret.append(tick.label1)\n            if tick.label2.get_visible():\n                ret.append(tick.label2)\n\n        self.stale = True\n        return ret"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticks",
      "name": "set_ticks",
      "qname": "lib.matplotlib.axis.Axis.set_ticks",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticks/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_ticks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticks/ticks",
          "name": "ticks",
          "qname": "lib.matplotlib.axis.Axis.set_ticks.ticks",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "list of floats",
            "default_value": "",
            "description": "List of tick locations.  The axis `.Locator` is replaced by a\n`~.ticker.FixedLocator`.\n\nSome tick formatters will not label arbitrary tick positions;\ne.g. log formatters only label decade ticks by default. In\nsuch a case you can set a formatter explicitly on the axis\nusing `.Axis.set_major_formatter` or provide formatted\n*labels* yourself."
          },
          "type": {
            "kind": "NamedType",
            "name": "list of floats"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticks/labels",
          "name": "labels",
          "qname": "lib.matplotlib.axis.Axis.set_ticks.labels",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "list of str",
            "default_value": "",
            "description": "List of tick labels. If not set, the labels are generated with\nthe axis tick `.Formatter`."
          },
          "type": {
            "kind": "NamedType",
            "name": "list of str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticks/minor",
          "name": "minor",
          "qname": "lib.matplotlib.axis.Axis.set_ticks.minor",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If ``False``, set the major ticks; if ``True``, the minor ticks."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_ticks/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.Axis.set_ticks.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "`.Text` properties for the labels. These take effect only if you\npass *labels*. In other cases, please use `~.Axes.tick_params`."
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set this Axis' tick locations and optionally labels.\n\nIf necessary, the view limits of the Axis are expanded so that all\ngiven ticks are visible.",
      "docstring": "Set this Axis' tick locations and optionally labels.\n\nIf necessary, the view limits of the Axis are expanded so that all\ngiven ticks are visible.\n\nParameters\n----------\nticks : list of floats\n    List of tick locations.  The axis `.Locator` is replaced by a\n    `~.ticker.FixedLocator`.\n\n    Some tick formatters will not label arbitrary tick positions;\n    e.g. log formatters only label decade ticks by default. In\n    such a case you can set a formatter explicitly on the axis\n    using `.Axis.set_major_formatter` or provide formatted\n    *labels* yourself.\nlabels : list of str, optional\n    List of tick labels. If not set, the labels are generated with\n    the axis tick `.Formatter`.\nminor : bool, default: False\n    If ``False``, set the major ticks; if ``True``, the minor ticks.\n**kwargs\n    `.Text` properties for the labels. These take effect only if you\n    pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\nNotes\n-----\nThe mandatory expansion of the view limits is an intentional design\nchoice to prevent the surprise of a non-visible tick. If you need\nother limits, you should set the limits explicitly after setting the\nticks.",
      "code": "    def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n        \"\"\"\n        Set this Axis' tick locations and optionally labels.\n\n        If necessary, the view limits of the Axis are expanded so that all\n        given ticks are visible.\n\n        Parameters\n        ----------\n        ticks : list of floats\n            List of tick locations.  The axis `.Locator` is replaced by a\n            `~.ticker.FixedLocator`.\n\n            Some tick formatters will not label arbitrary tick positions;\n            e.g. log formatters only label decade ticks by default. In\n            such a case you can set a formatter explicitly on the axis\n            using `.Axis.set_major_formatter` or provide formatted\n            *labels* yourself.\n        labels : list of str, optional\n            List of tick labels. If not set, the labels are generated with\n            the axis tick `.Formatter`.\n        minor : bool, default: False\n            If ``False``, set the major ticks; if ``True``, the minor ticks.\n        **kwargs\n            `.Text` properties for the labels. These take effect only if you\n            pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n        Notes\n        -----\n        The mandatory expansion of the view limits is an intentional design\n        choice to prevent the surprise of a non-visible tick. If you need\n        other limits, you should set the limits explicitly after setting the\n        ticks.\n        \"\"\"\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        return result"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_units",
      "name": "set_units",
      "qname": "lib.matplotlib.axis.Axis.set_units",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_units/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_units.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_units/u",
          "name": "u",
          "qname": "lib.matplotlib.axis.Axis.set_units.u",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "units tag",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "units tag"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the units for axis.",
      "docstring": "Set the units for axis.\n\nParameters\n----------\nu : units tag\n\nNotes\n-----\nThe units of any shared axis will also be updated.",
      "code": "    def set_units(self, u):\n        \"\"\"\n        Set the units for axis.\n\n        Parameters\n        ----------\n        u : units tag\n\n        Notes\n        -----\n        The units of any shared axis will also be updated.\n        \"\"\"\n        if u == self.units:\n            return\n        for name, axis in self.axes._axis_map.items():\n            if self is axis:\n                shared = [\n                    getattr(ax, f\"{name}axis\")\n                    for ax\n                    in self.axes._shared_axes[name].get_siblings(self.axes)]\n                break\n        else:\n            shared = [self]\n        for axis in shared:\n            axis.units = u\n            axis._update_axisinfo()\n            axis.callbacks.process('units')\n            axis.callbacks.process('units finalize')\n            axis.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/set_view_interval",
      "name": "set_view_interval",
      "qname": "lib.matplotlib.axis.Axis.set_view_interval",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_view_interval/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.set_view_interval.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_view_interval/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.axis.Axis.set_view_interval.vmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_view_interval/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.axis.Axis.set_view_interval.vmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/set_view_interval/ignore",
          "name": "ignore",
          "qname": "lib.matplotlib.axis.Axis.set_view_interval.ignore",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the axis view limits.  This method is for internal use; Matplotlib\nusers should typically use e.g. `~.Axes.set_xlim` or `~.Axes.set_ylim`.\n\nIf *ignore* is False (the default), this method will never reduce the\npreexisting view limits, only expand them if *vmin* or *vmax* are not\nwithin them.  Moreover, the order of *vmin* and *vmax* does not matter;\nthe orientation of the axis will not change.\n\nIf *ignore* is True, the view limits will be set exactly to ``(vmin,\nvmax)`` in that order.",
      "docstring": "Set the axis view limits.  This method is for internal use; Matplotlib\nusers should typically use e.g. `~.Axes.set_xlim` or `~.Axes.set_ylim`.\n\nIf *ignore* is False (the default), this method will never reduce the\npreexisting view limits, only expand them if *vmin* or *vmax* are not\nwithin them.  Moreover, the order of *vmin* and *vmax* does not matter;\nthe orientation of the axis will not change.\n\nIf *ignore* is True, the view limits will be set exactly to ``(vmin,\nvmax)`` in that order.",
      "code": "    def set_view_interval(self, vmin, vmax, ignore=False):\n        \"\"\"\n        Set the axis view limits.  This method is for internal use; Matplotlib\n        users should typically use e.g. `~.Axes.set_xlim` or `~.Axes.set_ylim`.\n\n        If *ignore* is False (the default), this method will never reduce the\n        preexisting view limits, only expand them if *vmin* or *vmax* are not\n        within them.  Moreover, the order of *vmin* and *vmax* does not matter;\n        the orientation of the axis will not change.\n\n        If *ignore* is True, the view limits will be set exactly to ``(vmin,\n        vmax)`` in that order.\n        \"\"\"\n        raise NotImplementedError('Derived must override')"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Axis/update_units",
      "name": "update_units",
      "qname": "lib.matplotlib.axis.Axis.update_units",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/update_units/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Axis.update_units.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Axis/update_units/data",
          "name": "data",
          "qname": "lib.matplotlib.axis.Axis.update_units.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Introspect *data* for units converter and update the\naxis.converter instance if necessary. Return *True*\nif *data* is registered for unit conversion.",
      "docstring": "Introspect *data* for units converter and update the\naxis.converter instance if necessary. Return *True*\nif *data* is registered for unit conversion.",
      "code": "    def update_units(self, data):\n        \"\"\"\n        Introspect *data* for units converter and update the\n        axis.converter instance if necessary. Return *True*\n        if *data* is registered for unit conversion.\n        \"\"\"\n        converter = munits.registry.get_converter(data)\n        if converter is None:\n            return False\n\n        neednew = self.converter != converter\n        self.converter = converter\n        default = self.converter.default_units(data, self)\n        if default is not None and self.units is None:\n            self.set_units(default)\n\n        elif neednew:\n            self._update_axisinfo()\n        self.stale = True\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.axis.Tick.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/axes",
          "name": "axes",
          "qname": "lib.matplotlib.axis.Tick.__init__.axes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/loc",
          "name": "loc",
          "qname": "lib.matplotlib.axis.Tick.__init__.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/size",
          "name": "size",
          "qname": "lib.matplotlib.axis.Tick.__init__.size",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.axis.Tick.__init__.width",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/color",
          "name": "color",
          "qname": "lib.matplotlib.axis.Tick.__init__.color",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/tickdir",
          "name": "tickdir",
          "qname": "lib.matplotlib.axis.Tick.__init__.tickdir",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/pad",
          "name": "pad",
          "qname": "lib.matplotlib.axis.Tick.__init__.pad",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/labelsize",
          "name": "labelsize",
          "qname": "lib.matplotlib.axis.Tick.__init__.labelsize",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/labelcolor",
          "name": "labelcolor",
          "qname": "lib.matplotlib.axis.Tick.__init__.labelcolor",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/zorder",
          "name": "zorder",
          "qname": "lib.matplotlib.axis.Tick.__init__.zorder",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/gridOn",
          "name": "gridOn",
          "qname": "lib.matplotlib.axis.Tick.__init__.gridOn",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/tick1On",
          "name": "tick1On",
          "qname": "lib.matplotlib.axis.Tick.__init__.tick1On",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/tick2On",
          "name": "tick2On",
          "qname": "lib.matplotlib.axis.Tick.__init__.tick2On",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/label1On",
          "name": "label1On",
          "qname": "lib.matplotlib.axis.Tick.__init__.label1On",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/label2On",
          "name": "label2On",
          "qname": "lib.matplotlib.axis.Tick.__init__.label2On",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/major",
          "name": "major",
          "qname": "lib.matplotlib.axis.Tick.__init__.major",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/labelrotation",
          "name": "labelrotation",
          "qname": "lib.matplotlib.axis.Tick.__init__.labelrotation",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/grid_color",
          "name": "grid_color",
          "qname": "lib.matplotlib.axis.Tick.__init__.grid_color",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/grid_linestyle",
          "name": "grid_linestyle",
          "qname": "lib.matplotlib.axis.Tick.__init__.grid_linestyle",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/grid_linewidth",
          "name": "grid_linewidth",
          "qname": "lib.matplotlib.axis.Tick.__init__.grid_linewidth",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/grid_alpha",
          "name": "grid_alpha",
          "qname": "lib.matplotlib.axis.Tick.__init__.grid_alpha",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.Tick.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for the axis ticks, grid lines and labels.\n\nTicks mark a position on an Axis. They contain two lines as markers and\ntwo labels; one each for the bottom and top positions (in case of an\n`.XAxis`) or for the left and right positions (in case of a `.YAxis`).",
      "docstring": "bbox is the Bound2D bounding box in display coords of the Axes\nloc is the tick location in data coords\nsize is the tick size in points",
      "code": "    def __init__(\n        self, axes, loc, *,\n        size=None,  # points\n        width=None,\n        color=None,\n        tickdir=None,\n        pad=None,\n        labelsize=None,\n        labelcolor=None,\n        zorder=None,\n        gridOn=None,  # defaults to axes.grid depending on axes.grid.which\n        tick1On=True,\n        tick2On=True,\n        label1On=True,\n        label2On=False,\n        major=True,\n        labelrotation=0,\n        grid_color=None,\n        grid_linestyle=None,\n        grid_linewidth=None,\n        grid_alpha=None,\n        **kwargs,  # Other Line2D kwargs applied to gridlines.\n    ):\n        \"\"\"\n        bbox is the Bound2D bounding box in display coords of the Axes\n        loc is the tick location in data coords\n        size is the tick size in points\n        \"\"\"\n        super().__init__()\n\n        if gridOn is None:\n            if major and (mpl.rcParams['axes.grid.which']\n                          in ('both', 'major')):\n                gridOn = mpl.rcParams['axes.grid']\n            elif (not major) and (mpl.rcParams['axes.grid.which']\n                                  in ('both', 'minor')):\n                gridOn = mpl.rcParams['axes.grid']\n            else:\n                gridOn = False\n\n        self.set_figure(axes.figure)\n        self.axes = axes\n\n        self._loc = loc\n        self._major = major\n\n        name = self.__name__\n        major_minor = \"major\" if major else \"minor\"\n\n        if size is None:\n            size = mpl.rcParams[f\"{name}.{major_minor}.size\"]\n        self._size = size\n\n        if width is None:\n            width = mpl.rcParams[f\"{name}.{major_minor}.width\"]\n        self._width = width\n\n        if color is None:\n            color = mpl.rcParams[f\"{name}.color\"]\n\n        if pad is None:\n            pad = mpl.rcParams[f\"{name}.{major_minor}.pad\"]\n        self._base_pad = pad\n\n        if labelcolor is None:\n            labelcolor = mpl.rcParams[f\"{name}.labelcolor\"]\n\n        if labelcolor == 'inherit':\n            # inherit from tick color\n            labelcolor = mpl.rcParams[f\"{name}.color\"]\n\n        if labelsize is None:\n            labelsize = mpl.rcParams[f\"{name}.labelsize\"]\n\n        self._set_labelrotation(labelrotation)\n\n        if zorder is None:\n            if major:\n                zorder = mlines.Line2D.zorder + 0.01\n            else:\n                zorder = mlines.Line2D.zorder\n        self._zorder = zorder\n\n        if grid_color is None:\n            grid_color = mpl.rcParams[\"grid.color\"]\n        if grid_linestyle is None:\n            grid_linestyle = mpl.rcParams[\"grid.linestyle\"]\n        if grid_linewidth is None:\n            grid_linewidth = mpl.rcParams[\"grid.linewidth\"]\n        if grid_alpha is None and not mcolors._has_alpha_channel(grid_color):\n            # alpha precedence: kwarg > color alpha > rcParams['grid.alpha']\n            # Note: only resolve to rcParams if the color does not have alpha\n            # otherwise `grid(color=(1, 1, 1, 0.5))` would work like\n            #   grid(color=(1, 1, 1, 0.5), alpha=rcParams['grid.alpha'])\n            # so the that the rcParams default would override color alpha.\n            grid_alpha = mpl.rcParams[\"grid.alpha\"]\n        grid_kw = {k[5:]: v for k, v in kwargs.items()}\n\n        self.tick1line = mlines.Line2D(\n            [], [],\n            color=color, linestyle=\"none\", zorder=zorder, visible=tick1On,\n            markeredgecolor=color, markersize=size, markeredgewidth=width,\n        )\n        self.tick2line = mlines.Line2D(\n            [], [],\n            color=color, linestyle=\"none\", zorder=zorder, visible=tick2On,\n            markeredgecolor=color, markersize=size, markeredgewidth=width,\n        )\n        self.gridline = mlines.Line2D(\n            [], [],\n            color=grid_color, alpha=grid_alpha, visible=gridOn,\n            linestyle=grid_linestyle, linewidth=grid_linewidth, marker=\"\",\n            **grid_kw,\n        )\n        self.gridline.get_path()._interpolation_steps = \\\n            GRIDLINE_INTERPOLATION_STEPS\n        self.label1 = mtext.Text(\n            np.nan, np.nan,\n            fontsize=labelsize, color=labelcolor, visible=label1On,\n            rotation=self._labelrotation[1])\n        self.label2 = mtext.Text(\n            np.nan, np.nan,\n            fontsize=labelsize, color=labelcolor, visible=label2On,\n            rotation=self._labelrotation[1])\n\n        self._apply_tickdir(tickdir)\n\n        for artist in [self.tick1line, self.tick2line, self.gridline,\n                       self.label1, self.label2]:\n            self._set_artist_props(artist)\n\n        self.update_position(loc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/apply_tickdir",
      "name": "apply_tickdir",
      "qname": "lib.matplotlib.axis.Tick.apply_tickdir",
      "decorators": [
        "_api.deprecated('3.5', alternative='`.Axis.set_tick_params`')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/apply_tickdir/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.apply_tickdir.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/apply_tickdir/tickdir",
          "name": "tickdir",
          "qname": "lib.matplotlib.axis.Tick.apply_tickdir.tickdir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.5\", alternative=\"`.Axis.set_tick_params`\")\n    def apply_tickdir(self, tickdir):\n        self._apply_tickdir(tickdir)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/contains",
      "name": "contains",
      "qname": "lib.matplotlib.axis.Tick.contains",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/contains/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.contains.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/contains/mouseevent",
          "name": "mouseevent",
          "qname": "lib.matplotlib.axis.Tick.contains.mouseevent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Test whether the mouse event occurred in the Tick marks.\n\nThis function always returns false.  It is more useful to test if the\naxis as a whole contains the mouse rather than the set of tick marks.",
      "docstring": "Test whether the mouse event occurred in the Tick marks.\n\nThis function always returns false.  It is more useful to test if the\naxis as a whole contains the mouse rather than the set of tick marks.",
      "code": "    def contains(self, mouseevent):\n        \"\"\"\n        Test whether the mouse event occurred in the Tick marks.\n\n        This function always returns false.  It is more useful to test if the\n        axis as a whole contains the mouse rather than the set of tick marks.\n        \"\"\"\n        inside, info = self._default_contains(mouseevent)\n        if inside is not None:\n            return inside, info\n        return False, {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/draw",
      "name": "draw",
      "qname": "lib.matplotlib.axis.Tick.draw",
      "decorators": [
        "martist.allow_rasterization"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/draw/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.axis.Tick.draw.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @martist.allow_rasterization\n    def draw(self, renderer):\n        if not self.get_visible():\n            self.stale = False\n            return\n        renderer.open_group(self.__name__, gid=self.get_gid())\n        for artist in [self.gridline, self.tick1line, self.tick2line,\n                       self.label1, self.label2]:\n            artist.draw(renderer)\n        renderer.close_group(self.__name__)\n        self.stale = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/get_children",
      "name": "get_children",
      "qname": "lib.matplotlib.axis.Tick.get_children",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/get_children/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.get_children.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_children(self):\n        children = [self.tick1line, self.tick2line,\n                    self.gridline, self.label1, self.label2]\n        return children"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/get_loc",
      "name": "get_loc",
      "qname": "lib.matplotlib.axis.Tick.get_loc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/get_loc/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.get_loc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the tick location (data coords) as a scalar.",
      "docstring": "Return the tick location (data coords) as a scalar.",
      "code": "    def get_loc(self):\n        \"\"\"Return the tick location (data coords) as a scalar.\"\"\"\n        return self._loc"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/get_pad",
      "name": "get_pad",
      "qname": "lib.matplotlib.axis.Tick.get_pad",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/get_pad/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.get_pad.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the value of the tick label pad in points.",
      "docstring": "Get the value of the tick label pad in points.",
      "code": "    def get_pad(self):\n        \"\"\"Get the value of the tick label pad in points.\"\"\"\n        return self._base_pad"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/get_pad_pixels",
      "name": "get_pad_pixels",
      "qname": "lib.matplotlib.axis.Tick.get_pad_pixels",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/get_pad_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.get_pad_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    def get_pad_pixels(self):\n        return self.figure.dpi * self._base_pad / 72"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/get_tick_padding",
      "name": "get_tick_padding",
      "qname": "lib.matplotlib.axis.Tick.get_tick_padding",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/get_tick_padding/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.get_tick_padding.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the length of the tick outside of the Axes.",
      "docstring": "Get the length of the tick outside of the Axes.",
      "code": "    def get_tick_padding(self):\n        \"\"\"Get the length of the tick outside of the Axes.\"\"\"\n        padding = {\n            'in': 0.0,\n            'inout': 0.5,\n            'out': 1.0\n        }\n        return self._size * padding[self._tickdir]"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/get_tickdir",
      "name": "get_tickdir",
      "qname": "lib.matplotlib.axis.Tick.get_tickdir",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/get_tickdir/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.get_tickdir.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_tickdir(self):\n        return self._tickdir"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/get_view_interval",
      "name": "get_view_interval",
      "qname": "lib.matplotlib.axis.Tick.get_view_interval",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/get_view_interval/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.get_view_interval.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the view limits ``(min, max)`` of the axis the tick belongs to.",
      "docstring": "Return the view limits ``(min, max)`` of the axis the tick belongs to.",
      "code": "    def get_view_interval(self):\n        \"\"\"\n        Return the view limits ``(min, max)`` of the axis the tick belongs to.\n        \"\"\"\n        raise NotImplementedError('Derived must override')"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/label@getter",
      "name": "label",
      "qname": "lib.matplotlib.axis.Tick.label",
      "decorators": [
        "property",
        "_api.deprecated('3.1', alternative='Tick.label1', removal='3.8')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/label@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.label.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    @_api.deprecated(\"3.1\", alternative=\"Tick.label1\", removal=\"3.8\")\n    def label(self):\n        return self.label1"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/set_clip_path",
      "name": "set_clip_path",
      "qname": "lib.matplotlib.axis.Tick.set_clip_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_clip_path/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.set_clip_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_clip_path/clippath",
          "name": "clippath",
          "qname": "lib.matplotlib.axis.Tick.set_clip_path.clippath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_clip_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.axis.Tick.set_clip_path.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_clip_path(self, clippath, transform=None):\n        # docstring inherited\n        super().set_clip_path(clippath, transform)\n        self.gridline.set_clip_path(clippath, transform)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/set_label1",
      "name": "set_label1",
      "qname": "lib.matplotlib.axis.Tick.set_label1",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_label1/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.set_label1.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_label1/s",
          "name": "s",
          "qname": "lib.matplotlib.axis.Tick.set_label1.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the label1 text.",
      "docstring": "Set the label1 text.\n\nParameters\n----------\ns : str",
      "code": "    def set_label1(self, s):\n        \"\"\"\n        Set the label1 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label1.set_text(s)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/set_label2",
      "name": "set_label2",
      "qname": "lib.matplotlib.axis.Tick.set_label2",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_label2/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.set_label2.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_label2/s",
          "name": "s",
          "qname": "lib.matplotlib.axis.Tick.set_label2.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the label2 text.",
      "docstring": "Set the label2 text.\n\nParameters\n----------\ns : str",
      "code": "    def set_label2(self, s):\n        \"\"\"\n        Set the label2 text.\n\n        Parameters\n        ----------\n        s : str\n        \"\"\"\n        self.label2.set_text(s)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/set_pad",
      "name": "set_pad",
      "qname": "lib.matplotlib.axis.Tick.set_pad",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_pad/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.set_pad.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_pad/val",
          "name": "val",
          "qname": "lib.matplotlib.axis.Tick.set_pad.val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the tick label pad in points",
      "docstring": "Set the tick label pad in points\n\nParameters\n----------\nval : float",
      "code": "    def set_pad(self, val):\n        \"\"\"\n        Set the tick label pad in points\n\n        Parameters\n        ----------\n        val : float\n        \"\"\"\n        self._apply_params(pad=val)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/set_url",
      "name": "set_url",
      "qname": "lib.matplotlib.axis.Tick.set_url",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_url/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.set_url.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/set_url/url",
          "name": "url",
          "qname": "lib.matplotlib.axis.Tick.set_url.url",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the url of label1 and label2.",
      "docstring": "Set the url of label1 and label2.\n\nParameters\n----------\nurl : str",
      "code": "    def set_url(self, url):\n        \"\"\"\n        Set the url of label1 and label2.\n\n        Parameters\n        ----------\n        url : str\n        \"\"\"\n        super().set_url(url)\n        self.label1.set_url(url)\n        self.label2.set_url(url)\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Tick/update_position",
      "name": "update_position",
      "qname": "lib.matplotlib.axis.Tick.update_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/update_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Tick.update_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Tick/update_position/loc",
          "name": "loc",
          "qname": "lib.matplotlib.axis.Tick.update_position.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the location of tick in data coords with scalar *loc*.",
      "docstring": "Set the location of tick in data coords with scalar *loc*.",
      "code": "    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        raise NotImplementedError('Derived must override')"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Ticker/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.axis.Ticker.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Ticker/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Ticker.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A container for the objects defining tick position and format.",
      "docstring": "",
      "code": "    def __init__(self):\n        self._locator = None\n        self._formatter = None\n        self._locator_is_default = True\n        self._formatter_is_default = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Ticker/formatter@getter",
      "name": "formatter",
      "qname": "lib.matplotlib.axis.Ticker.formatter",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Ticker/formatter@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Ticker.formatter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def formatter(self):\n        return self._formatter"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Ticker/formatter@setter",
      "name": "formatter",
      "qname": "lib.matplotlib.axis.Ticker.formatter",
      "decorators": [
        "formatter.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Ticker/formatter@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Ticker.formatter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Ticker/formatter@setter/formatter",
          "name": "formatter",
          "qname": "lib.matplotlib.axis.Ticker.formatter.formatter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @formatter.setter\n    def formatter(self, formatter):\n        if not isinstance(formatter, mticker.Formatter):\n            raise TypeError('formatter must be a subclass of '\n                            'matplotlib.ticker.Formatter')\n        self._formatter = formatter"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Ticker/locator@getter",
      "name": "locator",
      "qname": "lib.matplotlib.axis.Ticker.locator",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Ticker/locator@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Ticker.locator.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def locator(self):\n        return self._locator"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/Ticker/locator@setter",
      "name": "locator",
      "qname": "lib.matplotlib.axis.Ticker.locator",
      "decorators": [
        "locator.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/Ticker/locator@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.Ticker.locator.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/Ticker/locator@setter/locator",
          "name": "locator",
          "qname": "lib.matplotlib.axis.Ticker.locator.locator",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @locator.setter\n    def locator(self, locator):\n        if not isinstance(locator, mticker.Locator):\n            raise TypeError('locator must be a subclass of '\n                            'matplotlib.ticker.Locator')\n        self._locator = locator"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.axis.XAxis.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.axis.XAxis.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.XAxis.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in axes coords, y in display coords (to be updated at draw time by\n        # _update_label_positions and _update_offset_text_position).\n        self.label.set(\n            x=0.5, y=0,\n            verticalalignment='top', horizontalalignment='center',\n            transform=mtransforms.blended_transform_factory(\n                self.axes.transAxes, mtransforms.IdentityTransform()),\n        )\n        self.label_position = 'bottom'\n        self.offsetText.set(\n            x=1, y=0,\n            verticalalignment='top', horizontalalignment='right',\n            transform=mtransforms.blended_transform_factory(\n                self.axes.transAxes, mtransforms.IdentityTransform()),\n            fontsize=mpl.rcParams['xtick.labelsize'],\n            color=mpl.rcParams['xtick.color'],\n        )\n        self.offset_text_position = 'bottom'"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/contains",
      "name": "contains",
      "qname": "lib.matplotlib.axis.XAxis.contains",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/contains/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.contains.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/contains/mouseevent",
          "name": "mouseevent",
          "qname": "lib.matplotlib.axis.XAxis.contains.mouseevent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Test whether the mouse event occurred in the x axis.",
      "docstring": "Test whether the mouse event occurred in the x axis.",
      "code": "    def contains(self, mouseevent):\n        \"\"\"Test whether the mouse event occurred in the x axis.\"\"\"\n        inside, info = self._default_contains(mouseevent)\n        if inside is not None:\n            return inside, info\n\n        x, y = mouseevent.x, mouseevent.y\n        try:\n            trans = self.axes.transAxes.inverted()\n            xaxes, yaxes = trans.transform((x, y))\n        except ValueError:\n            return False, {}\n        (l, b), (r, t) = self.axes.transAxes.transform([(0, 0), (1, 1)])\n        inaxis = 0 <= xaxes <= 1 and (\n            b - self._pickradius < y < b or\n            t < y < t + self._pickradius)\n        return inaxis, {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/get_minpos",
      "name": "get_minpos",
      "qname": "lib.matplotlib.axis.XAxis.get_minpos",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/get_minpos/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.get_minpos.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_minpos(self):\n        return self.axes.dataLim.minposx"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/get_text_heights",
      "name": "get_text_heights",
      "qname": "lib.matplotlib.axis.XAxis.get_text_heights",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/get_text_heights/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.get_text_heights.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/get_text_heights/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.axis.XAxis.get_text_heights.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return how much space should be reserved for text above and below the\nAxes, as a pair of floats.",
      "docstring": "Return how much space should be reserved for text above and below the\nAxes, as a pair of floats.",
      "code": "    @_api.deprecated(\"3.6\")\n    def get_text_heights(self, renderer):\n        \"\"\"\n        Return how much space should be reserved for text above and below the\n        Axes, as a pair of floats.\n        \"\"\"\n        bbox, bbox2 = self.get_ticklabel_extents(renderer)\n        # MGDTODO: Need a better way to get the pad\n        pad_pixels = self.majorTicks[0].get_pad_pixels()\n\n        above = 0.0\n        if bbox2.height:\n            above += bbox2.height + pad_pixels\n        below = 0.0\n        if bbox.height:\n            below += bbox.height + pad_pixels\n\n        if self.get_label_position() == 'top':\n            above += self.label.get_window_extent(renderer).height + pad_pixels\n        else:\n            below += self.label.get_window_extent(renderer).height + pad_pixels\n        return above, below"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/get_tick_space",
      "name": "get_tick_space",
      "qname": "lib.matplotlib.axis.XAxis.get_tick_space",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/get_tick_space/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.get_tick_space.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_tick_space(self):\n        ends = mtransforms.Bbox.unit().transformed(\n            self.axes.transAxes - self.figure.dpi_scale_trans)\n        length = ends.width * 72\n        # There is a heuristic here that the aspect ratio of tick text\n        # is no more than 3:1\n        size = self._get_tick_label_size('x') * 3\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/get_ticks_position",
      "name": "get_ticks_position",
      "qname": "lib.matplotlib.axis.XAxis.get_ticks_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/get_ticks_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.get_ticks_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the ticks position (\"top\", \"bottom\", \"default\", or \"unknown\").",
      "docstring": "Return the ticks position (\"top\", \"bottom\", \"default\", or \"unknown\").",
      "code": "    def get_ticks_position(self):\n        \"\"\"\n        Return the ticks position (\"top\", \"bottom\", \"default\", or \"unknown\").\n        \"\"\"\n        return {1: \"bottom\", 2: \"top\",\n                \"default\": \"default\", \"unknown\": \"unknown\"}[\n                    self._get_ticks_position()]"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/set_default_intervals",
      "name": "set_default_intervals",
      "qname": "lib.matplotlib.axis.XAxis.set_default_intervals",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/set_default_intervals/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.set_default_intervals.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_default_intervals(self):\n        # docstring inherited\n        # only change view if dataLim has not changed and user has\n        # not changed the view:\n        if (not self.axes.dataLim.mutatedx() and\n                not self.axes.viewLim.mutatedx()):\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    xmin, xmax = self.convert_units(info.default_limits)\n                    self.axes.viewLim.intervalx = xmin, xmax\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/set_label_position",
      "name": "set_label_position",
      "qname": "lib.matplotlib.axis.XAxis.set_label_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/set_label_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.set_label_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/set_label_position/position",
          "name": "position",
          "qname": "lib.matplotlib.axis.XAxis.set_label_position.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'top', 'bottom'}",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "bottom",
              "top"
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the label position (top or bottom)",
      "docstring": "Set the label position (top or bottom)\n\nParameters\n----------\nposition : {'top', 'bottom'}",
      "code": "    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (top or bottom)\n\n        Parameters\n        ----------\n        position : {'top', 'bottom'}\n        \"\"\"\n        self.label.set_verticalalignment(_api.check_getitem({\n            'top': 'baseline', 'bottom': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/set_ticks_position",
      "name": "set_ticks_position",
      "qname": "lib.matplotlib.axis.XAxis.set_ticks_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/set_ticks_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.set_ticks_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/set_ticks_position/position",
          "name": "position",
          "qname": "lib.matplotlib.axis.XAxis.set_ticks_position.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'top', 'bottom', 'both', 'default', 'none'}",
            "default_value": "",
            "description": "'both' sets the ticks to appear on both positions, but does not\nchange the tick labels.  'default' resets the tick positions to\nthe default: ticks on both positions, labels at bottom.  'none'\ncan be used if you don't want any ticks. 'none' and 'both'\naffect only the ticks, not the labels."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "top",
              "bottom",
              "default",
              "none",
              "both"
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the ticks position.",
      "docstring": "Set the ticks position.\n\nParameters\n----------\nposition : {'top', 'bottom', 'both', 'default', 'none'}\n    'both' sets the ticks to appear on both positions, but does not\n    change the tick labels.  'default' resets the tick positions to\n    the default: ticks on both positions, labels at bottom.  'none'\n    can be used if you don't want any ticks. 'none' and 'both'\n    affect only the ticks, not the labels.",
      "code": "    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position.\n\n        Parameters\n        ----------\n        position : {'top', 'bottom', 'both', 'default', 'none'}\n            'both' sets the ticks to appear on both positions, but does not\n            change the tick labels.  'default' resets the tick positions to\n            the default: ticks on both positions, labels at bottom.  'none'\n            can be used if you don't want any ticks. 'none' and 'both'\n            affect only the ticks, not the labels.\n        \"\"\"\n        _api.check_in_list(['top', 'bottom', 'both', 'default', 'none'],\n                           position=position)\n        if position == 'top':\n            self.set_tick_params(which='both', top=True, labeltop=True,\n                                 bottom=False, labelbottom=False)\n            self._tick_position = 'top'\n            self.offsetText.set_verticalalignment('bottom')\n        elif position == 'bottom':\n            self.set_tick_params(which='both', top=False, labeltop=False,\n                                 bottom=True, labelbottom=True)\n            self._tick_position = 'bottom'\n            self.offsetText.set_verticalalignment('top')\n        elif position == 'both':\n            self.set_tick_params(which='both', top=True,\n                                 bottom=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', top=False,\n                                 bottom=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', top=True, labeltop=False,\n                                 bottom=True, labelbottom=True)\n            self._tick_position = 'bottom'\n            self.offsetText.set_verticalalignment('top')\n        else:\n            assert False, \"unhandled parameter not caught by _check_in_list\"\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/tick_bottom",
      "name": "tick_bottom",
      "qname": "lib.matplotlib.axis.XAxis.tick_bottom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/tick_bottom/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.tick_bottom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move ticks and ticklabels (if present) to the bottom of the Axes.",
      "docstring": "Move ticks and ticklabels (if present) to the bottom of the Axes.",
      "code": "    def tick_bottom(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the bottom of the Axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('bottom')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labelbottom=label)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XAxis/tick_top",
      "name": "tick_top",
      "qname": "lib.matplotlib.axis.XAxis.tick_top",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XAxis/tick_top/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XAxis.tick_top.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move ticks and ticklabels (if present) to the top of the Axes.",
      "docstring": "Move ticks and ticklabels (if present) to the top of the Axes.",
      "code": "    def tick_top(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the top of the Axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('top')\n        # If labels were turned off before this was called, leave them off.\n        self.set_tick_params(which='both', labeltop=label)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XTick/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.axis.XTick.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XTick/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XTick.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/XTick/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.axis.XTick.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/XTick/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.XTick.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Contains all the Artists needed to make an x tick - the tick line,\nthe label text and the grid line",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in data coords, y in axes coords\n        ax = self.axes\n        self.tick1line.set(\n            data=([0], [0]), transform=ax.get_xaxis_transform(\"tick1\"))\n        self.tick2line.set(\n            data=([0], [1]), transform=ax.get_xaxis_transform(\"tick2\"))\n        self.gridline.set(\n            data=([0, 0], [0, 1]), transform=ax.get_xaxis_transform(\"grid\"))\n        # the y loc is 3 points below the min of y axis\n        trans, va, ha = self._get_text1_transform()\n        self.label1.set(\n            x=0, y=0,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )\n        trans, va, ha = self._get_text2_transform()\n        self.label2.set(\n            x=0, y=1,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XTick/get_view_interval",
      "name": "get_view_interval",
      "qname": "lib.matplotlib.axis.XTick.get_view_interval",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XTick/get_view_interval/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XTick.get_view_interval.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervalx"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/XTick/update_position",
      "name": "update_position",
      "qname": "lib.matplotlib.axis.XTick.update_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/XTick/update_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.XTick.update_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/XTick/update_position/loc",
          "name": "loc",
          "qname": "lib.matplotlib.axis.XTick.update_position.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the location of tick in data coords with scalar *loc*.",
      "docstring": "Set the location of tick in data coords with scalar *loc*.",
      "code": "    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_xdata((loc,))\n        self.tick2line.set_xdata((loc,))\n        self.gridline.set_xdata((loc,))\n        self.label1.set_x(loc)\n        self.label2.set_x(loc)\n        self._loc = loc\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.axis.YAxis.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.axis.YAxis.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.YAxis.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in display coords, y in axes coords (to be updated at draw time by\n        # _update_label_positions and _update_offset_text_position).\n        self.label.set(\n            x=0, y=0.5,\n            verticalalignment='bottom', horizontalalignment='center',\n            rotation='vertical', rotation_mode='anchor',\n            transform=mtransforms.blended_transform_factory(\n                mtransforms.IdentityTransform(), self.axes.transAxes),\n        )\n        self.label_position = 'left'\n        # x in axes coords, y in display coords(!).\n        self.offsetText.set(\n            x=0, y=0.5,\n            verticalalignment='baseline', horizontalalignment='left',\n            transform=mtransforms.blended_transform_factory(\n                self.axes.transAxes, mtransforms.IdentityTransform()),\n            fontsize=mpl.rcParams['ytick.labelsize'],\n            color=mpl.rcParams['ytick.color'],\n        )\n        self.offset_text_position = 'left'"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/contains",
      "name": "contains",
      "qname": "lib.matplotlib.axis.YAxis.contains",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/contains/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.contains.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/contains/mouseevent",
          "name": "mouseevent",
          "qname": "lib.matplotlib.axis.YAxis.contains.mouseevent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def contains(self, mouseevent):\n        # docstring inherited\n        inside, info = self._default_contains(mouseevent)\n        if inside is not None:\n            return inside, info\n\n        x, y = mouseevent.x, mouseevent.y\n        try:\n            trans = self.axes.transAxes.inverted()\n            xaxes, yaxes = trans.transform((x, y))\n        except ValueError:\n            return False, {}\n        (l, b), (r, t) = self.axes.transAxes.transform([(0, 0), (1, 1)])\n        inaxis = 0 <= yaxes <= 1 and (\n            l - self._pickradius < x < l or\n            r < x < r + self._pickradius)\n        return inaxis, {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/get_minpos",
      "name": "get_minpos",
      "qname": "lib.matplotlib.axis.YAxis.get_minpos",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/get_minpos/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.get_minpos.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_minpos(self):\n        return self.axes.dataLim.minposy"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/get_text_widths",
      "name": "get_text_widths",
      "qname": "lib.matplotlib.axis.YAxis.get_text_widths",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/get_text_widths/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.get_text_widths.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/get_text_widths/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.axis.YAxis.get_text_widths.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    def get_text_widths(self, renderer):\n        bbox, bbox2 = self.get_ticklabel_extents(renderer)\n        # MGDTODO: Need a better way to get the pad\n        pad_pixels = self.majorTicks[0].get_pad_pixels()\n\n        left = 0.0\n        if bbox.width:\n            left += bbox.width + pad_pixels\n        right = 0.0\n        if bbox2.width:\n            right += bbox2.width + pad_pixels\n\n        if self.get_label_position() == 'left':\n            left += self.label.get_window_extent(renderer).width + pad_pixels\n        else:\n            right += self.label.get_window_extent(renderer).width + pad_pixels\n        return left, right"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/get_tick_space",
      "name": "get_tick_space",
      "qname": "lib.matplotlib.axis.YAxis.get_tick_space",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/get_tick_space/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.get_tick_space.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_tick_space(self):\n        ends = mtransforms.Bbox.unit().transformed(\n            self.axes.transAxes - self.figure.dpi_scale_trans)\n        length = ends.height * 72\n        # Having a spacing of at least 2 just looks good.\n        size = self._get_tick_label_size('y') * 2\n        if size > 0:\n            return int(np.floor(length / size))\n        else:\n            return 2**31 - 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/get_ticks_position",
      "name": "get_ticks_position",
      "qname": "lib.matplotlib.axis.YAxis.get_ticks_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/get_ticks_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.get_ticks_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the ticks position (\"left\", \"right\", \"default\", or \"unknown\").",
      "docstring": "Return the ticks position (\"left\", \"right\", \"default\", or \"unknown\").",
      "code": "    def get_ticks_position(self):\n        \"\"\"\n        Return the ticks position (\"left\", \"right\", \"default\", or \"unknown\").\n        \"\"\"\n        return {1: \"left\", 2: \"right\",\n                \"default\": \"default\", \"unknown\": \"unknown\"}[\n                    self._get_ticks_position()]"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/set_default_intervals",
      "name": "set_default_intervals",
      "qname": "lib.matplotlib.axis.YAxis.set_default_intervals",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/set_default_intervals/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.set_default_intervals.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_default_intervals(self):\n        # docstring inherited\n        # only change view if dataLim has not changed and user has\n        # not changed the view:\n        if (not self.axes.dataLim.mutatedy() and\n                not self.axes.viewLim.mutatedy()):\n            if self.converter is not None:\n                info = self.converter.axisinfo(self.units, self)\n                if info.default_limits is not None:\n                    ymin, ymax = self.convert_units(info.default_limits)\n                    self.axes.viewLim.intervaly = ymin, ymax\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/set_label_position",
      "name": "set_label_position",
      "qname": "lib.matplotlib.axis.YAxis.set_label_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/set_label_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.set_label_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/set_label_position/position",
          "name": "position",
          "qname": "lib.matplotlib.axis.YAxis.set_label_position.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'left', 'right'}",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "left",
              "right"
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the label position (left or right)",
      "docstring": "Set the label position (left or right)\n\nParameters\n----------\nposition : {'left', 'right'}",
      "code": "    def set_label_position(self, position):\n        \"\"\"\n        Set the label position (left or right)\n\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        self.label.set_rotation_mode('anchor')\n        self.label.set_verticalalignment(_api.check_getitem({\n            'left': 'bottom', 'right': 'top',\n        }, position=position))\n        self.label_position = position\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/set_offset_position",
      "name": "set_offset_position",
      "qname": "lib.matplotlib.axis.YAxis.set_offset_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/set_offset_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.set_offset_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/set_offset_position/position",
          "name": "position",
          "qname": "lib.matplotlib.axis.YAxis.set_offset_position.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'left', 'right'}",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "left",
              "right"
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Parameters\n----------\nposition : {'left', 'right'}",
      "code": "    def set_offset_position(self, position):\n        \"\"\"\n        Parameters\n        ----------\n        position : {'left', 'right'}\n        \"\"\"\n        x, y = self.offsetText.get_position()\n        x = _api.check_getitem({'left': 0, 'right': 1}, position=position)\n\n        self.offsetText.set_ha(position)\n        self.offsetText.set_position((x, y))\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/set_ticks_position",
      "name": "set_ticks_position",
      "qname": "lib.matplotlib.axis.YAxis.set_ticks_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/set_ticks_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.set_ticks_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/set_ticks_position/position",
          "name": "position",
          "qname": "lib.matplotlib.axis.YAxis.set_ticks_position.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'left', 'right', 'both', 'default', 'none'}",
            "default_value": "",
            "description": "'both' sets the ticks to appear on both positions, but does not\nchange the tick labels.  'default' resets the tick positions to\nthe default: ticks on both positions, labels at left.  'none'\ncan be used if you don't want any ticks. 'none' and 'both'\naffect only the ticks, not the labels."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "left",
              "default",
              "right",
              "none",
              "both"
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the ticks position.",
      "docstring": "Set the ticks position.\n\nParameters\n----------\nposition : {'left', 'right', 'both', 'default', 'none'}\n    'both' sets the ticks to appear on both positions, but does not\n    change the tick labels.  'default' resets the tick positions to\n    the default: ticks on both positions, labels at left.  'none'\n    can be used if you don't want any ticks. 'none' and 'both'\n    affect only the ticks, not the labels.",
      "code": "    def set_ticks_position(self, position):\n        \"\"\"\n        Set the ticks position.\n\n        Parameters\n        ----------\n        position : {'left', 'right', 'both', 'default', 'none'}\n            'both' sets the ticks to appear on both positions, but does not\n            change the tick labels.  'default' resets the tick positions to\n            the default: ticks on both positions, labels at left.  'none'\n            can be used if you don't want any ticks. 'none' and 'both'\n            affect only the ticks, not the labels.\n        \"\"\"\n        _api.check_in_list(['left', 'right', 'both', 'default', 'none'],\n                           position=position)\n        if position == 'right':\n            self.set_tick_params(which='both', right=True, labelright=True,\n                                 left=False, labelleft=False)\n            self.set_offset_position(position)\n        elif position == 'left':\n            self.set_tick_params(which='both', right=False, labelright=False,\n                                 left=True, labelleft=True)\n            self.set_offset_position(position)\n        elif position == 'both':\n            self.set_tick_params(which='both', right=True,\n                                 left=True)\n        elif position == 'none':\n            self.set_tick_params(which='both', right=False,\n                                 left=False)\n        elif position == 'default':\n            self.set_tick_params(which='both', right=True, labelright=False,\n                                 left=True, labelleft=True)\n        else:\n            assert False, \"unhandled parameter not caught by _check_in_list\"\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/tick_left",
      "name": "tick_left",
      "qname": "lib.matplotlib.axis.YAxis.tick_left",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/tick_left/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.tick_left.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move ticks and ticklabels (if present) to the left of the Axes.",
      "docstring": "Move ticks and ticklabels (if present) to the left of the Axes.",
      "code": "    def tick_left(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the left of the Axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('left')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelleft=label)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YAxis/tick_right",
      "name": "tick_right",
      "qname": "lib.matplotlib.axis.YAxis.tick_right",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YAxis/tick_right/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YAxis.tick_right.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move ticks and ticklabels (if present) to the right of the Axes.",
      "docstring": "Move ticks and ticklabels (if present) to the right of the Axes.",
      "code": "    def tick_right(self):\n        \"\"\"\n        Move ticks and ticklabels (if present) to the right of the Axes.\n        \"\"\"\n        label = True\n        if 'label1On' in self._major_tick_kw:\n            label = (self._major_tick_kw['label1On']\n                     or self._major_tick_kw['label2On'])\n        self.set_ticks_position('right')\n        # if labels were turned off before this was called\n        # leave them off\n        self.set_tick_params(which='both', labelright=label)"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YTick/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.axis.YTick.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YTick/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YTick.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YTick/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.axis.YTick.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YTick/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.axis.YTick.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Contains all the Artists needed to make a Y tick - the tick line,\nthe label text and the grid line",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # x in axes coords, y in data coords\n        ax = self.axes\n        self.tick1line.set(\n            data=([0], [0]), transform=ax.get_yaxis_transform(\"tick1\"))\n        self.tick2line.set(\n            data=([1], [0]), transform=ax.get_yaxis_transform(\"tick2\"))\n        self.gridline.set(\n            data=([0, 1], [0, 0]), transform=ax.get_yaxis_transform(\"grid\"))\n        # the y loc is 3 points below the min of y axis\n        trans, va, ha = self._get_text1_transform()\n        self.label1.set(\n            x=0, y=0,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )\n        trans, va, ha = self._get_text2_transform()\n        self.label2.set(\n            x=1, y=0,\n            verticalalignment=va, horizontalalignment=ha, transform=trans,\n        )"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YTick/get_view_interval",
      "name": "get_view_interval",
      "qname": "lib.matplotlib.axis.YTick.get_view_interval",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YTick/get_view_interval/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YTick.get_view_interval.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_view_interval(self):\n        # docstring inherited\n        return self.axes.viewLim.intervaly"
    },
    {
      "id": "matplotlib/lib.matplotlib.axis/YTick/update_position",
      "name": "update_position",
      "qname": "lib.matplotlib.axis.YTick.update_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.axis/YTick/update_position/self",
          "name": "self",
          "qname": "lib.matplotlib.axis.YTick.update_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.axis/YTick/update_position/loc",
          "name": "loc",
          "qname": "lib.matplotlib.axis.YTick.update_position.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the location of tick in data coords with scalar *loc*.",
      "docstring": "Set the location of tick in data coords with scalar *loc*.",
      "code": "    def update_position(self, loc):\n        \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n        self.tick1line.set_ydata((loc,))\n        self.tick2line.set_ydata((loc,))\n        self.gridline.set_ydata((loc,))\n        self.label1.set_y(loc)\n        self.label2.set_y(loc)\n        self._loc = loc\n        self.stale = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/buffer_rgba",
      "name": "buffer_rgba",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.buffer_rgba",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/buffer_rgba/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.buffer_rgba.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the image as a `memoryview` to the renderer's buffer.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "docstring": "Get the image as a `memoryview` to the renderer's buffer.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "code": "    def buffer_rgba(self):\n        \"\"\"\n        Get the image as a `memoryview` to the renderer's buffer.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.buffer_rgba()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox",
      "name": "copy_from_bbox",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.copy_from_bbox",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.copy_from_bbox.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.copy_from_bbox.bbox",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def copy_from_bbox(self, bbox):\n        renderer = self.get_renderer()\n        return renderer.copy_from_bbox(bbox)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        # docstring inherited\n        self.renderer = self.get_renderer()\n        self.renderer.clear()\n        # Acquire a lock on the shared font cache.\n        with RendererAgg.lock, \\\n             (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self.figure.draw(self.renderer)\n            # A GUI class may be need to update a window using this draw, so\n            # don't forget to call the superclass.\n            super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer",
      "name": "get_renderer",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer",
      "decorators": [
        "_api.delete_parameter('3.6', 'cleared', alternative='renderer.clear()')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer/cleared",
          "name": "cleared",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer.cleared",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg",
      "name": "print_jpg",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_jpg(self, filename_or_obj, *args, pil_kwargs=None):\n        # savefig() has already applied savefig.facecolor; we now set it to\n        # white to make imsave() blend semi-transparent figures against an\n        # assumed white background.\n        with mpl.rc_context({\"savefig.facecolor\": \"white\"}):\n            self._print_pil(filename_or_obj, \"jpeg\", pil_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "The file to write to."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "Metadata in the PNG file as key-value pairs of bytes or latin-1\nencodable strings.\nAccording to the PNG specification, keys must be shorter than 79\nchars.\n\nThe `PNG specification`_ defines some common keywords that may be\nused as appropriate:\n\n- Title: Short (one line) title or caption for image.\n- Author: Name of image's creator.\n- Description: Description of image (possibly long).\n- Copyright: Copyright notice.\n- Creation Time: Time of original image creation\n  (usually RFC 1123 format).\n- Software: Software used to create the image.\n- Disclaimer: Legal disclaimer.\n- Warning: Warning of nature of content.\n- Source: Device used to create the image.\n- Comment: Miscellaneous comment;\n  conversion from other image format.\n\nOther keywords may be invented for other purposes.\n\nIf 'Software' is not given, an autogenerated value for Matplotlib\nwill be used.  This can be removed by setting it to *None*.\n\nFor more details see the `PNG specification`_.\n\n.. _PNG specification:                 https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords"
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "Keyword arguments passed to `PIL.Image.Image.save`.\n\nIf the 'pnginfo' key is present, it completely overrides\n*metadata*, including the default 'Software' key."
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write the figure to a PNG file.",
      "docstring": "Write the figure to a PNG file.\n\nParameters\n----------\nfilename_or_obj : str or path-like or file-like\n    The file to write to.\n\nmetadata : dict, optional\n    Metadata in the PNG file as key-value pairs of bytes or latin-1\n    encodable strings.\n    According to the PNG specification, keys must be shorter than 79\n    chars.\n\n    The `PNG specification`_ defines some common keywords that may be\n    used as appropriate:\n\n    - Title: Short (one line) title or caption for image.\n    - Author: Name of image's creator.\n    - Description: Description of image (possibly long).\n    - Copyright: Copyright notice.\n    - Creation Time: Time of original image creation\n      (usually RFC 1123 format).\n    - Software: Software used to create the image.\n    - Disclaimer: Legal disclaimer.\n    - Warning: Warning of nature of content.\n    - Source: Device used to create the image.\n    - Comment: Miscellaneous comment;\n      conversion from other image format.\n\n    Other keywords may be invented for other purposes.\n\n    If 'Software' is not given, an autogenerated value for Matplotlib\n    will be used.  This can be removed by setting it to *None*.\n\n    For more details see the `PNG specification`_.\n\n    .. _PNG specification:                 https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\npil_kwargs : dict, optional\n    Keyword arguments passed to `PIL.Image.Image.save`.\n\n    If the 'pnginfo' key is present, it completely overrides\n    *metadata*, including the default 'Software' key.",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_png(self, filename_or_obj, *args,\n                  metadata=None, pil_kwargs=None):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for Matplotlib\n            will be used.  This can be removed by setting it to *None*.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            Keyword arguments passed to `PIL.Image.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n        self._print_pil(filename_or_obj, \"png\", pil_kwargs, metadata)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw",
      "name": "print_raw",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_raw(self, filename_or_obj, *args):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        with cbook.open_file_cm(filename_or_obj, \"wb\") as fh:\n            fh.write(renderer.buffer_rgba())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif",
      "name": "print_tif",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_tif(self, filename_or_obj, *, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"tiff\", pil_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_to_buffer",
      "name": "print_to_buffer",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_to_buffer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_to_buffer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_to_buffer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        return (bytes(renderer.buffer_rgba()),\n                (int(renderer.width), int(renderer.height)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp",
      "name": "print_webp",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_webp",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_webp.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_webp.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_webp.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_webp(self, filename_or_obj, *, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"webp\", pil_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region",
      "name": "restore_region",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/region",
          "name": "region",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.region",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/xy",
          "name": "xy",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.xy",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def restore_region(self, region, bbox=None, xy=None):\n        renderer = self.get_renderer()\n        return renderer.restore_region(region, bbox, xy)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_argb",
      "name": "tostring_argb",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_argb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_argb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_argb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the image as ARGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "docstring": "Get the image as ARGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "code": "    def tostring_argb(self):\n        \"\"\"\n        Get the image as ARGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_argb()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_rgb",
      "name": "tostring_rgb",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_rgb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_rgb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_rgb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the image as RGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "docstring": "Get the image as RGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "code": "    def tostring_rgb(self):\n        \"\"\"\n        Get the image as RGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_rgb()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__getstate__",
      "name": "__getstate__",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__getstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__getstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__getstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles",
      "docstring": "",
      "code": "    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('Agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__",
      "name": "__setstate__",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__setstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__setstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__/state",
          "name": "state",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__setstate__.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/buffer_rgba",
      "name": "buffer_rgba",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.buffer_rgba",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/buffer_rgba/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.buffer_rgba.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def buffer_rgba(self):\n        return memoryview(self._renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/clear",
      "name": "clear",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def clear(self):\n        self._renderer.clear()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext",
      "name": "draw_mathtext",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw mathtext using :mod:`matplotlib.mathtext`.",
      "docstring": "Draw mathtext using :mod:`matplotlib.mathtext`.",
      "code": "    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw mathtext using :mod:`matplotlib.mathtext`.\"\"\"\n        ox, oy, width, height, descent, font_image = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        xd = descent * sin(radians(angle))\n        yd = descent * cos(radians(angle))\n        x = round(x + ox + xd)\n        y = round(y - oy + yd)\n        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        nmax = mpl.rcParams['agg.path.chunksize']  # here at least for testing\n        npts = path.vertices.shape[0]\n\n        if (npts > nmax > 100 and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts / nmax)\n            chsize = int(np.ceil(npts / nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1, :]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO  # move to end of last chunk\n                p = Path(v, c)\n                p.simplify_threshold = path.simplify_threshold\n                try:\n                    self._renderer.draw_path(gc, p, transform, rgbFace)\n                except OverflowError:\n                    msg = (\n                        \"Exceeded cell block limit in Agg.\\n\\n\"\n                        \"Please reduce the value of \"\n                        f\"rcParams['agg.path.chunksize'] (currently {nmax}) \"\n                        \"or increase the path simplification threshold\"\n                        \"(rcParams['path.simplify_threshold'] = \"\n                        f\"{mpl.rcParams['path.simplify_threshold']:.2f} by \"\n                        \"default and path.simplify_threshold = \"\n                        f\"{path.simplify_threshold:.2f} on the input).\"\n                    )\n                    raise OverflowError(msg) from None\n        else:\n            try:\n                self._renderer.draw_path(gc, path, transform, rgbFace)\n            except OverflowError:\n                cant_chunk = ''\n                if rgbFace is not None:\n                    cant_chunk += \"- can not split filled path\\n\"\n                if gc.get_hatch() is not None:\n                    cant_chunk += \"- can not split hatched path\\n\"\n                if not path.should_simplify:\n                    cant_chunk += \"- path.should_simplify is False\\n\"\n                if len(cant_chunk):\n                    msg = (\n                        \"Exceeded cell block limit in Agg, however for the \"\n                        \"following reasons:\\n\\n\"\n                        f\"{cant_chunk}\\n\"\n                        \"we can not automatically split up this path to draw.\"\n                        \"\\n\\nPlease manually simplify your path.\"\n                    )\n\n                else:\n                    inc_threshold = (\n                        \"or increase the path simplification threshold\"\n                        \"(rcParams['path.simplify_threshold'] = \"\n                        f\"{mpl.rcParams['path.simplify_threshold']} \"\n                        \"by default and path.simplify_threshold \"\n                        f\"= {path.simplify_threshold} \"\n                        \"on the input).\"\n                        )\n                    if nmax > 100:\n                        msg = (\n                            \"Exceeded cell block limit in Agg.  Please reduce \"\n                            \"the value of rcParams['agg.path.chunksize'] \"\n                            f\"(currently {nmax}) {inc_threshold}\"\n                        )\n                    else:\n                        msg = (\n                            \"Exceeded cell block limit in Agg.  Please set \"\n                            \"the value of rcParams['agg.path.chunksize'], \"\n                            f\"(currently {nmax}) to be greater than 100 \"\n                            + inc_threshold\n                        )\n\n                raise OverflowError(msg) from None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        # todo, handle props, angle, origins\n        size = prop.get_size_in_points()\n\n        texmanager = self.get_texmanager()\n\n        Z = texmanager.get_grey(s, size, self.dpi)\n        Z = np.array(Z * 255.0, np.uint8)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xd)\n        y = round(y + yd)\n        self._renderer.draw_text_image(Z, x, y, angle, gc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n        font = self._prepare_font(prop)\n        # We pass '0' for angle here, since it will be rotated (in raster\n        # space) in the following call to draw_text_image).\n        font.set_text(s, 0, flags=get_hinting_flag())\n        font.draw_glyphs_to_bitmap(\n            antialiased=mpl.rcParams['text.antialiased'])\n        d = font.get_descent() / 64.0\n        # The descent needs to be adjusted for the angle.\n        xo, yo = font.get_bitmap_offset()\n        xo /= 64.0\n        yo /= 64.0\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xo + xd)\n        y = round(y + yo + yd)\n        self._renderer.draw_text_image(font, x, y + 1, angle, gc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        _api.check_in_list([\"TeX\", True, False], ismath=ismath)\n        if ismath == \"TeX\":\n            # todo: handle props\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(\n                s, fontsize, renderer=self)\n            return w, h, d\n\n        if ismath:\n            ox, oy, width, height, descent, font_image = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        font = self._prepare_font(prop)\n        font.set_text(s, 0.0, flags=get_hinting_flag())\n        w, h = font.get_width_height()  # width and height of unrotated string\n        d = font.get_descent()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d /= 64.0\n        return w, h, d"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_image_nocomposite",
      "name": "option_image_nocomposite",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_image_nocomposite/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_image_nocomposite(self):\n        # docstring inherited\n\n        # It is generally faster to composite each image directly to\n        # the Figure, and there's no file size benefit to compositing\n        # with the Agg backend\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_scale_image",
      "name": "option_scale_image",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_scale_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_scale_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_scale_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_scale_image(self):\n        # docstring inherited\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * self.dpi / 72"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region",
      "name": "restore_region",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/region",
          "name": "region",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.region",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/xy",
          "name": "xy",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.xy",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Restore the saved region. If bbox (instance of BboxBase, or\nits extents) is given, only the region specified by the bbox\nwill be restored. *xy* (a pair of floats) optionally\nspecifies the new position (the LLC of the original region,\nnot the LLC of the bbox) where the region will be restored.\n\n>>> region = renderer.copy_from_bbox()\n>>> x1, y1, x2, y2 = region.get_extents()\n>>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n...                         xy=(x1-dx, y1))",
      "docstring": "Restore the saved region. If bbox (instance of BboxBase, or\nits extents) is given, only the region specified by the bbox\nwill be restored. *xy* (a pair of floats) optionally\nspecifies the new position (the LLC of the original region,\nnot the LLC of the bbox) where the region will be restored.\n\n>>> region = renderer.copy_from_bbox()\n>>> x1, y1, x2, y2 = region.get_extents()\n>>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n...                         xy=(x1-dx, y1))",
      "code": "    def restore_region(self, region, bbox=None, xy=None):\n        \"\"\"\n        Restore the saved region. If bbox (instance of BboxBase, or\n        its extents) is given, only the region specified by the bbox\n        will be restored. *xy* (a pair of floats) optionally\n        specifies the new position (the LLC of the original region,\n        not the LLC of the bbox) where the region will be restored.\n\n        >>> region = renderer.copy_from_bbox()\n        >>> x1, y1, x2, y2 = region.get_extents()\n        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n        ...                         xy=(x1-dx, y1))\n\n        \"\"\"\n        if bbox is not None or xy is not None:\n            if bbox is None:\n                x1, y1, x2, y2 = region.get_extents()\n            elif isinstance(bbox, BboxBase):\n                x1, y1, x2, y2 = bbox.extents\n            else:\n                x1, y1, x2, y2 = bbox\n\n            if xy is None:\n                ox, oy = x1, y1\n            else:\n                ox, oy = xy\n\n            # The incoming data is float, but the _renderer type-checking wants\n            # to see integers.\n            self._renderer.restore_region(region, int(x1), int(y1),\n                                          int(x2), int(y2), int(ox), int(oy))\n\n        else:\n            self._renderer.restore_region(region)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/start_filter",
      "name": "start_filter",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.start_filter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/start_filter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.start_filter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Start filtering. It simply create a new canvas (the old one is saved).",
      "docstring": "Start filtering. It simply create a new canvas (the old one is saved).",
      "code": "    def start_filter(self):\n        \"\"\"\n        Start filtering. It simply create a new canvas (the old one is saved).\n        \"\"\"\n        self._filter_renderers.append(self._renderer)\n        self._renderer = _RendererAgg(int(self.width), int(self.height),\n                                      self.dpi)\n        self._update_methods()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter",
      "name": "stop_filter",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter/post_processing",
          "name": "post_processing",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter.post_processing",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save the plot in the current canvas as a image and apply\nthe *post_processing* function.\n\n   def post_processing(image, dpi):\n     # ny, nx, depth = image.shape\n     # image (numpy array) has RGBA channels and has a depth of 4.\n     ...\n     # create a new_image (numpy array of 4 channels, size can be\n     # different). The resulting image may have offsets from\n     # lower-left corner of the original image\n     return new_image, offset_x, offset_y\n\nThe saved renderer is restored and the returned image from\npost_processing is plotted (using draw_image) on it.",
      "docstring": "Save the plot in the current canvas as a image and apply\nthe *post_processing* function.\n\n   def post_processing(image, dpi):\n     # ny, nx, depth = image.shape\n     # image (numpy array) has RGBA channels and has a depth of 4.\n     ...\n     # create a new_image (numpy array of 4 channels, size can be\n     # different). The resulting image may have offsets from\n     # lower-left corner of the original image\n     return new_image, offset_x, offset_y\n\nThe saved renderer is restored and the returned image from\npost_processing is plotted (using draw_image) on it.",
      "code": "    def stop_filter(self, post_processing):\n        \"\"\"\n        Save the plot in the current canvas as a image and apply\n        the *post_processing* function.\n\n           def post_processing(image, dpi):\n             # ny, nx, depth = image.shape\n             # image (numpy array) has RGBA channels and has a depth of 4.\n             ...\n             # create a new_image (numpy array of 4 channels, size can be\n             # different). The resulting image may have offsets from\n             # lower-left corner of the original image\n             return new_image, offset_x, offset_y\n\n        The saved renderer is restored and the returned image from\n        post_processing is plotted (using draw_image) on it.\n        \"\"\"\n        orig_img = np.asarray(self.buffer_rgba())\n        slice_y, slice_x = cbook._get_nonzero_slices(orig_img[..., 3])\n        cropped_img = orig_img[slice_y, slice_x]\n\n        self._renderer = self._filter_renderers.pop()\n        self._update_methods()\n\n        if cropped_img.size:\n            img, ox, oy = post_processing(cropped_img / 255, self.dpi)\n            gc = self.new_gc()\n            if img.dtype.kind == 'f':\n                img = np.asarray(img * 255., np.uint8)\n            self._renderer.draw_image(\n                gc, slice_x.start + ox, int(self.height) - slice_y.stop + oy,\n                img[::-1])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_argb",
      "name": "tostring_argb",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_argb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_argb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_argb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def tostring_argb(self):\n        return np.asarray(self._renderer).take([3, 0, 1, 2], axis=2).tobytes()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgb",
      "name": "tostring_rgb",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def tostring_rgb(self):\n        return np.asarray(self._renderer).take([0, 1, 2], axis=2).tobytes()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/get_hinting_flag",
      "name": "get_hinting_flag",
      "qname": "lib.matplotlib.backends.backend_agg.get_hinting_flag",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_hinting_flag():\n    mapping = {\n        'default': LOAD_DEFAULT,\n        'no_autohint': LOAD_NO_AUTOHINT,\n        'force_autohint': LOAD_FORCE_AUTOHINT,\n        'no_hinting': LOAD_NO_HINTING,\n        True: LOAD_FORCE_AUTOHINT,\n        False: LOAD_NO_HINTING,\n        'either': LOAD_DEFAULT,\n        'native': LOAD_NO_AUTOHINT,\n        'auto': LOAD_FORCE_AUTOHINT,\n        'none': LOAD_NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox",
      "name": "copy_from_bbox",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.copy_from_bbox",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.copy_from_bbox.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.copy_from_bbox.bbox",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def copy_from_bbox(self, bbox):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"copy_from_bbox only works when rendering to an ImageSurface\")\n        sw = surface.get_width()\n        sh = surface.get_height()\n        x0 = math.ceil(bbox.x0)\n        x1 = math.floor(bbox.x1)\n        y0 = math.ceil(sh - bbox.y1)\n        y1 = math.floor(sh - bbox.y0)\n        if not (0 <= x0 and x1 <= sw and bbox.x0 <= bbox.x1\n                and 0 <= y0 and y1 <= sh and bbox.y0 <= bbox.y1):\n            raise ValueError(\"Invalid bbox\")\n        sls = slice(y0, y0 + max(y1 - y0, 0)), slice(x0, x0 + max(x1 - x0, 0))\n        data = (np.frombuffer(surface.get_data(), np.uint32)\n                .reshape((sh, sw))[sls].copy())\n        return _CairoRegion(sls, data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/get_renderer",
      "name": "get_renderer",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.get_renderer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/get_renderer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.get_renderer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_renderer(self):\n        return self._renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_png",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_png.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_png(self, fobj):\n        self._get_printed_image_surface().write_to_png(fobj)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba",
      "name": "print_rgba",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_rgba",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_rgba.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_rgba.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_rgba(self, fobj):\n        width, height = self.get_width_height()\n        buf = self._get_printed_image_surface().get_data()\n        fobj.write(cbook._premultiplied_argb32_to_unmultiplied_rgba8888(\n            np.asarray(buf).reshape((width, height, 4))))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region",
      "name": "restore_region",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.restore_region",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.restore_region.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region/region",
          "name": "region",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.restore_region.region",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def restore_region(self, region):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"restore_region only works when rendering to an ImageSurface\")\n        surface.flush()\n        sw = surface.get_width()\n        sh = surface.get_height()\n        sly, slx = region._slices\n        (np.frombuffer(surface.get_data(), np.uint32)\n         .reshape((sh, sw))[sly, slx]) = region._data\n        surface.mark_dirty_rectangle(\n            slx.start, sly.start, slx.stop - slx.start, sly.stop - sly.start)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.__init__.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, renderer):\n        super().__init__()\n        self.renderer = renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/get_rgb",
      "name": "get_rgb",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.get_rgb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/get_rgb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.get_rgb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_rgb(self):\n        return self.ctx.get_source().get_rgba()[:3]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/restore",
      "name": "restore",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.restore",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/restore/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.restore.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def restore(self):\n        self.ctx.restore()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha",
      "name": "set_alpha",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_alpha",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_alpha.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_alpha.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_alpha(self, alpha):\n        super().set_alpha(alpha)\n        _alpha = self.get_alpha()\n        rgb = self._rgb\n        if self.get_forced_alpha():\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], _alpha)\n        else:\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], rgb[3])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_antialiased",
      "name": "set_antialiased",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_antialiased",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_antialiased/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_antialiased.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_antialiased/b",
          "name": "b",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_antialiased.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_antialiased(self, b):\n        self.ctx.set_antialias(\n            cairo.ANTIALIAS_DEFAULT if b else cairo.ANTIALIAS_NONE)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle",
      "name": "set_capstyle",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_capstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_capstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle/cs",
          "name": "cs",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_capstyle.cs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_capstyle(self, cs):\n        self.ctx.set_line_cap(_api.check_getitem(self._capd, capstyle=cs))\n        self._capstyle = cs"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path",
      "name": "set_clip_path",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_clip_path(self, path):\n        if not path:\n            return\n        tpath, affine = path.get_transformed_path_and_affine()\n        ctx = self.ctx\n        ctx.new_path()\n        affine = (affine\n                  + Affine2D().scale(1, -1).translate(0, self.renderer.height))\n        _append_path(ctx, tpath, affine)\n        ctx.clip()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle",
      "name": "set_clip_rectangle",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_rectangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_rectangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle/rectangle",
          "name": "rectangle",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_rectangle.rectangle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_clip_rectangle(self, rectangle):\n        if not rectangle:\n            return\n        x, y, w, h = np.round(rectangle.bounds)\n        ctx = self.ctx\n        ctx.new_path()\n        ctx.rectangle(x, self.renderer.height - h - y, w, h)\n        ctx.clip()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes",
      "name": "set_dashes",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes/offset",
          "name": "offset",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes.offset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes/dashes",
          "name": "dashes",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes.dashes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_dashes(self, offset, dashes):\n        self._dashes = offset, dashes\n        if dashes is None:\n            self.ctx.set_dash([], 0)  # switch dashes off\n        else:\n            self.ctx.set_dash(\n                list(self.renderer.points_to_pixels(np.asarray(dashes))),\n                offset)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground",
      "name": "set_foreground",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground/fg",
          "name": "fg",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground.fg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground/isRGBA",
          "name": "isRGBA",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground.isRGBA",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_foreground(self, fg, isRGBA=None):\n        super().set_foreground(fg, isRGBA)\n        if len(self._rgb) == 3:\n            self.ctx.set_source_rgb(*self._rgb)\n        else:\n            self.ctx.set_source_rgba(*self._rgb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle",
      "name": "set_joinstyle",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_joinstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_joinstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle/js",
          "name": "js",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_joinstyle.js",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_joinstyle(self, js):\n        self.ctx.set_line_join(_api.check_getitem(self._joind, joinstyle=js))\n        self._joinstyle = js"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth",
      "name": "set_linewidth",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_linewidth",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_linewidth.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth/w",
          "name": "w",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_linewidth.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linewidth(self, w):\n        self._linewidth = float(w)\n        self.ctx.set_line_width(self.renderer.points_to_pixels(w))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, dpi):\n        self.dpi = dpi\n        self.gc = GraphicsContextCairo(renderer=self)\n        self.width = None\n        self.height = None\n        self.text_ctx = cairo.Context(\n           cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1))\n        super().__init__()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im):\n        im = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(im[::-1])\n        surface = cairo.ImageSurface.create_for_data(\n            im.ravel().data, cairo.FORMAT_ARGB32,\n            im.shape[1], im.shape[0], im.shape[1] * 4)\n        ctx = gc.ctx\n        y = self.height - y - im.shape[0]\n\n        ctx.save()\n        ctx.set_source_surface(surface, float(x), float(y))\n        ctx.paint()\n        ctx.restore()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(self, gc, marker_path, marker_trans, path, transform,\n                     rgbFace=None):\n        # docstring inherited\n\n        ctx = gc.ctx\n        ctx.new_path()\n        # Create the path for the marker; it needs to be flipped here already!\n        _append_path(ctx, marker_path, marker_trans + Affine2D().scale(1, -1))\n        marker_path = ctx.copy_path_flat()\n\n        # Figure out whether the path has a fill\n        x1, y1, x2, y2 = ctx.fill_extents()\n        if x1 == 0 and y1 == 0 and x2 == 0 and y2 == 0:\n            filled = False\n            # No fill, just unset this (so we don't try to fill it later on)\n            rgbFace = None\n        else:\n            filled = True\n\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n\n        ctx.new_path()\n        for i, (vertices, codes) in enumerate(\n                path.iter_segments(transform, simplify=False)):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ctx.save()\n\n                # Translate and apply path\n                ctx.translate(x, y)\n                ctx.append_path(marker_path)\n\n                ctx.restore()\n\n                # Slower code path if there is a fill; we need to draw\n                # the fill and stroke for each marker at the same time.\n                # Also flush out the drawing every once in a while to\n                # prevent the paths from getting way too long.\n                if filled or i % 1000 == 0:\n                    self._fill_and_stroke(\n                        ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n        # Fast path, if there is no fill, draw everything in one step\n        if not filled:\n            self._fill_and_stroke(\n                ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        ctx = gc.ctx\n        # Clip the path to the actual rendering extents if it isn't filled.\n        clip = (ctx.clip_extents()\n                if rgbFace is None and gc.get_hatch() is None\n                else None)\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n        ctx.new_path()\n        _append_path(ctx, path, transform, clip)\n        self._fill_and_stroke(\n            ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # Note: (x, y) are device/display coords, not user-coords, unlike other\n        # draw_* methods\n        if ismath:\n            self._draw_mathtext(gc, x, y, s, prop, angle)\n\n        else:\n            ctx = gc.ctx\n            ctx.new_path()\n            ctx.move_to(x, y)\n\n            ctx.save()\n            ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n            ctx.set_font_size(self.points_to_pixels(prop.get_size_in_points()))\n            opts = cairo.FontOptions()\n            opts.set_antialias(\n                cairo.ANTIALIAS_DEFAULT if mpl.rcParams[\"text.antialiased\"]\n                else cairo.ANTIALIAS_NONE)\n            ctx.set_font_options(opts)\n            if angle:\n                ctx.rotate(np.deg2rad(-angle))\n            ctx.show_text(s)\n            ctx.restore()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath == 'TeX':\n            return super().get_text_width_height_descent(s, prop, ismath)\n\n        if ismath:\n            width, height, descent, *_ = \\\n                self._text2path.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        ctx = self.text_ctx\n        # problem - scale remembers last setting and font can become\n        # enormous causing program to crash\n        # save/restore prevents the problem\n        ctx.save()\n        ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n        ctx.set_font_size(self.points_to_pixels(prop.get_size_in_points()))\n\n        y_bearing, w, h = ctx.text_extents(s)[1:4]\n        ctx.restore()\n\n        return w, h, h + y_bearing"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        self.gc.ctx.save()\n        self.gc._alpha = 1\n        self.gc._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        return self.gc"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points / 72 * self.dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_context",
      "name": "set_context",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_context",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_context/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_context.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_context/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_context.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_context(self, ctx):\n        surface = ctx.get_target()\n        if hasattr(surface, \"get_width\") and hasattr(surface, \"get_height\"):\n            size = surface.get_width(), surface.get_height()\n        elif hasattr(surface, \"get_extents\"):  # GTK4 RecordingSurface.\n            ext = surface.get_extents()\n            size = ext.width, ext.height\n        else:  # vector surfaces.\n            ctx.save()\n            ctx.reset_clip()\n            rect, *rest = ctx.copy_clip_rectangle_list()\n            if rest:\n                raise TypeError(\"Cannot infer surface size\")\n            size = rect.width, rect.height\n            ctx.restore()\n        self.gc.ctx = ctx\n        self.width, self.height = size"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface",
      "name": "set_ctx_from_surface",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_ctx_from_surface",
      "decorators": [
        "_api.deprecated('3.6', alternative='set_context')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_ctx_from_surface.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface/surface",
          "name": "surface",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_ctx_from_surface.surface",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\", alternative=\"set_context\")\n    def set_ctx_from_surface(self, surface):\n        self.gc.ctx = cairo.Context(surface)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height",
      "name": "set_width_height",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    def set_width_height(self, width, height):\n        self.width = width\n        self.height = height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.__init__.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event",
      "name": "button_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event",
      "name": "button_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_release_event(self, widget, event):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event",
      "name": "configure_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def configure_event(self, widget, event):\n        if widget.get_property(\"window\") is None:\n            return\n        w = event.width * self.device_pixel_ratio\n        h = event.height * self.device_pixel_ratio\n        if w < 3 or h < 3:\n            return  # empty fig\n        # resize the figure (in inches)\n        dpi = self.figure.dpi\n        self.figure.set_size_inches(w / dpi, h / dpi, forward=False)\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self):\n        CloseEvent(\"close_event\", self)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event",
      "name": "enter_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_notify_event(self, widget, event):\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/flush_events",
      "name": "flush_events",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.flush_events",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/flush_events/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.flush_events.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flush_events(self):\n        # docstring inherited\n        context = GLib.MainContext.default()\n        while context.pending():\n            context.iteration(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event",
      "name": "key_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_press_event(self, widget, event):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event",
      "name": "key_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_release_event(self, widget, event):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event",
      "name": "leave_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_notify_event(self, widget, event):\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event",
      "name": "motion_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK3Agg or GTK3Cairo\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event",
      "name": "scroll_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def scroll_event(self, widget, event):\n        step = 1 if event.direction == Gdk.ScrollDirection.UP else -1\n        MouseEvent(\"scroll_event\", self, *self._mpl_coords(event), step=step,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        # docstring inherited\n        window = self.get_property(\"window\")\n        if window is not None:\n            window.set_cursor(_mpl_to_gtk_cursor(cursor))\n            context = GLib.MainContext.default()\n            context.iteration(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate",
      "name": "size_allocate",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate/allocation",
          "name": "allocation",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate.allocation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        if Gtk.check_version(3, 20, 0) is None:\n            self._show_shortcuts_window()\n        else:\n            self._show_shortcuts_dialog()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__",
      "decorators": [
        "_api.delete_parameter('3.6', 'window')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__/window",
          "name": "window",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__.window",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.6\", \"window\")\n    def __init__(self, canvas, window=None):\n        self._win = window\n        GObject.GObject.__init__(self)\n\n        self.set_style(Gtk.ToolbarStyle.ICONS)\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.insert(Gtk.SeparatorToolItem(), -1)\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            self._gtk_ids[text] = button = (\n                Gtk.ToggleToolButton() if callback in ['zoom', 'pan'] else\n                Gtk.ToolButton())\n            button.set_label(text)\n            button.set_icon_widget(image)\n            # Save the handler id, so that we can block it as needed.\n            button._signal_handler = button.connect(\n                'clicked', getattr(self, callback))\n            button.set_tooltip_text(tooltip_text)\n            self.insert(button, -1)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        toolitem.set_expand(True)  # Push real message to the right.\n        toolitem.add(label)\n\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        self.message = Gtk.Label()\n        self.message.set_justify(Gtk.Justification.RIGHT)\n        toolitem.add(self.message)\n\n        self.show_all()\n\n        _NavigationToolbar2GTK.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        dialog = Gtk.FileChooserDialog(\n            title=\"Save the figure\",\n            parent=self.canvas.get_toplevel(),\n            action=Gtk.FileChooserAction.SAVE,\n            buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,\n                     Gtk.STOCK_SAVE,   Gtk.ResponseType.OK),\n        )\n        for name, fmts \\\n                in self.canvas.get_supported_filetypes_grouped().items():\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(f'*.{fmt}')\n            dialog.add_filter(ff)\n            if self.canvas.get_default_filetype() in fmts:\n                dialog.set_filter(ff)\n\n        @functools.partial(dialog.connect, \"notify::filter\")\n        def on_notify_filter(*args):\n            name = dialog.get_filter().get_name()\n            fmt = self.canvas.get_supported_filetypes_grouped()[name][0]\n            dialog.set_current_name(\n                str(Path(dialog.get_current_name()).with_suffix(f'.{fmt}')))\n\n        dialog.set_current_folder(mpl.rcParams[\"savefig.directory\"])\n        dialog.set_current_name(self.canvas.get_default_filename())\n        dialog.set_do_overwrite_confirmation(True)\n\n        response = dialog.run()\n        fname = dialog.get_filename()\n        ff = dialog.get_filter()  # Doesn't autoadjust to filename :/\n        fmt = self.canvas.get_supported_filetypes_grouped()[ff.get_name()][0]\n        dialog.destroy()\n        if response != Gtk.ResponseType.OK:\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n        try:\n            self.canvas.figure.savefig(fname, format=fmt)\n        except Exception as e:\n            dialog = Gtk.MessageDialog(\n                parent=self.canvas.get_toplevel(), message_format=str(e),\n                type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK)\n            dialog.run()\n            dialog.destroy()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK3.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        NavigationToolbar2GTK3.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        window = self.canvas.get_window()\n        x, y, width, height = window.get_geometry()\n        pb = Gdk.pixbuf_get_from_window(window, x, y, width, height)\n        clipboard.set_image(pb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.pack_end(self._message, False, False, 0)\n        self.show_all()\n        self._groups = {}\n        self._toolitems = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleToolButton()\n        else:\n            button = Gtk.ToolButton()\n        button.set_label(name)\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            button.set_icon_widget(image)\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        button.show_all()\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event(f'{name} not in toolbar', self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self._message.set_label(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/error_msg_gtk",
      "name": "error_msg_gtk",
      "qname": "lib.matplotlib.backends.backend_gtk3.error_msg_gtk",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/error_msg_gtk/msg",
          "name": "msg",
          "qname": "lib.matplotlib.backends.backend_gtk3.error_msg_gtk.msg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/error_msg_gtk/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_gtk3.error_msg_gtk.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef error_msg_gtk(msg, parent=None):\n    if parent is not None:  # find the toplevel Gtk.Window\n        parent = parent.get_toplevel()\n        if not parent.is_toplevel():\n            parent = None\n    if not isinstance(msg, str):\n        msg = ','.join(map(str, msg))\n    dialog = Gtk.MessageDialog(\n        parent=parent, type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK,\n        message_format=msg)\n    dialog.run()\n    dialog.destroy()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._bbox_queue = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # If bbox is None, blit the entire canvas to gtk. Otherwise\n        # blit only the area defined by the bbox.\n        if bbox is None:\n            bbox = self.figure.bbox\n\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        x = int(bbox.x0 / scale)\n        y = allocation.height - int(bbox.y1 / scale)\n        width = (int(bbox.x1) - int(bbox.x0)) // scale\n        height = (int(bbox.y1) - int(bbox.y0)) // scale\n\n        self._bbox_queue.append(bbox)\n        self.queue_draw_area(x, y, width, height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        w = allocation.width * scale\n        h = allocation.height * scale\n\n        if not len(self._bbox_queue):\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            bbox_queue = [transforms.Bbox([[0, 0], [w, h]])]\n        else:\n            bbox_queue = self._bbox_queue\n\n        for bbox in bbox_queue:\n            x = int(bbox.x0)\n            y = h - int(bbox.y1)\n            width = int(bbox.x1) - int(bbox.x0)\n            height = int(bbox.y1) - int(bbox.y0)\n\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                np.asarray(self.copy_from_bbox(bbox)))\n            image = cairo.ImageSurface.create_for_data(\n                buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n            image.set_device_scale(scale, scale)\n            ctx.set_source_surface(image, x / scale, y / scale)\n            ctx.paint()\n\n        if len(self._bbox_queue):\n            self._bbox_queue = []\n\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            scale = self.device_pixel_ratio\n            # Scale physical drawing to logical size.\n            ctx.scale(1 / scale, 1 / scale)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.__init__.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self.set_hexpand(True)\n        self.set_vexpand(True)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.set_draw_func(self._draw_func)\n        self.connect('resize', self.resize_event)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n\n        click = Gtk.GestureClick()\n        click.set_button(0)  # All buttons.\n        click.connect('pressed', self.button_press_event)\n        click.connect('released', self.button_release_event)\n        self.add_controller(click)\n\n        key = Gtk.EventControllerKey()\n        key.connect('key-pressed', self.key_press_event)\n        key.connect('key-released', self.key_release_event)\n        self.add_controller(key)\n\n        motion = Gtk.EventControllerMotion()\n        motion.connect('motion', self.motion_notify_event)\n        motion.connect('enter', self.enter_notify_event)\n        motion.connect('leave', self.leave_notify_event)\n        self.add_controller(motion)\n\n        scroll = Gtk.EventControllerScroll.new(\n            Gtk.EventControllerScrollFlags.VERTICAL)\n        scroll.connect('scroll', self.scroll_event)\n        self.add_controller(scroll)\n\n        self.set_focusable(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event",
      "name": "button_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/n_press",
          "name": "n_press",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.n_press",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_press_event(self, controller, n_press, x, y):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords((x, y)), controller.get_current_button()\n                   )._process()\n        self.grab_focus()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event",
      "name": "button_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/n_press",
          "name": "n_press",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.n_press",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_release_event(self, controller, n_press, x, y):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords((x, y)), controller.get_current_button()\n                   )._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self):\n        self.close_event()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event",
      "name": "enter_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._mpl_coords((x, y)))._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/flush_events",
      "name": "flush_events",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.flush_events",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/flush_events/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.flush_events.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flush_events(self):\n        # docstring inherited\n        context = GLib.MainContext.default()\n        while context.pending():\n            context.iteration(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event",
      "name": "key_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/keyval",
          "name": "keyval",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.keyval",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/keycode",
          "name": "keycode",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.keycode",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/state",
          "name": "state",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_press_event(self, controller, keyval, keycode, state):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(keyval, keycode, state), *self._mpl_coords()\n                 )._process()\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event",
      "name": "key_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/keyval",
          "name": "keyval",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.keyval",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/keycode",
          "name": "keycode",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.keycode",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/state",
          "name": "state",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_release_event(self, controller, keyval, keycode, state):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(keyval, keycode, state), *self._mpl_coords()\n                 )._process()\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/leave_notify_event",
      "name": "leave_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.leave_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/leave_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.leave_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/leave_notify_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.leave_notify_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_notify_event(self, controller):\n        LocationEvent(\"figure_leave_event\", self,\n                      *self._mpl_coords())._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event",
      "name": "motion_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def motion_notify_event(self, controller, x, y):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._mpl_coords((x, y)))._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK4Agg or GTK4Cairo\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event",
      "name": "resize_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event/area",
          "name": "area",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event.area",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event",
      "name": "scroll_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event/dx",
          "name": "dx",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event.dx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event/dy",
          "name": "dy",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event.dy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def scroll_event(self, controller, dx, dy):\n        MouseEvent(\"scroll_event\", self,\n                   *self._mpl_coords(), step=dy)._process()\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        # docstring inherited\n        self.set_cursor_from_name(_backend_gtk.mpl_to_gtk_cursor_name(cursor))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk4.HelpGTK4.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.HelpGTK4.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk4.HelpGTK4.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        section = Gtk.ShortcutsSection()\n\n        for name, tool in sorted(self.toolmanager.tools.items()):\n            if not tool.description:\n                continue\n\n            # Putting everything in a separate group allows GTK to\n            # automatically split them into separate columns/pages, which is\n            # useful because we have lots of shortcuts, some with many keys\n            # that are very wide.\n            group = Gtk.ShortcutsGroup()\n            section.append(group)\n            # A hack to remove the title since we have no group naming.\n            child = group.get_first_child()\n            while child is not None:\n                child.set_visible(False)\n                child = child.get_next_sibling()\n\n            shortcut = Gtk.ShortcutsShortcut(\n                accelerator=' '.join(\n                    self._normalize_shortcut(key)\n                    for key in self.toolmanager.get_tool_keymap(name)\n                    if self._is_valid_shortcut(key)),\n                title=tool.name,\n                subtitle=tool.description)\n            group.append(shortcut)\n\n        window = Gtk.ShortcutsWindow(\n            title='Help',\n            modal=True,\n            transient_for=self._figure.canvas.get_root())\n        window.set_child(section)\n\n        window.show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.__init__",
      "decorators": [
        "_api.delete_parameter('3.6', 'window')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__/window",
          "name": "window",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.__init__.window",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.6\", \"window\")\n    def __init__(self, canvas, window=None):\n        self._win = window\n        Gtk.Box.__init__(self)\n\n        self.add_css_class('toolbar')\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.append(Gtk.Separator())\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))))\n            self._gtk_ids[text] = button = (\n                Gtk.ToggleButton() if callback in ['zoom', 'pan'] else\n                Gtk.Button())\n            button.set_child(image)\n            button.add_css_class('flat')\n            button.add_css_class('image-button')\n            # Save the handler id, so that we can block it as needed.\n            button._signal_handler = button.connect(\n                'clicked', getattr(self, callback))\n            button.set_tooltip_text(tooltip_text)\n            self.append(button)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self.message = Gtk.Label()\n        self.message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self.message)\n\n        _NavigationToolbar2GTK.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        dialog = Gtk.FileChooserNative(\n            title='Save the figure',\n            transient_for=self.canvas.get_root(),\n            action=Gtk.FileChooserAction.SAVE,\n            modal=True)\n        self._save_dialog = dialog  # Must keep a reference.\n\n        ff = Gtk.FileFilter()\n        ff.set_name('All files')\n        ff.add_pattern('*')\n        dialog.add_filter(ff)\n        dialog.set_filter(ff)\n\n        formats = []\n        default_format = None\n        for i, (name, fmts) in enumerate(\n                self.canvas.get_supported_filetypes_grouped().items()):\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(f'*.{fmt}')\n            dialog.add_filter(ff)\n            formats.append(name)\n            if self.canvas.get_default_filetype() in fmts:\n                default_format = i\n        # Setting the choice doesn't always work, so make sure the default\n        # format is first.\n        formats = [formats[default_format], *formats[:default_format],\n                   *formats[default_format+1:]]\n        dialog.add_choice('format', 'File format', formats, formats)\n        dialog.set_choice('format', formats[default_format])\n\n        dialog.set_current_folder(Gio.File.new_for_path(\n            os.path.expanduser(mpl.rcParams['savefig.directory'])))\n        dialog.set_current_name(self.canvas.get_default_filename())\n\n        @functools.partial(dialog.connect, 'response')\n        def on_response(dialog, response):\n            file = dialog.get_file()\n            fmt = dialog.get_choice('format')\n            fmt = self.canvas.get_supported_filetypes_grouped()[fmt][0]\n            dialog.destroy()\n            self._save_dialog = None\n            if response != Gtk.ResponseType.ACCEPT:\n                return\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams['savefig.directory']:\n                parent = file.get_parent()\n                mpl.rcParams['savefig.directory'] = parent.get_path()\n            try:\n                self.canvas.figure.savefig(file.get_path(), format=fmt)\n            except Exception as e:\n                msg = Gtk.MessageDialog(\n                    transient_for=self.canvas.get_root(),\n                    message_type=Gtk.MessageType.ERROR,\n                    buttons=Gtk.ButtonsType.OK, modal=True,\n                    text=str(e))\n                msg.show()\n\n        dialog.show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK4.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        with io.BytesIO() as f:\n            self.canvas.print_rgba(f)\n            w, h = self.canvas.get_width_height()\n            pb = GdkPixbuf.Pixbuf.new_from_data(f.getbuffer(),\n                                                GdkPixbuf.Colorspace.RGB, True,\n                                                8, w, h, w*4)\n        clipboard = self.canvas.get_clipboard()\n        clipboard.set(pb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n\n        # Tool items are created later, but must appear before the message.\n        self._tool_box = Gtk.Box()\n        self.append(self._tool_box)\n        self._groups = {}\n        self._toolitems = {}\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self._message)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleButton()\n        else:\n            button = Gtk.Button()\n        button.set_label(name)\n        button.add_css_class('flat')\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file))\n            button.set_child(image)\n            button.add_css_class('image-button')\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event(f'{name} not in toolbar', self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self._message.set_label(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n\n        Gtk.render_background(\n            self.get_style_context(), ctx,\n            allocation.x, allocation.y,\n            allocation.width, allocation.height)\n\n        buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n            np.asarray(self.get_renderer().buffer_rgba()))\n        height, width, _ = buf.shape\n        image = cairo.ImageSurface.create_for_data(\n            buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n        image.set_device_scale(scale, scale)\n        ctx.set_source_surface(image, 0, 0)\n        ctx.paint()\n\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            scale = self.device_pixel_ratio\n            # Scale physical drawing to logical size.\n            ctx.scale(1 / scale, 1 / scale)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._draw_pending = False\n        self._is_drawing = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # docstring inherited\n        super().blit(bbox)\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure and update the macosx canvas.",
      "docstring": "Render the figure and update the macosx canvas.",
      "code": "    def draw(self):\n        \"\"\"Render the figure and update the macosx canvas.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        # docstring inherited\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            # Add a singleshot timer to the eventloop that will call back\n            # into the Python method _draw_idle to take care of the draw\n            self._single_shot_timer(self._draw_idle)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, width, height):\n        # Size from macOS is logical pixels, dpi is physical.\n        scale = self.figure.dpi / self.device_pixel_ratio\n        width /= scale\n        height /= scale\n        self.figure.set_size_inches(width, height, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        self._shown = False\n        _macosx.FigureManager.__init__(self, canvas)\n        icon_path = str(cbook._get_data_path('images/matplotlib.pdf'))\n        _macosx.FigureManager.set_icon(icon_path)\n        FigureManagerBase.__init__(self, canvas, num)\n        if self.toolbar is not None:\n            self.toolbar.update()\n        if mpl.is_interactive():\n            self.show()\n            self.canvas.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.close",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    def close(self):\n        return self._close_button_pressed()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        if not self._shown:\n            self._show()\n            self._shown = True\n        if mpl.rcParams[\"figure.raise_window\"]:\n            self._raise()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas):\n        data_path = cbook._get_data_path('images')\n        _, tooltips, image_names, _ = zip(*NavigationToolbar2.toolitems)\n        _macosx.NavigationToolbar2.__init__(\n            self, canvas,\n            tuple(str(data_path / image_name) + \".pdf\"\n                  for image_name in image_names if image_name is not None),\n            tuple(tooltip for tooltip in tooltips if tooltip is not None))\n        NavigationToolbar2.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.set_rubberband(int(x0), int(y0), int(x1), int(y1))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/prepare_configure_subplots",
      "name": "prepare_configure_subplots",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.prepare_configure_subplots",
      "decorators": [
        "_api.deprecated('3.6', alternative='configure_subplots()')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/prepare_configure_subplots/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.prepare_configure_subplots.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\", alternative='configure_subplots()')\n    def prepare_configure_subplots(self):\n        toolfig = Figure(figsize=(6, 3))\n        canvas = FigureCanvasMac(toolfig)\n        toolfig.subplots_adjust(top=0.9)\n        # Need to keep a reference to the tool.\n        _tool = SubplotTool(self.canvas.figure, toolfig)\n        return canvas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas.remove_rubberband()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        directory = os.path.expanduser(mpl.rcParams['savefig.directory'])\n        filename = _macosx.choose_save_file('Save the figure',\n                                            directory,\n                                            self.canvas.get_default_filename())\n        if filename is None:  # Cancel\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(filename)\n        self.canvas.figure.savefig(filename)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__getattr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__getattr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__/attr",
          "name": "attr",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__getattr__.attr",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getattr__(self, attr):\n        # Proxy everything that hasn't been overridden to the base\n        # renderer. Things that *are* overridden can call methods\n        # on self._renderer directly, but must not cache/store\n        # methods (because things like RendererAgg change their\n        # methods on the fly in order to optimise proxying down\n        # to the underlying C implementation).\n        return getattr(self._renderer, attr)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/vector_renderer",
          "name": "vector_renderer",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.vector_renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/raster_renderer_class",
          "name": "raster_renderer_class",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.raster_renderer_class",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/bbox_inches_restore",
          "name": "bbox_inches_restore",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.bbox_inches_restore",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper class to implement a renderer that switches between\nvector and raster drawing.  An example may be a PDF writer, where\nmost things are drawn with PDF vector commands, but some very\ncomplex objects, such as quad meshes, are rasterised and then\noutput as images.",
      "docstring": "Parameters\n----------\nfigure : `matplotlib.figure.Figure`\n    The figure instance.\nwidth : scalar\n    The width of the canvas in logical units\nheight : scalar\n    The height of the canvas in logical units\ndpi : float\n    The dpi of the canvas\nvector_renderer : `matplotlib.backend_bases.RendererBase`\n    An instance of a subclass of\n    `~matplotlib.backend_bases.RendererBase` that will be used for the\n    vector drawing.\nraster_renderer_class : `matplotlib.backend_bases.RendererBase`\n    The renderer class to use for the raster drawing.  If not provided,\n    this will use the Agg backend (which is currently the only viable\n    option anyway.)",
      "code": "    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        Parameters\n        ----------\n        figure : `matplotlib.figure.Figure`\n            The figure instance.\n        width : scalar\n            The width of the canvas in logical units\n        height : scalar\n            The height of the canvas in logical units\n        dpi : float\n            The dpi of the canvas\n        vector_renderer : `matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n        raster_renderer_class : `matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.dpi\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/start_rasterizing",
      "name": "start_rasterizing",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.start_rasterizing",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/start_rasterizing/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.start_rasterizing.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Enter \"raster\" mode.  All subsequent drawing commands (until\n`stop_rasterizing` is called) will be drawn with the raster backend.",
      "docstring": "Enter \"raster\" mode.  All subsequent drawing commands (until\n`stop_rasterizing` is called) will be drawn with the raster backend.",
      "code": "    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        `stop_rasterizing` is called) will be drawn with the raster backend.\n        \"\"\"\n        # change the dpi of the figure temporarily.\n        self.figure.dpi = self.dpi\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore)\n            self._bbox_inches_restore = r\n\n        self._raster_renderer = self._raster_renderer_class(\n            self._width*self.dpi, self._height*self.dpi, self.dpi)\n        self._renderer = self._raster_renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/stop_rasterizing",
      "name": "stop_rasterizing",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.stop_rasterizing",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/stop_rasterizing/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.stop_rasterizing.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Exit \"raster\" mode.  All of the drawing that was done since\nthe last `start_rasterizing` call will be copied to the\nvector backend by calling draw_image.",
      "docstring": "Exit \"raster\" mode.  All of the drawing that was done since\nthe last `start_rasterizing` call will be copied to the\nvector backend by calling draw_image.",
      "code": "    def stop_rasterizing(self):\n        \"\"\"\n        Exit \"raster\" mode.  All of the drawing that was done since\n        the last `start_rasterizing` call will be copied to the\n        vector backend by calling draw_image.\n        \"\"\"\n\n        self._renderer = self._vector_renderer\n\n        height = self._height * self.dpi\n        img = np.asarray(self._raster_renderer.buffer_rgba())\n        slice_y, slice_x = cbook._get_nonzero_slices(img[..., 3])\n        cropped_img = img[slice_y, slice_x]\n        if cropped_img.size:\n            gc = self._renderer.new_gc()\n            # TODO: If the mixedmode resolution differs from the figure's\n            #       dpi, the image must be scaled (dpi->_figdpi). Not all\n            #       backends support this.\n            self._renderer.draw_image(\n                gc,\n                slice_x.start * self._figdpi / self.dpi,\n                (height - slice_y.stop) * self._figdpi / self.dpi,\n                cropped_img[::-1])\n        self._raster_renderer = None\n\n        # restore the figure dpi.\n        self.figure.dpi = self._figdpi\n\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore,\n                                               self._figdpi)\n            self._bbox_inches_restore = r"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__/manager",
          "name": "manager",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.__init__.manager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Manages the Comm connection between IPython and the browser (client).\n\nComms are 2 way, with the CommSocket being able to publish a message\nvia the send_json method, and handle a message with on_message. On the\nJS side figure.send_message and figure.ws.onmessage do the sending and\nreceiving respectively.",
      "docstring": "",
      "code": "    def __init__(self, manager):\n        self.supports_binary = None\n        self.manager = manager\n        self.uuid = str(uuid.uuid4())\n        # Publish an output area with a unique ID. The javascript can then\n        # hook into this area.\n        display(HTML(\"<div id=%r></div>\" % self.uuid))\n        try:\n            self.comm = Comm('matplotlib', data={'id': self.uuid})\n        except AttributeError as err:\n            raise RuntimeError('Unable to create an IPython notebook Comm '\n                               'instance. Are you in the IPython '\n                               'notebook?') from err\n        self.comm.on_msg(self.on_message)\n\n        manager = self.manager\n        self._ext_close = False\n\n        def _on_close(close_message):\n            self._ext_close = True\n            manager.remove_comm(close_message['content']['comm_id'])\n            manager.clearup_closed()\n\n        self.comm.on_close(_on_close)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/is_open",
      "name": "is_open",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.is_open",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/is_open/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.is_open.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_open(self):\n        return not (self._ext_close or self.comm._closed)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_close",
      "name": "on_close",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_close(self):\n        # When the socket is closed, deregister the websocket with\n        # the FigureManager.\n        if self.is_open():\n            try:\n                self.comm.close()\n            except KeyError:\n                # apparently already cleaned it up?\n                pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message",
      "name": "on_message",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_message(self, message):\n        # The 'supports_binary' message is relevant to the\n        # websocket itself.  The other messages get passed along\n        # to matplotlib as-is.\n\n        # Every message has a \"type\" and a \"figure_id\".\n        message = json.loads(message['content']['data'])\n        if message['type'] == 'closing':\n            self.on_close()\n            self.manager.clearup_closed()\n        elif message['type'] == 'supports_binary':\n            self.supports_binary = message['value']\n        else:\n            self.manager.handle_json(message)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary",
      "name": "send_binary",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_binary",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_binary.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary/blob",
          "name": "blob",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_binary.blob",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def send_binary(self, blob):\n        if self.supports_binary:\n            self.comm.send({'blob': 'image/png'}, buffers=[blob])\n        else:\n            # The comm is ASCII, so we send the image in base64 encoded data\n            # URL form.\n            data = b64encode(blob).decode('ascii')\n            data_uri = \"data:image/png;base64,{0}\".format(data)\n            self.comm.send({'data': data_uri})"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json",
      "name": "send_json",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_json",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json/content",
          "name": "content",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_json.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def send_json(self, content):\n        self.comm.send({'data': json.dumps(content)})"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        self._shown = False\n        super().__init__(canvas, num)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/clearup_closed",
      "name": "clearup_closed",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.clearup_closed",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/clearup_closed/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.clearup_closed.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Clear up any closed Comms.",
      "docstring": "Clear up any closed Comms.",
      "code": "    def clearup_closed(self):\n        \"\"\"Clear up any closed Comms.\"\"\"\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.is_open()}\n\n        if len(self.web_sockets) == 0:\n            self.canvas.close_event()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/connected@getter",
      "name": "connected",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.connected",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/connected@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.connected.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def connected(self):\n        return bool(self.web_sockets)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas",
      "name": "create_with_canvas",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas/canvas_class",
          "name": "canvas_class",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas.canvas_class",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        canvas = canvas_class(figure)\n        manager = cls(canvas, num)\n        if is_interactive():\n            manager.show()\n            canvas.draw_idle()\n\n        def destroy(event):\n            canvas.mpl_disconnect(cid)\n            Gcf.destroy(manager)\n\n        cid = canvas.mpl_connect('close_event', destroy)\n        return manager"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self):\n        self._send_event('close')\n        # need to copy comms as callbacks will modify this list\n        for comm in list(self.web_sockets):\n            comm.on_close()\n        self.clearup_closed()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/display_js",
      "name": "display_js",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.display_js",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/display_js/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.display_js.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def display_js(self):\n        # XXX How to do this just once? It has to deal with multiple\n        # browser instances using the same kernel (require.js - but the\n        # file isn't static?).\n        display(Javascript(FigureManagerNbAgg.get_javascript()))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript",
      "name": "get_javascript",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.get_javascript",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.get_javascript.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript/stream",
          "name": "stream",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.get_javascript.stream",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = io.StringIO()\n        else:\n            output = stream\n        super().get_javascript(stream=output)\n        output.write((pathlib.Path(__file__).parent\n                      / \"web_backend/js/nbagg_mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n        if stream is None:\n            return output.getvalue()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm",
      "name": "remove_comm",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.remove_comm",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.remove_comm.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm/comm_id",
          "name": "comm_id",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.remove_comm.comm_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_comm(self, comm_id):\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.comm.comm_id != comm_id}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/reshow",
      "name": "reshow",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.reshow",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/reshow/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.reshow.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A special method to re-show the figure in the notebook.",
      "docstring": "A special method to re-show the figure in the notebook.",
      "code": "    def reshow(self):\n        \"\"\"\n        A special method to re-show the figure in the notebook.\n\n        \"\"\"\n        self._shown = False\n        self.show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        if not self._shown:\n            self.display_js()\n            self._create_comm()\n        else:\n            self.canvas.draw_idle()\n        self._shown = True\n        # plt.figure adds an event which makes the figure in focus the active\n        # one. Disable this behaviour, as it results in figures being put as\n        # the active figure after they have been shown, even in non-interactive\n        # mode.\n        if hasattr(self, '_cidgcf'):\n            self.canvas.mpl_disconnect(self._cidgcf)\n        if not is_interactive():\n            from matplotlib._pylab_helpers import Gcf\n            Gcf.figs.pop(self.num, None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/connection_info",
      "name": "connection_info",
      "qname": "lib.matplotlib.backends.backend_nbagg.connection_info",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a string showing the figure and connection status for the backend.\n\nThis is intended as a diagnostic tool, and not for general use.",
      "docstring": "Return a string showing the figure and connection status for the backend.\n\nThis is intended as a diagnostic tool, and not for general use.",
      "code": "def connection_info():\n    \"\"\"\n    Return a string showing the figure and connection status for the backend.\n\n    This is intended as a diagnostic tool, and not for general use.\n    \"\"\"\n    result = [\n        '{fig} - {socket}'.format(\n            fig=(manager.canvas.figure.get_label()\n                 or \"Figure {}\".format(manager.num)),\n            socket=manager.web_sockets)\n        for manager in Gcf.get_all_fig_managers()\n    ]\n    if not is_interactive():\n        result.append(f'Figures pending show: {len(Gcf.figs)}')\n    return '\\n'.join(result)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'pdf'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf",
      "name": "print_pdf",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/bbox_inches_restore",
          "name": "bbox_inches_restore",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.bbox_inches_restore",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_pdf(self, filename, *,\n                  bbox_inches_restore=None, metadata=None):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # there are 72 pdf points to an inch\n        width, height = self.figure.get_size_inches()\n        if isinstance(filename, PdfPages):\n            file = filename._file\n        else:\n            file = PdfFile(filename, metadata=metadata)\n        try:\n            file.newPage(width, height)\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererPdf(file, dpi, height, width),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n            if not isinstance(filename, PdfPages):\n                file.finalize()\n        finally:\n            if isinstance(filename, PdfPages):  # finish off this page\n                file.endStream()\n            else:            # we opened the file above; now finish it off\n                file.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, file):\n        super().__init__()\n        self._fillcolor = (0.0, 0.0, 0.0)\n        self._effective_alphas = (1.0, 1.0)\n        self.file = file\n        self.parent = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        d = dict(self.__dict__)\n        del d['file']\n        del d['parent']\n        return repr(d)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd",
      "name": "alpha_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/forced",
          "name": "forced",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.forced",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/effective_alphas",
          "name": "effective_alphas",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.effective_alphas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def alpha_cmd(self, alpha, forced, effective_alphas):\n        name = self.file.alphaState(effective_alphas)\n        return [name, Op.setgstate]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd",
      "name": "capstyle_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd.style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def capstyle_cmd(self, style):\n        return [self.capstyles[style], Op.setlinecap]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd",
      "name": "clip_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd/cliprect",
          "name": "cliprect",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd.cliprect",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd/clippath",
          "name": "clippath",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd.clippath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set clip rectangle. Calls `.pop()` and `.push()`.",
      "docstring": "Set clip rectangle. Calls `.pop()` and `.push()`.",
      "code": "    def clip_cmd(self, cliprect, clippath):\n        \"\"\"Set clip rectangle. Calls `.pop()` and `.push()`.\"\"\"\n        cmds = []\n        # Pop graphics state until we hit the right one or the stack is empty\n        while ((self._cliprect, self._clippath) != (cliprect, clippath)\n                and self.parent is not None):\n            cmds.extend(self.pop())\n        # Unless we hit the right one, set the clip polygon\n        if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n                self.parent is None):\n            cmds.extend(self.push())\n            if self._cliprect != cliprect:\n                cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n            if self._clippath != clippath:\n                path, affine = clippath.get_transformed_path_and_affine()\n                cmds.extend(\n                    PdfFile.pathOperations(path, affine, simplify=False) +\n                    [Op.clip, Op.endpath])\n        return cmds"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties",
      "name": "copy_properties",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy properties of other into self.",
      "docstring": "Copy properties of other into self.",
      "code": "    def copy_properties(self, other):\n        \"\"\"\n        Copy properties of other into self.\n        \"\"\"\n        super().copy_properties(other)\n        fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n        effective_alphas = getattr(other, '_effective_alphas',\n                                   self._effective_alphas)\n        self._fillcolor = fillcolor\n        self._effective_alphas = effective_alphas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd",
      "name": "dash_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd/dashes",
          "name": "dashes",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd.dashes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def dash_cmd(self, dashes):\n        offset, dash = dashes\n        if dash is None:\n            dash = []\n            offset = 0\n        return [list(dash), offset, Op.setdash]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta",
      "name": "delta",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy properties of other into self and return PDF commands\nneeded to transform self into other.",
      "docstring": "Copy properties of other into self and return PDF commands\nneeded to transform self into other.",
      "code": "    def delta(self, other):\n        \"\"\"\n        Copy properties of other into self and return PDF commands\n        needed to transform self into other.\n        \"\"\"\n        cmds = []\n        fill_performed = False\n        for params, cmd in self.commands:\n            different = False\n            for p in params:\n                ours = getattr(self, p)\n                theirs = getattr(other, p)\n                try:\n                    if ours is None or theirs is None:\n                        different = ours is not theirs\n                    else:\n                        different = bool(ours != theirs)\n                except ValueError:\n                    ours = np.asarray(ours)\n                    theirs = np.asarray(theirs)\n                    different = (ours.shape != theirs.shape or\n                                 np.any(ours != theirs))\n                if different:\n                    break\n\n            # Need to update hatching if we also updated fillcolor\n            if params == ('_hatch', '_hatch_color') and fill_performed:\n                different = True\n\n            if different:\n                if params == ('_fillcolor',):\n                    fill_performed = True\n                theirs = [getattr(other, p) for p in params]\n                cmds.extend(cmd(self, *theirs))\n                for p in params:\n                    setattr(self, p, getattr(other, p))\n        return cmds"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill",
      "name": "fill",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Predicate: does the path need to be filled?\n\nAn optional argument can be used to specify an alternative\n_fillcolor, as needed by RendererPdf.draw_markers.",
      "docstring": "Predicate: does the path need to be filled?\n\nAn optional argument can be used to specify an alternative\n_fillcolor, as needed by RendererPdf.draw_markers.",
      "code": "    def fill(self, *args):\n        \"\"\"\n        Predicate: does the path need to be filled?\n\n        An optional argument can be used to specify an alternative\n        _fillcolor, as needed by RendererPdf.draw_markers.\n        \"\"\"\n        if len(args):\n            _fillcolor = args[0]\n        else:\n            _fillcolor = self._fillcolor\n        return (self._hatch or\n                (_fillcolor is not None and\n                 (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd",
      "name": "fillcolor_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd/rgb",
          "name": "rgb",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd.rgb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def fillcolor_cmd(self, rgb):\n        if rgb is None or mpl.rcParams['pdf.inheritcolor']:\n            return []\n        elif rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_nonstroke]\n        else:\n            return [*rgb[:3], Op.setrgb_nonstroke]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Make sure every pushed graphics state is popped.",
      "docstring": "Make sure every pushed graphics state is popped.",
      "code": "    def finalize(self):\n        \"\"\"\n        Make sure every pushed graphics state is popped.\n        \"\"\"\n        cmds = []\n        while self.parent is not None:\n            cmds.extend(self.pop())\n        return cmds"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd",
      "name": "hatch_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd/hatch",
          "name": "hatch",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd.hatch",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd/hatch_color",
          "name": "hatch_color",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd.hatch_color",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def hatch_cmd(self, hatch, hatch_color):\n        if not hatch:\n            if self._fillcolor is not None:\n                return self.fillcolor_cmd(self._fillcolor)\n            else:\n                return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]\n        else:\n            hatch_style = (hatch_color, self._fillcolor, hatch)\n            name = self.file.hatchPattern(hatch_style)\n            return [Name('Pattern'), Op.setcolorspace_nonstroke,\n                    name, Op.setcolor_nonstroke]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd",
      "name": "joinstyle_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd.style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def joinstyle_cmd(self, style):\n        return [self.joinstyles[style], Op.setlinejoin]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd",
      "name": "linewidth_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def linewidth_cmd(self, width):\n        return [width, Op.setlinewidth]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/paint",
      "name": "paint",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.paint",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/paint/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.paint.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the appropriate pdf operator to cause the path to be\nstroked, filled, or both.",
      "docstring": "Return the appropriate pdf operator to cause the path to be\nstroked, filled, or both.",
      "code": "    def paint(self):\n        \"\"\"\n        Return the appropriate pdf operator to cause the path to be\n        stroked, filled, or both.\n        \"\"\"\n        return Op.paint_path(self.fill(), self.stroke())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/pop",
      "name": "pop",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/pop/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pop(self):\n        assert self.parent is not None\n        self.copy_properties(self.parent)\n        self.parent = self.parent.parent\n        return [Op.grestore]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/push",
      "name": "push",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/push/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def push(self):\n        parent = GraphicsContextPdf(self.file)\n        parent.copy_properties(self)\n        parent.parent = self.parent\n        self.parent = parent\n        return [Op.gsave]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd",
      "name": "rgb_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd/rgb",
          "name": "rgb",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd.rgb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def rgb_cmd(self, rgb):\n        if mpl.rcParams['pdf.inheritcolor']:\n            return []\n        if rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_stroke]\n        else:\n            return [*rgb[:3], Op.setrgb_stroke]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/stroke",
      "name": "stroke",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/stroke/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Predicate: does the path need to be stroked (its outline drawn)?\nThis tests for the various conditions that disable stroking\nthe path, in which case it would presumably be filled.",
      "docstring": "Predicate: does the path need to be stroked (its outline drawn)?\nThis tests for the various conditions that disable stroking\nthe path, in which case it would presumably be filled.",
      "code": "    def stroke(self):\n        \"\"\"\n        Predicate: does the path need to be stroked (its outline drawn)?\n        This tests for the various conditions that disable stroking\n        the path, in which case it would presumably be filled.\n        \"\"\"\n        # _linewidth > 0: in pdf a line of width 0 is drawn at minimum\n        #   possible device width, but e.g., agg doesn't draw at all\n        return (self._linewidth > 0 and self._alpha > 0 and\n                (len(self._rgb) <= 3 or self._rgb[3] != 0.0))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__",
      "name": "__eq__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other):\n        return isinstance(other, Name) and self.name == other.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__hash__",
      "name": "__hash__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__hash__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self):\n        return hash(self.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF name object.",
      "docstring": "",
      "code": "    def __init__(self, name):\n        if isinstance(name, Name):\n            self.name = name.name\n        else:\n            if isinstance(name, bytes):\n                name = name.decode('ascii')\n            self.name = name.translate(self._hexify).encode('ascii')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__",
      "name": "__lt__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__lt__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__lt__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__lt__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __lt__(self, other):\n        return isinstance(other, Name) and self.name < other.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return \"<Name %s>\" % self.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__str__",
      "name": "__str__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__str__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self):\n        return '/' + self.name.decode('ascii')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/hexify",
      "name": "hexify",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.hexify",
      "decorators": [
        "staticmethod",
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/hexify/match",
          "name": "match",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.hexify.match",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    @_api.deprecated(\"3.6\")\n    def hexify(match):\n        return '#%02x' % ord(match.group())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return b'/' + self.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path",
      "name": "paint_path",
      "qname": "lib.matplotlib.backends.backend_pdf.Op.paint_path",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_pdf.Op.paint_path.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path/fill",
          "name": "fill",
          "qname": "lib.matplotlib.backends.backend_pdf.Op.paint_path.fill",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Fill the path with the fill color."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path/stroke",
          "name": "stroke",
          "qname": "lib.matplotlib.backends.backend_pdf.Op.paint_path.stroke",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Stroke the outline of the path with the line color."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the PDF operator to paint a path.",
      "docstring": "Return the PDF operator to paint a path.\n\nParameters\n----------\nfill : bool\n    Fill the path with the fill color.\nstroke : bool\n    Stroke the outline of the path with the line color.",
      "code": "    @classmethod\n    def paint_path(cls, fill, stroke):\n        \"\"\"\n        Return the PDF operator to paint a path.\n\n        Parameters\n        ----------\n        fill : bool\n            Fill the path with the fill color.\n        stroke : bool\n            Stroke the outline of the path with the line color.\n        \"\"\"\n        if stroke:\n            if fill:\n                return cls.fill_stroke\n            else:\n                return cls.stroke\n        else:\n            if fill:\n                return cls.fill\n            else:\n                return cls.endpath"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Op.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Op.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return self.value"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__/op",
          "name": "op",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.__init__.op",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, op):\n        self.op = op"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return '<Operator %s>' % self.op"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return self.op"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF file object.",
      "docstring": "Parameters\n----------\nfilename : str or path-like or file-like\n    Output target; if a string, a file will be opened for writing.\n\nmetadata : dict from strings to strings and dates\n    Information dictionary object (see PDF reference section 10.2.1\n    'Document Information Dictionary'), e.g.:\n    ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n    The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n    'Creator', 'Producer', 'CreationDate', 'ModDate', and\n    'Trapped'. Values have been predefined for 'Creator', 'Producer'\n    and 'CreationDate'. They can be removed by setting them to `None`.",
      "code": "    def __init__(self, filename, metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n\n        metadata : dict from strings to strings and dates\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        super().__init__()\n\n        self._object_seq = itertools.count(1)  # consumed by reserveObject\n        self.xrefTable = [[0, 65535, 'the zero object']]\n        self.passed_in_file_object = False\n        self.original_file_like = None\n        self.tell_base = 0\n        fh, opened = cbook.to_filehandle(filename, \"wb\", return_opened=True)\n        if not opened:\n            try:\n                self.tell_base = filename.tell()\n            except IOError:\n                fh = BytesIO()\n                self.original_file_like = filename\n            else:\n                fh = filename\n                self.passed_in_file_object = True\n\n        self.fh = fh\n        self.currentstream = None  # stream object to write to, if any\n        fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n        # Output some eight-bit chars as a comment so various utilities\n        # recognize the file as binary by looking at the first few\n        # lines (see note in section 3.4.1 of the PDF reference).\n        fh.write(b\"%\\254\\334 \\253\\272\\n\")\n\n        self.rootObject = self.reserveObject('root')\n        self.pagesObject = self.reserveObject('pages')\n        self.pageList = []\n        self.fontObject = self.reserveObject('fonts')\n        self._extGStateObject = self.reserveObject('extended graphics states')\n        self.hatchObject = self.reserveObject('tiling patterns')\n        self.gouraudObject = self.reserveObject('Gouraud triangles')\n        self.XObjectObject = self.reserveObject('external objects')\n        self.resourceObject = self.reserveObject('resources')\n\n        root = {'Type': Name('Catalog'),\n                'Pages': self.pagesObject}\n        self.writeObject(self.rootObject, root)\n\n        self.infoDict = _create_pdf_info_dict('pdf', metadata or {})\n\n        self.fontNames = {}     # maps filenames to internal font names\n        self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))\n        self.dviFontInfo = {}   # maps dvi font names to embedding information\n        # differently encoded Type-1 fonts may share the same descriptor\n        self.type1Descriptors = {}\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n\n        self.alphaStates = {}   # maps alpha values to graphics state objects\n        self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))\n        self._soft_mask_states = {}\n        self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))\n        self._soft_mask_groups = []\n        self.hatchPatterns = {}\n        self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))\n        self.gouraudTriangles = []\n\n        self._images = {}\n        self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n\n        self.markers = {}\n        self.multi_byte_charprocs = {}\n\n        self.paths = []\n\n        # A list of annotations for each page. Each entry is a tuple of the\n        # overall Annots object reference that's inserted into the page object,\n        # followed by a list of the actual annotations.\n        self._annotations = []\n        # For annotations added before a page is created; mostly for the\n        # purpose of newTextnote.\n        self.pageAnnotations = []\n\n        # The PDF spec recommends to include every procset\n        procsets = [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]\n\n        # Write resource dictionary.\n        # Possibly TODO: more general ExtGState (graphics state dictionaries)\n        #                ColorSpace Pattern Shading Properties\n        resources = {'Font': self.fontObject,\n                     'XObject': self.XObjectObject,\n                     'ExtGState': self._extGStateObject,\n                     'Pattern': self.hatchObject,\n                     'Shading': self.gouraudObject,\n                     'ProcSet': procsets}\n        self.writeObject(self.resourceObject, resources)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles",
      "name": "addGouraudTriangles",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "np.ndarray",
            "default_value": "",
            "description": "Triangle vertices, shape (n, 3, 2)\nwhere n = number of triangles, 3 = vertices, 2 = x, y."
          },
          "type": {
            "kind": "NamedType",
            "name": "np.ndarray"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "np.ndarray",
            "default_value": "",
            "description": "Vertex colors, shape (n, 3, 1) or (n, 3, 4)\nas with points, but last dimension is either (gray,)\nor (r, g, b, alpha)."
          },
          "type": {
            "kind": "NamedType",
            "name": "np.ndarray"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a Gouraud triangle shading.",
      "docstring": "Add a Gouraud triangle shading.\n\nParameters\n----------\npoints : np.ndarray\n    Triangle vertices, shape (n, 3, 2)\n    where n = number of triangles, 3 = vertices, 2 = x, y.\ncolors : np.ndarray\n    Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n    as with points, but last dimension is either (gray,)\n    or (r, g, b, alpha).\n\nReturns\n-------\nName, Reference",
      "code": "    def addGouraudTriangles(self, points, colors):\n        \"\"\"\n        Add a Gouraud triangle shading.\n\n        Parameters\n        ----------\n        points : np.ndarray\n            Triangle vertices, shape (n, 3, 2)\n            where n = number of triangles, 3 = vertices, 2 = x, y.\n        colors : np.ndarray\n            Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n            as with points, but last dimension is either (gray,)\n            or (r, g, b, alpha).\n\n        Returns\n        -------\n        Name, Reference\n        \"\"\"\n        name = Name('GT%d' % len(self.gouraudTriangles))\n        ob = self.reserveObject(f'Gouraud triangle {name}')\n        self.gouraudTriangles.append((name, ob, points, colors))\n        return name, ob"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState",
      "name": "alphaState",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return name of an ExtGState that sets alpha to the given value.",
      "docstring": "Return name of an ExtGState that sets alpha to the given value.",
      "code": "    def alphaState(self, alpha):\n        \"\"\"Return name of an ExtGState that sets alpha to the given value.\"\"\"\n\n        state = self.alphaStates.get(alpha, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._alpha_state_seq)\n        self.alphaStates[alpha] = \\\n            (name, {'Type': Name('ExtGState'),\n                    'CA': alpha[0], 'ca': alpha[1]})\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream",
      "name": "beginStream",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/len",
          "name": "len",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.len",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.extra",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/png",
          "name": "png",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.png",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def beginStream(self, id, len, extra=None, png=None):\n        assert self.currentstream is None\n        self.currentstream = Stream(id, len, self, extra, png)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Flush all buffers and free all resources.",
      "docstring": "Flush all buffers and free all resources.",
      "code": "    def close(self):\n        \"\"\"Flush all buffers and free all resources.\"\"\"\n\n        self.endStream()\n        if self.passed_in_file_object:\n            self.fh.flush()\n        else:\n            if self.original_file_like is not None:\n                self.original_file_like.write(self.fh.getvalue())\n            self.fh.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor",
      "name": "createType1Descriptor",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor/t1font",
          "name": "t1font",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor.t1font",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor/fontfile",
          "name": "fontfile",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor.fontfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def createType1Descriptor(self, t1font, fontfile):\n        # Create and write the font descriptor and the font file\n        # of a Type-1 font\n        fontdescObject = self.reserveObject('font descriptor')\n        fontfileObject = self.reserveObject('font file')\n\n        italic_angle = t1font.prop['ItalicAngle']\n        fixed_pitch = t1font.prop['isFixedPitch']\n\n        flags = 0\n        # fixed width\n        if fixed_pitch:\n            flags |= 1 << 0\n        # TODO: serif\n        if 0:\n            flags |= 1 << 1\n        # TODO: symbolic (most TeX fonts are)\n        if 1:\n            flags |= 1 << 2\n        # non-symbolic\n        else:\n            flags |= 1 << 5\n        # italic\n        if italic_angle:\n            flags |= 1 << 6\n        # TODO: all caps\n        if 0:\n            flags |= 1 << 16\n        # TODO: small caps\n        if 0:\n            flags |= 1 << 17\n        # TODO: force bold\n        if 0:\n            flags |= 1 << 18\n\n        ft2font = get_font(fontfile)\n\n        descriptor = {\n            'Type':        Name('FontDescriptor'),\n            'FontName':    Name(t1font.prop['FontName']),\n            'Flags':       flags,\n            'FontBBox':    ft2font.bbox,\n            'ItalicAngle': italic_angle,\n            'Ascent':      ft2font.ascender,\n            'Descent':     ft2font.descender,\n            'CapHeight':   1000,  # TODO: find this out\n            'XHeight':     500,  # TODO: this one too\n            'FontFile':    fontfileObject,\n            'FontFamily':  t1font.prop['FamilyName'],\n            'StemV':       50,  # TODO\n            # (see also revision 3874; but not all TeX distros have AFM files!)\n            # 'FontWeight': a number where 400 = Regular, 700 = Bold\n            }\n\n        self.writeObject(fontdescObject, descriptor)\n\n        self.outputStream(fontfileObject, b\"\".join(t1font.parts[:2]),\n                          extra={'Length1': len(t1font.parts[0]),\n                                 'Length2': len(t1font.parts[1]),\n                                 'Length3': 0})\n\n        return fontdescObject"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName",
      "name": "dviFontName",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.dviFontName",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.dviFontName.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName/dvifont",
          "name": "dvifont",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.dviFontName.dvifont",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Given a dvi font object, return a name suitable for Op.selectfont.\nThis registers the font information in ``self.dviFontInfo`` if not yet\nregistered.",
      "docstring": "Given a dvi font object, return a name suitable for Op.selectfont.\nThis registers the font information in ``self.dviFontInfo`` if not yet\nregistered.",
      "code": "    def dviFontName(self, dvifont):\n        \"\"\"\n        Given a dvi font object, return a name suitable for Op.selectfont.\n        This registers the font information in ``self.dviFontInfo`` if not yet\n        registered.\n        \"\"\"\n\n        dvi_info = self.dviFontInfo.get(dvifont.texname)\n        if dvi_info is not None:\n            return dvi_info.pdfname\n\n        tex_font_map = dviread.PsfontsMap(dviread._find_tex_file('pdftex.map'))\n        psfont = tex_font_map[dvifont.texname]\n        if psfont.filename is None:\n            raise ValueError(\n                \"No usable font file found for {} (TeX: {}); \"\n                \"the font may lack a Type-1 version\"\n                .format(psfont.psname, dvifont.texname))\n\n        pdfname = next(self._internal_font_seq)\n        _log.debug('Assigning font %s = %s (dvi)', pdfname, dvifont.texname)\n        self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(\n            dvifont=dvifont,\n            pdfname=pdfname,\n            fontfile=psfont.filename,\n            basefont=psfont.psname,\n            encodingfile=psfont.encoding,\n            effects=psfont.effects)\n        return pdfname"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF",
      "name": "embedTTF",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF/characters",
          "name": "characters",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF.characters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Embed the TTF font from the named file into the document.",
      "docstring": "Embed the TTF font from the named file into the document.",
      "code": "    def embedTTF(self, filename, characters):\n        \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n\n        font = get_font(filename)\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"\"\"Convert font coordinates to PDF glyph coordinates.\"\"\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Best(?) to round away from zero for bounding boxes and the like.\n            if value < 0:\n                return math.floor(value)\n            else:\n                return math.ceil(value)\n\n        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array.\n            rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict = {'Type': Name('XObject'),\n                                    'Subtype': Name('Form'),\n                                    'BBox': bbox}\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.outputStream(charprocObject, stream, extra=charprocDict)\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_glyph_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject\n\n        def embedTTFType42(font, characters, descriptor):\n            \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n            fontdescObject = self.reserveObject('font descriptor')\n            cidFontDictObject = self.reserveObject('CID font dictionary')\n            type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n            cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n            fontfileObject = self.reserveObject('font file stream')\n            wObject = self.reserveObject('Type 0 widths')\n            toUnicodeMapObject = self.reserveObject('ToUnicode map')\n\n            subset_str = \"\".join(chr(c) for c in characters)\n            _log.debug(\"SUBSET %s characters: %s\", filename, subset_str)\n            fontdata = _backend_pdf_ps.get_glyphs_subset(filename, subset_str)\n            _log.debug(\n                \"SUBSET %s %d -> %d\", filename,\n                os.stat(filename).st_size, fontdata.getbuffer().nbytes\n            )\n\n            # We need this ref for XObjects\n            full_font = font\n\n            # reload the font object from the subset\n            # (all the necessary data could probably be obtained directly\n            # using fontLib.ttLib)\n            font = FT2Font(fontdata)\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            self.outputStream(\n                fontfileObject, fontdata.getvalue(),\n                extra={'Length1': fontdata.getbuffer().nbytes})\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\0'] * 65536\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph = font.load_char(ccode,\n                                       flags=LOAD_NO_SCALE | LOAD_NO_HINTING)\n                widths.append((ccode, cvt(glyph.horiAdvance)))\n                if ccode < 65536:\n                    cid_to_gid_map[ccode] = chr(gind)\n                max_ccode = max(ccode, max_ccode)\n            widths.sort()\n            cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n\n            last_ccode = -2\n            w = []\n            max_width = 0\n            unicode_groups = []\n            for ccode, width in widths:\n                if ccode != last_ccode + 1:\n                    w.append(ccode)\n                    w.append([width])\n                    unicode_groups.append([ccode, ccode])\n                else:\n                    w[-1].append(width)\n                    unicode_groups[-1][1] = ccode\n                max_width = max(max_width, width)\n                last_ccode = ccode\n\n            unicode_bfrange = []\n            for start, end in unicode_groups:\n                # Ensure the CID map contains only chars from BMP\n                if start > 65535:\n                    continue\n                end = min(65535, end)\n\n                unicode_bfrange.append(\n                    b\"<%04x> <%04x> [%s]\" %\n                    (start, end,\n                     b\" \".join(b\"<%04x>\" % x for x in range(start, end+1))))\n            unicode_cmap = (self._identityToUnicodeCMap %\n                            (len(unicode_groups), b\"\\n\".join(unicode_bfrange)))\n\n            # Add XObjects for unsupported chars\n            glyph_ids = []\n            for ccode in characters:\n                if not _font_supports_glyph(fonttype, ccode):\n                    gind = full_font.get_char_index(ccode)\n                    glyph_ids.append(gind)\n\n            bbox = [cvt(x, nearest=False) for x in full_font.bbox]\n            rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Type': Name('XObject'),\n                                'Subtype': Name('Form'),\n                                'BBox': bbox}\n                # Each glyph includes bounding box information,\n                # but xpdf and ghostscript can't handle it in a\n                # Form XObject (they segfault!!!), so we remove it\n                # from the stream here.  It's not needed anyway,\n                # since the Form XObject includes it in its BBox\n                # value.\n                stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.outputStream(charprocObject, stream, extra=charprocDict)\n\n                name = self._get_xobject_glyph_name(filename, charname)\n                self.multi_byte_charprocs[name] = charprocObject\n\n            # CIDToGIDMap stream\n            cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n            self.outputStream(cidToGidMapObject, cid_to_gid_map)\n\n            # ToUnicode CMap\n            self.outputStream(toUnicodeMapObject, unicode_cmap)\n\n            descriptor['MaxWidth'] = max_width\n\n            # Write everything out\n            self.writeObject(cidFontDictObject, cidFontDict)\n            self.writeObject(type0FontDictObject, type0FontDict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(wObject, w)\n\n            return type0FontDictObject\n\n        # Beginning of main embedTTF function...\n\n        ps_name = self._get_subsetted_psname(\n            font.postscript_name,\n            font.get_charmap()\n        )\n        ps_name = ps_name.encode('ascii', 'replace')\n        ps_name = Name(ps_name)\n        pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n        post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n        ff = font.face_flags\n        sf = font.style_flags\n\n        flags = 0\n        symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n        if ff & FIXED_WIDTH:\n            flags |= 1 << 0\n        if 0:  # TODO: serif\n            flags |= 1 << 1\n        if symbolic:\n            flags |= 1 << 2\n        else:\n            flags |= 1 << 5\n        if sf & ITALIC:\n            flags |= 1 << 6\n        if 0:  # TODO: all caps\n            flags |= 1 << 16\n        if 0:  # TODO: small caps\n            flags |= 1 << 17\n        if 0:  # TODO: force bold\n            flags |= 1 << 18\n\n        descriptor = {\n            'Type': Name('FontDescriptor'),\n            'FontName': ps_name,\n            'Flags': flags,\n            'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n            'Ascent': cvt(font.ascender, nearest=False),\n            'Descent': cvt(font.descender, nearest=False),\n            'CapHeight': cvt(pclt['capHeight'], nearest=False),\n            'XHeight': cvt(pclt['xHeight']),\n            'ItalicAngle': post['italicAngle'][1],  # ???\n            'StemV': 0  # ???\n            }\n\n        if fonttype == 3:\n            return embedTTFType3(font, characters, descriptor)\n        elif fonttype == 42:\n            return embedTTFType42(font, characters, descriptor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/endStream",
      "name": "endStream",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.endStream",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/endStream/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.endStream.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def endStream(self):\n        if self.currentstream is not None:\n            self.currentstream.end()\n            self.currentstream = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the various deferred objects and the pdf end matter.",
      "docstring": "Write out the various deferred objects and the pdf end matter.",
      "code": "    def finalize(self):\n        \"\"\"Write out the various deferred objects and the pdf end matter.\"\"\"\n\n        self.endStream()\n        self._write_annotations()\n        self.writeFonts()\n        self.writeExtGSTates()\n        self._write_soft_mask_groups()\n        self.writeHatches()\n        self.writeGouraudTriangles()\n        xobjects = {\n            name: ob for image, name, ob in self._images.values()}\n        for tup in self.markers.values():\n            xobjects[tup[0]] = tup[1]\n        for name, value in self.multi_byte_charprocs.items():\n            xobjects[name] = value\n        for name, path, trans, ob, join, cap, padding, filled, stroked \\\n                in self.paths:\n            xobjects[name] = ob\n        self.writeObject(self.XObjectObject, xobjects)\n        self.writeImages()\n        self.writeMarkers()\n        self.writePathCollectionTemplates()\n        self.writeObject(self.pagesObject,\n                         {'Type': Name('Pages'),\n                          'Kids': self.pageList,\n                          'Count': len(self.pageList)})\n        self.writeInfoDict()\n\n        # Finalize the file\n        self.writeXref()\n        self.writeTrailer()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName",
      "name": "fontName",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName/fontprop",
          "name": "fontprop",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName.fontprop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Select a font based on fontprop and return a name suitable for\nOp.selectfont. If fontprop is a string, it will be interpreted\nas the filename of the font.",
      "docstring": "Select a font based on fontprop and return a name suitable for\nOp.selectfont. If fontprop is a string, it will be interpreted\nas the filename of the font.",
      "code": "    def fontName(self, fontprop):\n        \"\"\"\n        Select a font based on fontprop and return a name suitable for\n        Op.selectfont. If fontprop is a string, it will be interpreted\n        as the filename of the font.\n        \"\"\"\n\n        if isinstance(fontprop, str):\n            filenames = [fontprop]\n        elif mpl.rcParams['pdf.use14corefonts']:\n            filenames = _fontManager._find_fonts_by_props(\n                fontprop, fontext='afm', directory=RendererPdf._afm_font_dir\n            )\n        else:\n            filenames = _fontManager._find_fonts_by_props(fontprop)\n        first_Fx = None\n        for fname in filenames:\n            Fx = self.fontNames.get(fname)\n            if not first_Fx:\n                first_Fx = Fx\n            if Fx is None:\n                Fx = next(self._internal_font_seq)\n                self.fontNames[fname] = Fx\n                _log.debug('Assigning font %s = %r', Fx, fname)\n                if not first_Fx:\n                    first_Fx = Fx\n\n        # find_fontsprop's first value always adheres to\n        # findfont's value, so technically no behaviour change\n        return first_Fx"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern",
      "name": "hatchPattern",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.hatchPattern",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.hatchPattern.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern/hatch_style",
          "name": "hatch_style",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.hatchPattern.hatch_style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def hatchPattern(self, hatch_style):\n        # The colors may come in as numpy arrays, which aren't hashable\n        if hatch_style is not None:\n            edge, face, hatch = hatch_style\n            if edge is not None:\n                edge = tuple(edge)\n            if face is not None:\n                face = tuple(face)\n            hatch_style = (edge, face, hatch)\n\n        pattern = self.hatchPatterns.get(hatch_style, None)\n        if pattern is not None:\n            return pattern\n\n        name = next(self._hatch_pattern_seq)\n        self.hatchPatterns[hatch_style] = name\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject",
      "name": "imageObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject/image",
          "name": "image",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject.image",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return name of an image XObject representing the given image.",
      "docstring": "Return name of an image XObject representing the given image.",
      "code": "    def imageObject(self, image):\n        \"\"\"Return name of an image XObject representing the given image.\"\"\"\n\n        entry = self._images.get(id(image), None)\n        if entry is not None:\n            return entry[1]\n\n        name = next(self._image_seq)\n        ob = self.reserveObject(f'image {name}')\n        self._images[id(image)] = (image, name, ob)\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject",
      "name": "markerObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/fill",
          "name": "fill",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.fill",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/stroke",
          "name": "stroke",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.stroke",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/lw",
          "name": "lw",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.lw",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/joinstyle",
          "name": "joinstyle",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.joinstyle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/capstyle",
          "name": "capstyle",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.capstyle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return name of a marker XObject representing the given path.",
      "docstring": "Return name of a marker XObject representing the given path.",
      "code": "    def markerObject(self, path, trans, fill, stroke, lw, joinstyle,\n                     capstyle):\n        \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n        # self.markers used by markerObject, writeMarkers, close:\n        # mapping from (path operations, fill?, stroke?) to\n        #   [name, object reference, bounding box, linewidth]\n        # This enables different draw_markers calls to share the XObject\n        # if the gc is sufficiently similar: colors etc can vary, but\n        # the choices of whether to fill and whether to stroke cannot.\n        # We need a bounding box enclosing all of the XObject path,\n        # but since line width may vary, we store the maximum of all\n        # occurring line widths in self.markers.\n        # close() is somewhat tightly coupled in that it expects the\n        # first two components of each value in self.markers to be the\n        # name and object reference.\n        pathops = self.pathOperations(path, trans, simplify=False)\n        key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)\n        result = self.markers.get(key)\n        if result is None:\n            name = Name('M%d' % len(self.markers))\n            ob = self.reserveObject('marker %d' % len(self.markers))\n            bbox = path.get_extents(trans)\n            self.markers[key] = [name, ob, bbox, lw]\n        else:\n            if result[-1] < lw:\n                result[-1] = lw\n            name = result[0]\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage",
      "name": "newPage",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def newPage(self, width, height):\n        self.endStream()\n\n        self.width, self.height = width, height\n        contentObject = self.reserveObject('page contents')\n        annotsObject = self.reserveObject('annotations')\n        thePage = {'Type': Name('Page'),\n                   'Parent': self.pagesObject,\n                   'Resources': self.resourceObject,\n                   'MediaBox': [0, 0, 72 * width, 72 * height],\n                   'Contents': contentObject,\n                   'Annots': annotsObject,\n                   }\n        pageObject = self.reserveObject('page')\n        self.writeObject(pageObject, thePage)\n        self.pageList.append(pageObject)\n        self._annotations.append((annotsObject, self.pageAnnotations))\n\n        self.beginStream(contentObject.id,\n                         self.reserveObject('length of content stream'))\n        # Initialize the pdf graphics state to match the default Matplotlib\n        # graphics context (colorspace and joinstyle).\n        self.output(Name('DeviceRGB'), Op.setcolorspace_stroke)\n        self.output(Name('DeviceRGB'), Op.setcolorspace_nonstroke)\n        self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n\n        # Clear the list of annotations for the next page\n        self.pageAnnotations = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote",
      "name": "newTextnote",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote/positionRect",
          "name": "positionRect",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote.positionRect",
          "default_value": "[-100, -100, 0, 0]",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def newTextnote(self, text, positionRect=[-100, -100, 0, 0]):\n        # Create a new annotation of type text\n        theNote = {'Type': Name('Annot'),\n                   'Subtype': Name('Text'),\n                   'Contents': text,\n                   'Rect': positionRect,\n                   }\n        self.pageAnnotations.append(theNote)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output",
      "name": "output",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.output",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.output.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.output.data",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def output(self, *data):\n        self.write(_fill([pdfRepr(x) for x in data]))\n        self.write(b'\\n')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream",
      "name": "outputStream",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream/ref",
          "name": "ref",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream.ref",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream.extra",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def outputStream(self, ref, data, *, extra=None):\n        self.beginStream(ref.id, None, extra)\n        self.currentstream.write(data)\n        self.endStream()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject",
      "name": "pathCollectionObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/padding",
          "name": "padding",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.padding",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/filled",
          "name": "filled",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.filled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/stroked",
          "name": "stroked",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.stroked",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):\n        name = Name('P%d' % len(self.paths))\n        ob = self.reserveObject('path %d' % len(self.paths))\n        self.paths.append(\n            (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),\n             padding, filled, stroked))\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations",
      "name": "pathOperations",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/clip",
          "name": "clip",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.clip",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/simplify",
          "name": "simplify",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.simplify",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/sketch",
          "name": "sketch",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.sketch",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def pathOperations(path, transform, clip=None, simplify=None, sketch=None):\n        return [Verbatim(_path.convert_to_string(\n            path, transform, clip, simplify, sketch,\n            6,\n            [Op.moveto.value, Op.lineto.value, b'', Op.curveto.value,\n             Op.closepath.value],\n            True))]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref",
      "name": "recordXref",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def recordXref(self, id):\n        self.xrefTable[id][0] = self.fh.tell() - self.tell_base"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject",
      "name": "reserveObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject.name",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Reserve an ID for an indirect object.\n\nThe name is used for debugging in case we forget to print out\nthe object with writeObject.",
      "docstring": "Reserve an ID for an indirect object.\n\nThe name is used for debugging in case we forget to print out\nthe object with writeObject.",
      "code": "    def reserveObject(self, name=''):\n        \"\"\"\n        Reserve an ID for an indirect object.\n\n        The name is used for debugging in case we forget to print out\n        the object with writeObject.\n        \"\"\"\n        id = next(self._object_seq)\n        self.xrefTable.append([None, 0, name])\n        return Reference(id)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write",
      "name": "write",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.write",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.write.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.write.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def write(self, data):\n        if self.currentstream is None:\n            self.fh.write(data)\n        else:\n            self.currentstream.write(data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeExtGSTates",
      "name": "writeExtGSTates",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeExtGSTates/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeExtGSTates(self):\n        self.writeObject(\n            self._extGStateObject,\n            dict([\n                *self.alphaStates.values(),\n                *self._soft_mask_states.values()\n            ])\n        )"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeFonts",
      "name": "writeFonts",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeFonts",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeFonts/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeFonts.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeFonts(self):\n        fonts = {}\n        for dviname, info in sorted(self.dviFontInfo.items()):\n            Fx = info.pdfname\n            _log.debug('Embedding Type-1 font %s from dvi.', dviname)\n            fonts[Fx] = self._embedTeXFont(info)\n        for filename in sorted(self.fontNames):\n            Fx = self.fontNames[filename]\n            _log.debug('Embedding font %s.', filename)\n            if filename.endswith('.afm'):\n                # from pdf.use14corefonts\n                _log.debug('Writing AFM font.')\n                fonts[Fx] = self._write_afm_font(filename)\n            else:\n                # a normal TrueType font\n                _log.debug('Writing TrueType font.')\n                chars = self._character_tracker.used.get(filename)\n                if chars:\n                    fonts[Fx] = self.embedTTF(filename, chars)\n        self.writeObject(self.fontObject, fonts)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeGouraudTriangles",
      "name": "writeGouraudTriangles",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeGouraudTriangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeGouraudTriangles(self):\n        gouraudDict = dict()\n        for name, ob, points, colors in self.gouraudTriangles:\n            gouraudDict[name] = ob\n            shape = points.shape\n            flat_points = points.reshape((shape[0] * shape[1], 2))\n            colordim = colors.shape[2]\n            assert colordim in (1, 4)\n            flat_colors = colors.reshape((shape[0] * shape[1], colordim))\n            if colordim == 4:\n                # strip the alpha channel\n                colordim = 3\n            points_min = np.min(flat_points, axis=0) - (1 << 8)\n            points_max = np.max(flat_points, axis=0) + (1 << 8)\n            factor = 0xffffffff / (points_max - points_min)\n\n            self.beginStream(\n                ob.id, None,\n                {'ShadingType': 4,\n                 'BitsPerCoordinate': 32,\n                 'BitsPerComponent': 8,\n                 'BitsPerFlag': 8,\n                 'ColorSpace': Name(\n                     'DeviceRGB' if colordim == 3 else 'DeviceGray'\n                 ),\n                 'AntiAlias': False,\n                 'Decode': ([points_min[0], points_max[0],\n                             points_min[1], points_max[1]]\n                            + [0, 1] * colordim),\n                 })\n\n            streamarr = np.empty(\n                (shape[0] * shape[1],),\n                dtype=[('flags', 'u1'),\n                       ('points', '>u4', (2,)),\n                       ('colors', 'u1', (colordim,))])\n            streamarr['flags'] = 0\n            streamarr['points'] = (flat_points - points_min) * factor\n            streamarr['colors'] = flat_colors[:, :colordim] * 255.0\n\n            self.write(streamarr.tobytes())\n            self.endStream()\n        self.writeObject(self.gouraudObject, gouraudDict)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeHatches",
      "name": "writeHatches",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeHatches/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self.hatchPatterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n\n            stroke_rgb, fill_rgb, hatch = hatch_style\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_stroke)\n            if fill_rgb is not None:\n                self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n                            Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n\n            self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)\n\n            self.output(*self.pathOperations(\n                Path.hatch(hatch),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.fill_stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeImages",
      "name": "writeImages",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeImages/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeImages(self):\n        for img, name, ob in self._images.values():\n            data, adata = self._unpack(img)\n            if adata is not None:\n                smaskObject = self.reserveObject(\"smask\")\n                self._writeImg(adata, smaskObject.id)\n            else:\n                smaskObject = None\n            self._writeImg(data, ob.id, smaskObject)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeInfoDict",
      "name": "writeInfoDict",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeInfoDict/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the info dictionary, checking it for good form",
      "docstring": "Write out the info dictionary, checking it for good form",
      "code": "    def writeInfoDict(self):\n        \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n\n        self.infoObject = self.reserveObject('info')\n        self.writeObject(self.infoObject, self.infoDict)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeMarkers",
      "name": "writeMarkers",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeMarkers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeMarkers(self):\n        for ((pathops, fill, stroke, joinstyle, capstyle),\n             (name, ob, bbox, lw)) in self.markers.items():\n            # bbox wraps the exact limits of the control points, so half a line\n            # will appear outside it. If the join style is miter and the line\n            # is not parallel to the edge, then the line will extend even\n            # further. From the PDF specification, Section 8.4.3.5, the miter\n            # limit is miterLength / lineWidth and from Table 52, the default\n            # is 10. With half the miter length outside, that works out to the\n            # following padding:\n            bbox = bbox.padded(lw * 5)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': list(bbox.extents)})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(fill, stroke))\n            self.endStream()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject",
      "name": "writeObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject/object",
          "name": "object",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject.object",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject/contents",
          "name": "contents",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject.contents",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeObject(self, object, contents):\n        self.recordXref(object.id)\n        object.write(contents, self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath",
      "name": "writePath",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/clip",
          "name": "clip",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.clip",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/sketch",
          "name": "sketch",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.sketch",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writePath(self, path, transform, clip=False, sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72, self.height * 72)\n            simplify = path.should_simplify\n        else:\n            clip = None\n            simplify = False\n        cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n                                   sketch=sketch)\n        self.output(*cmds)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePathCollectionTemplates",
      "name": "writePathCollectionTemplates",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePathCollectionTemplates/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writePathCollectionTemplates(self):\n        for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n             stroked) in self.paths:\n            pathops = self.pathOperations(path, trans, simplify=False)\n            bbox = path.get_extents(trans)\n            if not np.all(np.isfinite(bbox.extents)):\n                extents = [0, 0, 0, 0]\n            else:\n                bbox = bbox.padded(padding)\n                extents = list(bbox.extents)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': extents})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(filled, stroked))\n            self.endStream()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeTrailer",
      "name": "writeTrailer",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeTrailer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the PDF trailer.",
      "docstring": "Write out the PDF trailer.",
      "code": "    def writeTrailer(self):\n        \"\"\"Write out the PDF trailer.\"\"\"\n\n        self.write(b\"trailer\\n\")\n        self.write(pdfRepr(\n            {'Size': len(self.xrefTable),\n             'Root': self.rootObject,\n             'Info': self.infoObject}))\n        # Could add 'ID'\n        self.write(b\"\\nstartxref\\n%d\\n%%%%EOF\\n\" % self.startxref)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeXref",
      "name": "writeXref",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeXref/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the xref table.",
      "docstring": "Write out the xref table.",
      "code": "    def writeXref(self):\n        \"\"\"Write out the xref table.\"\"\"\n        self.startxref = self.fh.tell() - self.tell_base\n        self.write(b\"xref\\n0 %d\\n\" % len(self.xrefTable))\n        for i, (offset, generation, name) in enumerate(self.xrefTable):\n            if offset is None:\n                raise AssertionError(\n                    'No offset for object %d (%s)' % (i, name))\n            else:\n                key = b\"f\" if name == 'the zero object' else b\"n\"\n                text = b\"%010d %05d %b \\n\" % (offset, generation, key)\n                self.write(text)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__enter__",
      "name": "__enter__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__enter__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter__(self):\n        return self"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__",
      "name": "__exit__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/exc_type",
          "name": "exc_type",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.exc_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/exc_val",
          "name": "exc_val",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.exc_val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/exc_tb",
          "name": "exc_tb",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.exc_tb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/keep_empty",
          "name": "keep_empty",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.keep_empty",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file.",
      "docstring": "Create a new PdfPages object.\n\nParameters\n----------\nfilename : str or path-like or file-like\n    Plots using `PdfPages.savefig` will be written to a file at this\n    location. The file is opened at once and any older file with the\n    same name is overwritten.\n\nkeep_empty : bool, optional\n    If set to False, then empty pdf files will be deleted automatically\n    when closed.\n\nmetadata : dict, optional\n    Information dictionary object (see PDF reference section 10.2.1\n    'Document Information Dictionary'), e.g.:\n    ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n    The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n    'Creator', 'Producer', 'CreationDate', 'ModDate', and\n    'Trapped'. Values have been predefined for 'Creator', 'Producer'\n    and 'CreationDate'. They can be removed by setting them to `None`.",
      "code": "    def __init__(self, filename, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. The file is opened at once and any older file with the\n            same name is overwritten.\n\n        keep_empty : bool, optional\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        self._file = PdfFile(filename, metadata=metadata)\n        self.keep_empty = keep_empty"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note",
      "name": "attach_note",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note/positionRect",
          "name": "positionRect",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note.positionRect",
          "default_value": "[-100, -100, 0, 0]",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a new text note to the page to be saved next. The optional\npositionRect specifies the position of the new note on the\npage. It is outside the page per default to make sure it is\ninvisible on printouts.",
      "docstring": "Add a new text note to the page to be saved next. The optional\npositionRect specifies the position of the new note on the\npage. It is outside the page per default to make sure it is\ninvisible on printouts.",
      "code": "    def attach_note(self, text, positionRect=[-100, -100, 0, 0]):\n        \"\"\"\n        Add a new text note to the page to be saved next. The optional\n        positionRect specifies the position of the new note on the\n        page. It is outside the page per default to make sure it is\n        invisible on printouts.\n        \"\"\"\n        self._file.newTextnote(text, positionRect)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finalize this object, making the underlying file a complete\nPDF file.",
      "docstring": "Finalize this object, making the underlying file a complete\nPDF file.",
      "code": "    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        self._file.finalize()\n        self._file.close()\n        if (self.get_pagecount() == 0 and not self.keep_empty and\n                not self._file.passed_in_file_object):\n            os.remove(self._file.fh.name)\n        self._file = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/get_pagecount",
      "name": "get_pagecount",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/get_pagecount/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the current number of pages in the multipage pdf file.",
      "docstring": "Return the current number of pages in the multipage pdf file.",
      "code": "    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return len(self._file.pageList)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/infodict",
      "name": "infodict",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.infodict",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/infodict/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.infodict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a modifiable information dictionary object\n(see PDF reference section 10.2.1 'Document Information\nDictionary').",
      "docstring": "Return a modifiable information dictionary object\n(see PDF reference section 10.2.1 'Document Information\nDictionary').",
      "code": "    def infodict(self):\n        \"\"\"\n        Return a modifiable information dictionary object\n        (see PDF reference section 10.2.1 'Document Information\n        Dictionary').\n        \"\"\"\n        return self._file.infoDict"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig",
      "name": "savefig",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Figure` or int",
            "default_value": "the active figure",
            "description": "The figure, or index of the figure, that is saved to the file."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`.Figure`"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.",
      "docstring": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.\n\nParameters\n----------\nfigure : `.Figure` or int, default: the active figure\n    The figure, or index of the figure, that is saved to the file.",
      "code": "    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, default: the active figure\n            The figure, or index of the figure, that is saved to the file.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n        # Force use of pdf backend, as PdfPages is tightly coupled with it.\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPdf(figure)\n            figure.savefig(self, format=\"pdf\", **kwargs)\n        finally:\n            figure.canvas = orig_canvas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.__init__.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF reference object.\n\nUse PdfFile.reserveObject() to create References.",
      "docstring": "",
      "code": "    def __init__(self, id):\n        self.id = id"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return \"<Reference %d>\" % self.id"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return b\"%d 0 R\" % self.id"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write",
      "name": "write",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.write",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.write.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write/contents",
          "name": "contents",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.write.contents",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.write.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def write(self, contents, file):\n        write = file.write\n        write(b\"%d 0 obj\\n\" % self.id)\n        write(pdfRepr(contents))\n        write(b\"\\nendobj\\n\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/image_dpi",
          "name": "image_dpi",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.image_dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, file, image_dpi, height, width):\n        super().__init__(width, height)\n        self.file = file\n        self.gc = self.new_gc()\n        self.image_dpi = image_dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc",
      "name": "check_gc",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc/fillcolor",
          "name": "fillcolor",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc.fillcolor",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc.get_rgb() is None:\n            # It should not matter what color here since linewidth should be\n            # 0 unless affected by global settings in rcParams, hence setting\n            # zero alpha just in case.\n            gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle",
      "name": "draw_gouraud_triangle",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles",
      "name": "draw_gouraud_triangles",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        if len(points) == 0:\n            return\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] in (1, 4)\n\n        shape = points.shape\n        points = points.reshape((shape[0] * shape[1], 2))\n        tpoints = trans.transform(points)\n        tpoints = tpoints.reshape(shape)\n        name, _ = self.file.addGouraudTriangles(tpoints, colors)\n        output = self.file.output\n\n        if colors.shape[2] == 1:\n            # grayscale\n            gc.set_alpha(1.0)\n            self.check_gc(gc)\n            output(name, Op.shading)\n            return\n\n        alpha = colors[0, 0, 3]\n        if np.allclose(alpha, colors[:, :, 3]):\n            # single alpha value\n            gc.set_alpha(alpha)\n            self.check_gc(gc)\n            output(name, Op.shading)\n        else:\n            # varying alpha: use a soft mask\n            alpha = colors[:, :, 3][:, :, None]\n            _, smask_ob = self.file.addGouraudTriangles(tpoints, alpha)\n            gstate = self.file._soft_mask_state(smask_ob)\n            output(Op.gsave, gstate, Op.setgstate,\n                   name, Op.shading,\n                   Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if transform is None:\n            # If there's no transform, alpha has already been applied\n            gc.set_alpha(1.0)\n\n        self.check_gc(gc)\n\n        w = 72.0 * w / self.image_dpi\n        h = 72.0 * h / self.image_dpi\n\n        imob = self.file.imageObject(im)\n\n        if transform is None:\n            self.file.output(Op.gsave,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n\n            self.file.output(Op.gsave,\n                             1, 0, 0, 1, x, y, Op.concat_matrix,\n                             tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        # Same logic as in draw_path_collection\n        len_marker_path = len(marker_path)\n        uses = len(path)\n        if len_marker_path * uses < len_marker_path + uses + 5:\n            RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n                                      path, trans, rgbFace)\n            return\n\n        self.check_gc(gc, rgbFace)\n        fill = gc.fill(rgbFace)\n        stroke = gc.stroke()\n\n        output = self.file.output\n        marker = self.file.markerObject(\n            marker_path, marker_trans, fill, stroke, self.gc._linewidth,\n            gc.get_joinstyle(), gc.get_capstyle())\n\n        output(Op.gsave)\n        lastx, lasty = 0, 0\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.file.width*72, self.file.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                if not (0 <= x <= self.file.width * 72\n                        and 0 <= y <= self.file.height * 72):\n                    continue\n                dx, dy = x - lastx, y - lasty\n                output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n                       marker, Op.use_xobject)\n                lastx, lasty = x, y\n        output(Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext",
      "name": "draw_mathtext",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        # TODO: fix positioning and encoding\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width, height, angle))\n\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        # Set up a global transformation matrix for the whole math expression\n        a = math.radians(angle)\n        self.file.output(Op.gsave)\n        self.file.output(math.cos(a), math.sin(a),\n                         -math.sin(a), math.cos(a),\n                         x, y, Op.concat_matrix)\n\n        self.check_gc(gc, gc._rgb)\n        prev_font = None, None\n        oldx, oldy = 0, 0\n        unsupported_chars = []\n\n        self.file.output(Op.begin_text)\n        for font, fontsize, num, ox, oy in glyphs:\n            self.file._character_tracker.track_glyph(font, num)\n            fontname = font.fname\n            if not _font_supports_glyph(fonttype, num):\n                # Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in\n                # Type 42) must be emitted separately (below).\n                unsupported_chars.append((font, fontsize, ox, oy, num))\n            else:\n                self._setup_textpos(ox, oy, 0, oldx, oldy)\n                oldx, oldy = ox, oy\n                if (fontname, fontsize) != prev_font:\n                    self.file.output(self.file.fontName(fontname), fontsize,\n                                     Op.selectfont)\n                    prev_font = fontname, fontsize\n                self.file.output(self.encode_string(chr(num), fonttype),\n                                 Op.show)\n        self.file.output(Op.end_text)\n\n        for font, fontsize, ox, oy, num in unsupported_chars:\n            self._draw_xobject_glyph(\n                font, fontsize, font.get_char_index(num), ox, oy)\n\n        # Draw any horizontal lines in the math layout\n        for ox, oy, width, height in rects:\n            self.file.output(Op.gsave, ox, oy, width, height,\n                             Op.rectangle, Op.fill, Op.grestore)\n\n        # Pop off the global transformation\n        self.file.output(Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        self.check_gc(gc, rgbFace)\n        self.file.writePath(\n            path, transform,\n            rgbFace is None and gc.get_hatch_path() is None,\n            gc.get_sketch_params())\n        self.file.output(self.gc.paint())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/offset_trans",
          "name": "offset_trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.offset_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # We can only reuse the objects if the presence of fill and\n        # stroke (and the amount of alpha for each) is the same for\n        # all of them\n        can_do_optimization = True\n        facecolors = np.asarray(facecolors)\n        edgecolors = np.asarray(edgecolors)\n\n        if not len(facecolors):\n            filled = False\n            can_do_optimization = not gc.get_hatch()\n        else:\n            if np.all(facecolors[:, 3] == facecolors[0, 3]):\n                filled = facecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        if not len(edgecolors):\n            stroked = False\n        else:\n            if np.all(np.asarray(linewidths) == 0.0):\n                stroked = False\n            elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):\n                stroked = edgecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is len_path * uses_per_path\n        # cost of XObject is len_path + 5 for the definition,\n        #    uses_per_path for the uses\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + uses_per_path + 5 < len_path * uses_per_path\n\n        if (not can_do_optimization) or (not should_do_optimization):\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        padding = np.max(linewidths)\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = self.file.pathCollectionObject(\n                gc, path, transform, padding, filled, stroked)\n            path_codes.append(name)\n\n        output = self.file.output\n        output(*self.gc.push())\n        lastx, lasty = 0, 0\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n\n            self.check_gc(gc0, rgbFace)\n            dx, dy = xo - lastx, yo - lasty\n            output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,\n                   Op.use_xobject)\n            lastx, lasty = xo, yo\n        output(*self.gc.pop())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        texmanager = self.get_texmanager()\n        fontsize = prop.get_size_in_points()\n        dvifile = texmanager.make_dvi(s, fontsize)\n        with dviread.Dvi(dvifile, 72) as dvi:\n            page, = dvi\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, page.width, page.height, angle))\n\n        # Gather font information and do some setup for combining\n        # characters into strings. The variable seq will contain a\n        # sequence of font and text entries. A font entry is a list\n        # ['font', name, size] where name is a Name object for the\n        # font. A text entry is ['text', x, y, glyphs, x+w] where x\n        # and y are the starting coordinates, w is the width, and\n        # glyphs is a list; in this phase it will always contain just\n        # one one-character string, but later it may have longer\n        # strings interspersed with kern amounts.\n        oldfont, seq = None, []\n        for x1, y1, dvifont, glyph, width in page.text:\n            if dvifont != oldfont:\n                pdfname = self.file.dviFontName(dvifont)\n                seq += [['font', pdfname, dvifont.size]]\n                oldfont = dvifont\n            seq += [['text', x1, y1, [bytes([glyph])], x1+width]]\n\n        # Find consecutive text strings with constant y coordinate and\n        # combine into a sequence of strings and kerns, or just one\n        # string (if any kerns would be less than 0.1 points).\n        i, curx, fontsize = 0, 0, None\n        while i < len(seq)-1:\n            elt, nxt = seq[i:i+2]\n            if elt[0] == 'font':\n                fontsize = elt[2]\n            elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:\n                offset = elt[4] - nxt[1]\n                if abs(offset) < 0.1:\n                    elt[3][-1] += nxt[3][0]\n                    elt[4] += nxt[4]-nxt[1]\n                else:\n                    elt[3] += [offset*1000.0/fontsize, nxt[3][0]]\n                    elt[4] = nxt[4]\n                del seq[i+1]\n                continue\n            i += 1\n\n        # Create a transform to map the dvi contents to the canvas.\n        mytrans = Affine2D().rotate_deg(angle).translate(x, y)\n\n        # Output the text.\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        curx, cury, oldx, oldy = 0, 0, 0, 0\n        for elt in seq:\n            if elt[0] == 'font':\n                self.file.output(elt[1], elt[2], Op.selectfont)\n            elif elt[0] == 'text':\n                curx, cury = mytrans.transform((elt[1], elt[2]))\n                self._setup_textpos(curx, cury, angle, oldx, oldy)\n                oldx, oldy = curx, cury\n                if len(elt[3]) == 1:\n                    self.file.output(elt[3][0], Op.show)\n                else:\n                    self.file.output(elt[3], Op.showkern)\n            else:\n                assert False\n        self.file.output(Op.end_text)\n\n        # Then output the boxes (e.g., variable-length lines of square\n        # roots).\n        boxgc = self.new_gc()\n        boxgc.copy_properties(gc)\n        boxgc.set_linewidth(0)\n        pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.CLOSEPOLY]\n        for x1, y1, h, w in page.boxes:\n            path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],\n                         [0, 0]], pathops)\n            self.draw_path(boxgc, path, mytrans, gc._rgb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # TODO: combine consecutive texts into one BT/ET delimited section\n\n        self.check_gc(gc, gc._rgb)\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        fontsize = prop.get_size_in_points()\n\n        if mpl.rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            fonttype = 1\n        else:\n            font = self._get_font_ttf(prop)\n            self.file._character_tracker.track(font, s)\n            fonttype = mpl.rcParams['pdf.fonttype']\n\n        if gc.get_url() is not None:\n            font.set_text(s)\n            width, height = font.get_width_height()\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width / 64, height / 64, angle))\n\n        # If fonttype is neither 3 nor 42, emit the whole string at once\n        # without manual kerning.\n        if fonttype not in [3, 42]:\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            self._setup_textpos(x, y, angle)\n            self.file.output(self.encode_string(s, fonttype),\n                             Op.show, Op.end_text)\n\n        # A sequence of characters is broken into multiple chunks. The chunking\n        # serves two purposes:\n        #   - For Type 3 fonts, there is no way to access multibyte characters,\n        #     as they cannot have a CIDMap.  Therefore, in this case we break\n        #     the string into chunks, where each chunk contains either a string\n        #     of consecutive 1-byte characters or a single multibyte character.\n        #   - A sequence of 1-byte characters is split into chunks to allow for\n        #     kerning adjustments between consecutive chunks.\n        #\n        # Each chunk is emitted with a separate command: 1-byte characters use\n        # the regular text show command (TJ) with appropriate kerning between\n        # chunks, whereas multibyte characters use the XObject command (Do).\n        else:\n            # List of (ft_object, start_x, [prev_kern, char, char, ...]),\n            # w/o zero kerns.\n            singlebyte_chunks = []\n            # List of (ft_object, start_x, glyph_index).\n            multibyte_glyphs = []\n            prev_was_multibyte = True\n            prev_font = font\n            for item in _text_helpers.layout(\n                    s, font, kern_mode=KERNING_UNFITTED):\n                if _font_supports_glyph(fonttype, ord(item.char)):\n                    if prev_was_multibyte or item.ft_object != prev_font:\n                        singlebyte_chunks.append((item.ft_object, item.x, []))\n                        prev_font = item.ft_object\n                    if item.prev_kern:\n                        singlebyte_chunks[-1][2].append(item.prev_kern)\n                    singlebyte_chunks[-1][2].append(item.char)\n                    prev_was_multibyte = False\n                else:\n                    multibyte_glyphs.append(\n                        (item.ft_object, item.x, item.glyph_idx)\n                    )\n                    prev_was_multibyte = True\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = math.radians(angle)\n            self.file.output(math.cos(a), math.sin(a),\n                             -math.sin(a), math.cos(a),\n                             x, y, Op.concat_matrix)\n            # Emit all the 1-byte characters in a BT/ET group.\n\n            self.file.output(Op.begin_text)\n            prev_start_x = 0\n            for ft_object, start_x, kerns_or_chars in singlebyte_chunks:\n                ft_name = self.file.fontName(ft_object.fname)\n                self.file.output(ft_name, fontsize, Op.selectfont)\n                self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n                self.file.output(\n                    # See pdf spec \"Text space details\" for the 1000/fontsize\n                    # (aka. 1000/T_fs) factor.\n                    [-1000 * next(group) / fontsize if tp == float  # a kern\n                     else self.encode_string(\"\".join(group), fonttype)\n                     for tp, group in itertools.groupby(kerns_or_chars, type)],\n                    Op.showkern)\n                prev_start_x = start_x\n            self.file.output(Op.end_text)\n            # Then emit all the multibyte characters, one at a time.\n            for ft_object, start_x, glyph_idx in multibyte_glyphs:\n                self._draw_xobject_glyph(\n                    ft_object, fontsize, glyph_idx, start_x, 0\n                )\n            self.file.output(Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string",
      "name": "encode_string",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string/fonttype",
          "name": "fonttype",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string.fonttype",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def encode_string(self, s, fonttype):\n        if fonttype in (1, 3):\n            return s.encode('cp1252', 'replace')\n        return s.encode('utf-16be', 'replace')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def finalize(self):\n        self.file.output(*self.gc.finalize())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/get_image_magnification",
      "name": "get_image_magnification",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/get_image_magnification/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_image_magnification(self):\n        return self.image_dpi/72.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPdf(self.file)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/len",
          "name": "len",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.len",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.extra",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/png",
          "name": "png",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.png",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF stream object.\n\nThis has no pdfRepr method. Instead, call begin(), then output the\ncontents of the stream by calling write(), and finally call end().",
      "docstring": "Parameters\n----------\nid : int\n    Object id of the stream.\nlen : Reference or None\n    An unused Reference object for the length of the stream;\n    None means to use a memory buffer so the length can be inlined.\nfile : PdfFile\n    The underlying object to write the stream to.\nextra : dict from Name to anything, or None\n    Extra key-value pairs to include in the stream header.\npng : dict or None\n    If the data is already png encoded, the decode parameters.",
      "code": "    def __init__(self, id, len, file, extra=None, png=None):\n        \"\"\"\n        Parameters\n        ----------\n        id : int\n            Object id of the stream.\n        len : Reference or None\n            An unused Reference object for the length of the stream;\n            None means to use a memory buffer so the length can be inlined.\n        file : PdfFile\n            The underlying object to write the stream to.\n        extra : dict from Name to anything, or None\n            Extra key-value pairs to include in the stream header.\n        png : dict or None\n            If the data is already png encoded, the decode parameters.\n        \"\"\"\n        self.id = id            # object id\n        self.len = len          # id of length object\n        self.pdfFile = file\n        self.file = file.fh      # file to which the stream is written\n        self.compressobj = None  # compression object\n        if extra is None:\n            self.extra = dict()\n        else:\n            self.extra = extra.copy()\n        if png is not None:\n            self.extra.update({'Filter':      Name('FlateDecode'),\n                               'DecodeParms': png})\n\n        self.pdfFile.recordXref(self.id)\n        if mpl.rcParams['pdf.compression'] and not png:\n            self.compressobj = zlib.compressobj(\n                mpl.rcParams['pdf.compression'])\n        if self.len is None:\n            self.file = BytesIO()\n        else:\n            self._writeHeader()\n            self.pos = self.file.tell()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/end",
      "name": "end",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream.end",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/end/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.end.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finalize stream.",
      "docstring": "Finalize stream.",
      "code": "    def end(self):\n        \"\"\"Finalize stream.\"\"\"\n\n        self._flush()\n        if self.len is None:\n            contents = self.file.getvalue()\n            self.len = len(contents)\n            self.file = self.pdfFile.fh\n            self._writeHeader()\n            self.file.write(contents)\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n        else:\n            length = self.file.tell() - self.pos\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n            self.pdfFile.writeObject(self.len, length)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write",
      "name": "write",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream.write",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.write.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.write.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write some data on the stream.",
      "docstring": "Write some data on the stream.",
      "code": "    def write(self, data):\n        \"\"\"Write some data on the stream.\"\"\"\n\n        if self.compressobj is None:\n            self.file.write(data)\n        else:\n            compressed = self.compressobj.compress(data)\n            self.file.write(compressed)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.__init__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Store verbatim PDF command content for later inclusion in the stream.",
      "docstring": "",
      "code": "    def __init__(self, x):\n        self._x = x"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return self._x"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/fill",
      "name": "fill",
      "qname": "lib.matplotlib.backends.backend_pdf.fill",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _fill')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/fill/strings",
          "name": "strings",
          "qname": "lib.matplotlib.backends.backend_pdf.fill.strings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/fill/linelen",
          "name": "linelen",
          "qname": "lib.matplotlib.backends.backend_pdf.fill.linelen",
          "default_value": "75",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _fill\")\ndef fill(strings, linelen=75):\n    return _fill(strings, linelen=linelen)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/pdfRepr/obj",
          "name": "obj",
          "qname": "lib.matplotlib.backends.backend_pdf.pdfRepr.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Map Python objects to PDF syntax.",
      "docstring": "Map Python objects to PDF syntax.",
      "code": "def pdfRepr(obj):\n    \"\"\"Map Python objects to PDF syntax.\"\"\"\n\n    # Some objects defined later have their own pdfRepr method.\n    if hasattr(obj, 'pdfRepr'):\n        return obj.pdfRepr()\n\n    # Floats. PDF does not have exponential notation (1.0e-10) so we\n    # need to use %f with some precision.  Perhaps the precision\n    # should adapt to the magnitude of the number?\n    elif isinstance(obj, (float, np.floating)):\n        if not np.isfinite(obj):\n            raise ValueError(\"Can only output finite numbers in PDF\")\n        r = b\"%.10f\" % obj\n        return r.rstrip(b'0').rstrip(b'.')\n\n    # Booleans. Needs to be tested before integers since\n    # isinstance(True, int) is true.\n    elif isinstance(obj, bool):\n        return [b'false', b'true'][obj]\n\n    # Integers are written as such.\n    elif isinstance(obj, (int, np.integer)):\n        return b\"%d\" % obj\n\n    # Non-ASCII Unicode strings are encoded in UTF-16BE with byte-order mark.\n    elif isinstance(obj, str):\n        return pdfRepr(obj.encode('ascii') if obj.isascii()\n                       else codecs.BOM_UTF16_BE + obj.encode('UTF-16BE'))\n\n    # Strings are written in parentheses, with backslashes and parens\n    # escaped. Actually balanced parens are allowed, but it is\n    # simpler to escape them all. TODO: cut long strings into lines;\n    # I believe there is some maximum line length in PDF.\n    # Despite the extra decode/encode, translate is faster than regex.\n    elif isinstance(obj, bytes):\n        return (\n            b'(' +\n            obj.decode('latin-1').translate(_str_escapes).encode('latin-1')\n            + b')')\n\n    # Dictionaries. The keys must be PDF names, so if we find strings\n    # there, we make Name objects from them. The values may be\n    # anything, so the caller must ensure that PDF names are\n    # represented as Name objects.\n    elif isinstance(obj, dict):\n        return _fill([\n            b\"<<\",\n            *[Name(k).pdfRepr() + b\" \" + pdfRepr(v) for k, v in obj.items()],\n            b\">>\",\n        ])\n\n    # Lists.\n    elif isinstance(obj, (list, tuple)):\n        return _fill([b\"[\", *[pdfRepr(val) for val in obj], b\"]\"])\n\n    # The null keyword.\n    elif obj is None:\n        return b'null'\n\n    # A date.\n    elif isinstance(obj, datetime):\n        return pdfRepr(_datetime_to_pdf(obj))\n\n    # A bounding box\n    elif isinstance(obj, BboxBase):\n        return _fill([pdfRepr(val) for val in obj.bounds])\n\n    else:\n        raise TypeError(\"Don't know a PDF representation for {} objects\"\n                        .format(type(obj)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'pdf'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_renderer",
      "name": "get_renderer",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_renderer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_renderer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_renderer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_renderer(self):\n        return RendererPgf(self.figure, None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf",
      "name": "print_pdf",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/fname_or_fh",
          "name": "fname_or_fh",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.fname_or_fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use LaTeX to compile a pgf generated figure to pdf.",
      "docstring": "Use LaTeX to compile a pgf generated figure to pdf.",
      "code": "    def print_pdf(self, fname_or_fh, *, metadata=None, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf generated figure to pdf.\"\"\"\n        w, h = self.figure.get_size_inches()\n\n        info_dict = _create_pdf_info_dict('pgf', metadata or {})\n        pdfinfo = ','.join(\n            _metadata_to_str(k, v) for k, v in info_dict.items())\n\n        # print figure to pgf and compile it with latex\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            self.print_pgf(tmppath / \"figure.pgf\", **kwargs)\n            (tmppath / \"figure.tex\").write_text(\n                \"\\n\".join([\n                    r\"\\documentclass[12pt]{article}\",\n                    r\"\\usepackage[pdfinfo={%s}]{hyperref}\" % pdfinfo,\n                    r\"\\usepackage[papersize={%fin,%fin}, margin=0in]{geometry}\"\n                    % (w, h),\n                    r\"\\usepackage{pgf}\",\n                    _get_preamble(),\n                    r\"\\begin{document}\",\n                    r\"\\centering\",\n                    r\"\\input{figure.pgf}\",\n                    r\"\\end{document}\",\n                ]), encoding=\"utf-8\")\n            texcommand = mpl.rcParams[\"pgf.texsystem\"]\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 \"figure.tex\"], _log, cwd=tmpdir)\n            with (tmppath / \"figure.pdf\").open(\"rb\") as orig, \\\n                 cbook.open_file_cm(fname_or_fh, \"wb\") as dest:\n                shutil.copyfileobj(orig, dest)  # copy file contents to target"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf",
      "name": "print_pgf",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/fname_or_fh",
          "name": "fname_or_fh",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.fname_or_fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Output pgf macros for drawing the figure so it can be included and\nrendered in latex documents.",
      "docstring": "Output pgf macros for drawing the figure so it can be included and\nrendered in latex documents.",
      "code": "    def print_pgf(self, fname_or_fh, **kwargs):\n        \"\"\"\n        Output pgf macros for drawing the figure so it can be included and\n        rendered in latex documents.\n        \"\"\"\n        with cbook.open_file_cm(fname_or_fh, \"w\", encoding=\"utf-8\") as file:\n            if not cbook.file_requires_unicode(file):\n                file = codecs.getwriter(\"utf-8\")(file)\n            self._print_pgf_to_fh(file, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/fname_or_fh",
          "name": "fname_or_fh",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.fname_or_fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use LaTeX to compile a pgf figure to pdf and convert it to png.",
      "docstring": "Use LaTeX to compile a pgf figure to pdf and convert it to png.",
      "code": "    def print_png(self, fname_or_fh, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf figure to pdf and convert it to png.\"\"\"\n        converter = make_pdf_to_png_converter()\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            pdf_path = tmppath / \"figure.pdf\"\n            png_path = tmppath / \"figure.png\"\n            self.print_pdf(pdf_path, **kwargs)\n            converter(pdf_path, png_path, dpi=self.figure.dpi)\n            with png_path.open(\"rb\") as orig, \\\n                 cbook.open_file_cm(fname_or_fh, \"wb\") as dest:\n                shutil.copyfileobj(orig, dest)  # copy file contents to target"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__/latex_output",
          "name": "latex_output",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__.latex_output",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, message, latex_output=\"\"):\n        super().__init__(message)\n        self.latex_output = latex_output"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__str__",
      "name": "__str__",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__str__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self):\n        s, = self.args\n        if self.latex_output:\n            s += \"\\n\" + self.latex_output\n        return s"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.",
      "docstring": "",
      "code": "    def __init__(self):\n        # create a tmp directory for running latex, register it for deletion\n        self._tmpdir = TemporaryDirectory()\n        self.tmpdir = self._tmpdir.name\n        self._finalize_tmpdir = weakref.finalize(self, self._tmpdir.cleanup)\n\n        # test the LaTeX setup to ensure a clean startup of the subprocess\n        try:\n            self._setup_latex_process(expect_reply=False)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{self.latex.args[0]!r} not found.  Install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX \"\n                f\"implementation.\") from err\n        except OSError as err:\n            raise RuntimeError(\n                f\"Error starting process {self.latex.args[0]!r}\") from err\n        stdout, stderr = self.latex.communicate(\"\\n\\\\makeatletter\\\\@@end\\n\")\n        if self.latex.returncode != 0:\n            raise LatexError(\n                f\"LaTeX errored (probably missing font or error in preamble) \"\n                f\"while processing the following input:\\n\"\n                f\"{self._build_latex_header()}\",\n                stdout)\n\n        self.latex = None  # Will be set up on first use.\n        # Per-instance cache.\n        self._get_box_metrics = functools.lru_cache()(self._get_box_metrics)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent",
      "name": "get_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the width, total height, and descent (in TeX points) for a text\ntypeset by the current LaTeX environment.",
      "docstring": "Get the width, total height, and descent (in TeX points) for a text\ntypeset by the current LaTeX environment.",
      "code": "    def get_width_height_descent(self, text, prop):\n        \"\"\"\n        Get the width, total height, and descent (in TeX points) for a text\n        typeset by the current LaTeX environment.\n        \"\"\"\n        return self._get_box_metrics(_escape_and_apply_props(text, prop))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__enter__",
      "name": "__enter__",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__enter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__enter__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__enter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter__(self):\n        return self"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__",
      "name": "__exit__",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/exc_type",
          "name": "exc_type",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.exc_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/exc_val",
          "name": "exc_val",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.exc_val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/exc_tb",
          "name": "exc_tb",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.exc_tb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/keep_empty",
          "name": "keep_empty",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.keep_empty",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file using the pgf backend",
      "docstring": "Create a new PdfPages object.\n\nParameters\n----------\nfilename : str or path-like\n    Plots using `PdfPages.savefig` will be written to a file at this\n    location. Any older file with the same name is overwritten.\n\nkeep_empty : bool, default: True\n    If set to False, then empty pdf files will be deleted automatically\n    when closed.\n\nmetadata : dict, optional\n    Information dictionary object (see PDF reference section 10.2.1\n    'Document Information Dictionary'), e.g.:\n    ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n    The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n    'Creator', 'Producer', 'CreationDate', 'ModDate', and\n    'Trapped'. Values have been predefined for 'Creator', 'Producer'\n    and 'CreationDate'. They can be removed by setting them to `None`.\n\n    Note that some versions of LaTeX engines may ignore the 'Producer'\n    key and set it to themselves.",
      "code": "    def __init__(self, filename, *, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. Any older file with the same name is overwritten.\n\n        keep_empty : bool, default: True\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n\n            Note that some versions of LaTeX engines may ignore the 'Producer'\n            key and set it to themselves.\n        \"\"\"\n        self._output_name = filename\n        self._n_figures = 0\n        self.keep_empty = keep_empty\n        self._metadata = (metadata or {}).copy()\n        self._info_dict = _create_pdf_info_dict('pgf', self._metadata)\n        self._file = BytesIO()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finalize this object, running LaTeX in a temporary directory\nand moving the final pdf file to *filename*.",
      "docstring": "Finalize this object, running LaTeX in a temporary directory\nand moving the final pdf file to *filename*.",
      "code": "    def close(self):\n        \"\"\"\n        Finalize this object, running LaTeX in a temporary directory\n        and moving the final pdf file to *filename*.\n        \"\"\"\n        self._file.write(rb'\\end{document}\\n')\n        if self._n_figures > 0:\n            self._run_latex()\n        elif self.keep_empty:\n            open(self._output_name, 'wb').close()\n        self._file.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/get_pagecount",
      "name": "get_pagecount",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.get_pagecount",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/get_pagecount/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.get_pagecount.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the current number of pages in the multipage pdf file.",
      "docstring": "Return the current number of pages in the multipage pdf file.",
      "code": "    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return self._n_figures"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig",
      "name": "savefig",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Figure` or int",
            "default_value": "the active figure",
            "description": "The figure, or index of the figure, that is saved to the file."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`.Figure`"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.",
      "docstring": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.\n\nParameters\n----------\nfigure : `.Figure` or int, default: the active figure\n    The figure, or index of the figure, that is saved to the file.",
      "code": "    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, default: the active figure\n            The figure, or index of the figure, that is saved to the file.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPgf(figure)\n\n            width, height = figure.get_size_inches()\n            if self._n_figures == 0:\n                self._write_header(width, height)\n            else:\n                # \\pdfpagewidth and \\pdfpageheight exist on pdftex, xetex, and\n                # luatex<0.85; they were renamed to \\pagewidth and \\pageheight\n                # on luatex>=0.85.\n                self._file.write(\n                    br'\\newpage'\n                    br'\\ifdefined\\pdfpagewidth\\pdfpagewidth'\n                    br'\\else\\pagewidth\\fi=%ain'\n                    br'\\ifdefined\\pdfpageheight\\pdfpageheight'\n                    br'\\else\\pageheight\\fi=%ain'\n                    b'%%\\n' % (width, height)\n                )\n\n            figure.savefig(self._file, format=\"pgf\", **kwargs)\n            self._n_figures += 1\n        finally:\n            figure.canvas = orig_canvas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/fh",
          "name": "fh",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Create a new PGF renderer that translates any drawing instruction\ninto text commands to be interpreted in a latex pgfpicture environment.\n\nAttributes\n----------\nfigure : `matplotlib.figure.Figure`\n    Matplotlib figure to initialize height, width and dpi from.\nfh : file-like\n    File handle for the output of the drawing commands.",
      "code": "    def __init__(self, figure, fh):\n        \"\"\"\n        Create a new PGF renderer that translates any drawing instruction\n        into text commands to be interpreted in a latex pgfpicture environment.\n\n        Attributes\n        ----------\n        figure : `matplotlib.figure.Figure`\n            Matplotlib figure to initialize height, width and dpi from.\n        fh : file-like\n            File handle for the output of the drawing commands.\n        \"\"\"\n\n        super().__init__()\n        self.dpi = figure.dpi\n        self.fh = fh\n        self.figure = figure\n        self.image_counter = 0"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if not os.path.exists(getattr(self.fh, \"name\", \"\")):\n            raise ValueError(\n                \"streamed pgf-code does not support raster graphics, consider \"\n                \"using the pgf-to-pdf option\")\n\n        # save the images to png files\n        path = pathlib.Path(self.fh.name)\n        fname_img = \"%s-img%d.png\" % (path.stem, self.image_counter)\n        Image.fromarray(im[::-1]).save(path.parent / fname_img)\n        self.image_counter += 1\n\n        # reference the image in the pgf picture\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n        self._print_pgf_clip(gc)\n        f = 1. / self.dpi  # from display coords to inch\n        if transform is None:\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x * f, y * f))\n            w, h = w * f, h * f\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformcm{%f}{%f}{%f}{%f}{%fin}{%fin}\" %\n                     (tr1 * f, tr2 * f, tr3 * f, tr4 * f,\n                      (tr5 + x) * f, (tr6 + y) * f))\n            w = h = 1  # scale is already included in the transform\n        interp = str(transform is None).lower()  # interpolation in PDF reader\n        _writeln(self.fh,\n                 r\"\\pgftext[left,bottom]\"\n                 r\"{%s[interpolate=%s,width=%fin,height=%fin]{%s}}\" %\n                 (_get_image_inclusion_command(),\n                  interp, w, h, fname_img))\n        _writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        # convert from display units to in\n        f = 1. / self.dpi\n\n        # set style and clip\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n\n        # build marker definition\n        bl, tr = marker_path.get_extents(marker_trans).get_points()\n        coords = bl[0] * f, bl[1] * f, tr[0] * f, tr[1] * f\n        _writeln(self.fh,\n                 r\"\\pgfsys@defobject{currentmarker}\"\n                 r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}{\" % coords)\n        self._print_pgf_path(None, marker_path, marker_trans)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        _writeln(self.fh, r\"}\")\n\n        maxcoord = 16383 / 72.27 * self.dpi  # Max dimensions in LaTeX.\n        clip = (-maxcoord, -maxcoord, maxcoord, maxcoord)\n\n        # draw marker for each vertex\n        for point, code in path.iter_segments(trans, simplify=False,\n                                              clip=clip):\n            x, y = point[0] * f, point[1] * f\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            _writeln(self.fh, r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x, y))\n            _writeln(self.fh, r\"\\pgfsys@useobject{currentmarker}{}\")\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n\n        _writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n        # draw the path\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n        self._print_pgf_path(gc, path, transform, rgbFace)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n        # if present, draw pattern on top\n        if gc.get_hatch():\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            self._print_pgf_path_styles(gc, rgbFace)\n\n            # combine clip and path for clipping\n            self._print_pgf_clip(gc)\n            self._print_pgf_path(gc, path, transform, rgbFace)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n            # build pattern definition\n            _writeln(self.fh,\n                     r\"\\pgfsys@defobject{currentpattern}\"\n                     r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}{\")\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            _writeln(self.fh,\n                     r\"\\pgfpathrectangle\"\n                     r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}\")\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n            scale = mpl.transforms.Affine2D().scale(self.dpi)\n            self._print_pgf_path(None, gc.get_hatch_path(), scale)\n            self._pgf_path_draw(stroke=True)\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n            _writeln(self.fh, r\"}\")\n            # repeat pattern, filling the bounding rect of the path\n            f = 1. / self.dpi\n            (xmin, ymin), (xmax, ymax) = \\\n                path.get_extents(transform).get_points()\n            xmin, xmax = f * xmin, f * xmax\n            ymin, ymax = f * ymin, f * ymax\n            repx, repy = math.ceil(xmax - xmin), math.ceil(ymax - ymin)\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformshift{%fin}{%fin}\" % (xmin, ymin))\n            for iy in range(repy):\n                for ix in range(repx):\n                    _writeln(self.fh, r\"\\pgfsys@useobject{currentpattern}{}\")\n                    _writeln(self.fh, r\"\\pgfsys@transformshift{1in}{0in}\")\n                _writeln(self.fh, r\"\\pgfsys@transformshift{-%din}{0in}\" % repx)\n                _writeln(self.fh, r\"\\pgfsys@transformshift{0in}{1in}\")\n\n            _writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.ismath",
          "default_value": "'TeX'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_tex(self, gc, x, y, s, prop, angle, ismath=\"TeX\", mtext=None):\n        # docstring inherited\n        self.draw_text(gc, x, y, s, prop, angle, ismath, mtext)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # prepare string for tex\n        s = _escape_and_apply_props(s, prop)\n\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        alpha = gc.get_alpha()\n        if alpha != 1.0:\n            _writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % alpha)\n            _writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % alpha)\n        rgb = tuple(gc.get_rgb())[:3]\n        _writeln(self.fh, r\"\\definecolor{textcolor}{rgb}{%f,%f,%f}\" % rgb)\n        _writeln(self.fh, r\"\\pgfsetstrokecolor{textcolor}\")\n        _writeln(self.fh, r\"\\pgfsetfillcolor{textcolor}\")\n        s = r\"\\color{textcolor}\" + s\n\n        dpi = self.figure.dpi\n        text_args = []\n        if mtext and (\n                (angle == 0 or\n                 mtext.get_rotation_mode() == \"anchor\") and\n                mtext.get_verticalalignment() != \"center_baseline\"):\n            # if text anchoring can be supported, get the original coordinates\n            # and add alignment information\n            pos = mtext.get_unitless_position()\n            x, y = mtext.get_transform().transform(pos)\n            halign = {\"left\": \"left\", \"right\": \"right\", \"center\": \"\"}\n            valign = {\"top\": \"top\", \"bottom\": \"bottom\",\n                      \"baseline\": \"base\", \"center\": \"\"}\n            text_args.extend([\n                f\"x={x/dpi:f}in\",\n                f\"y={y/dpi:f}in\",\n                halign[mtext.get_horizontalalignment()],\n                valign[mtext.get_verticalalignment()],\n            ])\n        else:\n            # if not, use the text layout provided by Matplotlib.\n            text_args.append(f\"x={x/dpi:f}in, y={y/dpi:f}in, left, base\")\n\n        if angle != 0:\n            text_args.append(\"rotate=%f\" % angle)\n\n        _writeln(self.fh, r\"\\pgftext[%s]{%s}\" % (\",\".join(text_args), s))\n        _writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return (self.figure.get_figwidth() * self.dpi,\n                self.figure.get_figheight() * self.dpi)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        # get text metrics in units of latex pt, convert to display units\n        w, h, d = (LatexManager._get_cached_or_new()\n                   .get_width_height_descent(s, prop))\n        # TODO: this should be latex_pt_to_in instead of mpl_pt_to_in\n        # but having a little bit more space around the text looks better,\n        # plus the bounding box reported by LaTeX is VERY narrow\n        f = mpl_pt_to_in * self.dpi\n        return w * f, h * f, d * f"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_image_nocomposite",
      "name": "option_image_nocomposite",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_image_nocomposite",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_image_nocomposite/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_image_nocomposite.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_scale_image",
      "name": "option_scale_image",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_scale_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_scale_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_scale_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_scale_image(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * mpl_pt_to_in * self.dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/common_texification",
      "name": "common_texification",
      "qname": "lib.matplotlib.backends.backend_pgf.common_texification",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/common_texification/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pgf.common_texification.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef common_texification(text):\n    return _tex_escape(text)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/get_fontspec",
      "name": "get_fontspec",
      "qname": "lib.matplotlib.backends.backend_pgf.get_fontspec",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Build fontspec preamble from rc.",
      "docstring": "Build fontspec preamble from rc.",
      "code": "@_api.deprecated(\"3.6\")\ndef get_fontspec():\n    \"\"\"Build fontspec preamble from rc.\"\"\"\n    with mpl.rc_context({\"pgf.preamble\": \"\"}):\n        return _get_preamble()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/get_preamble",
      "name": "get_preamble",
      "qname": "lib.matplotlib.backends.backend_pgf.get_preamble",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get LaTeX preamble from rc.",
      "docstring": "Get LaTeX preamble from rc.",
      "code": "@_api.deprecated(\"3.6\")\ndef get_preamble():\n    \"\"\"Get LaTeX preamble from rc.\"\"\"\n    return mpl.rcParams[\"pgf.preamble\"]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/make_pdf_to_png_converter",
      "name": "make_pdf_to_png_converter",
      "qname": "lib.matplotlib.backends.backend_pgf.make_pdf_to_png_converter",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a function that converts a pdf file to a png file.",
      "docstring": "Return a function that converts a pdf file to a png file.",
      "code": "def make_pdf_to_png_converter():\n    \"\"\"Return a function that converts a pdf file to a png file.\"\"\"\n    try:\n        mpl._get_executable_info(\"pdftocairo\")\n    except mpl.ExecutableNotFoundError:\n        pass\n    else:\n        return lambda pdffile, pngfile, dpi: subprocess.check_output(\n            [\"pdftocairo\", \"-singlefile\", \"-transp\", \"-png\", \"-r\", \"%d\" % dpi,\n             pdffile, os.path.splitext(pngfile)[0]],\n            stderr=subprocess.STDOUT)\n    try:\n        gs_info = mpl._get_executable_info(\"gs\")\n    except mpl.ExecutableNotFoundError:\n        pass\n    else:\n        return lambda pdffile, pngfile, dpi: subprocess.check_output(\n            [gs_info.executable,\n             '-dQUIET', '-dSAFER', '-dBATCH', '-dNOPAUSE', '-dNOPROMPT',\n             '-dUseCIEColor', '-dTextAlphaBits=4',\n             '-dGraphicsAlphaBits=4', '-dDOINTERPOLATE',\n             '-sDEVICE=pngalpha', '-sOutputFile=%s' % pngfile,\n             '-r%d' % dpi, pdffile],\n            stderr=subprocess.STDOUT)\n    raise RuntimeError(\"No suitable pdf to png renderer found.\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/writeln",
      "name": "writeln",
      "qname": "lib.matplotlib.backends.backend_pgf.writeln",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/writeln/fh",
          "name": "fh",
          "qname": "lib.matplotlib.backends.backend_pgf.writeln.fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/writeln/line",
          "name": "line",
          "qname": "lib.matplotlib.backends.backend_pgf.writeln.line",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef writeln(fh, line):\n    return _writeln(fh, line)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'ps'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_ps.PsBackendHelper.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.PsBackendHelper.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self):\n        self._cached = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/pswriter",
          "name": "pswriter",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.pswriter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/imagedpi",
          "name": "imagedpi",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.imagedpi",
          "default_value": "72",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.",
      "docstring": "",
      "code": "    def __init__(self, width, height, pswriter, imagedpi=72):\n        # Although postscript itself is dpi independent, we need to inform the\n        # image code about a requested dpi to generate high resolution images\n        # and them scale them before embedding them.\n        super().__init__(width, height)\n        self._pswriter = pswriter\n        if mpl.rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi / 72\n        self._clip_paths = {}\n        self._path_collection_id = 0\n\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n        self._logwarn_once = functools.lru_cache(None)(_log.warning)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch",
      "name": "create_hatch",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.create_hatch",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.create_hatch.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch/hatch",
          "name": "hatch",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.create_hatch.hatch",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def create_hatch(self, hatch):\n        sidelen = 72\n        if hatch in self._hatches:\n            return self._hatches[hatch]\n        name = 'H%d' % len(self._hatches)\n        linewidth = mpl.rcParams['hatch.linewidth']\n        pageheight = self.height * 72\n        self._pswriter.write(f\"\"\"\\\n  << /PatternType 1\n     /PaintType 2\n     /TilingType 2\n     /BBox[0 0 {sidelen:d} {sidelen:d}]\n     /XStep {sidelen:d}\n     /YStep {sidelen:d}\n\n     /PaintProc {{\n        pop\n        {linewidth:g} setlinewidth\n{self._convert_path(\n    Path.hatch(hatch), Affine2D().scale(sidelen), simplify=False)}\n        gsave\n        fill\n        grestore\n        stroke\n     }} bind\n   >>\n   matrix\n   0 {pageheight:g} translate\n   makepattern\n   /{name} exch def\n\"\"\")\n        self._hatches[hatch] = name\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle",
      "name": "draw_gouraud_triangle",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles",
      "name": "draw_gouraud_triangles",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] == 4\n\n        shape = points.shape\n        flat_points = points.reshape((shape[0] * shape[1], 2))\n        flat_points = trans.transform(flat_points)\n        flat_colors = colors.reshape((shape[0] * shape[1], 4))\n        points_min = np.min(flat_points, axis=0) - (1 << 12)\n        points_max = np.max(flat_points, axis=0) + (1 << 12)\n        factor = np.ceil((2 ** 32 - 1) / (points_max - points_min))\n\n        xmin, ymin = points_min\n        xmax, ymax = points_max\n\n        data = np.empty(\n            shape[0] * shape[1],\n            dtype=[('flags', 'u1'), ('points', '2>u4'), ('colors', '3u1')])\n        data['flags'] = 0\n        data['points'] = (flat_points - points_min) * factor\n        data['colors'] = flat_colors[:, :3] * 255.0\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n<< /ShadingType 4\n   /ColorSpace [/DeviceRGB]\n   /BitsPerCoordinate 32\n   /BitsPerComponent 8\n   /BitsPerFlag 8\n   /AntiAlias true\n   /Decode [ {xmin:g} {xmax:g} {ymin:g} {ymax:g} 0 1 0 1 0 1 ]\n   /DataSource <\n{hexdata}\n>\n>>\nshfill\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n[{matrix}] concat\n{xscale:g} {yscale:g} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataString readhexstring pop\n}} bind {imagecmd}\n{hexdata}\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        ps_color = (\n            None\n            if self._is_transparent(rgbFace)\n            else '%1.3f setgray' % rgbFace[0]\n            if rgbFace[0] == rgbFace[1] == rgbFace[2]\n            else '%1.3f %1.3f %1.3f setrgbcolor' % rgbFace[:3])\n\n        # construct the generic marker command:\n\n        # don't want the translate to be global\n        ps_cmd = ['/o {', 'gsave', 'newpath', 'translate']\n\n        lw = gc.get_linewidth()\n        alpha = (gc.get_alpha()\n                 if gc.get_forced_alpha() or len(gc.get_rgb()) == 3\n                 else gc.get_rgb()[3])\n        stroke = lw > 0 and alpha > 0\n        if stroke:\n            ps_cmd.append('%.1f setlinewidth' % lw)\n            ps_cmd.append(self._linejoin_cmd(gc.get_joinstyle()))\n            ps_cmd.append(self._linecap_cmd(gc.get_capstyle()))\n\n        ps_cmd.append(self._convert_path(marker_path, marker_trans,\n                                         simplify=False))\n\n        if rgbFace:\n            if stroke:\n                ps_cmd.append('gsave')\n            if ps_color:\n                ps_cmd.extend([ps_color, 'fill'])\n            if stroke:\n                ps_cmd.append('grestore')\n\n        if stroke:\n            ps_cmd.append('stroke')\n        ps_cmd.extend(['grestore', '} bind def'])\n\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.width*72, self.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ps_cmd.append(\"%g %g o\" % (x, y))\n\n        ps = '\\n'.join(ps_cmd)\n        self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext",
      "name": "draw_mathtext",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw the math text using matplotlib.mathtext.",
      "docstring": "Draw the math text using matplotlib.mathtext.",
      "code": "    @_log_if_debug_on\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw the math text using matplotlib.mathtext.\"\"\"\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n        self.set_color(*gc.get_rgb())\n        self._pswriter.write(\n            f\"gsave\\n\"\n            f\"{x:g} {y:g} translate\\n\"\n            f\"{angle:g} rotate\\n\")\n        lastfont = None\n        for font, fontsize, num, ox, oy in glyphs:\n            self._character_tracker.track_glyph(font, num)\n            if (font.postscript_name, fontsize) != lastfont:\n                lastfont = font.postscript_name, fontsize\n                self._pswriter.write(\n                    f\"/{font.postscript_name} {fontsize} selectfont\\n\")\n            glyph_name = (\n                font.get_name_char(chr(num)) if isinstance(font, AFM) else\n                font.get_glyph_name(font.get_char_index(num)))\n            self._pswriter.write(\n                f\"{ox:g} {oy:g} moveto\\n\"\n                f\"/{glyph_name} glyphshow\\n\")\n        for ox, oy, w, h in rects:\n            self._pswriter.write(f\"{ox} {oy} {w} {h} rectfill\\n\")\n        self._pswriter.write(\"grestore\\n\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        clip = rgbFace is None and gc.get_hatch_path() is None\n        simplify = path.should_simplify and clip\n        ps = self._convert_path(path, transform, clip=clip, simplify=simplify)\n        self._draw_ps(ps, gc, rgbFace)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/offset_trans",
          "name": "offset_trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.offset_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #     (len_path + 2) * uses_per_path\n        # cost of definition+use is\n        #     (len_path + 3) + 3 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 3 * uses_per_path + 3 < (len_path + 2) * uses_per_path\n        if not should_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = 'p%d_%d' % (self._path_collection_id, i)\n            path_bytes = self._convert_path(path, transform, simplify=False)\n            self._pswriter.write(f\"\"\"\\\n/{name} {{\nnewpath\ntranslate\n{path_bytes}\n}} bind def\n\"\"\")\n            path_codes.append(name)\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            ps = \"%g %g %s\" % (xo, yo, path_id)\n            self._draw_ps(ps, gc0, rgbFace)\n\n        self._path_collection_id += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if not hasattr(self, \"psfrag\"):\n            self._logwarn_once(\n                \"The PS backend determines usetex status solely based on \"\n                \"rcParams['text.usetex'] and does not support having \"\n                \"usetex=True only for some elements; this element will thus \"\n                \"be rendered as if usetex=False.\")\n            self.draw_text(gc, x, y, s, prop, angle, False, mtext)\n            return\n\n        w, h, bl = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        fontsize = prop.get_size_in_points()\n        thetext = 'psmarker%d' % self.textcnt\n        color = '%1.3f,%1.3f,%1.3f' % gc.get_rgb()[:3]\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(\n                       mpl.rcParams['font.family'][0], r'{\\rmfamily %s}')\n        s = fontcmd % s\n        tex = r'\\color[rgb]{%s} %s' % (color, s)\n\n        # Stick to the bottom alignment.\n        pos = _nums_to_str(x, y-bl)\n        self.psfrag.append(\n            r'\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                thetext, angle, fontsize, fontsize*1.25, tex))\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{pos} moveto\n({thetext})\nshow\ngrestore\n\"\"\")\n        self.textcnt += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if ismath == 'TeX':\n            return self.draw_tex(gc, x, y, s, prop, angle)\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        if mpl.rcParams['ps.useafm']:\n            font = self._get_font_afm(prop)\n            scale = 0.001 * prop.get_size_in_points()\n            stream = []\n            thisx = 0\n            last_name = None  # kerns returns 0 for None.\n            xs_names = []\n            for c in s:\n                name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char('?')\n                kern = font.get_kern_dist_from_name(last_name, name)\n                last_name = name\n                thisx += kern * scale\n                xs_names.append((thisx, name))\n                thisx += width * scale\n            ps_name = (font.postscript_name\n                       .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n            stream.append((ps_name, xs_names))\n\n        else:\n            font = self._get_font_ttf(prop)\n            self._character_tracker.track(font, s)\n            stream = []\n            prev_font = curr_stream = None\n            for item in _text_helpers.layout(s, font):\n                ps_name = (item.ft_object.postscript_name\n                           .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n                if item.ft_object is not prev_font:\n                    if curr_stream:\n                        stream.append(curr_stream)\n                    prev_font = item.ft_object\n                    curr_stream = [ps_name, []]\n                curr_stream[1].append(\n                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                )\n            # append the last entry\n            stream.append(curr_stream)\n\n        self.set_color(*gc.get_rgb())\n\n        for ps_name, xs_names in stream:\n            self.set_font(ps_name, prop.get_size_in_points(), False)\n            thetext = \"\\n\".join(f\"{x:g} 0 m /{name:s} glyphshow\"\n                                for x, name in xs_names)\n            self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n{angle:g} rotate\n{thetext}\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/get_image_magnification",
      "name": "get_image_magnification",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.get_image_magnification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/get_image_magnification/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.get_image_magnification.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the factor by which to magnify images passed to draw_image.\nAllows a backend to have images at a different resolution to other\nartists.",
      "docstring": "Get the factor by which to magnify images passed to draw_image.\nAllows a backend to have images at a different resolution to other\nartists.",
      "code": "    def get_image_magnification(self):\n        \"\"\"\n        Get the factor by which to magnify images passed to draw_image.\n        Allows a backend to have images at a different resolution to other\n        artists.\n        \"\"\"\n        return self.image_magnification"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color",
      "name": "set_color",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/r",
          "name": "r",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.r",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/g",
          "name": "g",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.g",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/b",
          "name": "b",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_color(self, r, g, b, store=True):\n        if (r, g, b) != self.color:\n            self._pswriter.write(f\"{r:1.3f} setgray\\n\"\n                                 if r == g == b else\n                                 f\"{r:1.3f} {g:1.3f} {b:1.3f} setrgbcolor\\n\")\n            if store:\n                self.color = (r, g, b)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font",
      "name": "set_font",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/fontname",
          "name": "fontname",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.fontname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/fontsize",
          "name": "fontsize",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.fontsize",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_font(self, fontname, fontsize, store=True):\n        if (fontname, fontsize) != (self.fontname, self.fontsize):\n            self._pswriter.write(f\"/{fontname} {fontsize:1.3f} selectfont\\n\")\n            if store:\n                self.fontname = fontname\n                self.fontsize = fontsize"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap",
      "name": "set_linecap",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap/linecap",
          "name": "linecap",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap.linecap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linecap(self, linecap, store=True):\n        if linecap != self.linecap:\n            self._pswriter.write(self._linecap_cmd(linecap))\n            if store:\n                self.linecap = linecap"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash",
      "name": "set_linedash",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/offset",
          "name": "offset",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.offset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/seq",
          "name": "seq",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.seq",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linedash(self, offset, seq, store=True):\n        if self.linedash is not None:\n            oldo, oldseq = self.linedash\n            if np.array_equal(seq, oldseq) and oldo == offset:\n                return\n\n        self._pswriter.write(f\"[{_nums_to_str(*seq)}]\"\n                             f\" {_nums_to_str(offset)} setdash\\n\"\n                             if seq is not None and len(seq) else\n                             \"[] 0 setdash\\n\")\n        if store:\n            self.linedash = (offset, seq)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin",
      "name": "set_linejoin",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin/linejoin",
          "name": "linejoin",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin.linejoin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linejoin(self, linejoin, store=True):\n        if linejoin != self.linejoin:\n            self._pswriter.write(self._linejoin_cmd(linejoin))\n            if store:\n                self.linejoin = linejoin"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth",
      "name": "set_linewidth",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth/linewidth",
          "name": "linewidth",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth.linewidth",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linewidth(self, linewidth, store=True):\n        linewidth = float(linewidth)\n        if linewidth != self.linewidth:\n            self._pswriter.write(\"%1.3f setlinewidth\\n\" % linewidth)\n            if store:\n                self.linewidth = linewidth"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags",
      "name": "convert_psfrags",
      "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/psfrags",
          "name": "psfrags",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.psfrags",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/font_preamble",
          "name": "font_preamble",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.font_preamble",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/custom_preamble",
          "name": "custom_preamble",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.custom_preamble",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/paper_width",
          "name": "paper_width",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.paper_width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/paper_height",
          "name": "paper_height",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.paper_height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/orientation",
          "name": "orientation",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.orientation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef convert_psfrags(tmpfile, psfrags, font_preamble, custom_preamble,\n                    paper_width, paper_height, orientation):\n    return _convert_psfrags(\n        pathlib.Path(tmpfile), psfrags, paper_width, paper_height, orientation)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/get_bbox_header",
      "name": "get_bbox_header",
      "qname": "lib.matplotlib.backends.backend_ps.get_bbox_header",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/get_bbox_header/lbrt",
          "name": "lbrt",
          "qname": "lib.matplotlib.backends.backend_ps.get_bbox_header.lbrt",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/get_bbox_header/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.get_bbox_header.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a postscript header string for the given bbox lbrt=(l, b, r, t).\nOptionally, return rotate command.",
      "docstring": "Return a postscript header string for the given bbox lbrt=(l, b, r, t).\nOptionally, return rotate command.",
      "code": "def get_bbox_header(lbrt, rotated=False):\n    \"\"\"\n    Return a postscript header string for the given bbox lbrt=(l, b, r, t).\n    Optionally, return rotate command.\n    \"\"\"\n\n    l, b, r, t = lbrt\n    if rotated:\n        rotate = \"%.2f %.2f translate\\n90 rotate\" % (l+r, 0)\n    else:\n        rotate = \"\"\n    bbox_info = '%%%%BoundingBox: %d %d %d %d' % (l, b, np.ceil(r), np.ceil(t))\n    hires_bbox_info = '%%%%HiResBoundingBox: %.6f %.6f %.6f %.6f' % (\n        l, b, r, t)\n\n    return '\\n'.join([bbox_info, hires_bbox_info]), rotate"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill",
      "name": "gs_distill",
      "qname": "lib.matplotlib.backends.backend_ps.gs_distill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/eps",
          "name": "eps",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.eps",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/ptype",
          "name": "ptype",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.ptype",
          "default_value": "'letter'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use ghostscript's pswrite or epswrite device to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. The output is low-level, converting text to outlines.",
      "docstring": "Use ghostscript's pswrite or epswrite device to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. The output is low-level, converting text to outlines.",
      "code": "def gs_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's pswrite or epswrite device to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. The output is low-level, converting text to outlines.\n    \"\"\"\n\n    if eps:\n        paper_option = \"-dEPSCrop\"\n    else:\n        paper_option = \"-sPAPERSIZE=%s\" % ptype\n\n    psfile = tmpfile + '.ps'\n    dpi = mpl.rcParams['ps.distiller.res']\n\n    cbook._check_and_log_subprocess(\n        [mpl._get_executable_info(\"gs\").executable,\n         \"-dBATCH\", \"-dNOPAUSE\", \"-r%d\" % dpi, \"-sDEVICE=ps2write\",\n         paper_option, \"-sOutputFile=%s\" % psfile, tmpfile],\n        _log)\n\n    os.remove(tmpfile)\n    shutil.move(psfile, tmpfile)\n\n    # While it is best if above steps preserve the original bounding\n    # box, there seem to be cases when it is not. For those cases,\n    # the original bbox can be restored during the pstoeps step.\n\n    if eps:\n        # For some versions of gs, above steps result in an ps file where the\n        # original bbox is no more correct. Do not adjust bbox for now.\n        pstoeps(tmpfile, bbox, rotated=rotated)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps",
      "name": "pstoeps",
      "qname": "lib.matplotlib.backends.backend_ps.pstoeps",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.pstoeps.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_ps.pstoeps.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.pstoeps.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert the postscript to encapsulated postscript.  The bbox of\nthe eps file will be replaced with the given *bbox* argument. If\nNone, original bbox will be used.",
      "docstring": "Convert the postscript to encapsulated postscript.  The bbox of\nthe eps file will be replaced with the given *bbox* argument. If\nNone, original bbox will be used.",
      "code": "def pstoeps(tmpfile, bbox=None, rotated=False):\n    \"\"\"\n    Convert the postscript to encapsulated postscript.  The bbox of\n    the eps file will be replaced with the given *bbox* argument. If\n    None, original bbox will be used.\n    \"\"\"\n\n    # if rotated==True, the output eps file need to be rotated\n    if bbox:\n        bbox_info, rotate = get_bbox_header(bbox, rotated=rotated)\n    else:\n        bbox_info, rotate = None, None\n\n    epsfile = tmpfile + '.eps'\n    with open(epsfile, 'wb') as epsh, open(tmpfile, 'rb') as tmph:\n        write = epsh.write\n        # Modify the header:\n        for line in tmph:\n            if line.startswith(b'%!PS'):\n                write(b\"%!PS-Adobe-3.0 EPSF-3.0\\n\")\n                if bbox:\n                    write(bbox_info.encode('ascii') + b'\\n')\n            elif line.startswith(b'%%EndComments'):\n                write(line)\n                write(b'%%BeginProlog\\n'\n                      b'save\\n'\n                      b'countdictstack\\n'\n                      b'mark\\n'\n                      b'newpath\\n'\n                      b'/showpage {} def\\n'\n                      b'/setpagedevice {pop} def\\n'\n                      b'%%EndProlog\\n'\n                      b'%%Page 1 1\\n')\n                if rotate:\n                    write(rotate.encode('ascii') + b'\\n')\n                break\n            elif bbox and line.startswith((b'%%Bound', b'%%HiResBound',\n                                           b'%%DocumentMedia', b'%%Pages')):\n                pass\n            else:\n                write(line)\n        # Now rewrite the rest of the file, and modify the trailer.\n        # This is done in a second loop such that the header of the embedded\n        # eps file is not modified.\n        for line in tmph:\n            if line.startswith(b'%%EOF'):\n                write(b'cleartomark\\n'\n                      b'countdictstack\\n'\n                      b'exch sub { end } repeat\\n'\n                      b'restore\\n'\n                      b'showpage\\n'\n                      b'%%EOF\\n')\n            elif line.startswith(b'%%PageBoundingBox'):\n                pass\n            else:\n                write(line)\n\n    os.remove(tmpfile)\n    shutil.move(epsfile, tmpfile)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/quote_ps_string",
      "name": "quote_ps_string",
      "qname": "lib.matplotlib.backends.backend_ps.quote_ps_string",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of this function')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/quote_ps_string/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.quote_ps_string.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Quote dangerous characters of S for use in a PostScript string constant.",
      "docstring": "Quote dangerous characters of S for use in a PostScript string constant.",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of this function\")\ndef quote_ps_string(s):\n    \"\"\"\n    Quote dangerous characters of S for use in a PostScript string constant.\n    \"\"\"\n    s = s.replace(b\"\\\\\", b\"\\\\\\\\\")\n    s = s.replace(b\"(\", b\"\\\\(\")\n    s = s.replace(b\")\", b\"\\\\)\")\n    s = s.replace(b\"'\", b\"\\\\251\")\n    s = s.replace(b\"`\", b\"\\\\301\")\n    s = re.sub(br\"[^ -~\\n]\", lambda x: br\"\\%03o\" % ord(x.group()), s)\n    return s.decode('ascii')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill",
      "name": "xpdf_distill",
      "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/eps",
          "name": "eps",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.eps",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/ptype",
          "name": "ptype",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.ptype",
          "default_value": "'letter'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. This distiller is preferred, generating high-level postscript\noutput that treats text as text.",
      "docstring": "Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. This distiller is preferred, generating high-level postscript\noutput that treats text as text.",
      "code": "def xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. This distiller is preferred, generating high-level postscript\n    output that treats text as text.\n    \"\"\"\n    mpl._get_executable_info(\"gs\")  # Effectively checks for ps2pdf.\n    mpl._get_executable_info(\"pdftops\")\n\n    with TemporaryDirectory() as tmpdir:\n        tmppdf = pathlib.Path(tmpdir, \"tmp.pdf\")\n        tmpps = pathlib.Path(tmpdir, \"tmp.ps\")\n        # Pass options as `-foo#bar` instead of `-foo=bar` to keep Windows\n        # happy (https://ghostscript.com/doc/9.56.1/Use.htm#MS_Windows).\n        cbook._check_and_log_subprocess(\n            [\"ps2pdf\",\n             \"-dAutoFilterColorImages#false\",\n             \"-dAutoFilterGrayImages#false\",\n             \"-sAutoRotatePages#None\",\n             \"-sGrayImageFilter#FlateEncode\",\n             \"-sColorImageFilter#FlateEncode\",\n             \"-dEPSCrop\" if eps else \"-sPAPERSIZE#%s\" % ptype,\n             tmpfile, tmppdf], _log)\n        cbook._check_and_log_subprocess(\n            [\"pdftops\", \"-paper\", \"match\", \"-level2\", tmppdf, tmpps], _log)\n        shutil.move(tmpps, tmpfile)\n    if eps:\n        pstoeps(tmpfile)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._subplot_dialog = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2QT.configure_subplots(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.__init__.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure=None):\n        _create_qApp()\n        super().__init__(figure=figure)\n\n        self._draw_pending = False\n        self._is_drawing = False\n        self._draw_rect_callback = lambda painter: None\n        self._in_resize_event = False\n\n        self.setAttribute(\n            _enum(\"QtCore.Qt.WidgetAttribute\").WA_OpaquePaintEvent)\n        self.setMouseTracking(True)\n        self.resize(*self.get_width_height())\n\n        palette = QtGui.QPalette(QtGui.QColor(\"white\"))\n        self.setPalette(palette)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # docstring inherited\n        if bbox is None and self.figure:\n            bbox = self.figure.bbox  # Blit the entire canvas if bbox is None.\n        # repaint uses logical pixels, not physical pixels like the renderer.\n        l, b, w, h = [int(pt / self.device_pixel_ratio) for pt in bbox.bounds]\n        t = b + h\n        self.repaint(l, self.rect().height() - t, w, h)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure, and queue a request for a Qt draw.",
      "docstring": "Render the figure, and queue a request for a Qt draw.",
      "code": "    def draw(self):\n        \"\"\"Render the figure, and queue a request for a Qt draw.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/drawRectangle",
      "name": "drawRectangle",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.drawRectangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/drawRectangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.drawRectangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/drawRectangle/rect",
          "name": "rect",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.drawRectangle.rect",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def drawRectangle(self, rect):\n        # Draw the zoom rectangle to the QPainter.  _draw_rect_callback needs\n        # to be called at the end of paintEvent.\n        if rect is not None:\n            x0, y0, w, h = [int(pt / self.device_pixel_ratio) for pt in rect]\n            x1 = x0 + w\n            y1 = y0 + h\n            def _draw_rect_callback(painter):\n                pen = QtGui.QPen(\n                    QtGui.QColor(\"black\"),\n                    1 / self.device_pixel_ratio\n                )\n\n                pen.setDashPattern([3, 3])\n                for color, offset in [\n                        (QtGui.QColor(\"black\"), 0),\n                        (QtGui.QColor(\"white\"), 3),\n                ]:\n                    pen.setDashOffset(offset)\n                    pen.setColor(color)\n                    painter.setPen(pen)\n                    # Draw the lines from x0, y0 towards x1, y1 so that the\n                    # dashes don't \"jump\" when moving the zoom box.\n                    painter.drawLine(x0, y0, x0, y1)\n                    painter.drawLine(x0, y0, x1, y0)\n                    painter.drawLine(x0, y1, x1, y1)\n                    painter.drawLine(x1, y0, x1, y1)\n        else:\n            def _draw_rect_callback(painter):\n                return\n        self._draw_rect_callback = _draw_rect_callback\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Queue redraw of the Agg buffer and request Qt paintEvent.",
      "docstring": "Queue redraw of the Agg buffer and request Qt paintEvent.",
      "code": "    def draw_idle(self):\n        \"\"\"Queue redraw of the Agg buffer and request Qt paintEvent.\"\"\"\n        # The Agg draw needs to be handled by the same thread Matplotlib\n        # modifies the scene graph from. Post Agg draw request to the\n        # current event loop in order to ensure thread affinity and to\n        # accumulate multiple draw requests from event handling.\n        # TODO: queued signal connection might be safer than singleShot\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            QtCore.QTimer.singleShot(0, self._draw_idle)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/enterEvent",
      "name": "enterEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.enterEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/enterEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.enterEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/enterEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.enterEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enterEvent(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self.mouseEventCoords(event),\n                      guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/flush_events",
      "name": "flush_events",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.flush_events",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/flush_events/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.flush_events.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flush_events(self):\n        # docstring inherited\n        QtWidgets.QApplication.instance().processEvents()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyPressEvent",
      "name": "keyPressEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyPressEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyPressEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyPressEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyPressEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyPressEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def keyPressEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            KeyEvent(\"key_press_event\", self,\n                     key, *self.mouseEventCoords(),\n                     guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyReleaseEvent",
      "name": "keyReleaseEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyReleaseEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyReleaseEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyReleaseEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyReleaseEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyReleaseEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def keyReleaseEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            KeyEvent(\"key_release_event\", self,\n                     key, *self.mouseEventCoords(),\n                     guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/leaveEvent",
      "name": "leaveEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.leaveEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/leaveEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.leaveEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/leaveEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.leaveEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        LocationEvent(\"figure_leave_event\", self,\n                      *self.mouseEventCoords(),\n                      guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/minumumSizeHint",
      "name": "minumumSizeHint",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.minumumSizeHint",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/minumumSizeHint/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.minumumSizeHint.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def minumumSizeHint(self):\n        return QtCore.QSize(10, 10)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseDoubleClickEvent",
      "name": "mouseDoubleClickEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseDoubleClickEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseDoubleClickEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseDoubleClickEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseDoubleClickEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseDoubleClickEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mouseDoubleClickEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseEventCoords",
      "name": "mouseEventCoords",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseEventCoords",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseEventCoords/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseEventCoords.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseEventCoords/pos",
          "name": "pos",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseEventCoords.pos",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Calculate mouse coordinates in physical pixels.\n\nQt uses logical pixels, but the figure is scaled to physical\npixels for rendering.  Transform to physical pixels so that\nall of the down-stream transforms work as expected.\n\nAlso, the origin is different and needs to be corrected.",
      "docstring": "Calculate mouse coordinates in physical pixels.\n\nQt uses logical pixels, but the figure is scaled to physical\npixels for rendering.  Transform to physical pixels so that\nall of the down-stream transforms work as expected.\n\nAlso, the origin is different and needs to be corrected.",
      "code": "    def mouseEventCoords(self, pos=None):\n        \"\"\"\n        Calculate mouse coordinates in physical pixels.\n\n        Qt uses logical pixels, but the figure is scaled to physical\n        pixels for rendering.  Transform to physical pixels so that\n        all of the down-stream transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        if pos is None:\n            pos = self.mapFromGlobal(QtGui.QCursor.pos())\n        elif hasattr(pos, \"position\"):  # qt6 QtGui.QEvent\n            pos = pos.position()\n        elif hasattr(pos, \"pos\"):  # qt5 QtCore.QEvent\n            pos = pos.pos()\n        # (otherwise, it's already a QPoint)\n        x = pos.x()\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height / self.device_pixel_ratio - pos.y()\n        return x * self.device_pixel_ratio, y * self.device_pixel_ratio"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseMoveEvent",
      "name": "mouseMoveEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseMoveEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseMoveEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseMoveEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseMoveEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseMoveEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mouseMoveEvent(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mousePressEvent",
      "name": "mousePressEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mousePressEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mousePressEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mousePressEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mousePressEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mousePressEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mousePressEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseReleaseEvent",
      "name": "mouseReleaseEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseReleaseEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseReleaseEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseReleaseEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseReleaseEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseReleaseEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/resizeEvent",
      "name": "resizeEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.resizeEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/resizeEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.resizeEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/resizeEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.resizeEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resizeEvent(self, event):\n        if self._in_resize_event:  # Prevent PyQt6 recursion\n            return\n        self._in_resize_event = True\n        try:\n            w = event.size().width() * self.device_pixel_ratio\n            h = event.size().height() * self.device_pixel_ratio\n            dpival = self.figure.dpi\n            winch = w / dpival\n            hinch = h / dpival\n            self.figure.set_size_inches(winch, hinch, forward=False)\n            # pass back into Qt to let it finish\n            QtWidgets.QWidget.resizeEvent(self, event)\n            # emit our resize events\n            ResizeEvent(\"resize_event\", self)._process()\n            self.draw_idle()\n        finally:\n            self._in_resize_event = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        # docstring inherited\n        self.setCursor(_api.check_getitem(cursord, cursor=cursor))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/showEvent",
      "name": "showEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.showEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/showEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.showEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/showEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.showEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def showEvent(self, event):\n        # Set up correct pixel ratio, and connect to any signal changes for it,\n        # once the window is shown (and thus has these attributes).\n        window = self.window().windowHandle()\n        window.screenChanged.connect(self._update_screen)\n        self._update_screen(window.screen())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/sizeHint",
      "name": "sizeHint",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.sizeHint",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/sizeHint/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.sizeHint.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def sizeHint(self):\n        w, h = self.get_width_height()\n        return QtCore.QSize(w, h)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/start_event_loop",
      "name": "start_event_loop",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.start_event_loop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/start_event_loop/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.start_event_loop.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/start_event_loop/timeout",
          "name": "timeout",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.start_event_loop.timeout",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def start_event_loop(self, timeout=0):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\") and self._event_loop.isRunning():\n            raise RuntimeError(\"Event loop already running\")\n        self._event_loop = event_loop = QtCore.QEventLoop()\n        if timeout > 0:\n            _ = QtCore.QTimer.singleShot(int(timeout * 1000), event_loop.quit)\n\n        with _maybe_allow_interrupt(event_loop):\n            qt_compat._exec(event_loop)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/stop_event_loop",
      "name": "stop_event_loop",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.stop_event_loop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/stop_event_loop/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.stop_event_loop.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/stop_event_loop/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.stop_event_loop.event",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def stop_event_loop(self, event=None):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\"):\n            self._event_loop.quit()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/wheelEvent",
      "name": "wheelEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.wheelEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/wheelEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.wheelEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/wheelEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.wheelEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is sometimes not\n        # provided (`isNull()`) and is unreliable on X11 (\"xcb\").\n        if (event.pixelDelta().isNull()\n                or QtWidgets.QApplication.instance().platformName() == \"xcb\"):\n            steps = event.angleDelta().y() / 120\n        else:\n            steps = event.pixelDelta().y()\n        if steps:\n            MouseEvent(\"scroll_event\", self,\n                       *self.mouseEventCoords(event), step=steps,\n                       guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        self.window = MainWindow()\n        super().__init__(canvas, num)\n        self.window.closing.connect(\n            # The lambda prevents the event from being immediately gc'd.\n            lambda: CloseEvent(\"close_event\", self.canvas)._process())\n        self.window.closing.connect(self._widgetclosed)\n\n        if sys.platform != \"darwin\":\n            image = str(cbook._get_data_path('images/matplotlib.svg'))\n            icon = QtGui.QIcon(image)\n            self.window.setWindowIcon(icon)\n\n        self.window._destroying = False\n\n        if self.toolbar:\n            self.window.addToolBar(self.toolbar)\n            tbs_height = self.toolbar.sizeHint().height()\n        else:\n            tbs_height = 0\n\n        # resize the main window so it will display the canvas with the\n        # requested size:\n        cs = canvas.sizeHint()\n        cs_height = cs.height()\n        height = cs_height + tbs_height\n        self.window.resize(cs.width(), height)\n\n        self.window.setCentralWidget(self.canvas)\n\n        if mpl.is_interactive():\n            self.window.show()\n            self.canvas.draw_idle()\n\n        # Give the keyboard focus to the figure instead of the manager:\n        # StrongFocus accepts both tab and click to focus and will enable the\n        # canvas to process event without clicking.\n        # https://doc.qt.io/qt-5/qt.html#FocusPolicy-enum\n        self.canvas.setFocusPolicy(_enum(\"QtCore.Qt.FocusPolicy\").StrongFocus)\n        self.canvas.setFocus()\n\n        self.window.raise_()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/destroy/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.destroy.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self, *args):\n        # check for qApp first, as PySide deletes it in its atexit handler\n        if QtWidgets.QApplication.instance() is None:\n            return\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        if self.toolbar:\n            self.toolbar.destroy()\n        self.window.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/full_screen_toggle",
      "name": "full_screen_toggle",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.full_screen_toggle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/full_screen_toggle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.full_screen_toggle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def full_screen_toggle(self):\n        if self.window.isFullScreen():\n            self.window.showNormal()\n        else:\n            self.window.showFullScreen()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/get_window_title",
      "name": "get_window_title",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.get_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/get_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.get_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_window_title(self):\n        return self.window.windowTitle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, width, height):\n        # The Qt methods return sizes in 'virtual' pixels so we do need to\n        # rescale from physical to logical pixels.\n        width = int(width / self.canvas.device_pixel_ratio)\n        height = int(height / self.canvas.device_pixel_ratio)\n        extra_width = self.window.width() - self.canvas.width()\n        extra_height = self.window.height() - self.canvas.height()\n        self.canvas.resize(width, height)\n        self.window.resize(width + extra_width, height + extra_height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        self.window.setWindowTitle(title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        self.window.show()\n        if mpl.rcParams['figure.raise_window']:\n            self.window.activateWindow()\n            self.window.raise_()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt.HelpQt.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.HelpQt.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.HelpQt.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        QtWidgets.QMessageBox.information(None, \"Help\", self._get_help_html())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow/closeEvent",
      "name": "closeEvent",
      "qname": "lib.matplotlib.backends.backend_qt.MainWindow.closeEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow/closeEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.MainWindow.closeEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow/closeEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.MainWindow.closeEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def closeEvent(self, event):\n        self.closing.emit()\n        super().closeEvent(event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__/coordinates",
          "name": "coordinates",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__.coordinates",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "coordinates: should we show the coordinates on the right?",
      "code": "    def __init__(self, canvas, parent=None, coordinates=True):\n        \"\"\"coordinates: should we show the coordinates on the right?\"\"\"\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(QtCore.Qt.ToolBarArea(\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").TopToolBarArea) |\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").BottomToolBarArea)))\n\n        self.coordinates = coordinates\n        self._actions = {}  # mapping of toolitem method names to QActions.\n        self._subplot_dialog = None\n\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.addSeparator()\n            else:\n                a = self.addAction(self._icon(image_file + '.png'),\n                                   text, getattr(self, callback))\n                self._actions[callback] = a\n                if callback in ['zoom', 'pan']:\n                    a.setCheckable(True)\n                if tooltip_text is not None:\n                    a.setToolTip(tooltip_text)\n\n        # Add the (x, y) location widget at the right side of the toolbar\n        # The stretch factor is 1 which means any resizing of the toolbar\n        # will resize this label instead of the buttons.\n        if self.coordinates:\n            self.locLabel = QtWidgets.QLabel(\"\", self)\n            self.locLabel.setAlignment(QtCore.Qt.AlignmentFlag(\n                _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignRight) |\n                _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignVCenter)))\n            self.locLabel.setSizePolicy(QtWidgets.QSizePolicy(\n                _enum(\"QtWidgets.QSizePolicy.Policy\").Expanding,\n                _enum(\"QtWidgets.QSizePolicy.Policy\").Ignored,\n            ))\n            labelAction = self.addWidget(self.locLabel)\n            labelAction.setVisible(True)\n\n        NavigationToolbar2.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/configure_subplots",
      "name": "configure_subplots",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.configure_subplots",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/configure_subplots/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.configure_subplots.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def configure_subplots(self):\n        if self._subplot_dialog is None:\n            self._subplot_dialog = SubplotToolQt(\n                self.canvas.figure, self.canvas.parent())\n            self.canvas.mpl_connect(\n                \"close_event\", lambda e: self._subplot_dialog.reject())\n        self._subplot_dialog.update_from_current_subplotpars()\n        self._subplot_dialog.show()\n        return self._subplot_dialog"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas.drawRectangle(rect)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/edit_parameters",
      "name": "edit_parameters",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.edit_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/edit_parameters/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.edit_parameters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def edit_parameters(self):\n        axes = self.canvas.figure.get_axes()\n        if not axes:\n            QtWidgets.QMessageBox.warning(\n                self.canvas.parent(), \"Error\", \"There are no axes to edit.\")\n            return\n        elif len(axes) == 1:\n            ax, = axes\n        else:\n            titles = [\n                ax.get_label() or\n                ax.get_title() or\n                ax.get_title(\"left\") or\n                ax.get_title(\"right\") or\n                \" - \".join(filter(None, [ax.get_xlabel(), ax.get_ylabel()])) or\n                f\"<anonymous {type(ax).__name__}>\"\n                for ax in axes]\n            duplicate_titles = [\n                title for title in titles if titles.count(title) > 1]\n            for i, ax in enumerate(axes):\n                if titles[i] in duplicate_titles:\n                    titles[i] += f\" (id: {id(ax):#x})\"  # Deduplicate titles.\n            item, ok = QtWidgets.QInputDialog.getItem(\n                self.canvas.parent(),\n                'Customize', 'Select axes:', titles, 0, False)\n            if not ok:\n                return\n            ax = axes[titles.index(item)]\n        figureoptions.figure_edit(ax, self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/pan/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.pan.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas.drawRectangle(None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        filetypes = self.canvas.get_supported_filetypes_grouped()\n        sorted_filetypes = sorted(filetypes.items())\n        default_filetype = self.canvas.get_default_filetype()\n\n        startpath = os.path.expanduser(mpl.rcParams['savefig.directory'])\n        start = os.path.join(startpath, self.canvas.get_default_filename())\n        filters = []\n        selectedFilter = None\n        for name, exts in sorted_filetypes:\n            exts_list = \" \".join(['*.%s' % ext for ext in exts])\n            filter = '%s (%s)' % (name, exts_list)\n            if default_filetype in exts:\n                selectedFilter = filter\n            filters.append(filter)\n        filters = ';;'.join(filters)\n\n        fname, filter = qt_compat._getSaveFileName(\n            self.canvas.parent(), \"Choose a filename to save to\", start,\n            filters, selectedFilter)\n        if fname:\n            # Save dir for next time, unless empty str (i.e., use cwd).\n            if startpath != \"\":\n                mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n            try:\n                self.canvas.figure.savefig(fname)\n            except Exception as e:\n                QtWidgets.QMessageBox.critical(\n                    self, \"Error saving file\", str(e),\n                    _enum(\"QtWidgets.QMessageBox.StandardButton\").Ok,\n                    _enum(\"QtWidgets.QMessageBox.StandardButton\").NoButton)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'back' in self._actions:\n            self._actions['back'].setEnabled(can_backward)\n        if 'forward' in self._actions:\n            self._actions['forward'].setEnabled(can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self.message.emit(s)\n        if self.coordinates:\n            self.locLabel.setText(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/zoom/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.zoom.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2QT.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        NavigationToolbar2QT.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt.SaveFigureQt.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.SaveFigureQt.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.SaveFigureQt.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2QT.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_qt.SetCursorQt.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.SetCursorQt.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_qt.SetCursorQt.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        NavigationToolbar2QT.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__/targetfig",
          "name": "targetfig",
          "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.__init__.targetfig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.__init__.parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, targetfig, parent):\n        super().__init__()\n        self.setWindowIcon(QtGui.QIcon(\n            str(cbook._get_data_path(\"images/matplotlib.png\"))))\n        self.setObjectName(\"SubplotTool\")\n        self._spinboxes = {}\n        main_layout = QtWidgets.QHBoxLayout()\n        self.setLayout(main_layout)\n        for group, spinboxes, buttons in [\n                (\"Borders\",\n                 [\"top\", \"bottom\", \"left\", \"right\"],\n                 [(\"Export values\", self._export_values)]),\n                (\"Spacings\",\n                 [\"hspace\", \"wspace\"],\n                 [(\"Tight layout\", self._tight_layout),\n                  (\"Reset\", self._reset),\n                  (\"Close\", self.close)])]:\n            layout = QtWidgets.QVBoxLayout()\n            main_layout.addLayout(layout)\n            box = QtWidgets.QGroupBox(group)\n            layout.addWidget(box)\n            inner = QtWidgets.QFormLayout(box)\n            for name in spinboxes:\n                self._spinboxes[name] = spinbox = QtWidgets.QDoubleSpinBox()\n                spinbox.setRange(0, 1)\n                spinbox.setDecimals(3)\n                spinbox.setSingleStep(0.005)\n                spinbox.setKeyboardTracking(False)\n                spinbox.valueChanged.connect(self._on_value_changed)\n                inner.addRow(name, spinbox)\n            layout.addStretch(1)\n            for name, method in buttons:\n                button = QtWidgets.QPushButton(name)\n                # Don't trigger on <enter>, which is used to input values.\n                button.setAutoDefault(False)\n                button.clicked.connect(method)\n                layout.addWidget(button)\n                if name == \"Close\":\n                    button.setFocus()\n        self._figure = targetfig\n        self._defaults = {}\n        self._export_values_dialog = None\n        self.update_from_current_subplotpars()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/update_from_current_subplotpars",
      "name": "update_from_current_subplotpars",
      "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.update_from_current_subplotpars",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/update_from_current_subplotpars/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.update_from_current_subplotpars.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def update_from_current_subplotpars(self):\n        self._defaults = {spinbox: getattr(self._figure.subplotpars, name)\n                          for name, spinbox in self._spinboxes.items()}\n        self._reset()  # Set spinbox current values without triggering signals."
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__del__",
      "name": "__del__",
      "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__del__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__del__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__del__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __del__(self):\n        # The check for deletedness is needed to avoid an error at animation\n        # shutdown with PySide2.\n        if not _isdeleted(self._timer):\n            self._timer_stop()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using QTimer events.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        # Create a new timer and connect the timeout() signal to the\n        # _on_timer method.\n        self._timer = QtCore.QTimer()\n        self._timer.timeout.connect(self._on_timer)\n        super().__init__(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        pixmap = self.canvas.grab()\n        QtWidgets.QApplication.instance().clipboard().setPixmap(pixmap)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.__init__.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager, parent=None):\n        ToolContainerBase.__init__(self, toolmanager)\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(QtCore.Qt.ToolBarArea(\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").TopToolBarArea) |\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").BottomToolBarArea)))\n        message_label = QtWidgets.QLabel(\"\")\n        message_label.setAlignment(QtCore.Qt.AlignmentFlag(\n            _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignRight) |\n            _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignVCenter)))\n        message_label.setSizePolicy(QtWidgets.QSizePolicy(\n            _enum(\"QtWidgets.QSizePolicy.Policy\").Expanding,\n            _enum(\"QtWidgets.QSizePolicy.Policy\").Ignored,\n        ))\n        self._message_action = self.addWidget(message_label)\n        self._toolitems = {}\n        self._groups = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(\n            self, name, group, position, image_file, description, toggle):\n\n        button = QtWidgets.QToolButton(self)\n        if image_file:\n            button.setIcon(NavigationToolbar2QT._icon(self, image_file))\n        button.setText(name)\n        if description:\n            button.setToolTip(description)\n\n        def handler():\n            self.trigger_tool(name)\n        if toggle:\n            button.setCheckable(True)\n            button.toggled.connect(handler)\n        else:\n            button.clicked.connect(handler)\n\n        self._toolitems.setdefault(name, [])\n        self._add_to_group(group, name, button, position)\n        self._toolitems[name].append((button, handler))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        for button, handler in self._toolitems[name]:\n            button.setParent(None)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self.widgetForAction(self._message_action).setText(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for button, handler in self._toolitems[name]:\n            button.toggled.disconnect(handler)\n            button.setChecked(toggled)\n            button.toggled.connect(handler)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_qt5.__getattr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/__getattr__/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt5.__getattr__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __getattr__(name):\n    if name == 'qApp':\n        return _backend_qt.qApp\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/paintEvent",
      "name": "paintEvent",
      "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.paintEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/paintEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.paintEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/paintEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.paintEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy the image from the Agg canvas to the qt.drawable.\n\nIn Qt, all drawing should be done inside of here when a widget is\nshown onscreen.",
      "docstring": "Copy the image from the Agg canvas to the qt.drawable.\n\nIn Qt, all drawing should be done inside of here when a widget is\nshown onscreen.",
      "code": "    def paintEvent(self, event):\n        \"\"\"\n        Copy the image from the Agg canvas to the qt.drawable.\n\n        In Qt, all drawing should be done inside of here when a widget is\n        shown onscreen.\n        \"\"\"\n        self._draw_idle()  # Only does something if a draw is pending.\n\n        # If the canvas does not have a renderer, then give up and wait for\n        # FigureCanvasAgg.draw(self) to be called.\n        if not hasattr(self, 'renderer'):\n            return\n\n        painter = QtGui.QPainter(self)\n        try:\n            # See documentation of QRect: bottom() and right() are off\n            # by 1, so use left() + width() and top() + height().\n            rect = event.rect()\n            # scale rect dimensions using the screen dpi ratio to get\n            # correct values for the Figure coordinates (rather than\n            # QT5's coords)\n            width = rect.width() * self.device_pixel_ratio\n            height = rect.height() * self.device_pixel_ratio\n            left, top = self.mouseEventCoords(rect.topLeft())\n            # shift the \"top\" by the height of the image to get the\n            # correct corner for our coordinate system\n            bottom = top - height\n            # same with the right side of the image\n            right = left + width\n            # create a buffer using the image bounding box\n            bbox = Bbox([[left, bottom], [right, top]])\n            reg = self.copy_from_bbox(bbox)\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                memoryview(reg))\n\n            # clear the widget canvas\n            painter.eraseRect(rect)\n\n            if QT_API == \"PyQt6\":\n                from PyQt6 import sip\n                ptr = int(sip.voidptr(buf))\n            else:\n                ptr = buf\n            qimage = QtGui.QImage(\n                ptr, buf.shape[1], buf.shape[0],\n                _enum(\"QtGui.QImage.Format\").Format_ARGB32_Premultiplied)\n            _setDevicePixelRatio(qimage, self.device_pixel_ratio)\n            # set origin using original QT coordinates\n            origin = QtCore.QPoint(rect.left(), rect.top())\n            painter.drawImage(origin, qimage)\n            # Adjust the buf reference count to work around a memory\n            # leak bug in QImage under PySide.\n            if QT_API in ('PySide', 'PySide2'):\n                if QtCore.__version_info__ < (5, 12):\n                    ctypes.c_long.from_address(id(buf)).value = 1\n\n            self._draw_rect_callback(painter)\n        finally:\n            painter.end()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure",
      "name": "print_figure",
      "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.print_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.print_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.print_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.print_figure.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_figure(self, *args, **kwargs):\n        super().print_figure(*args, **kwargs)\n        self.draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        if hasattr(self._renderer.gc, \"ctx\"):\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/paintEvent",
      "name": "paintEvent",
      "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.paintEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/paintEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.paintEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/paintEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.paintEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def paintEvent(self, event):\n        width = int(self.device_pixel_ratio * self.width())\n        height = int(self.device_pixel_ratio * self.height())\n        if (width, height) != self._renderer.get_canvas_width_height():\n            surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n            self._renderer.set_context(cairo.Context(surface))\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        buf = self._renderer.gc.ctx.get_target().get_data()\n        if QT_API == \"PyQt6\":\n            from PyQt6 import sip\n            ptr = int(sip.voidptr(buf))\n        else:\n            ptr = buf\n        qimage = QtGui.QImage(\n            ptr, width, height,\n            _enum(\"QtGui.QImage.Format\").Format_ARGB32_Premultiplied)\n        # Adjust the buf reference count to work around a memory leak bug in\n        # QImage under PySide.\n        if QT_API in ('PySide', 'PySide2'):\n            if QtCore.__version_info__ < (5, 12):\n                ctypes.c_long.from_address(id(buf)).value = 1\n        _setDevicePixelRatio(qimage, self.device_pixel_ratio)\n        painter = QtGui.QPainter(self)\n        painter.eraseRect(event.rect())\n        painter.drawImage(0, 0, qimage)\n        self._draw_rect_callback(painter)\n        painter.end()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'svg'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg",
      "name": "print_svg",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "Output target; if a string, a file will be opened for writing."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/bbox_inches_restore",
          "name": "bbox_inches_restore",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.bbox_inches_restore",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "dict[str, Any]",
            "default_value": "",
            "description": "Metadata in the SVG file defined as key-value pairs of strings,\ndatetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\nThe standard keys and their value types are:\n\n* *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n  ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n  ``'Title'``, and ``'Type'``.\n* *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n  ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n* *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n  non-*str*, then it will be formatted as ISO 8601.\n\nValues have been predefined for ``'Creator'``, ``'Date'``,\n``'Format'``, and ``'Type'``. They can be removed by setting them\nto `None`.\n\nInformation is encoded as `Dublin Core Metadata`__.\n\n.. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n__ DC_"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "Any]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Parameters\n----------\nfilename : str or path-like or file-like\n    Output target; if a string, a file will be opened for writing.\n\nmetadata : dict[str, Any], optional\n    Metadata in the SVG file defined as key-value pairs of strings,\n    datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n    'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n    The standard keys and their value types are:\n\n    * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n      ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n      ``'Title'``, and ``'Type'``.\n    * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n      ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n    * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n      non-*str*, then it will be formatted as ISO 8601.\n\n    Values have been predefined for ``'Creator'``, ``'Date'``,\n    ``'Format'``, and ``'Type'``. They can be removed by setting them\n    to `None`.\n\n    Information is encoded as `Dublin Core Metadata`__.\n\n    .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n    __ DC_",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_svg(self, filename, *args, bbox_inches_restore=None,\n                  metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n\n        metadata : dict[str, Any], optional\n            Metadata in the SVG file defined as key-value pairs of strings,\n            datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n            'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n            The standard keys and their value types are:\n\n            * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n              ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n              ``'Title'``, and ``'Type'``.\n            * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n              ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n            * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n              non-*str*, then it will be formatted as ISO 8601.\n\n            Values have been predefined for ``'Creator'``, ``'Date'``,\n            ``'Format'``, and ``'Type'``. They can be removed by setting them\n            to `None`.\n\n            Information is encoded as `Dublin Core Metadata`__.\n\n            .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n            __ DC_\n        \"\"\"\n        with cbook.open_file_cm(filename, \"w\", encoding=\"utf-8\") as fh:\n            if not cbook.file_requires_unicode(fh):\n                fh = codecs.getwriter('utf-8')(fh)\n            dpi = self.figure.dpi\n            self.figure.dpi = 72\n            width, height = self.figure.get_size_inches()\n            w, h = width * 72, height * 72\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererSVG(w, h, fh, image_dpi=dpi, metadata=metadata),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz",
      "name": "print_svgz",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_svgz(self, filename, *args, **kwargs):\n        with cbook.open_file_cm(filename, \"wb\") as fh, \\\n                gzip.GzipFile(mode='w', fileobj=fh) as gzipwriter:\n            return self.print_svg(gzipwriter, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/svgwriter",
          "name": "svgwriter",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.svgwriter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/basename",
          "name": "basename",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.basename",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/image_dpi",
          "name": "image_dpi",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.image_dpi",
          "default_value": "72",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72,\n                 *, metadata=None):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        if basename is None:\n            basename = getattr(svgwriter, \"name\", \"\")\n            if not isinstance(basename, str):\n                basename = \"\"\n        self.basename = basename\n\n        self._groupd = {}\n        self._image_counter = itertools.count()\n        self._clipd = {}\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = {}\n        self._has_gouraud = False\n        self._n_gradients = 0\n\n        super().__init__()\n        self._glyph_map = dict()\n        str_height = _short_float_fmt(height)\n        str_width = _short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width='%spt' % str_width,\n            height='%spt' % str_height,\n            viewBox='0 0 %s %s' % (str_width, str_height),\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group",
      "name": "close_group",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.close_group",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.close_group.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.close_group.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle",
      "name": "draw_gouraud_triangle",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        # docstring inherited\n\n        # This uses a method described here:\n        #\n        #   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html\n        #\n        # that uses three overlapping linear gradients to simulate a\n        # Gouraud triangle.  Each gradient goes from fully opaque in\n        # one corner to fully transparent along the opposite edge.\n        # The line between the stop points is perpendicular to the\n        # opposite edge.  Underlying these three gradients is a solid\n        # triangle whose color is the average of all three points.\n\n        writer = self.writer\n        if not self._has_gouraud:\n            self._has_gouraud = True\n            writer.start(\n                'filter',\n                id='colorAdd')\n            writer.element(\n                'feComposite',\n                attrib={'in': 'SourceGraphic'},\n                in2='BackgroundImage',\n                operator='arithmetic',\n                k2=\"1\", k3=\"1\")\n            writer.end('filter')\n            # feColorMatrix filter to correct opacity\n            writer.start(\n                'filter',\n                id='colorMat')\n            writer.element(\n                'feColorMatrix',\n                attrib={'type': 'matrix'},\n                values='1 0 0 0 0 \\n0 1 0 0 0 \\n0 0 1 0 0' +\n                       ' \\n1 1 1 1 0 \\n0 0 0 0 1 ')\n            writer.end('filter')\n\n        avg_color = np.average(colors, axis=0)\n        if avg_color[-1] == 0:\n            # Skip fully-transparent triangles\n            return\n\n        trans_and_flip = self._make_flip_transform(trans)\n        tpoints = trans_and_flip.transform(points)\n\n        writer.start('defs')\n        for i in range(3):\n            x1, y1 = tpoints[i]\n            x2, y2 = tpoints[(i + 1) % 3]\n            x3, y3 = tpoints[(i + 2) % 3]\n            rgba_color = colors[i]\n\n            if x2 == x3:\n                xb = x2\n                yb = y1\n            elif y2 == y3:\n                xb = x1\n                yb = y2\n            else:\n                m1 = (y2 - y3) / (x2 - x3)\n                b1 = y2 - (m1 * x2)\n                m2 = -(1.0 / m1)\n                b2 = y1 - (m2 * x1)\n                xb = (-b1 + b2) / (m1 - m2)\n                yb = m2 * xb + b2\n\n            writer.start(\n                'linearGradient',\n                id=\"GR%x_%d\" % (self._n_gradients, i),\n                gradientUnits=\"userSpaceOnUse\",\n                x1=_short_float_fmt(x1), y1=_short_float_fmt(y1),\n                x2=_short_float_fmt(xb), y2=_short_float_fmt(yb))\n            writer.element(\n                'stop',\n                offset='1',\n                style=_generate_css({\n                    'stop-color': rgb2hex(avg_color),\n                    'stop-opacity': _short_float_fmt(rgba_color[-1])}))\n            writer.element(\n                'stop',\n                offset='0',\n                style=_generate_css({'stop-color': rgb2hex(rgba_color),\n                                    'stop-opacity': \"0\"}))\n\n            writer.end('linearGradient')\n\n        writer.end('defs')\n\n        # triangle formation using \"path\"\n        dpath = \"M \" + _short_float_fmt(x1)+',' + _short_float_fmt(y1)\n        dpath += \" L \" + _short_float_fmt(x2) + ',' + _short_float_fmt(y2)\n        dpath += \" \" + _short_float_fmt(x3) + ',' + _short_float_fmt(y3) + \" Z\"\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': rgb2hex(avg_color),\n                    'fill-opacity': '1',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.start(\n                'g',\n                attrib={'stroke': \"none\",\n                        'stroke-width': \"0\",\n                        'shape-rendering': \"crispEdges\",\n                        'filter': \"url(#colorMat)\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_0)' % self._n_gradients,\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_1)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_2)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.end('g')\n\n        self._n_gradients += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles",
      "name": "draw_gouraud_triangles",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/triangles_array",
          "name": "triangles_array",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.triangles_array",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/colors_array",
          "name": "colors_array",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.colors_array",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangles(self, gc, triangles_array, colors_array,\n                               transform):\n        self.writer.start('g', **self._get_clip_attrs(gc))\n        transform = transform.frozen()\n        for tri, col in zip(triangles_array, colors_array):\n            self.draw_gouraud_triangle(gc, tri, col, transform)\n        self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n\n        if w == 0 or h == 0:\n            return\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Can't apply clip-path directly to the image because the image has\n            # a transformation, which would also be applied to the clip-path.\n            self.writer.start('g', **clip_attrs)\n\n        url = gc.get_url()\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n\n        attrib = {}\n        oid = gc.get_gid()\n        if mpl.rcParams['svg.image_inline']:\n            buf = BytesIO()\n            Image.fromarray(im).save(buf, format=\"png\")\n            oid = oid or self._make_id('image', buf.getvalue())\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(buf.getvalue()).decode('ascii'))\n        else:\n            if self.basename is None:\n                raise ValueError(\"Cannot save image data to filesystem when \"\n                                 \"writing SVG to an in-memory buffer\")\n            filename = '{}.image{}.png'.format(\n                self.basename, next(self._image_counter))\n            _log.info('Writing image file for inclusion: %s', filename)\n            Image.fromarray(im).save(filename)\n            oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n        attrib['id'] = oid\n\n        if transform is None:\n            w = 72.0 * w / self.image_dpi\n            h = 72.0 * h / self.image_dpi\n\n            self.writer.element(\n                'image',\n                transform=_generate_transform([\n                    ('scale', (1, -1)), ('translate', (0, -h))]),\n                x=_short_float_fmt(x),\n                y=_short_float_fmt(-(self.height - y - h)),\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n        else:\n            alpha = gc.get_alpha()\n            if alpha != 1.0:\n                attrib['opacity'] = _short_float_fmt(alpha)\n\n            flipped = (\n                Affine2D().scale(1.0 / w, 1.0 / h) +\n                transform +\n                Affine2D()\n                .translate(x, y)\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n            attrib['transform'] = _generate_transform(\n                [('matrix', flipped.frozen())])\n            attrib['style'] = (\n                'image-rendering:crisp-edges;'\n                'image-rendering:pixelated')\n            self.writer.element(\n                'image',\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clip_attrs:\n            self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, _generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = _generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        writer.start('g', **self._get_clip_attrs(gc))\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': '#%s' % oid}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = _short_float_fmt(x)\n                attrib['y'] = _short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify,\n            sketch=gc.get_sketch_params())\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, **self._get_clip_attrs(gc),\n                            style=self._get_style(gc, rgbFace))\n        if gc.get_url() is not None:\n            self.writer.end('a')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/offset_trans",
          "name": "offset_trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.offset_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #    (len_path + 5) * uses_per_path\n        # cost of definition+use is\n        #    (len_path + 3) + 9 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 9 * uses_per_path + 3 < (len_path + 5) * uses_per_path\n        if not should_do_optimization:\n            return super().draw_path_collection(\n                gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C%x_%x_%s' % (\n                self._path_collection_id, i, self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            clip_attrs = self._get_clip_attrs(gc0)\n            if clip_attrs:\n                writer.start('g', **clip_attrs)\n            attrib = {\n                'xlink:href': '#%s' % path_id,\n                'x': _short_float_fmt(xo),\n                'y': _short_float_fmt(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clip_attrs:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath=\"TeX\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Cannot apply clip-path directly to the text, because\n            # it has a transformation\n            self.writer.start('g', **clip_attrs)\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n\n        if mpl.rcParams['svg.fonttype'] == 'path':\n            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n        else:\n            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n        if clip_attrs:\n            self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_image_magnification",
      "name": "get_image_magnification",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_image_magnification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_image_magnification/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_image_magnification.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_image_magnification(self):\n        return self.image_dpi / 72.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group",
      "name": "open_group",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group/gid",
          "name": "gid",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group.gid",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=\"%s_%d\" % (s, self._groupd[s]))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_image_nocomposite",
      "name": "option_image_nocomposite",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_image_nocomposite",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_image_nocomposite/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_image_nocomposite.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_scale_image",
      "name": "option_scale_image",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_scale_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_scale_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_scale_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_scale_image(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "writable text file-like object",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "writable text file-like object"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, file):\n        self.__write = file.write\n        if hasattr(file, \"flush\"):\n            self.flush = file.flush\n        self.__open = 0  # true if start tag is open\n        self.__tags = []\n        self.__data = []\n        self.__indentation = \" \" * 64"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.close.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Element identifier, as returned by the :meth:`start` method."
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Close open elements, up to (and including) the element identified\nby the given identifier.",
      "docstring": "Close open elements, up to (and including) the element identified\nby the given identifier.\n\nParameters\n----------\nid\n    Element identifier, as returned by the :meth:`start` method.",
      "code": "    def close(self, id):\n        \"\"\"\n        Close open elements, up to (and including) the element identified\n        by the given identifier.\n\n        Parameters\n        ----------\n        id\n            Element identifier, as returned by the :meth:`start` method.\n        \"\"\"\n        while len(self.__tags) > id:\n            self.end()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment",
      "name": "comment",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.comment",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.comment.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment/comment",
          "name": "comment",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.comment.comment",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Comment text."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a comment to the output stream.",
      "docstring": "Add a comment to the output stream.\n\nParameters\n----------\ncomment : str\n    Comment text.",
      "code": "    def comment(self, comment):\n        \"\"\"\n        Add a comment to the output stream.\n\n        Parameters\n        ----------\n        comment : str\n            Comment text.\n        \"\"\"\n        self.__flush()\n        self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"<!-- %s -->\\n\" % _escape_comment(comment))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data",
      "name": "data",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.data",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.data.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.data.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Character data."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add character data to the output stream.",
      "docstring": "Add character data to the output stream.\n\nParameters\n----------\ntext : str\n    Character data.",
      "code": "    def data(self, text):\n        \"\"\"\n        Add character data to the output stream.\n\n        Parameters\n        ----------\n        text : str\n            Character data.\n        \"\"\"\n        self.__data.append(text)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element",
      "name": "element",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/tag",
          "name": "tag",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.tag",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.text",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/attrib",
          "name": "attrib",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.attrib",
          "default_value": "{}",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.extra",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add an entire element.  This is the same as calling :meth:`start`,\n:meth:`data`, and :meth:`end` in sequence. The *text* argument can be\nomitted.",
      "docstring": "Add an entire element.  This is the same as calling :meth:`start`,\n:meth:`data`, and :meth:`end` in sequence. The *text* argument can be\nomitted.",
      "code": "    def element(self, tag, text=None, attrib={}, **extra):\n        \"\"\"\n        Add an entire element.  This is the same as calling :meth:`start`,\n        :meth:`data`, and :meth:`end` in sequence. The *text* argument can be\n        omitted.\n        \"\"\"\n        self.start(tag, attrib, **extra)\n        if text:\n            self.data(text)\n        self.end(indent=False)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end",
      "name": "end",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end/tag",
          "name": "tag",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end.tag",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Element tag.  If given, the tag must match the start tag.  If\nomitted, the current element is closed."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end/indent",
          "name": "indent",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end.indent",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Close the current element (opened by the most recent call to\n:meth:`start`).",
      "docstring": "Close the current element (opened by the most recent call to\n:meth:`start`).\n\nParameters\n----------\ntag\n    Element tag.  If given, the tag must match the start tag.  If\n    omitted, the current element is closed.",
      "code": "    def end(self, tag=None, indent=True):\n        \"\"\"\n        Close the current element (opened by the most recent call to\n        :meth:`start`).\n\n        Parameters\n        ----------\n        tag\n            Element tag.  If given, the tag must match the start tag.  If\n            omitted, the current element is closed.\n        \"\"\"\n        if tag:\n            assert self.__tags, \"unbalanced end(%s)\" % tag\n            assert _escape_cdata(tag) == self.__tags[-1], \\\n                \"expected end(%s), got %s\" % (self.__tags[-1], tag)\n        else:\n            assert self.__tags, \"unbalanced end()\"\n        tag = self.__tags.pop()\n        if self.__data:\n            self.__flush(indent)\n        elif self.__open:\n            self.__open = 0\n            self.__write(\"/>\\n\")\n            return\n        if indent:\n            self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"</%s>\\n\" % tag)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/flush",
      "name": "flush",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.flush",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/flush/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.flush.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Flush the output stream.",
      "docstring": "Flush the output stream.",
      "code": "    def flush(self):\n        \"\"\"Flush the output stream.\"\"\"\n        pass  # replaced by the constructor"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start",
      "name": "start",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/tag",
          "name": "tag",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.tag",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Element tag."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/attrib",
          "name": "attrib",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.attrib",
          "default_value": "{}",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Attribute dictionary.  Alternatively, attributes can be given as\nkeyword arguments."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.extra",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Open a new element.  Attributes can be given as keyword\narguments, or as a string/string dictionary. The method returns\nan opaque identifier that can be passed to the :meth:`close`\nmethod, to close all open elements up to and including this one.",
      "docstring": "Open a new element.  Attributes can be given as keyword\narguments, or as a string/string dictionary. The method returns\nan opaque identifier that can be passed to the :meth:`close`\nmethod, to close all open elements up to and including this one.\n\nParameters\n----------\ntag\n    Element tag.\nattrib\n    Attribute dictionary.  Alternatively, attributes can be given as\n    keyword arguments.\n\nReturns\n-------\nAn element identifier.",
      "code": "    def start(self, tag, attrib={}, **extra):\n        \"\"\"\n        Open a new element.  Attributes can be given as keyword\n        arguments, or as a string/string dictionary. The method returns\n        an opaque identifier that can be passed to the :meth:`close`\n        method, to close all open elements up to and including this one.\n\n        Parameters\n        ----------\n        tag\n            Element tag.\n        attrib\n            Attribute dictionary.  Alternatively, attributes can be given as\n            keyword arguments.\n\n        Returns\n        -------\n        An element identifier.\n        \"\"\"\n        self.__flush()\n        tag = _escape_cdata(tag)\n        self.__data = []\n        self.__tags.append(tag)\n        self.__write(self.__indentation[:len(self.__tags) - 1])\n        self.__write(\"<%s\" % tag)\n        for k, v in {**attrib, **extra}.items():\n            if v:\n                k = _escape_cdata(k)\n                v = _quote_escape_attrib(v)\n                self.__write(' %s=%s' % (k, v))\n        self.__open = 1\n        return len(self.__tags) - 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_attrib",
      "name": "escape_attrib",
      "qname": "lib.matplotlib.backends.backend_svg.escape_attrib",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _escape_attrib')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_attrib/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.escape_attrib.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _escape_attrib\")\ndef escape_attrib(s):\n    return _escape_attrib(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_cdata",
      "name": "escape_cdata",
      "qname": "lib.matplotlib.backends.backend_svg.escape_cdata",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _escape_cdata')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_cdata/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.escape_cdata.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _escape_cdata\")\ndef escape_cdata(s):\n    return _escape_cdata(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_comment",
      "name": "escape_comment",
      "qname": "lib.matplotlib.backends.backend_svg.escape_comment",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _escape_comment')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_comment/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.escape_comment.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _escape_comment\")\ndef escape_comment(s):\n    return _escape_comment.sub(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_css",
      "name": "generate_css",
      "qname": "lib.matplotlib.backends.backend_svg.generate_css",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_css/attrib",
          "name": "attrib",
          "qname": "lib.matplotlib.backends.backend_svg.generate_css.attrib",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef generate_css(attrib=None):\n    return _generate_css(attrib or {})"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_transform",
      "name": "generate_transform",
      "qname": "lib.matplotlib.backends.backend_svg.generate_transform",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_transform/transform_list",
          "name": "transform_list",
          "qname": "lib.matplotlib.backends.backend_svg.generate_transform.transform_list",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef generate_transform(transform_list=None):\n    return _generate_transform(transform_list or [])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/short_float_fmt",
      "name": "short_float_fmt",
      "qname": "lib.matplotlib.backends.backend_svg.short_float_fmt",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _short_float_fmt')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/short_float_fmt/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.short_float_fmt.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _short_float_fmt\")\ndef short_float_fmt(x):\n    return _short_float_fmt(x)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw the figure using the renderer.\n\nIt is important that this method actually walk the artist tree\neven if not output is produced because this will trigger\ndeferred work (like computing limits auto-limits and tick\nvalues) that users may want access to before saving to disk.",
      "docstring": "Draw the figure using the renderer.\n\nIt is important that this method actually walk the artist tree\neven if not output is produced because this will trigger\ndeferred work (like computing limits auto-limits and tick\nvalues) that users may want access to before saving to disk.",
      "code": "    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'foo'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo",
      "name": "print_foo",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out format foo.\n\nThis method is normally called via `.Figure.savefig` and\n`.FigureCanvasBase.print_figure`, which take care of setting the figure\nfacecolor, edgecolor, and dpi to the desired output values, and will\nrestore them to the original values.  Therefore, `print_foo` does not\nneed to handle these settings.",
      "docstring": "Write out format foo.\n\nThis method is normally called via `.Figure.savefig` and\n`.FigureCanvasBase.print_figure`, which take care of setting the figure\nfacecolor, edgecolor, and dpi to the desired output values, and will\nrestore them to the original values.  Therefore, `print_foo` does not\nneed to handle these settings.",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_foo(self, filename, *args, **kwargs):\n        \"\"\"\n        Write out format foo.\n\n        This method is normally called via `.Figure.savefig` and\n        `.FigureCanvasBase.print_figure`, which take care of setting the figure\n        facecolor, edgecolor, and dpi to the desired output values, and will\n        restore them to the original values.  Therefore, `print_foo` does not\n        need to handle these settings.\n        \"\"\"\n        self.draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `.backend_bases.RendererBase` for\ndocumentation of the methods.",
      "docstring": "",
      "code": "    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return 100, 100"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        return 1, 1, 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextTemplate()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # if backend doesn't have dpi, e.g., postscript or svg\n        return points"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_template.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/show/block",
          "name": "block",
          "qname": "lib.matplotlib.backends.backend_template.show.block",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "For image backends - is not required.\nFor GUI backends - show() is usually the last line of a pyplot script and\ntells the backend that it is time to draw.  In interactive mode, this\nshould do nothing.",
      "docstring": "For image backends - is not required.\nFor GUI backends - show() is usually the last line of a pyplot script and\ntells the backend that it is time to draw.  In interactive mode, this\nshould do nothing.",
      "code": "def show(*, block=None):\n    \"\"\"\n    For image backends - is not required.\n    For GUI backends - show() is usually the last line of a pyplot script and\n    tells the backend that it is time to draw.  In interactive mode, this\n    should do nothing.\n    \"\"\"\n    for manager in Gcf.get_all_fig_managers():\n        # do something to display the GUI\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        _backend_tk.blit(self._tkphoto, self.renderer.buffer_rgba(),\n                         (0, 1, 2, 3), bbox=bbox)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        super().draw()\n        self.blit()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        width = int(self.figure.bbox.width)\n        height = int(self.figure.bbox.height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_context(cairo.Context(surface))\n        self._renderer.dpi = self.figure.dpi\n        self.figure.draw(self._renderer)\n        buf = np.reshape(surface.get_data(), (height, width, 4))\n        _backend_tk.blit(\n            self._tkphoto, buf,\n            (2, 1, 0, 3) if sys.byteorder == \"little\" else (1, 2, 3, 0))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread/run",
      "name": "run",
      "qname": "lib.matplotlib.backends.backend_webagg.ServerThread.run",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread/run/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.ServerThread.run.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def run(self):\n        tornado.ioloop.IOLoop.instance().start()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/application",
          "name": "application",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.application",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/request",
          "name": "request",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.request",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.url_prefix",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self):\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"all_figures.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                figures=sorted(Gcf.figs.items()),\n                toolitems=core.NavigationToolbar2WebAgg.toolitems)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get/fignum",
          "name": "fignum",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get.fignum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get/fmt",
          "name": "fmt",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get.fmt",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self, fignum, fmt):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n            self.set_header(\n                'Content-Type', mimetypes.types_map.get(fmt, 'binary'))\n            buff = BytesIO()\n            manager.canvas.figure.savefig(buff, format=fmt)\n            self.write(buff.getvalue())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/FavIcon/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.FavIcon.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/FavIcon/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.FavIcon.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self):\n            self.set_header('Content-Type', 'image/png')\n            self.write(Path(mpl.get_data_path(),\n                            'images/matplotlib.png').read_bytes())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/MplJs/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.MplJs.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/MplJs/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.MplJs.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self):\n            self.set_header('Content-Type', 'application/javascript')\n\n            js_content = core.FigureManagerWebAgg.get_javascript()\n\n            self.write(js_content)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/application",
          "name": "application",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.application",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/request",
          "name": "request",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.request",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.url_prefix",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/get/fignum",
          "name": "fignum",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.get.fignum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self, fignum):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"single_figure.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                fig_id=fignum,\n                toolitems=core.NavigationToolbar2WebAgg.toolitems,\n                canvas=manager.canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_close",
      "name": "on_close",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def on_close(self):\n            self.manager.remove_web_socket(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_message",
      "name": "on_message",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def on_message(self, message):\n            message = json.loads(message)\n            # The 'supports_binary' message is on a client-by-client\n            # basis.  The others affect the (shared) canvas as a\n            # whole.\n            if message['type'] == 'supports_binary':\n                self.supports_binary = message['value']\n            else:\n                manager = Gcf.get_fig_manager(self.fignum)\n                # It is possible for a figure to be closed,\n                # but a stale figure UI is still sending messages\n                # from the browser.\n                if manager is not None:\n                    manager.handle_json(message)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/open",
      "name": "open",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.open",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/open/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.open.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/open/fignum",
          "name": "fignum",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.open.fignum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def open(self, fignum):\n            self.fignum = int(fignum)\n            self.manager = Gcf.get_fig_manager(self.fignum)\n            self.manager.add_web_socket(self)\n            if hasattr(self, 'set_nodelay'):\n                self.set_nodelay(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_binary",
      "name": "send_binary",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_binary",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_binary/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_binary.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_binary/blob",
          "name": "blob",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_binary.blob",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def send_binary(self, blob):\n            if self.supports_binary:\n                self.write_message(blob, binary=True)\n            else:\n                data_uri = \"data:image/png;base64,{0}\".format(\n                    blob.encode('base64').replace('\\n', ''))\n                self.write_message(data_uri)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_json",
      "name": "send_json",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_json",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_json/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_json/content",
          "name": "content",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_json.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def send_json(self, content):\n            self.write_message(json.dumps(content))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.__init__.url_prefix",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, url_prefix=''):\n        if url_prefix:\n            assert url_prefix[0] == '/' and url_prefix[-1] != '/', \\\n                'url_prefix must start with a \"/\" and not end with one.'\n\n        super().__init__(\n            [\n                # Static files for the CSS and JS\n                (url_prefix + r'/_static/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': core.FigureManagerWebAgg.get_static_file_path()}),\n\n                # Static images for the toolbar\n                (url_prefix + r'/_images/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': Path(mpl.get_data_path(), 'images')}),\n\n                # A Matplotlib favicon\n                (url_prefix + r'/favicon.ico', self.FavIcon),\n\n                # The page that contains all of the pieces\n                (url_prefix + r'/([0-9]+)', self.SingleFigurePage,\n                 {'url_prefix': url_prefix}),\n\n                # The page that contains all of the figures\n                (url_prefix + r'/?', self.AllFiguresPage,\n                 {'url_prefix': url_prefix}),\n\n                (url_prefix + r'/js/mpl.js', self.MplJs),\n\n                # Sends images and events to the browser, and receives\n                # events from the browser\n                (url_prefix + r'/([0-9]+)/ws', self.WebSocket),\n\n                # Handles the downloading (i.e., saving) of static images\n                (url_prefix + r'/([0-9]+)/download.([a-z0-9.]+)',\n                 self.Download),\n            ],\n            template_path=core.FigureManagerWebAgg.get_static_file_path())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize",
      "name": "initialize",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.url_prefix",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/port",
          "name": "port",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.port",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/address",
          "name": "address",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.address",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def initialize(cls, url_prefix='', port=None, address=None):\n        if cls.initialized:\n            return\n\n        # Create the class instance\n        app = cls(url_prefix=url_prefix)\n\n        cls.url_prefix = url_prefix\n\n        # This port selection algorithm is borrowed, more or less\n        # verbatim, from IPython.\n        def random_ports(port, n):\n            \"\"\"\n            Generate a list of n random ports near the given port.\n\n            The first 5 ports will be sequential, and the remaining n-5 will be\n            randomly selected in the range [port-2*n, port+2*n].\n            \"\"\"\n            for i in range(min(5, n)):\n                yield port + i\n            for i in range(n - 5):\n                yield port + random.randint(-2 * n, 2 * n)\n\n        if address is None:\n            cls.address = mpl.rcParams['webagg.address']\n        else:\n            cls.address = address\n        cls.port = mpl.rcParams['webagg.port']\n        for port in random_ports(cls.port,\n                                 mpl.rcParams['webagg.port_retries']):\n            try:\n                app.listen(port, cls.address)\n            except socket.error as e:\n                if e.errno != errno.EADDRINUSE:\n                    raise\n            else:\n                cls.port = port\n                break\n        else:\n            raise SystemExit(\n                \"The webagg server could not be started because an available \"\n                \"port could not be found\")\n\n        cls.initialized = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/start",
      "name": "start",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.start",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/start/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.start.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def start(cls):\n        if cls.started:\n            return\n\n        \"\"\"\n        IOLoop.running() was removed as of Tornado 2.4; see for example\n        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY\n        Thus there is no correct way to check if the loop has already been\n        launched. We may end up with two concurrently running loops in that\n        unlucky case with all the expected consequences.\n        \"\"\"\n        ioloop = tornado.ioloop.IOLoop.instance()\n\n        def shutdown():\n            ioloop.stop()\n            print(\"Server is stopped\")\n            sys.stdout.flush()\n            cls.started = False\n\n        @contextmanager\n        def catch_sigint():\n            old_handler = signal.signal(\n                signal.SIGINT,\n                lambda sig, frame: ioloop.add_callback_from_signal(shutdown))\n            try:\n                yield\n            finally:\n                signal.signal(signal.SIGINT, old_handler)\n\n        # Set the flag to True *before* blocking on ioloop.start()\n        cls.started = True\n\n        print(\"Press Ctrl+C to stop WebAgg server\")\n        sys.stdout.flush()\n        with catch_sigint():\n            ioloop.start()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ipython_inline_display",
      "name": "ipython_inline_display",
      "qname": "lib.matplotlib.backends.backend_webagg.ipython_inline_display",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ipython_inline_display/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_webagg.ipython_inline_display.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def ipython_inline_display(figure):\n    import tornado.template\n\n    WebAggApplication.initialize()\n    if not webagg_server_thread.is_alive():\n        webagg_server_thread.start()\n\n    fignum = figure.number\n    tpl = Path(core.FigureManagerWebAgg.get_static_file_path(),\n               \"ipython_inline_figure.html\").read_text()\n    t = tornado.template.Template(tpl)\n    return t.generate(\n        prefix=WebAggApplication.url_prefix,\n        fig_id=fignum,\n        toolitems=core.NavigationToolbar2WebAgg.toolitems,\n        canvas=figure.canvas,\n        port=WebAggApplication.port).decode('utf-8')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Set to True when the renderer contains data that is newer\n        # than the PNG buffer.\n        self._png_is_old = True\n        # Set to True by the `refresh` message so that the next frame\n        # sent to the clients will be a full frame.\n        self._force_full = True\n        # The last buffer, for diff mode.\n        self._last_buff = np.empty((0, 0))\n        # Store the current image mode so that at any point, clients can\n        # request the information. This should be changed by calling\n        # self.set_image_mode(mode) so that the notification can be given\n        # to the connected clients.\n        self._current_image_mode = 'full'\n        # Track mouse events to fill in the x, y position of key events.\n        self._last_mouse_xy = (None, None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        self._png_is_old = True\n        self.manager.refresh_all()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self._png_is_old = True\n        try:\n            super().draw()\n        finally:\n            self.manager.refresh_all()  # Swap the frames."
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        self.send_event(\"draw\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_diff_image",
      "name": "get_diff_image",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.get_diff_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_diff_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.get_diff_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_diff_image(self):\n        if self._png_is_old:\n            renderer = self.get_renderer()\n\n            pixels = np.asarray(renderer.buffer_rgba())\n            # The buffer is created as type uint32 so that entire\n            # pixels can be compared in one numpy call, rather than\n            # needing to compare each plane separately.\n            buff = pixels.view(np.uint32).squeeze(2)\n\n            if (self._force_full\n                    # If the buffer has changed size we need to do a full draw.\n                    or buff.shape != self._last_buff.shape\n                    # If any pixels have transparency, we need to force a full\n                    # draw as we cannot overlay new on top of old.\n                    or (pixels[:, :, 3] != 255).any()):\n                self.set_image_mode('full')\n                output = buff\n            else:\n                self.set_image_mode('diff')\n                diff = buff != self._last_buff\n                output = np.where(diff, buff, 0)\n\n            # Store the current buffer so we can compute the next diff.\n            self._last_buff = buff.copy()\n            self._force_full = False\n            self._png_is_old = False\n\n            data = output.view(dtype=np.uint8).reshape((*output.shape, 4))\n            with BytesIO() as png:\n                Image.fromarray(data).save(png, format=\"png\")\n                return png.getvalue()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack",
      "name": "handle_ack",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_ack",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_ack.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_ack.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_ack(self, event):\n        # Network latency tends to decrease if traffic is flowing\n        # in both directions.  Therefore, the browser sends back\n        # an \"ack\" message after each image frame is received.\n        # This could also be used as a simple sanity check in the\n        # future, but for now the performance increase is enough\n        # to justify it, even if the server does nothing with it.\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw",
      "name": "handle_draw",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_draw.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_draw(self, event):\n        self.draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event",
      "name": "handle_event",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_event(self, event):\n        e_type = event['type']\n        handler = getattr(self, 'handle_{0}'.format(e_type),\n                          self.handle_unknown_event)\n        return handler(event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh",
      "name": "handle_refresh",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_refresh",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_refresh.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_refresh.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_refresh(self, event):\n        figure_label = self.figure.get_label()\n        if not figure_label:\n            figure_label = \"Figure {0}\".format(self.manager.num)\n        self.send_event('figure_label', label=figure_label)\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize",
      "name": "handle_resize",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_resize.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_resize(self, event):\n        x = int(event.get('width', 800)) * self.device_pixel_ratio\n        y = int(event.get('height', 800)) * self.device_pixel_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        ResizeEvent('resize_event', self)._process()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode",
      "name": "handle_send_image_mode",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_send_image_mode",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_send_image_mode.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_send_image_mode.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_send_image_mode(self, event):\n        # The client requests notification of what the current image mode is.\n        self.send_event('image_mode', mode=self._current_image_mode)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_device_pixel_ratio",
      "name": "handle_set_device_pixel_ratio",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_device_pixel_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_device_pixel_ratio/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_device_pixel_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_device_pixel_ratio/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_device_pixel_ratio.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_set_device_pixel_ratio(self, event):\n        self._handle_set_device_pixel_ratio(event.get('device_pixel_ratio', 1))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio",
      "name": "handle_set_dpi_ratio",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_dpi_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_dpi_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_dpi_ratio.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_set_dpi_ratio(self, event):\n        # This handler is for backwards-compatibility with older ipympl.\n        self._handle_set_device_pixel_ratio(event.get('dpi_ratio', 1))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button",
      "name": "handle_toolbar_button",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_toolbar_button",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_toolbar_button.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_toolbar_button.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event",
      "name": "handle_unknown_event",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_unknown_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_unknown_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_unknown_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_unknown_event(self, event):\n        _log.warning('Unhandled message type {0}. {1}'.format(\n                     event['type'], event))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event",
      "name": "send_event",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event/event_type",
          "name": "event_type",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event.event_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def send_event(self, event_type, **kwargs):\n        if self.manager:\n            self.manager._send_event(event_type, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        # docstring inherited\n        cursor = _api.check_getitem({\n            backend_tools.Cursors.HAND: 'pointer',\n            backend_tools.Cursors.POINTER: 'default',\n            backend_tools.Cursors.SELECT_REGION: 'crosshair',\n            backend_tools.Cursors.MOVE: 'move',\n            backend_tools.Cursors.WAIT: 'wait',\n            backend_tools.Cursors.RESIZE_HORIZONTAL: 'ew-resize',\n            backend_tools.Cursors.RESIZE_VERTICAL: 'ns-resize',\n        }, cursor=cursor)\n        self.send_event('cursor', cursor=cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode",
      "name": "set_image_mode",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_image_mode",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_image_mode.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode/mode",
          "name": "mode",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_image_mode.mode",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the image mode for any subsequent images which will be sent\nto the clients. The modes may currently be either 'full' or 'diff'.\n\nNote: diff images may not contain transparency, therefore upon\ndraw this mode may be changed if the resulting image has any\ntransparent component.",
      "docstring": "Set the image mode for any subsequent images which will be sent\nto the clients. The modes may currently be either 'full' or 'diff'.\n\nNote: diff images may not contain transparency, therefore upon\ndraw this mode may be changed if the resulting image has any\ntransparent component.",
      "code": "    def set_image_mode(self, mode):\n        \"\"\"\n        Set the image mode for any subsequent images which will be sent\n        to the clients. The modes may currently be either 'full' or 'diff'.\n\n        Note: diff images may not contain transparency, therefore upon\n        draw this mode may be changed if the resulting image has any\n        transparent component.\n        \"\"\"\n        _api.check_in_list(['full', 'diff'], mode=mode)\n        if self._current_image_mode != mode:\n            self._current_image_mode = mode\n            self.handle_send_image_mode(None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        # show the figure window\n        from matplotlib.pyplot import show\n        show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        self.web_sockets = set()\n        super().__init__(canvas, num)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket",
      "name": "add_web_socket",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.add_web_socket",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.add_web_socket.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket/web_socket",
          "name": "web_socket",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.add_web_socket.web_socket",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_web_socket(self, web_socket):\n        assert hasattr(web_socket, 'send_binary')\n        assert hasattr(web_socket, 'send_json')\n        self.web_sockets.add(web_socket)\n        self.resize(*self.canvas.figure.bbox.size)\n        self._send_event('refresh')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript",
      "name": "get_javascript",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_javascript",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_javascript.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript/stream",
          "name": "stream",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_javascript.stream",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = StringIO()\n        else:\n            output = stream\n\n        output.write((Path(__file__).parent / \"web_backend/js/mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n\n        toolitems = []\n        for name, tooltip, image, method in cls.ToolbarCls.toolitems:\n            if name is None:\n                toolitems.append(['', '', '', ''])\n            else:\n                toolitems.append([name, tooltip, image, method])\n        output.write(\"mpl.toolbar_items = {0};\\n\\n\".format(\n            json.dumps(toolitems)))\n\n        extensions = []\n        for filetype, ext in sorted(FigureCanvasWebAggCore.\n                                    get_supported_filetypes_grouped().\n                                    items()):\n            extensions.append(ext[0])\n        output.write(\"mpl.extensions = {0};\\n\\n\".format(\n            json.dumps(extensions)))\n\n        output.write(\"mpl.default_extension = {0};\".format(\n            json.dumps(FigureCanvasWebAggCore.get_default_filetype())))\n\n        if stream is None:\n            return output.getvalue()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_static_file_path",
      "name": "get_static_file_path",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_static_file_path",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_static_file_path/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_static_file_path.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def get_static_file_path(cls):\n        return os.path.join(os.path.dirname(__file__), 'web_backend')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json",
      "name": "handle_json",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.handle_json",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.handle_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json/content",
          "name": "content",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.handle_json.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_json(self, content):\n        self.canvas.handle_event(content)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/refresh_all",
      "name": "refresh_all",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.refresh_all",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/refresh_all/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.refresh_all.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def refresh_all(self):\n        if self.web_sockets:\n            diff = self.canvas.get_diff_image()\n            if diff is not None:\n                for s in self.web_sockets:\n                    s.send_binary(diff)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket",
      "name": "remove_web_socket",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.remove_web_socket",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.remove_web_socket.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket/web_socket",
          "name": "web_socket",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.remove_web_socket.web_socket",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_web_socket(self, web_socket):\n        self.web_sockets.remove(web_socket)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/w",
          "name": "w",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/h",
          "name": "h",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.h",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/forward",
          "name": "forward",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.forward",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, w, h, forward=True):\n        self._send_event(\n            'resize',\n            size=(w / self.canvas.device_pixel_ratio,\n                  h / self.canvas.device_pixel_ratio),\n            forward=forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        self._send_event('figure_label', label=title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas):\n        self.message = ''\n        self._cursor = None  # Remove with deprecation.\n        super().__init__(canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.send_event(\"rubberband\", x0=x0, y0=y0, x1=x1, y1=y1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self):\n        super().pan()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas.send_event(\"rubberband\", x0=-1, y0=-1, x1=-1, y1=-1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save the current figure",
      "docstring": "Save the current figure",
      "code": "    def save_figure(self, *args):\n        \"\"\"Save the current figure\"\"\"\n        self.canvas.send_event('save')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        self.canvas.send_event('history_buttons',\n                               Back=can_backward, Forward=can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, message):\n        if message != self.message:\n            self.canvas.send_event(\"message\", message=message)\n        self.message = message"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self):\n        super().zoom()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._task = None\n        super().__init__(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._timer = None\n        super().__init__(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2Wx.configure_subplots(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw/drawDC",
          "name": "drawDC",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.draw.drawDC",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure using RendererWx instance renderer, or using a\npreviously defined renderer if none is specified.",
      "docstring": "Render the figure using RendererWx instance renderer, or using a\npreviously defined renderer if none is specified.",
      "code": "    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using RendererWx instance renderer, or using a\n        previously defined renderer if none is specified.\n        \"\"\"\n        _log.debug(\"%s - draw()\", type(self))\n        self.renderer = RendererWx(self.bitmap, self.figure.dpi)\n        self.figure.draw(self.renderer)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/canvas_class",
          "name": "canvas_class",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.canvas_class",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, num, fig, *, canvas_class=None):\n        # On non-Windows platform, explicitly set the position - fix\n        # positioning bug on some Linux platforms\n        if wx.Platform == '__WXMSW__':\n            pos = wx.DefaultPosition\n        else:\n            pos = wx.Point(20, 20)\n        super().__init__(parent=None, id=-1, pos=pos)\n        # Frame will be sized later by the Fit method\n        _log.debug(\"%s - __init__()\", type(self))\n        _set_frame_icon(self)\n\n        # The parameter will become required after the deprecation elapses.\n        if canvas_class is not None:\n            self.canvas = canvas_class(self, -1, fig)\n        else:\n            _api.warn_deprecated(\n                \"3.6\", message=\"The canvas_class parameter will become \"\n                \"required after the deprecation period starting in Matplotlib \"\n                \"%(since)s elapses.\")\n            self.canvas = self.get_canvas(fig)\n\n        # Auto-attaches itself to self.canvas.manager\n        manager = FigureManagerWx(self.canvas, num, self)\n\n        toolbar = self.canvas.manager.toolbar\n        if toolbar is not None:\n            self.SetToolBar(toolbar)\n\n        # On Windows, canvas sizing must occur after toolbar addition;\n        # otherwise the toolbar further resizes the canvas.\n        w, h = map(math.ceil, fig.bbox.size)\n        self.canvas.SetInitialSize(wx.Size(w, h))\n        self.canvas.SetMinSize((2, 2))\n        self.canvas.SetFocus()\n\n        self.Fit()\n\n        self.Bind(wx.EVT_CLOSE, self._on_close)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_canvas",
      "decorators": [
        "_api.deprecated('3.6', alternative='the canvas_class constructor parameter')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\n        \"3.6\", alternative=\"the canvas_class constructor parameter\")\n    def get_canvas(self, fig):\n        return FigureCanvasWx(self, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_figure_manager",
      "name": "get_figure_manager",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_figure_manager",
      "decorators": [
        "_api.deprecated('3.6', alternative='frame.canvas.manager')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_figure_manager/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_figure_manager.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\", alternative=\"frame.canvas.manager\")\n    def get_figure_manager(self):\n        _log.debug(\"%s - get_figure_manager()\", type(self))\n        return self.canvas.manager"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/frame",
          "name": "frame",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.",
      "docstring": "",
      "code": "    def __init__(self, canvas, num, frame):\n        _log.debug(\"%s - __init__()\", type(self))\n        self.frame = self.window = frame\n        super().__init__(canvas, num)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas",
      "name": "create_with_canvas",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas/canvas_class",
          "name": "canvas_class",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas.canvas_class",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        # docstring inherited\n        wxapp = wx.GetApp() or _create_wxapp()\n        frame = FigureFrameWx(num, figure, canvas_class=canvas_class)\n        manager = figure.canvas.manager\n        if mpl.is_interactive():\n            manager.frame.Show()\n            figure.canvas.draw_idle()\n        return manager"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.destroy.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self, *args):\n        # docstring inherited\n        _log.debug(\"%s - destroy()\", type(self))\n        frame = self.frame\n        if frame:  # Else, may have been already deleted, e.g. when closing.\n            # As this can be called from non-GUI thread from plt.close use\n            # wx.CallAfter to ensure thread safety.\n            wx.CallAfter(frame.Close)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/full_screen_toggle",
      "name": "full_screen_toggle",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.full_screen_toggle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/full_screen_toggle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.full_screen_toggle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def full_screen_toggle(self):\n        # docstring inherited\n        self.frame.ShowFullScreen(not self.frame.IsFullScreen())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/get_window_title",
      "name": "get_window_title",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.get_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/get_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.get_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_window_title(self):\n        # docstring inherited\n        return self.window.GetTitle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, width, height):\n        # docstring inherited\n        # Directly using SetClientSize doesn't handle the toolbar on Windows.\n        self.window.SetSize(self.window.ClientToWindowSize(wx.Size(\n            math.ceil(width), math.ceil(height))))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        # docstring inherited\n        self.window.SetTitle(title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        # docstring inherited\n        self.frame.Show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.frame.Raise()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__/bitmap",
          "name": "bitmap",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__.bitmap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The graphics context provides the color, line styles, etc.\n\nThis class stores a reference to a wxMemoryDC, and a\nwxGraphicsContext that draws to it.  Creating a wxGraphicsContext\nseems to be fairly heavy, so these objects are cached based on the\nbitmap object that is passed in.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\nsince wxPython colour management is rather simple, I have not chosen\nto implement a separate colour manager class.",
      "docstring": "",
      "code": "    def __init__(self, bitmap, renderer):\n        super().__init__()\n        # assert self.Ok(), \"wxMemoryDC not OK to use\"\n        _log.debug(\"%s - __init__(): %s\", type(self), bitmap)\n\n        dc, gfx_ctx = self._cache.get(bitmap, (None, None))\n        if dc is None:\n            dc = wx.MemoryDC(bitmap)\n            gfx_ctx = wx.GraphicsContext.Create(dc)\n            gfx_ctx._lastcliprect = None\n            self._cache[bitmap] = dc, gfx_ctx\n\n        self.bitmap = bitmap\n        self.dc = dc\n        self.gfx_ctx = gfx_ctx\n        self._pen = wx.Pen('BLACK', 1, wx.SOLID)\n        gfx_ctx.SetPen(self._pen)\n        self.renderer = renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour",
      "name": "get_wxcolour",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.get_wxcolour",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.get_wxcolour.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour/color",
          "name": "color",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.get_wxcolour.color",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert a RGB(A) color to a wx.Colour.",
      "docstring": "Convert a RGB(A) color to a wx.Colour.",
      "code": "    def get_wxcolour(self, color):\n        \"\"\"Convert a RGB(A) color to a wx.Colour.\"\"\"\n        _log.debug(\"%s - get_wx_color()\", type(self))\n        return wx.Colour(*[int(255 * x) for x in color])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/select",
      "name": "select",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.select",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/select/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.select.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Select the current bitmap into this wxDC instance.",
      "docstring": "Select the current bitmap into this wxDC instance.",
      "code": "    def select(self):\n        \"\"\"Select the current bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(self.bitmap)\n            self.IsSelected = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle",
      "name": "set_capstyle",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_capstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_capstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle/cs",
          "name": "cs",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_capstyle.cs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_capstyle(self, cs):\n        # docstring inherited\n        _log.debug(\"%s - set_capstyle()\", type(self))\n        self.select()\n        super().set_capstyle(cs)\n        self._pen.SetCap(GraphicsContextWx._capd[self._capstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground",
      "name": "set_foreground",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground/fg",
          "name": "fg",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground.fg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground/isRGBA",
          "name": "isRGBA",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground.isRGBA",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_foreground(self, fg, isRGBA=None):\n        # docstring inherited\n        # Implementation note: wxPython has a separate concept of pen and\n        # brush - the brush fills any outline trace left by the pen.\n        # Here we set both to the same colour - if a figure is not to be\n        # filled, the renderer will set the brush to be transparent\n        # Same goes for text foreground...\n        _log.debug(\"%s - set_foreground()\", type(self))\n        self.select()\n        super().set_foreground(fg, isRGBA)\n\n        self._pen.SetColour(self.get_wxcolour(self.get_rgb()))\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle",
      "name": "set_joinstyle",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_joinstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_joinstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle/js",
          "name": "js",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_joinstyle.js",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_joinstyle(self, js):\n        # docstring inherited\n        _log.debug(\"%s - set_joinstyle()\", type(self))\n        self.select()\n        super().set_joinstyle(js)\n        self._pen.SetJoin(GraphicsContextWx._joind[self._joinstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth",
      "name": "set_linewidth",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_linewidth",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_linewidth.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth/w",
          "name": "w",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_linewidth.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linewidth(self, w):\n        # docstring inherited\n        w = float(w)\n        _log.debug(\"%s - set_linewidth()\", type(self))\n        self.select()\n        if 0 < w < 1:\n            w = 1\n        super().set_linewidth(w)\n        lw = int(self.renderer.points_to_pixels(self._linewidth))\n        if lw == 0:\n            lw = 1\n        self._pen.SetWidth(lw)\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/unselect",
      "name": "unselect",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.unselect",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/unselect/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.unselect.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Select a Null bitmap into this wxDC instance.",
      "docstring": "Select a Null bitmap into this wxDC instance.",
      "code": "    def unselect(self):\n        \"\"\"Select a Null bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(wx.NullBitmap)\n            self.IsSelected = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.HelpWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.HelpWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.HelpWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        _HelpDialog.show(self.figure.canvas.GetTopLevelParent(),\n                         self._get_help_entries())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/coordinates",
          "name": "coordinates",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.coordinates",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.style",
          "default_value": "wx.TB_BOTTOM",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, coordinates=True, *, style=wx.TB_BOTTOM):\n        wx.ToolBar.__init__(self, canvas.GetParent(), -1, style=style)\n\n        if 'wxMac' in wx.PlatformInfo:\n            self.SetToolBitmapSize((24, 24))\n        self.wx_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.AddSeparator()\n                continue\n            self.wx_ids[text] = (\n                self.AddTool(\n                    -1,\n                    bitmap=self._icon(f\"{image_file}.png\"),\n                    bmpDisabled=wx.NullBitmap,\n                    label=text, shortHelp=tooltip_text,\n                    kind=(wx.ITEM_CHECK if text in [\"Pan\", \"Zoom\"]\n                          else wx.ITEM_NORMAL))\n                .Id)\n            self.Bind(wx.EVT_TOOL, getattr(self, callback),\n                      id=self.wx_ids[text])\n\n        self._coordinates = coordinates\n        if self._coordinates:\n            self.AddStretchableSpace()\n            self._label_text = wx.StaticText(self, style=wx.ALIGN_RIGHT)\n            self.AddControl(self._label_text)\n\n        self.Realize()\n\n        NavigationToolbar2.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        self.canvas._rubberband_rect = (x0, height - y0, x1, height - y1)\n        self.canvas.Refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.pan.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas._rubberband_rect = None\n        self.canvas.Refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        # Fetch the required filename and file type.\n        filetypes, exts, filter_index = self.canvas._get_imagesave_wildcards()\n        default_file = self.canvas.get_default_filename()\n        dialog = wx.FileDialog(\n            self.canvas.GetParent(), \"Save to file\",\n            mpl.rcParams[\"savefig.directory\"], default_file, filetypes,\n            wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)\n        dialog.SetFilterIndex(filter_index)\n        if dialog.ShowModal() == wx.ID_OK:\n            path = pathlib.Path(dialog.GetPath())\n            _log.debug('%s - Save file path: %s', type(self), path)\n            fmt = exts[dialog.GetFilterIndex()]\n            ext = path.suffix[1:]\n            if ext in self.canvas.get_supported_filetypes() and fmt != ext:\n                # looks like they forgot to set the image type drop\n                # down, going with the extension.\n                _log.warning('extension %s did not match the selected '\n                             'image type %s; going with %s',\n                             ext, fmt, ext)\n                fmt = ext\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams[\"savefig.directory\"]:\n                mpl.rcParams[\"savefig.directory\"] = str(path.parent)\n            try:\n                self.canvas.figure.savefig(str(path), format=fmt)\n            except Exception as e:\n                dialog = wx.MessageDialog(\n                    parent=self.canvas.GetParent(), message=str(e),\n                    caption='Matplotlib error')\n                dialog.ShowModal()\n                dialog.Destroy()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'Back' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Back'], can_backward)\n        if 'Forward' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Forward'], can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        if self._coordinates:\n            self._label_text.SetLabel(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.zoom.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__/bitmap",
          "name": "bitmap",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__.bitmap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles. It acts as the\n'renderer' instance used by many classes in the hierarchy.",
      "docstring": "Initialise a wxWindows renderer instance.",
      "code": "    def __init__(self, bitmap, dpi):\n        \"\"\"Initialise a wxWindows renderer instance.\"\"\"\n        super().__init__()\n        _log.debug(\"%s - __init__()\", type(self))\n        self.width = bitmap.GetWidth()\n        self.height = bitmap.GetHeight()\n        self.bitmap = bitmap\n        self.fontd = {}\n        self.dpi = dpi\n        self.gc = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path",
      "name": "convert_path",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path/gfx_ctx",
          "name": "gfx_ctx",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path.gfx_ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def convert_path(gfx_ctx, path, transform):\n        wxpath = gfx_ctx.CreatePath()\n        for points, code in path.iter_segments(transform):\n            if code == Path.MOVETO:\n                wxpath.MoveToPoint(*points)\n            elif code == Path.LINETO:\n                wxpath.AddLineToPoint(*points)\n            elif code == Path.CURVE3:\n                wxpath.AddQuadCurveToPoint(*points)\n            elif code == Path.CURVE4:\n                wxpath.AddCurveToPoint(*points)\n            elif code == Path.CLOSEPOLY:\n                wxpath.CloseSubpath()\n        return wxpath"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im):\n        bbox = gc.get_clip_rectangle()\n        if bbox is not None:\n            l, b, w, h = bbox.bounds\n        else:\n            l = 0\n            b = 0\n            w = self.width\n            h = self.height\n        rows, cols = im.shape[:2]\n        bitmap = wx.Bitmap.FromBufferRGBA(cols, rows, im.tobytes())\n        gc.select()\n        gc.gfx_ctx.DrawBitmap(bitmap, int(l), int(self.height - b),\n                              int(w), int(-h))\n        gc.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n        transform = transform + \\\n            Affine2D().scale(1.0, -1.0).translate(0.0, self.height)\n        wxpath = self.convert_path(gfx_ctx, path, transform)\n        if rgbFace is not None:\n            gfx_ctx.SetBrush(wx.Brush(gc.get_wxcolour(rgbFace)))\n            gfx_ctx.DrawPath(wxpath)\n        else:\n            gfx_ctx.StrokePath(wxpath)\n        gc.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n        _log.debug(\"%s - draw_text()\", type(self))\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n\n        font = self.get_wx_font(s, prop)\n        color = gc.get_wxcolour(gc.get_rgb())\n        gfx_ctx.SetFont(font, color)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath)\n        x = int(x)\n        y = int(y - h)\n\n        if angle == 0.0:\n            gfx_ctx.DrawText(s, x, y)\n        else:\n            rads = math.radians(angle)\n            xo = h * math.sin(rads)\n            yo = h * math.cos(rads)\n            gfx_ctx.DrawRotatedText(s, x - xo, y - yo, rads)\n\n        gc.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n\n        if self.gc is None:\n            gc = self.new_gc()\n        else:\n            gc = self.gc\n        gfx_ctx = gc.gfx_ctx\n        font = self.get_wx_font(s, prop)\n        gfx_ctx.SetFont(font, wx.BLACK)\n        w, h, descent, leading = gfx_ctx.GetFullTextExtent(s)\n\n        return w, h, descent"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font",
      "name": "get_wx_font",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a wx font.  Cache font instances for efficiency.",
      "docstring": "Return a wx font.  Cache font instances for efficiency.",
      "code": "    def get_wx_font(self, s, prop):\n        \"\"\"Return a wx font.  Cache font instances for efficiency.\"\"\"\n        _log.debug(\"%s - get_wx_font()\", type(self))\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is not None:\n            return font\n        size = self.points_to_pixels(prop.get_size_in_points())\n        # Font colour is determined by the active wx.Pen\n        # TODO: It may be wise to cache font information\n        self.fontd[key] = font = wx.Font(  # Cache the font and gc.\n            pointSize=int(size + 0.5),\n            family=self.fontnames.get(prop.get_name(), wx.ROMAN),\n            style=self.fontangles[prop.get_style()],\n            weight=self.fontweights[prop.get_weight()])\n        return font"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle",
      "name": "handle_clip_rectangle",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.handle_clip_rectangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.handle_clip_rectangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.handle_clip_rectangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_clip_rectangle(self, gc):\n        new_bounds = gc.get_clip_rectangle()\n        if new_bounds is not None:\n            new_bounds = new_bounds.bounds\n        gfx_ctx = gc.gfx_ctx\n        if gfx_ctx._lastcliprect != new_bounds:\n            gfx_ctx._lastcliprect = new_bounds\n            if new_bounds is None:\n                gfx_ctx.ResetClip()\n            else:\n                gfx_ctx.Clip(new_bounds[0],\n                             self.height - new_bounds[1] - new_bounds[3],\n                             new_bounds[2], new_bounds[3])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        _log.debug(\"%s - new_gc()\", type(self))\n        self.gc = GraphicsContextWx(self.bitmap, self)\n        self.gc.select()\n        self.gc.unselect()\n        return self.gc"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/offset_text_height",
      "name": "offset_text_height",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.offset_text_height",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/offset_text_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.offset_text_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    def offset_text_height(self):\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2Wx.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        NavigationToolbar2Wx.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2Wx.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        NavigationToolbar2Wx.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using wx.Timer events.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._timer = wx.Timer()\n        self._timer.Notify = self._on_timer\n        super().__init__(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        if not self.canvas._isDrawn:\n            self.canvas.draw()\n        if not self.canvas.bitmap.IsOk() or not wx.TheClipboard.Open():\n            return\n        try:\n            wx.TheClipboard.SetData(wx.BitmapDataObject(self.canvas.bitmap))\n        finally:\n            wx.TheClipboard.Close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.style",
          "default_value": "wx.TB_BOTTOM",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager, parent=None, style=wx.TB_BOTTOM):\n        if parent is None:\n            parent = toolmanager.canvas.GetParent()\n        ToolContainerBase.__init__(self, toolmanager)\n        wx.ToolBar.__init__(self, parent, -1, style=style)\n        self._space = self.AddStretchableSpace()\n        self._label_text = wx.StaticText(self, style=wx.ALIGN_RIGHT)\n        self.AddControl(self._label_text)\n        self._toolitems = {}\n        self._groups = {}  # Mapping of groups to the separator after them."
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        # Find or create the separator that follows this group.\n        if group not in self._groups:\n            self._groups[group] = self.InsertSeparator(\n                self._get_tool_pos(self._space))\n        sep = self._groups[group]\n        # List all separators.\n        seps = [t for t in map(self.GetToolByPos, range(self.ToolsCount))\n                if t.IsSeparator() and not t.IsStretchableSpace()]\n        # Find where to insert the tool.\n        if position >= 0:\n            # Find the start of the group by looking for the separator\n            # preceding this one; then move forward from it.\n            start = (0 if sep == seps[0]\n                     else self._get_tool_pos(seps[seps.index(sep) - 1]) + 1)\n        else:\n            # Move backwards from this separator.\n            start = self._get_tool_pos(sep) + 1\n        idx = start + position\n        if image_file:\n            bmp = NavigationToolbar2Wx._icon(image_file)\n            kind = wx.ITEM_NORMAL if not toggle else wx.ITEM_CHECK\n            tool = self.InsertTool(idx, -1, name, bmp, wx.NullBitmap, kind,\n                                   description or \"\")\n        else:\n            size = (self.GetTextExtent(name)[0] + 10, -1)\n            if toggle:\n                control = wx.ToggleButton(self, -1, name, size=size)\n            else:\n                control = wx.Button(self, -1, name, size=size)\n            tool = self.InsertControl(idx, control, label=name)\n        self.Realize()\n\n        def handler(event):\n            self.trigger_tool(name)\n\n        if image_file:\n            self.Bind(wx.EVT_TOOL, handler, tool)\n        else:\n            control.Bind(wx.EVT_LEFT_DOWN, handler)\n\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tool, handler))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        for tool, handler in self._toolitems[name]:\n            self.DeleteTool(tool.Id)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self._label_text.SetLabel(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for tool, handler in self._toolitems[name]:\n            if not tool.IsControl():\n                self.ToggleTool(tool.Id, toggled)\n            else:\n                tool.GetControl().SetValue(toggled)\n        self.Refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/error_msg_wx",
      "name": "error_msg_wx",
      "qname": "lib.matplotlib.backends.backend_wx.error_msg_wx",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/error_msg_wx/msg",
          "name": "msg",
          "qname": "lib.matplotlib.backends.backend_wx.error_msg_wx.msg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/error_msg_wx/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_wx.error_msg_wx.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Signal an error condition with a popup error dialog.",
      "docstring": "Signal an error condition with a popup error dialog.",
      "code": "@_api.deprecated(\"3.6\")\ndef error_msg_wx(msg, parent=None):\n    \"\"\"Signal an error condition with a popup error dialog.\"\"\"\n    dialog = wx.MessageDialog(parent=parent,\n                              message=msg,\n                              caption='Matplotlib backend_wx error',\n                              style=wx.OK | wx.CENTRE)\n    dialog.ShowModal()\n    dialog.Destroy()\n    return None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # docstring inherited\n        bitmap = _rgba_to_wx_bitmap(self.get_renderer().buffer_rgba())\n        if bbox is None:\n            self.bitmap = bitmap\n        else:\n            srcDC = wx.MemoryDC(bitmap)\n            destDC = wx.MemoryDC(self.bitmap)\n            x = int(bbox.x0)\n            y = int(self.bitmap.GetHeight() - bbox.y1)\n            destDC.Blit(x, y, int(bbox.width), int(bbox.height), srcDC, x, y)\n            destDC.SelectObject(wx.NullBitmap)\n            srcDC.SelectObject(wx.NullBitmap)\n        self.gui_repaint()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw/drawDC",
          "name": "drawDC",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.draw.drawDC",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure using agg.",
      "docstring": "Render the figure using agg.",
      "code": "    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using agg.\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n        self.bitmap = _rgba_to_wx_bitmap(self.get_renderer().buffer_rgba())\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg.get_canvas",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas(self, fig):\n        return FigureCanvasWxAgg(self, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw/drawDC",
          "name": "drawDC",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.draw.drawDC",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self, drawDC=None):\n        size = self.figure.bbox.size.astype(int)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, *size)\n        self._renderer.set_context(cairo.Context(surface))\n        self._renderer.dpi = self.figure.dpi\n        self.figure.draw(self._renderer)\n        self.bitmap = wxcairo.BitmapFromImageSurface(surface)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo.get_canvas",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas(self, fig):\n        return FigureCanvasWxCairo(self, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.qt_editor.figureoptions/figure_edit",
      "name": "figure_edit",
      "qname": "lib.matplotlib.backends.qt_editor.figureoptions.figure_edit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.qt_editor.figureoptions/figure_edit/axes",
          "name": "axes",
          "qname": "lib.matplotlib.backends.qt_editor.figureoptions.figure_edit.axes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.qt_editor.figureoptions/figure_edit/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.qt_editor.figureoptions.figure_edit.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Edit matplotlib figure options",
      "docstring": "Edit matplotlib figure options",
      "code": "def figure_edit(axes, parent=None):\n    \"\"\"Edit matplotlib figure options\"\"\"\n    sep = (None, None)  # separator\n\n    # Get / General\n    def convert_limits(lim, converter):\n        \"\"\"Convert axis limits for correct input editors.\"\"\"\n        if isinstance(converter, DateConverter):\n            return map(num2date, lim)\n        # Cast to builtin floats as they have nicer reprs.\n        return map(float, lim)\n\n    xconverter = axes.xaxis.converter\n    xmin, xmax = convert_limits(axes.get_xlim(), xconverter)\n    yconverter = axes.yaxis.converter\n    ymin, ymax = convert_limits(axes.get_ylim(), yconverter)\n    general = [('Title', axes.get_title()),\n               sep,\n               (None, \"<b>X-Axis</b>\"),\n               ('Left', xmin), ('Right', xmax),\n               ('Label', axes.get_xlabel()),\n               ('Scale', [axes.get_xscale(),\n                          'linear', 'log', 'symlog', 'logit']),\n               sep,\n               (None, \"<b>Y-Axis</b>\"),\n               ('Bottom', ymin), ('Top', ymax),\n               ('Label', axes.get_ylabel()),\n               ('Scale', [axes.get_yscale(),\n                          'linear', 'log', 'symlog', 'logit']),\n               sep,\n               ('(Re-)Generate automatic legend', False),\n               ]\n\n    # Save the unit data\n    xunits = axes.xaxis.get_units()\n    yunits = axes.yaxis.get_units()\n\n    # Get / Curves\n    labeled_lines = []\n    for line in axes.get_lines():\n        label = line.get_label()\n        if label == '_nolegend_':\n            continue\n        labeled_lines.append((label, line))\n    curves = []\n\n    def prepare_data(d, init):\n        \"\"\"\n        Prepare entry for FormLayout.\n\n        *d* is a mapping of shorthands to style names (a single style may\n        have multiple shorthands, in particular the shorthands `None`,\n        `\"None\"`, `\"none\"` and `\"\"` are synonyms); *init* is one shorthand\n        of the initial style.\n\n        This function returns an list suitable for initializing a\n        FormLayout combobox, namely `[initial_name, (shorthand,\n        style_name), (shorthand, style_name), ...]`.\n        \"\"\"\n        if init not in d:\n            d = {**d, init: str(init)}\n        # Drop duplicate shorthands from dict (by overwriting them during\n        # the dict comprehension).\n        name2short = {name: short for short, name in d.items()}\n        # Convert back to {shorthand: name}.\n        short2name = {short: name for name, short in name2short.items()}\n        # Find the kept shorthand for the style specified by init.\n        canonical_init = name2short[d[init]]\n        # Sort by representation and prepend the initial value.\n        return ([canonical_init] +\n                sorted(short2name.items(),\n                       key=lambda short_and_name: short_and_name[1]))\n\n    for label, line in labeled_lines:\n        color = mcolors.to_hex(\n            mcolors.to_rgba(line.get_color(), line.get_alpha()),\n            keep_alpha=True)\n        ec = mcolors.to_hex(\n            mcolors.to_rgba(line.get_markeredgecolor(), line.get_alpha()),\n            keep_alpha=True)\n        fc = mcolors.to_hex(\n            mcolors.to_rgba(line.get_markerfacecolor(), line.get_alpha()),\n            keep_alpha=True)\n        curvedata = [\n            ('Label', label),\n            sep,\n            (None, '<b>Line</b>'),\n            ('Line style', prepare_data(LINESTYLES, line.get_linestyle())),\n            ('Draw style', prepare_data(DRAWSTYLES, line.get_drawstyle())),\n            ('Width', line.get_linewidth()),\n            ('Color (RGBA)', color),\n            sep,\n            (None, '<b>Marker</b>'),\n            ('Style', prepare_data(MARKERS, line.get_marker())),\n            ('Size', line.get_markersize()),\n            ('Face color (RGBA)', fc),\n            ('Edge color (RGBA)', ec)]\n        curves.append([curvedata, label, \"\"])\n    # Is there a curve displayed?\n    has_curve = bool(curves)\n\n    # Get ScalarMappables.\n    labeled_mappables = []\n    for mappable in [*axes.images, *axes.collections]:\n        label = mappable.get_label()\n        if label == '_nolegend_' or mappable.get_array() is None:\n            continue\n        labeled_mappables.append((label, mappable))\n    mappables = []\n    cmaps = [(cmap, name) for name, cmap in sorted(cm._colormaps.items())]\n    for label, mappable in labeled_mappables:\n        cmap = mappable.get_cmap()\n        if cmap not in cm._colormaps.values():\n            cmaps = [(cmap, cmap.name), *cmaps]\n        low, high = mappable.get_clim()\n        mappabledata = [\n            ('Label', label),\n            ('Colormap', [cmap.name] + cmaps),\n            ('Min. value', low),\n            ('Max. value', high),\n        ]\n        if hasattr(mappable, \"get_interpolation\"):  # Images.\n            interpolations = [\n                (name, name) for name in sorted(mimage.interpolations_names)]\n            mappabledata.append((\n                'Interpolation',\n                [mappable.get_interpolation(), *interpolations]))\n        mappables.append([mappabledata, label, \"\"])\n    # Is there a scalarmappable displayed?\n    has_sm = bool(mappables)\n\n    datalist = [(general, \"Axes\", \"\")]\n    if curves:\n        datalist.append((curves, \"Curves\", \"\"))\n    if mappables:\n        datalist.append((mappables, \"Images, etc.\", \"\"))\n\n    def apply_callback(data):\n        \"\"\"A callback to apply changes.\"\"\"\n        orig_xlim = axes.get_xlim()\n        orig_ylim = axes.get_ylim()\n\n        general = data.pop(0)\n        curves = data.pop(0) if has_curve else []\n        mappables = data.pop(0) if has_sm else []\n        if data:\n            raise ValueError(\"Unexpected field\")\n\n        # Set / General\n        (title, xmin, xmax, xlabel, xscale, ymin, ymax, ylabel, yscale,\n         generate_legend) = general\n\n        if axes.get_xscale() != xscale:\n            axes.set_xscale(xscale)\n        if axes.get_yscale() != yscale:\n            axes.set_yscale(yscale)\n\n        axes.set_title(title)\n        axes.set_xlim(xmin, xmax)\n        axes.set_xlabel(xlabel)\n        axes.set_ylim(ymin, ymax)\n        axes.set_ylabel(ylabel)\n\n        # Restore the unit data\n        axes.xaxis.converter = xconverter\n        axes.yaxis.converter = yconverter\n        axes.xaxis.set_units(xunits)\n        axes.yaxis.set_units(yunits)\n        axes.xaxis._update_axisinfo()\n        axes.yaxis._update_axisinfo()\n\n        # Set / Curves\n        for index, curve in enumerate(curves):\n            line = labeled_lines[index][1]\n            (label, linestyle, drawstyle, linewidth, color, marker, markersize,\n             markerfacecolor, markeredgecolor) = curve\n            line.set_label(label)\n            line.set_linestyle(linestyle)\n            line.set_drawstyle(drawstyle)\n            line.set_linewidth(linewidth)\n            rgba = mcolors.to_rgba(color)\n            line.set_alpha(None)\n            line.set_color(rgba)\n            if marker != 'none':\n                line.set_marker(marker)\n                line.set_markersize(markersize)\n                line.set_markerfacecolor(markerfacecolor)\n                line.set_markeredgecolor(markeredgecolor)\n\n        # Set ScalarMappables.\n        for index, mappable_settings in enumerate(mappables):\n            mappable = labeled_mappables[index][1]\n            if len(mappable_settings) == 5:\n                label, cmap, low, high, interpolation = mappable_settings\n                mappable.set_interpolation(interpolation)\n            elif len(mappable_settings) == 4:\n                label, cmap, low, high = mappable_settings\n            mappable.set_label(label)\n            mappable.set_cmap(cm.get_cmap(cmap))\n            mappable.set_clim(*sorted([low, high]))\n\n        # re-generate legend, if checkbox is checked\n        if generate_legend:\n            draggable = None\n            ncols = 1\n            if axes.legend_ is not None:\n                old_legend = axes.get_legend()\n                draggable = old_legend._draggable is not None\n                ncols = old_legend._ncols\n            new_legend = axes.legend(ncols=ncols)\n            if new_legend:\n                new_legend.set_draggable(draggable)\n\n        # Redraw\n        figure = axes.get_figure()\n        figure.canvas.draw()\n        if not (axes.get_xlim() == orig_xlim and axes.get_ylim() == orig_ylim):\n            figure.canvas.toolbar.push_current()\n\n    _formlayout.fedit(\n        datalist, title=\"Figure options\", parent=parent,\n        icon=QtGui.QIcon(\n            str(cbook._get_data_path('images', 'qt4_editor_options.svg'))),\n        apply=apply_callback)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__getstate__",
      "name": "__getstate__",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.__getstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__getstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__getstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getstate__(self):\n        return {\n            **vars(self),\n            # In general, callbacks may not be pickled, so we just drop them,\n            # unless directed otherwise by self._pickled_cids.\n            \"callbacks\": {s: {cid: proxy() for cid, proxy in d.items()\n                              if cid in self._pickled_cids}\n                          for s, d in self.callbacks.items()},\n            # It is simpler to reconstruct this from callbacks in __setstate__.\n            \"_func_cid_map\": None,\n        }"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__/exception_handler",
          "name": "exception_handler",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__.exception_handler",
          "default_value": "_exception_printer",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "If not None, *exception_handler* must be a function that takes an\n`Exception` as single parameter.  It gets called with any `Exception`\nraised by the callbacks during `CallbackRegistry.process`, and may\neither re-raise the exception or handle it in another manner.\n\nThe default handler prints the exception (with `traceback.print_exc`) if\nan interactive event loop is running; it re-raises the exception if no\ninteractive event loop is running."
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__/signals",
          "name": "signals",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__.signals",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "list",
            "default_value": "",
            "description": "If not None, *signals* is a list of signals that this registry handles:\nattempting to `process` or to `connect` to a signal not in the list\nthrows a `ValueError`.  The default, None, does not restrict the\nhandled signals."
          },
          "type": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Handle registering, processing, blocking, and disconnecting\nfor a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...    print('eat', x)\n    >>> def ondrink(x):\n    ...    print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456)   # nothing will be called\n\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)        # nothing will be called\n\n    >>> with callbacks.blocked(signal='drink'):\n    ...     callbacks.process('drink', 123)  # nothing will be called\n    >>> callbacks.process('drink', 123)\n    drink 123\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.",
      "docstring": "",
      "code": "    def __init__(self, exception_handler=_exception_printer, *, signals=None):\n        self._signals = None if signals is None else list(signals)  # Copy it.\n        self.exception_handler = exception_handler\n        self.callbacks = {}\n        self._cid_gen = itertools.count()\n        self._func_cid_map = {}\n        # A hidden variable that marks cids that need to be pickled.\n        self._pickled_cids = set()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__setstate__",
      "name": "__setstate__",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.__setstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__setstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__setstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__setstate__/state",
          "name": "state",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__setstate__.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __setstate__(self, state):\n        vars(self).update(state)\n        self.callbacks = {\n            s: {cid: _weak_or_strong_ref(func, self._remove_proxy)\n                for cid, func in d.items()}\n            for s, d in self.callbacks.items()}\n        self._func_cid_map = {\n            s: {proxy: cid for cid, proxy in d.items()}\n            for s, d in self.callbacks.items()}"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/blocked",
      "name": "blocked",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.blocked",
      "decorators": [
        "contextlib.contextmanager"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/blocked/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.blocked.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/blocked/signal",
          "name": "signal",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.blocked.signal",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The callback signal to block. The default is to block all signals."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Block callback signals from being processed.\n\nA context manager to temporarily block/disable callback signals\nfrom being processed by the registered listeners.",
      "docstring": "Block callback signals from being processed.\n\nA context manager to temporarily block/disable callback signals\nfrom being processed by the registered listeners.\n\nParameters\n----------\nsignal : str, optional\n    The callback signal to block. The default is to block all signals.",
      "code": "    @contextlib.contextmanager\n    def blocked(self, *, signal=None):\n        \"\"\"\n        Block callback signals from being processed.\n\n        A context manager to temporarily block/disable callback signals\n        from being processed by the registered listeners.\n\n        Parameters\n        ----------\n        signal : str, optional\n            The callback signal to block. The default is to block all signals.\n        \"\"\"\n        orig = self.callbacks\n        try:\n            if signal is None:\n                # Empty out the callbacks\n                self.callbacks = {}\n            else:\n                # Only remove the specific signal\n                self.callbacks = {k: orig[k] for k in orig if k != signal}\n            yield\n        finally:\n            self.callbacks = orig"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect",
      "name": "connect",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.connect",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.connect.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect/signal",
          "name": "signal",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.connect.signal",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect/func",
          "name": "func",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.connect.func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Register *func* to be called when signal *signal* is generated.",
      "docstring": "Register *func* to be called when signal *signal* is generated.",
      "code": "    def connect(self, signal, func):\n        \"\"\"Register *func* to be called when signal *signal* is generated.\"\"\"\n        if signal == \"units finalize\":\n            _api.warn_deprecated(\n                \"3.5\", name=signal, obj_type=\"signal\", alternative=\"units\")\n        if self._signals is not None:\n            _api.check_in_list(self._signals, signal=signal)\n        self._func_cid_map.setdefault(signal, {})\n        proxy = _weak_or_strong_ref(func, self._remove_proxy)\n        if proxy in self._func_cid_map[signal]:\n            return self._func_cid_map[signal][proxy]\n        cid = next(self._cid_gen)\n        self._func_cid_map[signal][proxy] = cid\n        self.callbacks.setdefault(signal, {})\n        self.callbacks[signal][cid] = proxy\n        return cid"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect",
      "name": "disconnect",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.disconnect",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.disconnect.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect/cid",
          "name": "cid",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.disconnect.cid",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Disconnect the callback registered with callback id *cid*.\n\nNo error is raised if such a callback does not exist.",
      "docstring": "Disconnect the callback registered with callback id *cid*.\n\nNo error is raised if such a callback does not exist.",
      "code": "    def disconnect(self, cid):\n        \"\"\"\n        Disconnect the callback registered with callback id *cid*.\n\n        No error is raised if such a callback does not exist.\n        \"\"\"\n        self._pickled_cids.discard(cid)\n        # Clean up callbacks\n        for signal, cid_to_proxy in list(self.callbacks.items()):\n            proxy = cid_to_proxy.pop(cid, None)\n            if proxy is not None:\n                break\n        else:\n            # Not found\n            return\n\n        proxy_to_cid = self._func_cid_map[signal]\n        for current_proxy, current_cid in list(proxy_to_cid.items()):\n            if current_cid == cid:\n                assert proxy is current_proxy\n                del proxy_to_cid[current_proxy]\n        # Clean up empty dicts\n        if len(self.callbacks[signal]) == 0:\n            del self.callbacks[signal]\n            del self._func_cid_map[signal]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process",
      "name": "process",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.process",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Process signal *s*.\n\nAll of the functions registered to receive callbacks on *s* will be\ncalled with ``*args`` and ``**kwargs``.",
      "docstring": "Process signal *s*.\n\nAll of the functions registered to receive callbacks on *s* will be\ncalled with ``*args`` and ``**kwargs``.",
      "code": "    def process(self, s, *args, **kwargs):\n        \"\"\"\n        Process signal *s*.\n\n        All of the functions registered to receive callbacks on *s* will be\n        called with ``*args`` and ``**kwargs``.\n        \"\"\"\n        if self._signals is not None:\n            _api.check_in_list(self._signals, signal=s)\n        for cid, ref in list(self.callbacks.get(s, {}).items()):\n            func = ref()\n            if func is not None:\n                try:\n                    func(*args, **kwargs)\n                # this does not capture KeyboardInterrupt, SystemExit,\n                # and GeneratorExit\n                except Exception as exc:\n                    if self.exception_handler is not None:\n                        self.exception_handler(exc)\n                    else:\n                        raise"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/__contains__",
      "name": "__contains__",
      "qname": "lib.matplotlib.cbook.Grouper.__contains__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__contains__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.__contains__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__contains__/item",
          "name": "item",
          "qname": "lib.matplotlib.cbook.Grouper.__contains__.item",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.Grouper.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__init__/init",
          "name": "init",
          "qname": "lib.matplotlib.cbook.Grouper.__init__.init",
          "default_value": "()",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.",
      "docstring": "",
      "code": "    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/__iter__",
      "name": "__iter__",
      "qname": "lib.matplotlib.cbook.Grouper.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__iter__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Iterate over each of the disjoint sets as a list.\n\nThe iterator is invalid if interleaved with calls to join().",
      "docstring": "Iterate over each of the disjoint sets as a list.\n\nThe iterator is invalid if interleaved with calls to join().",
      "code": "    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/clean",
      "name": "clean",
      "qname": "lib.matplotlib.cbook.Grouper.clean",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/clean/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.clean.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Clean dead weak references from the dictionary.",
      "docstring": "Clean dead weak references from the dictionary.",
      "code": "    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings",
      "name": "get_siblings",
      "qname": "lib.matplotlib.cbook.Grouper.get_siblings",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.get_siblings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.get_siblings.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return all of the items joined with *a*, including itself.",
      "docstring": "Return all of the items joined with *a*, including itself.",
      "code": "    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/join",
      "name": "join",
      "qname": "lib.matplotlib.cbook.Grouper.join",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/join/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.join.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/join/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.join.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/join/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.Grouper.join.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Join given arguments into the same set.  Accepts one or more arguments.",
      "docstring": "Join given arguments into the same set.  Accepts one or more arguments.",
      "code": "    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined",
      "name": "joined",
      "qname": "lib.matplotlib.cbook.Grouper.joined",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.joined.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.joined.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined/b",
          "name": "b",
          "qname": "lib.matplotlib.cbook.Grouper.joined.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether *a* and *b* are members of the same set.",
      "docstring": "Return whether *a* and *b* are members of the same set.",
      "code": "    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/remove",
      "name": "remove",
      "qname": "lib.matplotlib.cbook.Grouper.remove",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/remove/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.remove.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/remove/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.remove.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/GrouperView/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.GrouperView.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/GrouperView/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.GrouperView.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/GrouperView/__init__/grouper",
          "name": "grouper",
          "qname": "lib.matplotlib.cbook.GrouperView.__init__.grouper",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Immutable view over a `.Grouper`.",
      "docstring": "",
      "code": "    def __init__(self, grouper):\n        self._grouper = grouper"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.cbook.Stack.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the current element, or None.",
      "docstring": "Return the current element, or None.",
      "code": "    def __call__(self):\n        \"\"\"Return the current element, or None.\"\"\"\n        if not self._elements:\n            return self._default\n        else:\n            return self._elements[self._pos]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__getitem__",
      "name": "__getitem__",
      "qname": "lib.matplotlib.cbook.Stack.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__getitem__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__getitem__/ind",
          "name": "ind",
          "qname": "lib.matplotlib.cbook.Stack.__getitem__.ind",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getitem__(self, ind):\n        return self._elements[ind]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.Stack.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__init__/default",
          "name": "default",
          "qname": "lib.matplotlib.cbook.Stack.__init__.default",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "docstring": "",
      "code": "    def __init__(self, default=None):\n        self.clear()\n        self._default = default"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__len__",
      "name": "__len__",
      "qname": "lib.matplotlib.cbook.Stack.__len__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__len__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__len__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __len__(self):\n        return len(self._elements)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/back",
      "name": "back",
      "qname": "lib.matplotlib.cbook.Stack.back",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/back/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.back.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move the position back and return the current element.",
      "docstring": "Move the position back and return the current element.",
      "code": "    def back(self):\n        \"\"\"Move the position back and return the current element.\"\"\"\n        if self._pos > 0:\n            self._pos -= 1\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/bubble",
      "name": "bubble",
      "qname": "lib.matplotlib.cbook.Stack.bubble",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/bubble/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.bubble.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/bubble/o",
          "name": "o",
          "qname": "lib.matplotlib.cbook.Stack.bubble.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Raise all references of *o* to the top of the stack, and return it.",
      "docstring": "Raise all references of *o* to the top of the stack, and return it.\n\nRaises\n------\nValueError\n    If *o* is not in the stack.",
      "code": "    def bubble(self, o):\n        \"\"\"\n        Raise all references of *o* to the top of the stack, and return it.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        top_elements = []\n        for elem in old_elements:\n            if elem == o:\n                top_elements.append(elem)\n            else:\n                self.push(elem)\n        for _ in top_elements:\n            self.push(o)\n        return o"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/clear",
      "name": "clear",
      "qname": "lib.matplotlib.cbook.Stack.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Empty the stack.",
      "docstring": "Empty the stack.",
      "code": "    def clear(self):\n        \"\"\"Empty the stack.\"\"\"\n        self._pos = -1\n        self._elements = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/empty",
      "name": "empty",
      "qname": "lib.matplotlib.cbook.Stack.empty",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/empty/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.empty.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the stack is empty.",
      "docstring": "Return whether the stack is empty.",
      "code": "    def empty(self):\n        \"\"\"Return whether the stack is empty.\"\"\"\n        return len(self._elements) == 0"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/forward",
      "name": "forward",
      "qname": "lib.matplotlib.cbook.Stack.forward",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/forward/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.forward.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move the position forward and return the current element.",
      "docstring": "Move the position forward and return the current element.",
      "code": "    def forward(self):\n        \"\"\"Move the position forward and return the current element.\"\"\"\n        self._pos = min(self._pos + 1, len(self._elements) - 1)\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/home",
      "name": "home",
      "qname": "lib.matplotlib.cbook.Stack.home",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/home/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.home.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Push the first element onto the top of the stack.\n\nThe first element is returned.",
      "docstring": "Push the first element onto the top of the stack.\n\nThe first element is returned.",
      "code": "    def home(self):\n        \"\"\"\n        Push the first element onto the top of the stack.\n\n        The first element is returned.\n        \"\"\"\n        if not self._elements:\n            return\n        self.push(self._elements[0])\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/push",
      "name": "push",
      "qname": "lib.matplotlib.cbook.Stack.push",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/push/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.push.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/push/o",
          "name": "o",
          "qname": "lib.matplotlib.cbook.Stack.push.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Push *o* to the stack at current position.  Discard all later elements.\n\n*o* is returned.",
      "docstring": "Push *o* to the stack at current position.  Discard all later elements.\n\n*o* is returned.",
      "code": "    def push(self, o):\n        \"\"\"\n        Push *o* to the stack at current position.  Discard all later elements.\n\n        *o* is returned.\n        \"\"\"\n        self._elements = self._elements[:self._pos + 1] + [o]\n        self._pos = len(self._elements) - 1\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/remove",
      "name": "remove",
      "qname": "lib.matplotlib.cbook.Stack.remove",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/remove/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.remove.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/remove/o",
          "name": "o",
          "qname": "lib.matplotlib.cbook.Stack.remove.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Remove *o* from the stack.",
      "docstring": "Remove *o* from the stack.\n\nRaises\n------\nValueError\n    If *o* is not in the stack.",
      "code": "    def remove(self, o):\n        \"\"\"\n        Remove *o* from the stack.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        for elem in old_elements:\n            if elem != o:\n                self.push(elem)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats",
      "name": "boxplot_stats",
      "qname": "lib.matplotlib.cbook.boxplot_stats",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/X",
          "name": "X",
          "qname": "lib.matplotlib.cbook.boxplot_stats.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Data that will be represented in the boxplots. Should have 2 or\nfewer dimensions."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/whis",
          "name": "whis",
          "qname": "lib.matplotlib.cbook.boxplot_stats.whis",
          "default_value": "1.5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float or (float, float)",
            "default_value": "1.5",
            "description": "The position of the whiskers.\n\nIf a float, the lower whisker is at the lowest datum above\n``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\nquartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\noriginal definition of boxplots.\n\nIf a pair of floats, they indicate the percentiles at which to draw the\nwhiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\nresults in whiskers covering the whole range of the data.\n\nIn the edge case where ``Q1 == Q3``, *whis* is automatically set to\n(0, 100) (cover the whole range of the data) if *autorange* is True.\n\nBeyond the whiskers, data are considered outliers and are plotted as\nindividual points."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "(float, float)"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/bootstrap",
          "name": "bootstrap",
          "qname": "lib.matplotlib.cbook.boxplot_stats.bootstrap",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Number of times the confidence intervals around the median\nshould be bootstrapped (percentile method)."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/labels",
          "name": "labels",
          "qname": "lib.matplotlib.cbook.boxplot_stats.labels",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Labels for each dataset. Length must be compatible with\ndimensions of *X*."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/autorange",
          "name": "autorange",
          "qname": "lib.matplotlib.cbook.boxplot_stats.autorange",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "(False)",
            "description": "When `True` and the data are distributed such that the 25th and 75th\npercentiles are equal, ``whis`` is set to (0, 100) such that the\nwhisker ends are at the minimum and maximum of the data."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of dictionaries of statistics used to draw a series of box\nand whisker plots using `~.Axes.bxp`.",
      "docstring": "Return a list of dictionaries of statistics used to draw a series of box\nand whisker plots using `~.Axes.bxp`.\n\nParameters\n----------\nX : array-like\n    Data that will be represented in the boxplots. Should have 2 or\n    fewer dimensions.\n\nwhis : float or (float, float), default: 1.5\n    The position of the whiskers.\n\n    If a float, the lower whisker is at the lowest datum above\n    ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n    ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\n    quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\n    original definition of boxplots.\n\n    If a pair of floats, they indicate the percentiles at which to draw the\n    whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\n    results in whiskers covering the whole range of the data.\n\n    In the edge case where ``Q1 == Q3``, *whis* is automatically set to\n    (0, 100) (cover the whole range of the data) if *autorange* is True.\n\n    Beyond the whiskers, data are considered outliers and are plotted as\n    individual points.\n\nbootstrap : int, optional\n    Number of times the confidence intervals around the median\n    should be bootstrapped (percentile method).\n\nlabels : array-like, optional\n    Labels for each dataset. Length must be compatible with\n    dimensions of *X*.\n\nautorange : bool, optional (False)\n    When `True` and the data are distributed such that the 25th and 75th\n    percentiles are equal, ``whis`` is set to (0, 100) such that the\n    whisker ends are at the minimum and maximum of the data.\n\nReturns\n-------\nlist of dict\n    A list of dictionaries containing the results for each column\n    of data. Keys of each dictionary are the following:\n\n    ========   ===================================\n    Key        Value Description\n    ========   ===================================\n    label      tick label for the boxplot\n    mean       arithmetic mean value\n    med        50th percentile\n    q1         first quartile (25th percentile)\n    q3         third quartile (75th percentile)\n    iqr        interquartile range\n    cilo       lower notch around the median\n    cihi       upper notch around the median\n    whislo     end of the lower whisker\n    whishi     end of the upper whisker\n    fliers     outliers\n    ========   ===================================\n\nNotes\n-----\nNon-bootstrapping approach to confidence interval uses Gaussian-based\nasymptotic approximation:\n\n.. math::\n\n    \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}\n\nGeneral approach from:\nMcGill, R., Tukey, J.W., and Larsen, W.A. (1978) \"Variations of\nBoxplots\", The American Statistician, 32:12-16.",
      "code": "def boxplot_stats(X, whis=1.5, bootstrap=None, labels=None,\n                  autorange=False):\n    r\"\"\"\n    Return a list of dictionaries of statistics used to draw a series of box\n    and whisker plots using `~.Axes.bxp`.\n\n    Parameters\n    ----------\n    X : array-like\n        Data that will be represented in the boxplots. Should have 2 or\n        fewer dimensions.\n\n    whis : float or (float, float), default: 1.5\n        The position of the whiskers.\n\n        If a float, the lower whisker is at the lowest datum above\n        ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n        ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\n        quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\n        original definition of boxplots.\n\n        If a pair of floats, they indicate the percentiles at which to draw the\n        whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\n        results in whiskers covering the whole range of the data.\n\n        In the edge case where ``Q1 == Q3``, *whis* is automatically set to\n        (0, 100) (cover the whole range of the data) if *autorange* is True.\n\n        Beyond the whiskers, data are considered outliers and are plotted as\n        individual points.\n\n    bootstrap : int, optional\n        Number of times the confidence intervals around the median\n        should be bootstrapped (percentile method).\n\n    labels : array-like, optional\n        Labels for each dataset. Length must be compatible with\n        dimensions of *X*.\n\n    autorange : bool, optional (False)\n        When `True` and the data are distributed such that the 25th and 75th\n        percentiles are equal, ``whis`` is set to (0, 100) such that the\n        whisker ends are at the minimum and maximum of the data.\n\n    Returns\n    -------\n    list of dict\n        A list of dictionaries containing the results for each column\n        of data. Keys of each dictionary are the following:\n\n        ========   ===================================\n        Key        Value Description\n        ========   ===================================\n        label      tick label for the boxplot\n        mean       arithmetic mean value\n        med        50th percentile\n        q1         first quartile (25th percentile)\n        q3         third quartile (75th percentile)\n        iqr        interquartile range\n        cilo       lower notch around the median\n        cihi       upper notch around the median\n        whislo     end of the lower whisker\n        whishi     end of the upper whisker\n        fliers     outliers\n        ========   ===================================\n\n    Notes\n    -----\n    Non-bootstrapping approach to confidence interval uses Gaussian-based\n    asymptotic approximation:\n\n    .. math::\n\n        \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}\n\n    General approach from:\n    McGill, R., Tukey, J.W., and Larsen, W.A. (1978) \"Variations of\n    Boxplots\", The American Statistician, 32:12-16.\n    \"\"\"\n\n    def _bootstrap_median(data, N=5000):\n        # determine 95% confidence intervals of the median\n        M = len(data)\n        percentiles = [2.5, 97.5]\n\n        bs_index = np.random.randint(M, size=(N, M))\n        bsData = data[bs_index]\n        estimate = np.median(bsData, axis=1, overwrite_input=True)\n\n        CI = np.percentile(estimate, percentiles)\n        return CI\n\n    def _compute_conf_interval(data, med, iqr, bootstrap):\n        if bootstrap is not None:\n            # Do a bootstrap estimate of notch locations.\n            # get conf. intervals around median\n            CI = _bootstrap_median(data, N=bootstrap)\n            notch_min = CI[0]\n            notch_max = CI[1]\n        else:\n\n            N = len(data)\n            notch_min = med - 1.57 * iqr / np.sqrt(N)\n            notch_max = med + 1.57 * iqr / np.sqrt(N)\n\n        return notch_min, notch_max\n\n    # output is a list of dicts\n    bxpstats = []\n\n    # convert X to a list of lists\n    X = _reshape_2D(X, \"X\")\n\n    ncols = len(X)\n    if labels is None:\n        labels = itertools.repeat(None)\n    elif len(labels) != ncols:\n        raise ValueError(\"Dimensions of labels and X must be compatible\")\n\n    input_whis = whis\n    for ii, (x, label) in enumerate(zip(X, labels)):\n\n        # empty dict\n        stats = {}\n        if label is not None:\n            stats['label'] = label\n\n        # restore whis to the input values in case it got changed in the loop\n        whis = input_whis\n\n        # note tricksiness, append up here and then mutate below\n        bxpstats.append(stats)\n\n        # if empty, bail\n        if len(x) == 0:\n            stats['fliers'] = np.array([])\n            stats['mean'] = np.nan\n            stats['med'] = np.nan\n            stats['q1'] = np.nan\n            stats['q3'] = np.nan\n            stats['iqr'] = np.nan\n            stats['cilo'] = np.nan\n            stats['cihi'] = np.nan\n            stats['whislo'] = np.nan\n            stats['whishi'] = np.nan\n            continue\n\n        # up-convert to an array, just to be safe\n        x = np.asarray(x)\n\n        # arithmetic mean\n        stats['mean'] = np.mean(x)\n\n        # medians and quartiles\n        q1, med, q3 = np.percentile(x, [25, 50, 75])\n\n        # interquartile range\n        stats['iqr'] = q3 - q1\n        if stats['iqr'] == 0 and autorange:\n            whis = (0, 100)\n\n        # conf. interval around median\n        stats['cilo'], stats['cihi'] = _compute_conf_interval(\n            x, med, stats['iqr'], bootstrap\n        )\n\n        # lowest/highest non-outliers\n        if np.iterable(whis) and not isinstance(whis, str):\n            loval, hival = np.percentile(x, whis)\n        elif np.isreal(whis):\n            loval = q1 - whis * stats['iqr']\n            hival = q3 + whis * stats['iqr']\n        else:\n            raise ValueError('whis must be a float or list of percentiles')\n\n        # get high extreme\n        wiskhi = x[x <= hival]\n        if len(wiskhi) == 0 or np.max(wiskhi) < q3:\n            stats['whishi'] = q3\n        else:\n            stats['whishi'] = np.max(wiskhi)\n\n        # get low extreme\n        wisklo = x[x >= loval]\n        if len(wisklo) == 0 or np.min(wisklo) > q1:\n            stats['whislo'] = q1\n        else:\n            stats['whislo'] = np.min(wisklo)\n\n        # compute a single array of outliers\n        stats['fliers'] = np.concatenate([\n            x[x < stats['whislo']],\n            x[x > stats['whishi']],\n        ])\n\n        # add in the remaining stats\n        stats['q1'], stats['med'], stats['q3'] = q1, med, q3\n\n    return bxpstats"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/contiguous_regions",
      "name": "contiguous_regions",
      "qname": "lib.matplotlib.cbook.contiguous_regions",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/contiguous_regions/mask",
          "name": "mask",
          "qname": "lib.matplotlib.cbook.contiguous_regions.mask",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\nTrue and we cover all such regions.",
      "docstring": "Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\nTrue and we cover all such regions.",
      "code": "def contiguous_regions(mask):\n    \"\"\"\n    Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\n    True and we cover all such regions.\n    \"\"\"\n    mask = np.asarray(mask, dtype=bool)\n\n    if not mask.size:\n        return []\n\n    # Find the indices of region changes, and correct offset\n    idx, = np.nonzero(mask[:-1] != mask[1:])\n    idx += 1\n\n    # List operations are faster for moderately sized arrays\n    idx = idx.tolist()\n\n    # Add first and/or last index if needed\n    if mask[0]:\n        idx = [0] + idx\n    if mask[-1]:\n        idx.append(len(mask))\n\n    return list(zip(idx[::2], idx[1::2]))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/delete_masked_points",
      "name": "delete_masked_points",
      "qname": "lib.matplotlib.cbook.delete_masked_points",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/delete_masked_points/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.delete_masked_points.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Find all masked and/or non-finite points in a set of arguments,\nand return the arguments with only the unmasked points remaining.\n\nArguments can be in any of 5 categories:\n\n1) 1-D masked arrays\n2) 1-D ndarrays\n3) ndarrays with more than one dimension\n4) other non-string iterables\n5) anything else\n\nThe first argument must be in one of the first four categories;\nany argument with a length differing from that of the first\nargument (and hence anything in category 5) then will be\npassed through unchanged.\n\nMasks are obtained from all arguments of the correct length\nin categories 1, 2, and 4; a point is bad if masked in a masked\narray or if it is a nan or inf.  No attempt is made to\nextract a mask from categories 2, 3, and 4 if `numpy.isfinite`\ndoes not yield a Boolean array.\n\nAll input arguments that are not passed unchanged are returned\nas ndarrays after removing the points or rows corresponding to\nmasks in any of the arguments.\n\nA vastly simpler version of this function was originally\nwritten as a helper for Axes.scatter().",
      "docstring": "Find all masked and/or non-finite points in a set of arguments,\nand return the arguments with only the unmasked points remaining.\n\nArguments can be in any of 5 categories:\n\n1) 1-D masked arrays\n2) 1-D ndarrays\n3) ndarrays with more than one dimension\n4) other non-string iterables\n5) anything else\n\nThe first argument must be in one of the first four categories;\nany argument with a length differing from that of the first\nargument (and hence anything in category 5) then will be\npassed through unchanged.\n\nMasks are obtained from all arguments of the correct length\nin categories 1, 2, and 4; a point is bad if masked in a masked\narray or if it is a nan or inf.  No attempt is made to\nextract a mask from categories 2, 3, and 4 if `numpy.isfinite`\ndoes not yield a Boolean array.\n\nAll input arguments that are not passed unchanged are returned\nas ndarrays after removing the points or rows corresponding to\nmasks in any of the arguments.\n\nA vastly simpler version of this function was originally\nwritten as a helper for Axes.scatter().",
      "code": "def delete_masked_points(*args):\n    \"\"\"\n    Find all masked and/or non-finite points in a set of arguments,\n    and return the arguments with only the unmasked points remaining.\n\n    Arguments can be in any of 5 categories:\n\n    1) 1-D masked arrays\n    2) 1-D ndarrays\n    3) ndarrays with more than one dimension\n    4) other non-string iterables\n    5) anything else\n\n    The first argument must be in one of the first four categories;\n    any argument with a length differing from that of the first\n    argument (and hence anything in category 5) then will be\n    passed through unchanged.\n\n    Masks are obtained from all arguments of the correct length\n    in categories 1, 2, and 4; a point is bad if masked in a masked\n    array or if it is a nan or inf.  No attempt is made to\n    extract a mask from categories 2, 3, and 4 if `numpy.isfinite`\n    does not yield a Boolean array.\n\n    All input arguments that are not passed unchanged are returned\n    as ndarrays after removing the points or rows corresponding to\n    masks in any of the arguments.\n\n    A vastly simpler version of this function was originally\n    written as a helper for Axes.scatter().\n\n    \"\"\"\n    if not len(args):\n        return ()\n    if is_scalar_or_string(args[0]):\n        raise ValueError(\"First argument must be a sequence\")\n    nrecs = len(args[0])\n    margs = []\n    seqlist = [False] * len(args)\n    for i, x in enumerate(args):\n        if not isinstance(x, str) and np.iterable(x) and len(x) == nrecs:\n            seqlist[i] = True\n            if isinstance(x, np.ma.MaskedArray):\n                if x.ndim > 1:\n                    raise ValueError(\"Masked arrays must be 1-D\")\n            else:\n                x = np.asarray(x)\n        margs.append(x)\n    masks = []  # List of masks that are True where good.\n    for i, x in enumerate(margs):\n        if seqlist[i]:\n            if x.ndim > 1:\n                continue  # Don't try to get nan locations unless 1-D.\n            if isinstance(x, np.ma.MaskedArray):\n                masks.append(~np.ma.getmaskarray(x))  # invert the mask\n                xd = x.data\n            else:\n                xd = x\n            try:\n                mask = np.isfinite(xd)\n                if isinstance(mask, np.ndarray):\n                    masks.append(mask)\n            except Exception:  # Fixme: put in tuple of possible exceptions?\n                pass\n    if len(masks):\n        mask = np.logical_and.reduce(masks)\n        igood = mask.nonzero()[0]\n        if len(igood) < nrecs:\n            for i, x in enumerate(margs):\n                if seqlist[i]:\n                    margs[i] = x[igood]\n    for i, x in enumerate(margs):\n        if seqlist[i] and isinstance(x, np.ma.MaskedArray):\n            margs[i] = x.filled()\n    return margs"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/file_requires_unicode",
      "name": "file_requires_unicode",
      "qname": "lib.matplotlib.cbook.file_requires_unicode",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/file_requires_unicode/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.file_requires_unicode.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the given writable file-like object requires Unicode to be\nwritten to it.",
      "docstring": "Return whether the given writable file-like object requires Unicode to be\nwritten to it.",
      "code": "def file_requires_unicode(x):\n    \"\"\"\n    Return whether the given writable file-like object requires Unicode to be\n    written to it.\n    \"\"\"\n    try:\n        x.write(b'')\n    except TypeError:\n        return True\n    else:\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/flatten",
      "name": "flatten",
      "qname": "lib.matplotlib.cbook.flatten",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/flatten/seq",
          "name": "seq",
          "qname": "lib.matplotlib.cbook.flatten.seq",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/flatten/scalarp",
          "name": "scalarp",
          "qname": "lib.matplotlib.cbook.flatten.scalarp",
          "default_value": "is_scalar_or_string",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a generator of flattened nested containers.\n\nFor example:\n\n    >>> from matplotlib.cbook import flatten\n    >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n    >>> print(list(flatten(l)))\n    ['John', 'Hunter', 1, 23, 42, 5, 23]\n\nBy: Composite of Holger Krekel and Luther Blissett\nFrom: https://code.activestate.com/recipes/121294/\nand Recipe 1.12 in cookbook",
      "docstring": "Return a generator of flattened nested containers.\n\nFor example:\n\n    >>> from matplotlib.cbook import flatten\n    >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n    >>> print(list(flatten(l)))\n    ['John', 'Hunter', 1, 23, 42, 5, 23]\n\nBy: Composite of Holger Krekel and Luther Blissett\nFrom: https://code.activestate.com/recipes/121294/\nand Recipe 1.12 in cookbook",
      "code": "def flatten(seq, scalarp=is_scalar_or_string):\n    \"\"\"\n    Return a generator of flattened nested containers.\n\n    For example:\n\n        >>> from matplotlib.cbook import flatten\n        >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n        >>> print(list(flatten(l)))\n        ['John', 'Hunter', 1, 23, 42, 5, 23]\n\n    By: Composite of Holger Krekel and Luther Blissett\n    From: https://code.activestate.com/recipes/121294/\n    and Recipe 1.12 in cookbook\n    \"\"\"\n    for item in seq:\n        if scalarp(item) or item is None:\n            yield item\n        else:\n            yield from flatten(item, scalarp)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/get_sample_data",
      "name": "get_sample_data",
      "qname": "lib.matplotlib.cbook.get_sample_data",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_sample_data/fname",
          "name": "fname",
          "qname": "lib.matplotlib.cbook.get_sample_data.fname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_sample_data/asfileobj",
          "name": "asfileobj",
          "qname": "lib.matplotlib.cbook.get_sample_data.asfileobj",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_sample_data/np_load",
          "name": "np_load",
          "qname": "lib.matplotlib.cbook.get_sample_data.np_load",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a sample data file.  *fname* is a path relative to the\n:file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\nreturn a file object, otherwise just a file path.\n\nSample data files are stored in the 'mpl-data/sample_data' directory within\nthe Matplotlib package.\n\nIf the filename ends in .gz, the file is implicitly ungzipped.  If the\nfilename ends with .npy or .npz, *asfileobj* is True, and *np_load* is\nTrue, the file is loaded with `numpy.load`.  *np_load* currently defaults\nto False but will default to True in a future release.",
      "docstring": "Return a sample data file.  *fname* is a path relative to the\n:file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\nreturn a file object, otherwise just a file path.\n\nSample data files are stored in the 'mpl-data/sample_data' directory within\nthe Matplotlib package.\n\nIf the filename ends in .gz, the file is implicitly ungzipped.  If the\nfilename ends with .npy or .npz, *asfileobj* is True, and *np_load* is\nTrue, the file is loaded with `numpy.load`.  *np_load* currently defaults\nto False but will default to True in a future release.",
      "code": "def get_sample_data(fname, asfileobj=True, *, np_load=False):\n    \"\"\"\n    Return a sample data file.  *fname* is a path relative to the\n    :file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\n    return a file object, otherwise just a file path.\n\n    Sample data files are stored in the 'mpl-data/sample_data' directory within\n    the Matplotlib package.\n\n    If the filename ends in .gz, the file is implicitly ungzipped.  If the\n    filename ends with .npy or .npz, *asfileobj* is True, and *np_load* is\n    True, the file is loaded with `numpy.load`.  *np_load* currently defaults\n    to False but will default to True in a future release.\n    \"\"\"\n    path = _get_data_path('sample_data', fname)\n    if asfileobj:\n        suffix = path.suffix.lower()\n        if suffix == '.gz':\n            return gzip.open(path)\n        elif suffix in ['.npy', '.npz']:\n            if np_load:\n                return np.load(path)\n            else:\n                _api.warn_deprecated(\n                    \"3.3\", message=\"In a future release, get_sample_data \"\n                    \"will automatically load numpy arrays.  Set np_load to \"\n                    \"True to get the array and suppress this warning.  Set \"\n                    \"asfileobj to False to get the path to the data file and \"\n                    \"suppress this warning.\")\n                return path.open('rb')\n        elif suffix in ['.csv', '.xrc', '.txt']:\n            return path.open('r')\n        else:\n            return path.open('rb')\n    else:\n        return str(path)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/index_of",
      "name": "index_of",
      "qname": "lib.matplotlib.cbook.index_of",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/index_of/y",
          "name": "y",
          "qname": "lib.matplotlib.cbook.index_of.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float or array-like",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "array-like"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper function to create reasonable x values for the given *y*.\n\nThis is used for plotting (x, y) if x values are not explicitly given.\n\nFirst try ``y.index`` (assuming *y* is a `pandas.Series`), if that\nfails, use ``range(len(y))``.\n\nThis will be extended in the future to deal with more types of\nlabeled data.",
      "docstring": "A helper function to create reasonable x values for the given *y*.\n\nThis is used for plotting (x, y) if x values are not explicitly given.\n\nFirst try ``y.index`` (assuming *y* is a `pandas.Series`), if that\nfails, use ``range(len(y))``.\n\nThis will be extended in the future to deal with more types of\nlabeled data.\n\nParameters\n----------\ny : float or array-like\n\nReturns\n-------\nx, y : ndarray\n   The x and y values to plot.",
      "code": "def index_of(y):\n    \"\"\"\n    A helper function to create reasonable x values for the given *y*.\n\n    This is used for plotting (x, y) if x values are not explicitly given.\n\n    First try ``y.index`` (assuming *y* is a `pandas.Series`), if that\n    fails, use ``range(len(y))``.\n\n    This will be extended in the future to deal with more types of\n    labeled data.\n\n    Parameters\n    ----------\n    y : float or array-like\n\n    Returns\n    -------\n    x, y : ndarray\n       The x and y values to plot.\n    \"\"\"\n    try:\n        return y.index.to_numpy(), y.to_numpy()\n    except AttributeError:\n        pass\n    try:\n        y = _check_1d(y)\n    except (np.VisibleDeprecationWarning, ValueError):\n        # NumPy 1.19 will warn on ragged input, and we can't actually use it.\n        pass\n    else:\n        return np.arange(y.shape[0], dtype=float), y\n    raise ValueError('Input could not be cast to an at-least-1D NumPy array')"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/is_math_text",
      "name": "is_math_text",
      "qname": "lib.matplotlib.cbook.is_math_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/is_math_text/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.is_math_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the string *s* contains math expressions.\n\nThis is done by checking whether *s* contains an even number of\nnon-escaped dollar signs.",
      "docstring": "Return whether the string *s* contains math expressions.\n\nThis is done by checking whether *s* contains an even number of\nnon-escaped dollar signs.",
      "code": "def is_math_text(s):\n    \"\"\"\n    Return whether the string *s* contains math expressions.\n\n    This is done by checking whether *s* contains an even number of\n    non-escaped dollar signs.\n    \"\"\"\n    s = str(s)\n    dollar_count = s.count(r'$') - s.count(r'\\$')\n    even_dollars = (dollar_count > 0 and dollar_count % 2 == 0)\n    return even_dollars"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/is_scalar_or_string",
      "name": "is_scalar_or_string",
      "qname": "lib.matplotlib.cbook.is_scalar_or_string",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/is_scalar_or_string/val",
          "name": "val",
          "qname": "lib.matplotlib.cbook.is_scalar_or_string.val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the given object is a scalar or string like.",
      "docstring": "Return whether the given object is a scalar or string like.",
      "code": "def is_scalar_or_string(val):\n    \"\"\"Return whether the given object is a scalar or string like.\"\"\"\n    return isinstance(val, str) or not np.iterable(val)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/is_writable_file_like",
      "name": "is_writable_file_like",
      "qname": "lib.matplotlib.cbook.is_writable_file_like",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/is_writable_file_like/obj",
          "name": "obj",
          "qname": "lib.matplotlib.cbook.is_writable_file_like.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether *obj* looks like a file object with a *write* method.",
      "docstring": "Return whether *obj* looks like a file object with a *write* method.",
      "code": "def is_writable_file_like(obj):\n    \"\"\"Return whether *obj* looks like a file object with a *write* method.\"\"\"\n    return callable(getattr(obj, 'write', None))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/maxdict/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.maxdict.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.maxdict.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__init__/maxsize",
          "name": "maxsize",
          "qname": "lib.matplotlib.cbook.maxdict.__init__.maxsize",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A dictionary with a maximum size.",
      "docstring": "",
      "code": "    def __init__(self, maxsize):\n        super().__init__()\n        self.maxsize = maxsize"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__",
      "name": "__setitem__",
      "qname": "lib.matplotlib.cbook.maxdict.__setitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.maxdict.__setitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__/k",
          "name": "k",
          "qname": "lib.matplotlib.cbook.maxdict.__setitem__.k",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__/v",
          "name": "v",
          "qname": "lib.matplotlib.cbook.maxdict.__setitem__.v",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __setitem__(self, k, v):\n        super().__setitem__(k, v)\n        while len(self) >= self.maxsize:\n            del self[next(iter(self))]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs",
      "name": "normalize_kwargs",
      "qname": "lib.matplotlib.cbook.normalize_kwargs",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs/kw",
          "name": "kw",
          "qname": "lib.matplotlib.cbook.normalize_kwargs.kw",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict or None",
            "default_value": "",
            "description": "A dict of keyword arguments.  None is explicitly supported and treated\nas an empty dict, to support functions with an optional parameter of\nthe form ``props=None``."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs/alias_mapping",
          "name": "alias_mapping",
          "qname": "lib.matplotlib.cbook.normalize_kwargs.alias_mapping",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict or Artist subclass or Artist instance",
            "default_value": "",
            "description": "A mapping between a canonical name to a list of aliases, in order of\nprecedence from lowest to highest.\n\nIf the canonical value is not in the list it is assumed to have the\nhighest priority.\n\nIf an Artist subclass or instance is passed, use its properties alias\nmapping."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "Artist subclass"
              },
              {
                "kind": "NamedType",
                "name": "Artist instance"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Helper function to normalize kwarg inputs.",
      "docstring": "Helper function to normalize kwarg inputs.\n\nParameters\n----------\nkw : dict or None\n    A dict of keyword arguments.  None is explicitly supported and treated\n    as an empty dict, to support functions with an optional parameter of\n    the form ``props=None``.\n\nalias_mapping : dict or Artist subclass or Artist instance, optional\n    A mapping between a canonical name to a list of aliases, in order of\n    precedence from lowest to highest.\n\n    If the canonical value is not in the list it is assumed to have the\n    highest priority.\n\n    If an Artist subclass or instance is passed, use its properties alias\n    mapping.\n\nRaises\n------\nTypeError\n    To match what Python raises if invalid arguments/keyword arguments are\n    passed to a callable.",
      "code": "def normalize_kwargs(kw, alias_mapping=None):\n    \"\"\"\n    Helper function to normalize kwarg inputs.\n\n    Parameters\n    ----------\n    kw : dict or None\n        A dict of keyword arguments.  None is explicitly supported and treated\n        as an empty dict, to support functions with an optional parameter of\n        the form ``props=None``.\n\n    alias_mapping : dict or Artist subclass or Artist instance, optional\n        A mapping between a canonical name to a list of aliases, in order of\n        precedence from lowest to highest.\n\n        If the canonical value is not in the list it is assumed to have the\n        highest priority.\n\n        If an Artist subclass or instance is passed, use its properties alias\n        mapping.\n\n    Raises\n    ------\n    TypeError\n        To match what Python raises if invalid arguments/keyword arguments are\n        passed to a callable.\n    \"\"\"\n    from matplotlib.artist import Artist\n\n    if kw is None:\n        return {}\n\n    # deal with default value of alias_mapping\n    if alias_mapping is None:\n        alias_mapping = dict()\n    elif (isinstance(alias_mapping, type) and issubclass(alias_mapping, Artist)\n          or isinstance(alias_mapping, Artist)):\n        alias_mapping = getattr(alias_mapping, \"_alias_map\", {})\n\n    to_canonical = {alias: canonical\n                    for canonical, alias_list in alias_mapping.items()\n                    for alias in alias_list}\n    canonical_to_seen = {}\n    ret = {}  # output dictionary\n\n    for k, v in kw.items():\n        canonical = to_canonical.get(k, k)\n        if canonical in canonical_to_seen:\n            raise TypeError(f\"Got both {canonical_to_seen[canonical]!r} and \"\n                            f\"{k!r}, which are aliases of one another\")\n        canonical_to_seen[canonical] = k\n        ret[canonical] = v\n\n    return ret"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/open_file_cm",
      "name": "open_file_cm",
      "qname": "lib.matplotlib.cbook.open_file_cm",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/open_file_cm/path_or_file",
          "name": "path_or_file",
          "qname": "lib.matplotlib.cbook.open_file_cm.path_or_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/open_file_cm/mode",
          "name": "mode",
          "qname": "lib.matplotlib.cbook.open_file_cm.mode",
          "default_value": "'r'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/open_file_cm/encoding",
          "name": "encoding",
          "qname": "lib.matplotlib.cbook.open_file_cm.encoding",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Pass through file objects and context-manage path-likes.",
      "docstring": "Pass through file objects and context-manage path-likes.",
      "code": "def open_file_cm(path_or_file, mode=\"r\", encoding=None):\n    r\"\"\"Pass through file objects and context-manage path-likes.\"\"\"\n    fh, opened = to_filehandle(path_or_file, mode, True, encoding)\n    return fh if opened else contextlib.nullcontext(fh)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/print_cycles",
      "name": "print_cycles",
      "qname": "lib.matplotlib.cbook.print_cycles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/print_cycles/objects",
          "name": "objects",
          "qname": "lib.matplotlib.cbook.print_cycles.objects",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "A list of objects to find cycles in."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/print_cycles/outstream",
          "name": "outstream",
          "qname": "lib.matplotlib.cbook.print_cycles.outstream",
          "default_value": "sys.stdout",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "The stream for output."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/print_cycles/show_progress",
          "name": "show_progress",
          "qname": "lib.matplotlib.cbook.print_cycles.show_progress",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "If True, print the number of objects reached as they are found."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Print loops of cyclic references in the given *objects*.\n\nIt is often useful to pass in ``gc.garbage`` to find the cycles that are\npreventing some objects from being garbage collected.",
      "docstring": "Print loops of cyclic references in the given *objects*.\n\nIt is often useful to pass in ``gc.garbage`` to find the cycles that are\npreventing some objects from being garbage collected.\n\nParameters\n----------\nobjects\n    A list of objects to find cycles in.\noutstream\n    The stream for output.\nshow_progress : bool\n    If True, print the number of objects reached as they are found.",
      "code": "def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n    \"\"\"\n    Print loops of cyclic references in the given *objects*.\n\n    It is often useful to pass in ``gc.garbage`` to find the cycles that are\n    preventing some objects from being garbage collected.\n\n    Parameters\n    ----------\n    objects\n        A list of objects to find cycles in.\n    outstream\n        The stream for output.\n    show_progress : bool\n        If True, print the number of objects reached as they are found.\n    \"\"\"\n    import gc\n\n    def print_path(path):\n        for i, step in enumerate(path):\n            # next \"wraps around\"\n            next = path[(i + 1) % len(path)]\n\n            outstream.write(\"   %s -- \" % type(step))\n            if isinstance(step, dict):\n                for key, val in step.items():\n                    if val is next:\n                        outstream.write(\"[{!r}]\".format(key))\n                        break\n                    if key is next:\n                        outstream.write(\"[key] = {!r}\".format(val))\n                        break\n            elif isinstance(step, list):\n                outstream.write(\"[%d]\" % step.index(next))\n            elif isinstance(step, tuple):\n                outstream.write(\"( tuple )\")\n            else:\n                outstream.write(repr(step))\n            outstream.write(\" ->\\n\")\n        outstream.write(\"\\n\")\n\n    def recurse(obj, start, all, current_path):\n        if show_progress:\n            outstream.write(\"%d\\r\" % len(all))\n\n        all[id(obj)] = None\n\n        referents = gc.get_referents(obj)\n        for referent in referents:\n            # If we've found our way back to the start, this is\n            # a cycle, so print it out\n            if referent is start:\n                print_path(current_path)\n\n            # Don't go back through the original list of objects, or\n            # through temporary references to the object, since those\n            # are just an artifact of the cycle detector itself.\n            elif referent is objects or isinstance(referent, types.FrameType):\n                continue\n\n            # We haven't seen this object before, so recurse\n            elif id(referent) not in all:\n                recurse(referent, start, all, current_path + [obj])\n\n    for obj in objects:\n        outstream.write(f\"Examining: {obj!r}\\n\")\n        recurse(obj, obj, {}, [])"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/pts_to_midstep",
      "name": "pts_to_midstep",
      "qname": "lib.matplotlib.cbook.pts_to_midstep",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_midstep/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.pts_to_midstep.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array",
            "default_value": "",
            "description": "The x location of the steps. May be empty."
          },
          "type": {
            "kind": "NamedType",
            "name": "array"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_midstep/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.pts_to_midstep.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert continuous line to mid-steps.\n\nGiven a set of ``N`` points convert to ``2N`` points which when connected\nlinearly give a step function which changes values at the middle of the\nintervals.",
      "docstring": "Convert continuous line to mid-steps.\n\nGiven a set of ``N`` points convert to ``2N`` points which when connected\nlinearly give a step function which changes values at the middle of the\nintervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as\n    ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N``.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)",
      "code": "def pts_to_midstep(x, *args):\n    \"\"\"\n    Convert continuous line to mid-steps.\n\n    Given a set of ``N`` points convert to ``2N`` points which when connected\n    linearly give a step function which changes values at the middle of the\n    intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as\n        ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N``.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), 2 * len(x)))\n    x = np.asanyarray(x)\n    steps[0, 1:-1:2] = steps[0, 2::2] = (x[:-1] + x[1:]) / 2\n    steps[0, :1] = x[:1]  # Also works for zero-sized input.\n    steps[0, -1:] = x[-1:]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0::2]\n    return steps"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/pts_to_poststep",
      "name": "pts_to_poststep",
      "qname": "lib.matplotlib.cbook.pts_to_poststep",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_poststep/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.pts_to_poststep.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array",
            "default_value": "",
            "description": "The x location of the steps. May be empty."
          },
          "type": {
            "kind": "NamedType",
            "name": "array"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_poststep/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.pts_to_poststep.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert continuous line to post-steps.\n\nGiven a set of ``N`` points convert to ``2N + 1`` points, which when\nconnected linearly give a step function which changes values at the end of\nthe intervals.",
      "docstring": "Convert continuous line to post-steps.\n\nGiven a set of ``N`` points convert to ``2N + 1`` points, which when\nconnected linearly give a step function which changes values at the end of\nthe intervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N + 1``. For\n    ``N=0``, the length will be 0.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)",
      "code": "def pts_to_poststep(x, *args):\n    \"\"\"\n    Convert continuous line to post-steps.\n\n    Given a set of ``N`` points convert to ``2N + 1`` points, which when\n    connected linearly give a step function which changes values at the end of\n    the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 2::2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0:-2:2]\n    return steps"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/pts_to_prestep",
      "name": "pts_to_prestep",
      "qname": "lib.matplotlib.cbook.pts_to_prestep",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_prestep/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.pts_to_prestep.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array",
            "default_value": "",
            "description": "The x location of the steps. May be empty."
          },
          "type": {
            "kind": "NamedType",
            "name": "array"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_prestep/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.pts_to_prestep.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert continuous line to pre-steps.\n\nGiven a set of ``N`` points, convert to ``2N - 1`` points, which when\nconnected linearly give a step function which changes values at the\nbeginning of the intervals.",
      "docstring": "Convert continuous line to pre-steps.\n\nGiven a set of ``N`` points, convert to ``2N - 1`` points, which when\nconnected linearly give a step function which changes values at the\nbeginning of the intervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N + 1``. For\n    ``N=0``, the length will be 0.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)",
      "code": "def pts_to_prestep(x, *args):\n    \"\"\"\n    Convert continuous line to pre-steps.\n\n    Given a set of ``N`` points, convert to ``2N - 1`` points, which when\n    connected linearly give a step function which changes values at the\n    beginning of the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    # In all `pts_to_*step` functions, only assign once using *x* and *args*,\n    # as converting to an array may be expensive.\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 0:-2:2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 2::2]\n    return steps"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/report_memory",
      "name": "report_memory",
      "qname": "lib.matplotlib.cbook.report_memory",
      "decorators": [
        "_api.deprecated('3.5', alternative='psutil.virtual_memory')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/report_memory/i",
          "name": "i",
          "qname": "lib.matplotlib.cbook.report_memory.i",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the memory consumed by the process.",
      "docstring": "Return the memory consumed by the process.",
      "code": "@_api.deprecated(\"3.5\", alternative=\"psutil.virtual_memory\")\ndef report_memory(i=0):  # argument may go away\n    \"\"\"Return the memory consumed by the process.\"\"\"\n    def call(command, os_name):\n        try:\n            return subprocess.check_output(command)\n        except subprocess.CalledProcessError as err:\n            raise NotImplementedError(\n                \"report_memory works on %s only if \"\n                \"the '%s' program is found\" % (os_name, command[0])\n            ) from err\n\n    pid = os.getpid()\n    if sys.platform == 'sunos5':\n        lines = call(['ps', '-p', '%d' % pid, '-o', 'osz'], 'Sun OS')\n        mem = int(lines[-1].strip())\n    elif sys.platform == 'linux':\n        lines = call(['ps', '-p', '%d' % pid, '-o', 'rss,sz'], 'Linux')\n        mem = int(lines[1].split()[1])\n    elif sys.platform == 'darwin':\n        lines = call(['ps', '-p', '%d' % pid, '-o', 'rss,vsz'], 'Mac OS')\n        mem = int(lines[1].split()[0])\n    elif sys.platform == 'win32':\n        lines = call([\"tasklist\", \"/nh\", \"/fi\", \"pid eq %d\" % pid], 'Windows')\n        mem = int(lines.strip().split()[-2].replace(',', ''))\n    else:\n        raise NotImplementedError(\n            \"We don't have a memory monitor for %s\" % sys.platform)\n    return mem"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/safe_first_element",
      "name": "safe_first_element",
      "qname": "lib.matplotlib.cbook.safe_first_element",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/safe_first_element/obj",
          "name": "obj",
          "qname": "lib.matplotlib.cbook.safe_first_element.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the first element in *obj*.\n\nThis is an type-independent way of obtaining the first element,\nsupporting both index access and the iterator protocol.",
      "docstring": "Return the first element in *obj*.\n\nThis is an type-independent way of obtaining the first element,\nsupporting both index access and the iterator protocol.",
      "code": "def safe_first_element(obj):\n    \"\"\"\n    Return the first element in *obj*.\n\n    This is an type-independent way of obtaining the first element,\n    supporting both index access and the iterator protocol.\n    \"\"\"\n    return _safe_first_non_none(obj, skip_none=False)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/safe_masked_invalid",
      "name": "safe_masked_invalid",
      "qname": "lib.matplotlib.cbook.safe_masked_invalid",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/safe_masked_invalid/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.safe_masked_invalid.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/safe_masked_invalid/copy",
          "name": "copy",
          "qname": "lib.matplotlib.cbook.safe_masked_invalid.copy",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def safe_masked_invalid(x, copy=False):\n    x = np.array(x, subok=True, copy=copy)\n    if not x.dtype.isnative:\n        # If we have already made a copy, do the byteswap in place, else make a\n        # copy with the byte order swapped.\n        x = x.byteswap(inplace=copy).newbyteorder('N')  # Swap to native order.\n    try:\n        xm = np.ma.masked_invalid(x, copy=False)\n        xm.shrink_mask()\n    except TypeError:\n        return x\n    return xm"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/sanitize_sequence",
      "name": "sanitize_sequence",
      "qname": "lib.matplotlib.cbook.sanitize_sequence",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/sanitize_sequence/data",
          "name": "data",
          "qname": "lib.matplotlib.cbook.sanitize_sequence.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert dictview objects to list. Other inputs are returned unchanged.",
      "docstring": "Convert dictview objects to list. Other inputs are returned unchanged.",
      "code": "def sanitize_sequence(data):\n    \"\"\"\n    Convert dictview objects to list. Other inputs are returned unchanged.\n    \"\"\"\n    return (list(data) if isinstance(data, collections.abc.MappingView)\n            else data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.silent_list.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.silent_list.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__/type",
          "name": "type",
          "qname": "lib.matplotlib.cbook.silent_list.__init__.type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__/seq",
          "name": "seq",
          "qname": "lib.matplotlib.cbook.silent_list.__init__.seq",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>\n\nIf ``self.type`` is None, the type name is obtained from the first item in\nthe list (if any).",
      "docstring": "",
      "code": "    def __init__(self, type, seq=None):\n        self.type = type\n        if seq is not None:\n            self.extend(seq)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/silent_list/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.cbook.silent_list.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.silent_list.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        if self.type is not None or len(self) != 0:\n            tp = self.type if self.type is not None else type(self[0]).__name__\n            return f\"<a list of {len(self)} {tp} objects>\"\n        else:\n            return \"<an empty list>\""
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/simple_linear_interpolation",
      "name": "simple_linear_interpolation",
      "qname": "lib.matplotlib.cbook.simple_linear_interpolation",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/simple_linear_interpolation/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.simple_linear_interpolation.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array, shape (n, ...)",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array"
              },
              {
                "kind": "NamedType",
                "name": "shape (n, ...)"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/simple_linear_interpolation/steps",
          "name": "steps",
          "qname": "lib.matplotlib.cbook.simple_linear_interpolation.steps",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Resample an array with ``steps - 1`` points between original point pairs.\n\nAlong each column of *a*, ``(steps - 1)`` points are introduced between\neach original values; the values are linearly interpolated.",
      "docstring": "Resample an array with ``steps - 1`` points between original point pairs.\n\nAlong each column of *a*, ``(steps - 1)`` points are introduced between\neach original values; the values are linearly interpolated.\n\nParameters\n----------\na : array, shape (n, ...)\nsteps : int\n\nReturns\n-------\narray\n    shape ``((n - 1) * steps + 1, ...)``",
      "code": "def simple_linear_interpolation(a, steps):\n    \"\"\"\n    Resample an array with ``steps - 1`` points between original point pairs.\n\n    Along each column of *a*, ``(steps - 1)`` points are introduced between\n    each original values; the values are linearly interpolated.\n\n    Parameters\n    ----------\n    a : array, shape (n, ...)\n    steps : int\n\n    Returns\n    -------\n    array\n        shape ``((n - 1) * steps + 1, ...)``\n    \"\"\"\n    fps = a.reshape((len(a), -1))\n    xp = np.arange(len(a)) * steps\n    x = np.arange((len(a) - 1) * steps + 1)\n    return (np.column_stack([np.interp(x, xp, fp) for fp in fps.T])\n            .reshape((len(x),) + a.shape[1:]))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/strip_math",
      "name": "strip_math",
      "qname": "lib.matplotlib.cbook.strip_math",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/strip_math/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.strip_math.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Remove latex formatting from mathtext.\n\nOnly handles fully math and fully non-math strings.",
      "docstring": "Remove latex formatting from mathtext.\n\nOnly handles fully math and fully non-math strings.",
      "code": "def strip_math(s):\n    \"\"\"\n    Remove latex formatting from mathtext.\n\n    Only handles fully math and fully non-math strings.\n    \"\"\"\n    if len(s) >= 2 and s[0] == s[-1] == \"$\":\n        s = s[1:-1]\n        for tex, plain in [\n                (r\"\\times\", \"x\"),  # Specifically for Formatter support.\n                (r\"\\mathdefault\", \"\"),\n                (r\"\\rm\", \"\"),\n                (r\"\\cal\", \"\"),\n                (r\"\\tt\", \"\"),\n                (r\"\\it\", \"\"),\n                (\"\\\\\", \"\"),\n                (\"{\", \"\"),\n                (\"}\", \"\"),\n        ]:\n            s = s.replace(tex, plain)\n    return s"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/to_filehandle",
      "name": "to_filehandle",
      "qname": "lib.matplotlib.cbook.to_filehandle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/fname",
          "name": "fname",
          "qname": "lib.matplotlib.cbook.to_filehandle.fname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "If `str` or `os.PathLike`, the file is opened using the flags specified\nby *flag* and *encoding*.  If a file-like object, it is passed through."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/flag",
          "name": "flag",
          "qname": "lib.matplotlib.cbook.to_filehandle.flag",
          "default_value": "'r'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'r'",
            "description": "Passed as the *mode* argument to `open` when *fname* is `str` or\n`os.PathLike`; ignored if *fname* is file-like."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/return_opened",
          "name": "return_opened",
          "qname": "lib.matplotlib.cbook.to_filehandle.return_opened",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, return both the file object and a boolean indicating whether\nthis was a new file (that the caller needs to close).  If False, return\nonly the new file."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/encoding",
          "name": "encoding",
          "qname": "lib.matplotlib.cbook.to_filehandle.encoding",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or None",
            "default_value": "None",
            "description": "Passed as the *mode* argument to `open` when *fname* is `str` or\n`os.PathLike`; ignored if *fname* is file-like."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert a path to an open file handle or pass-through a file-like object.\n\nConsider using `open_file_cm` instead, as it allows one to properly close\nnewly created file objects more easily.",
      "docstring": "Convert a path to an open file handle or pass-through a file-like object.\n\nConsider using `open_file_cm` instead, as it allows one to properly close\nnewly created file objects more easily.\n\nParameters\n----------\nfname : str or path-like or file-like\n    If `str` or `os.PathLike`, the file is opened using the flags specified\n    by *flag* and *encoding*.  If a file-like object, it is passed through.\nflag : str, default: 'r'\n    Passed as the *mode* argument to `open` when *fname* is `str` or\n    `os.PathLike`; ignored if *fname* is file-like.\nreturn_opened : bool, default: False\n    If True, return both the file object and a boolean indicating whether\n    this was a new file (that the caller needs to close).  If False, return\n    only the new file.\nencoding : str or None, default: None\n    Passed as the *mode* argument to `open` when *fname* is `str` or\n    `os.PathLike`; ignored if *fname* is file-like.\n\nReturns\n-------\nfh : file-like\nopened : bool\n    *opened* is only returned if *return_opened* is True.",
      "code": "def to_filehandle(fname, flag='r', return_opened=False, encoding=None):\n    \"\"\"\n    Convert a path to an open file handle or pass-through a file-like object.\n\n    Consider using `open_file_cm` instead, as it allows one to properly close\n    newly created file objects more easily.\n\n    Parameters\n    ----------\n    fname : str or path-like or file-like\n        If `str` or `os.PathLike`, the file is opened using the flags specified\n        by *flag* and *encoding*.  If a file-like object, it is passed through.\n    flag : str, default: 'r'\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n    return_opened : bool, default: False\n        If True, return both the file object and a boolean indicating whether\n        this was a new file (that the caller needs to close).  If False, return\n        only the new file.\n    encoding : str or None, default: None\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n\n    Returns\n    -------\n    fh : file-like\n    opened : bool\n        *opened* is only returned if *return_opened* is True.\n    \"\"\"\n    if isinstance(fname, os.PathLike):\n        fname = os.fspath(fname)\n    if isinstance(fname, str):\n        if fname.endswith('.gz'):\n            fh = gzip.open(fname, flag)\n        elif fname.endswith('.bz2'):\n            # python may not be compiled with bz2 support,\n            # bury import until we need it\n            import bz2\n            fh = bz2.BZ2File(fname, flag)\n        else:\n            fh = open(fname, flag, encoding=encoding)\n        opened = True\n    elif hasattr(fname, 'seek'):\n        fh = fname\n        opened = False\n    else:\n        raise ValueError('fname must be a PathLike or file handle')\n    if return_opened:\n        return fh, opened\n    return fh"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/violin_stats",
      "name": "violin_stats",
      "qname": "lib.matplotlib.cbook.violin_stats",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/X",
          "name": "X",
          "qname": "lib.matplotlib.cbook.violin_stats.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Sample data that will be used to produce the gaussian kernel density\nestimates. Must have 2 or fewer dimensions."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/method",
          "name": "method",
          "qname": "lib.matplotlib.cbook.violin_stats.method",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "The method used to calculate the kernel density estimate for each\ncolumn of data. When called via ``method(v, coords)``, it should\nreturn a vector of the values of the KDE evaluated at the values\nspecified in coords."
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/points",
          "name": "points",
          "qname": "lib.matplotlib.cbook.violin_stats.points",
          "default_value": "100",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "100",
            "description": "Defines the number of points to evaluate each of the gaussian kernel\ndensity estimates at."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/quantiles",
          "name": "quantiles",
          "qname": "lib.matplotlib.cbook.violin_stats.quantiles",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "Defines (if not None) a list of floats in interval [0, 1] for each\ncolumn of data, which represents the quantiles that will be rendered\nfor that column of data. Must have 2 or fewer dimensions. 1D array will\nbe treated as a singleton list containing them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": true,
                "max_inclusive": true
              },
              {
                "kind": "NamedType",
                "name": "array-like"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of dictionaries of data which can be used to draw a series\nof violin plots.\n\nSee the ``Returns`` section below to view the required keys of the\ndictionary.\n\nUsers can skip this function and pass a user-defined set of dictionaries\nwith the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\nto do the calculations. See the *Returns* section below for the keys\nthat must be present in the dictionaries.",
      "docstring": "Return a list of dictionaries of data which can be used to draw a series\nof violin plots.\n\nSee the ``Returns`` section below to view the required keys of the\ndictionary.\n\nUsers can skip this function and pass a user-defined set of dictionaries\nwith the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\nto do the calculations. See the *Returns* section below for the keys\nthat must be present in the dictionaries.\n\nParameters\n----------\nX : array-like\n    Sample data that will be used to produce the gaussian kernel density\n    estimates. Must have 2 or fewer dimensions.\n\nmethod : callable\n    The method used to calculate the kernel density estimate for each\n    column of data. When called via ``method(v, coords)``, it should\n    return a vector of the values of the KDE evaluated at the values\n    specified in coords.\n\npoints : int, default: 100\n    Defines the number of points to evaluate each of the gaussian kernel\n    density estimates at.\n\nquantiles : array-like, default: None\n    Defines (if not None) a list of floats in interval [0, 1] for each\n    column of data, which represents the quantiles that will be rendered\n    for that column of data. Must have 2 or fewer dimensions. 1D array will\n    be treated as a singleton list containing them.\n\nReturns\n-------\nlist of dict\n    A list of dictionaries containing the results for each column of data.\n    The dictionaries contain at least the following:\n\n    - coords: A list of scalars containing the coordinates this particular\n      kernel density estimate was evaluated at.\n    - vals: A list of scalars containing the values of the kernel density\n      estimate at each of the coordinates given in *coords*.\n    - mean: The mean value for this column of data.\n    - median: The median value for this column of data.\n    - min: The minimum value for this column of data.\n    - max: The maximum value for this column of data.\n    - quantiles: The quantile values for this column of data.",
      "code": "def violin_stats(X, method, points=100, quantiles=None):\n    \"\"\"\n    Return a list of dictionaries of data which can be used to draw a series\n    of violin plots.\n\n    See the ``Returns`` section below to view the required keys of the\n    dictionary.\n\n    Users can skip this function and pass a user-defined set of dictionaries\n    with the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\n    to do the calculations. See the *Returns* section below for the keys\n    that must be present in the dictionaries.\n\n    Parameters\n    ----------\n    X : array-like\n        Sample data that will be used to produce the gaussian kernel density\n        estimates. Must have 2 or fewer dimensions.\n\n    method : callable\n        The method used to calculate the kernel density estimate for each\n        column of data. When called via ``method(v, coords)``, it should\n        return a vector of the values of the KDE evaluated at the values\n        specified in coords.\n\n    points : int, default: 100\n        Defines the number of points to evaluate each of the gaussian kernel\n        density estimates at.\n\n    quantiles : array-like, default: None\n        Defines (if not None) a list of floats in interval [0, 1] for each\n        column of data, which represents the quantiles that will be rendered\n        for that column of data. Must have 2 or fewer dimensions. 1D array will\n        be treated as a singleton list containing them.\n\n    Returns\n    -------\n    list of dict\n        A list of dictionaries containing the results for each column of data.\n        The dictionaries contain at least the following:\n\n        - coords: A list of scalars containing the coordinates this particular\n          kernel density estimate was evaluated at.\n        - vals: A list of scalars containing the values of the kernel density\n          estimate at each of the coordinates given in *coords*.\n        - mean: The mean value for this column of data.\n        - median: The median value for this column of data.\n        - min: The minimum value for this column of data.\n        - max: The maximum value for this column of data.\n        - quantiles: The quantile values for this column of data.\n    \"\"\"\n\n    # List of dictionaries describing each of the violins.\n    vpstats = []\n\n    # Want X to be a list of data sequences\n    X = _reshape_2D(X, \"X\")\n\n    # Want quantiles to be as the same shape as data sequences\n    if quantiles is not None and len(quantiles) != 0:\n        quantiles = _reshape_2D(quantiles, \"quantiles\")\n    # Else, mock quantiles if it's none or empty\n    else:\n        quantiles = [[]] * len(X)\n\n    # quantiles should has the same size as dataset\n    if len(X) != len(quantiles):\n        raise ValueError(\"List of violinplot statistics and quantiles values\"\n                         \" must have the same length\")\n\n    # Zip x and quantiles\n    for (x, q) in zip(X, quantiles):\n        # Dictionary of results for this distribution\n        stats = {}\n\n        # Calculate basic stats for the distribution\n        min_val = np.min(x)\n        max_val = np.max(x)\n        quantile_val = np.percentile(x, 100 * q)\n\n        # Evaluate the kernel density estimate\n        coords = np.linspace(min_val, max_val, points)\n        stats['vals'] = method(x, coords)\n        stats['coords'] = coords\n\n        # Store additional statistics for this distribution\n        stats['mean'] = np.mean(x)\n        stats['median'] = np.median(x)\n        stats['min'] = min_val\n        stats['max'] = max_val\n        stats['quantiles'] = np.atleast_1d(quantile_val)\n\n        # Append to output\n        vpstats.append(stats)\n\n    return vpstats"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return AitoffAxes.InvertedAitoffTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/transform_non_affine/ll",
          "name": "ll",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.transform_non_affine.ll",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n\n            # Pre-compute some values\n            half_long = longitude / 2.0\n            cos_latitude = np.cos(latitude)\n\n            alpha = np.arccos(cos_latitude * np.cos(half_long))\n            sinc_alpha = np.sinc(alpha / np.pi)  # np.sinc is sin(pi*x)/(pi*x).\n\n            x = (cos_latitude * np.sin(half_long)) / sinc_alpha\n            y = np.sin(latitude) / sinc_alpha\n            return np.column_stack([x, y])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return AitoffAxes.AitoffTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, xy):\n            # docstring inherited\n            # MGDTODO: Math is hard ;(\n            return np.full_like(xy, np.nan)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        super().__init__(*args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.clear()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__call__/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__call__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__call__/pos",
          "name": "pos",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__call__.pos",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __call__(self, x, pos=None):\n            degrees = round(np.rad2deg(x) / self._round_to) * self._round_to\n            return f\"{degrees:0.0f}\\N{DEGREE SIGN}\""
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__init__/round_to",
          "name": "round_to",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__init__.round_to",
          "default_value": "1.0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to format the theta tick labels.  Converts the native\nunit of radians into degrees and adds a degree symbol.",
      "docstring": "",
      "code": "        def __init__(self, round_to=1.0):\n            self._round_to = round_to"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_pan",
      "name": "can_pan",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.can_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.can_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether this axes supports the pan/zoom button functionality.\n\nThis axes object does not support interactive pan/zoom.",
      "docstring": "Return whether this axes supports the pan/zoom button functionality.\n\nThis axes object does not support interactive pan/zoom.",
      "code": "    def can_pan(self):\n        \"\"\"\n        Return whether this axes supports the pan/zoom button functionality.\n\n        This axes object does not support interactive pan/zoom.\n        \"\"\"\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_zoom",
      "name": "can_zoom",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.can_zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.can_zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether this axes supports the zoom box button functionality.\n\nThis axes object does not support interactive zoom box.",
      "docstring": "Return whether this axes supports the zoom box button functionality.\n\nThis axes object does not support interactive zoom box.",
      "code": "    def can_zoom(self):\n        \"\"\"\n        Return whether this axes supports the zoom box button functionality.\n\n        This axes object does not support interactive zoom box.\n        \"\"\"\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/clear",
      "name": "clear",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def clear(self):\n        # docstring inherited\n        super().clear()\n\n        self.set_longitude_grid(30)\n        self.set_latitude_grid(15)\n        self.set_longitude_grid_ends(75)\n        self.xaxis.set_minor_locator(NullLocator())\n        self.yaxis.set_minor_locator(NullLocator())\n        self.xaxis.set_ticks_position('none')\n        self.yaxis.set_ticks_position('none')\n        self.yaxis.set_tick_params(label1On=True)\n        # Why do we need to turn on yaxis tick labels, but\n        # xaxis tick labels are already on?\n\n        self.grid(mpl.rcParams['axes.grid'])\n\n        Axes.set_xlim(self, -np.pi, np.pi)\n        Axes.set_ylim(self, -np.pi / 2.0, np.pi / 2.0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan",
      "name": "drag_pan",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/button",
          "name": "button",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.button",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/key",
          "name": "key",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.key",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/y",
          "name": "y",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def drag_pan(self, button, key, x, y):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/end_pan",
      "name": "end_pan",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.end_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/end_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.end_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def end_pan(self):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord",
      "name": "format_coord",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.format_coord",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.format_coord.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord/lon",
          "name": "lon",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.format_coord.lon",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord/lat",
          "name": "lat",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.format_coord.lat",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a format string formatting the coordinate.",
      "docstring": "Return a format string formatting the coordinate.",
      "code": "    def format_coord(self, lon, lat):\n        \"\"\"Return a format string formatting the coordinate.\"\"\"\n        lon, lat = np.rad2deg([lon, lat])\n        ns = 'N' if lat >= 0.0 else 'S'\n        ew = 'E' if lon >= 0.0 else 'W'\n        return ('%f\\N{DEGREE SIGN}%s, %f\\N{DEGREE SIGN}%s'\n                % (abs(lat), ns, abs(lon), ew))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_data_ratio",
      "name": "get_data_ratio",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_data_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_data_ratio/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_data_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the aspect ratio of the data itself.",
      "docstring": "Return the aspect ratio of the data itself.",
      "code": "    def get_data_ratio(self):\n        \"\"\"Return the aspect ratio of the data itself.\"\"\"\n        return 1.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text1_transform",
      "name": "get_xaxis_text1_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text1_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text1_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text1_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text1_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text1_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text1_transform, 'bottom', 'center'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text2_transform",
      "name": "get_xaxis_text2_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text2_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text2_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text2_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text2_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text2_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_text2_transform(self, pad):\n        return self._xaxis_text2_transform, 'top', 'center'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_transform",
      "name": "get_xaxis_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_transform/which",
          "name": "which",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_transform.which",
          "default_value": "'grid'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_transform(self, which='grid'):\n        _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._xaxis_transform"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text1_transform",
      "name": "get_yaxis_text1_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text1_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text1_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text1_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text1_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text1_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_text1_transform(self, pad):\n        return self._yaxis_text1_transform, 'center', 'right'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text2_transform",
      "name": "get_yaxis_text2_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text2_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text2_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text2_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text2_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text2_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_text2_transform(self, pad):\n        return self._yaxis_text2_transform, 'center', 'left'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_transform",
      "name": "get_yaxis_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_transform/which",
          "name": "which",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_transform.which",
          "default_value": "'grid'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_transform(self, which='grid'):\n        _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._yaxis_transform"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_latitude_grid",
      "name": "set_latitude_grid",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_latitude_grid",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_latitude_grid/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_latitude_grid.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_latitude_grid/degrees",
          "name": "degrees",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_latitude_grid.degrees",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the number of degrees between each latitude grid.",
      "docstring": "Set the number of degrees between each latitude grid.",
      "code": "    def set_latitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each latitude grid.\n        \"\"\"\n        # Skip -90 and 90, which are the fixed limits.\n        grid = np.arange(-90 + degrees, 90, degrees)\n        self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid",
      "name": "set_longitude_grid",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid/degrees",
          "name": "degrees",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid.degrees",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the number of degrees between each longitude grid.",
      "docstring": "Set the number of degrees between each longitude grid.",
      "code": "    def set_longitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each longitude grid.\n        \"\"\"\n        # Skip -180 and 180, which are the fixed limits.\n        grid = np.arange(-180 + degrees, 180, degrees)\n        self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid_ends",
      "name": "set_longitude_grid_ends",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid_ends",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid_ends/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid_ends.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid_ends/degrees",
          "name": "degrees",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid_ends.degrees",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the latitude(s) at which to stop drawing the longitude grids.",
      "docstring": "Set the latitude(s) at which to stop drawing the longitude grids.",
      "code": "    def set_longitude_grid_ends(self, degrees):\n        \"\"\"\n        Set the latitude(s) at which to stop drawing the longitude grids.\n        \"\"\"\n        self._longitude_cap = np.deg2rad(degrees)\n        self._xaxis_pretransform \\\n            .clear() \\\n            .scale(1.0, self._longitude_cap * 2.0) \\\n            .translate(0.0, -self._longitude_cap)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim",
      "name": "set_xlim",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_xlim",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_xlim.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_xlim.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_xlim.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Not supported. Please consider using Cartopy.",
      "docstring": "Not supported. Please consider using Cartopy.",
      "code": "    def set_xlim(self, *args, **kwargs):\n        \"\"\"Not supported. Please consider using Cartopy.\"\"\"\n        raise TypeError(\"Changing axes limits of a geographic projection is \"\n                        \"not supported.  Please consider using Cartopy.\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale",
      "name": "set_yscale",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_yscale",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_yscale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_yscale.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_yscale.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_yscale(self, *args, **kwargs):\n        if args[0] != 'linear':\n            raise NotImplementedError"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan",
      "name": "start_pan",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan/y",
          "name": "y",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan/button",
          "name": "button",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan.button",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def start_pan(self, x, y, button):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return HammerAxes.InvertedHammerTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/transform_non_affine/ll",
          "name": "ll",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.transform_non_affine.ll",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n            half_long = longitude / 2.0\n            cos_latitude = np.cos(latitude)\n            sqrt2 = np.sqrt(2.0)\n            alpha = np.sqrt(1.0 + cos_latitude * np.cos(half_long))\n            x = (2.0 * sqrt2) * (cos_latitude * np.sin(half_long)) / alpha\n            y = (sqrt2 * np.sin(latitude)) / alpha\n            return np.column_stack([x, y])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return HammerAxes.HammerTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            z = np.sqrt(1 - (x / 4) ** 2 - (y / 2) ** 2)\n            longitude = 2 * np.arctan((z * x) / (2 * (2 * z ** 2 - 1)))\n            latitude = np.arcsin(y*z)\n            return np.column_stack([longitude, latitude])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        super().__init__(*args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.clear()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__/center_longitude",
          "name": "center_longitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__.center_longitude",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__/center_latitude",
          "name": "center_latitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__.center_latitude",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__/resolution",
          "name": "resolution",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__.resolution",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __init__(self, center_longitude, center_latitude, resolution):\n            _GeoTransform.__init__(self, resolution)\n            self._center_longitude = center_longitude\n            self._center_latitude = center_latitude"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return LambertAxes.LambertTransform(\n                self._center_longitude,\n                self._center_latitude,\n                self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            clong = self._center_longitude\n            clat = self._center_latitude\n            p = np.maximum(np.hypot(x, y), 1e-9)\n            c = 2 * np.arcsin(0.5 * p)\n            sin_c = np.sin(c)\n            cos_c = np.cos(c)\n\n            latitude = np.arcsin(cos_c*np.sin(clat) +\n                                 ((y*sin_c*np.cos(clat)) / p))\n            longitude = clong + np.arctan(\n                (x*sin_c) / (p*np.cos(clat)*cos_c - y*np.sin(clat)*sin_c))\n\n            return np.column_stack([longitude, latitude])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__/center_longitude",
          "name": "center_longitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__.center_longitude",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__/center_latitude",
          "name": "center_latitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__.center_latitude",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__/resolution",
          "name": "resolution",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__.resolution",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The base Lambert transform.",
      "docstring": "Create a new Lambert transform.  Resolution is the number of steps\nto interpolate between each input line segment to approximate its\npath in curved Lambert space.",
      "code": "        def __init__(self, center_longitude, center_latitude, resolution):\n            \"\"\"\n            Create a new Lambert transform.  Resolution is the number of steps\n            to interpolate between each input line segment to approximate its\n            path in curved Lambert space.\n            \"\"\"\n            _GeoTransform.__init__(self, resolution)\n            self._center_longitude = center_longitude\n            self._center_latitude = center_latitude"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return LambertAxes.InvertedLambertTransform(\n                self._center_longitude,\n                self._center_latitude,\n                self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/transform_non_affine/ll",
          "name": "ll",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.transform_non_affine.ll",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n            clong = self._center_longitude\n            clat = self._center_latitude\n            cos_lat = np.cos(latitude)\n            sin_lat = np.sin(latitude)\n            diff_long = longitude - clong\n            cos_diff_long = np.cos(diff_long)\n\n            inner_k = np.maximum(  # Prevent divide-by-zero problems\n                1 + np.sin(clat)*sin_lat + np.cos(clat)*cos_lat*cos_diff_long,\n                1e-15)\n            k = np.sqrt(2 / inner_k)\n            x = k * cos_lat*np.sin(diff_long)\n            y = k * (np.cos(clat)*sin_lat - np.sin(clat)*cos_lat*cos_diff_long)\n\n            return np.column_stack([x, y])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/center_longitude",
          "name": "center_longitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.center_longitude",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/center_latitude",
          "name": "center_latitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.center_latitude",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, center_longitude=0, center_latitude=0, **kwargs):\n        self._longitude_cap = np.pi / 2\n        self._center_longitude = center_longitude\n        self._center_latitude = center_latitude\n        super().__init__(*args, **kwargs)\n        self.set_aspect('equal', adjustable='box', anchor='C')\n        self.clear()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/clear",
      "name": "clear",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def clear(self):\n        # docstring inherited\n        super().clear()\n        self.yaxis.set_major_formatter(NullFormatter())"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return MollweideAxes.MollweideTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            # from Equations (7, 8) of\n            # https://mathworld.wolfram.com/MollweideProjection.html\n            theta = np.arcsin(y / np.sqrt(2))\n            longitude = (np.pi / (2 * np.sqrt(2))) * x / np.cos(theta)\n            latitude = np.arcsin((2 * theta + np.sin(2 * theta)) / np.pi)\n            return np.column_stack([longitude, latitude])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return MollweideAxes.InvertedMollweideTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/transform_non_affine/ll",
          "name": "ll",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.transform_non_affine.ll",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, ll):\n            # docstring inherited\n            def d(theta):\n                delta = (-(theta + np.sin(theta) - pi_sin_l)\n                         / (1 + np.cos(theta)))\n                return delta, np.abs(delta) > 0.001\n\n            longitude, latitude = ll.T\n\n            clat = np.pi/2 - np.abs(latitude)\n            ihigh = clat < 0.087  # within 5 degrees of the poles\n            ilow = ~ihigh\n            aux = np.empty(latitude.shape, dtype=float)\n\n            if ilow.any():  # Newton-Raphson iteration\n                pi_sin_l = np.pi * np.sin(latitude[ilow])\n                theta = 2.0 * latitude[ilow]\n                delta, large_delta = d(theta)\n                while np.any(large_delta):\n                    theta[large_delta] += delta[large_delta]\n                    delta, large_delta = d(theta)\n                aux[ilow] = theta / 2\n\n            if ihigh.any():  # Taylor series-based approx. solution\n                e = clat[ihigh]\n                d = 0.5 * (3 * np.pi * e**2) ** (1.0/3)\n                aux[ihigh] = (np.pi/2 - d) * np.sign(latitude[ihigh])\n\n            xy = np.empty(ll.shape, dtype=float)\n            xy[:, 0] = (2.0 * np.sqrt(2.0) / np.pi) * longitude * np.cos(aux)\n            xy[:, 1] = np.sqrt(2.0) * np.sin(aux)\n\n            return xy"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        super().__init__(*args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.clear()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__/axis",
          "name": "axis",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__.axis",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__/use_rmin",
          "name": "use_rmin",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__.use_rmin",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__/_apply_theta_transforms",
          "name": "_apply_theta_transforms",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__._apply_theta_transforms",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The inverse of the polar transform, mapping Cartesian\ncoordinate space *x* and *y* back to *theta* and *r*.",
      "docstring": "",
      "code": "    def __init__(self, axis=None, use_rmin=True,\n                 _apply_theta_transforms=True):\n        super().__init__()\n        self._axis = axis\n        self._use_rmin = use_rmin\n        self._apply_theta_transforms = _apply_theta_transforms"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def inverted(self):\n        # docstring inherited\n        return PolarAxes.PolarTransform(self._axis, self._use_rmin,\n                                        self._apply_theta_transforms)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def transform_non_affine(self, xy):\n        # docstring inherited\n        x, y = xy.T\n        r = np.hypot(x, y)\n        theta = (np.arctan2(y, x) + 2 * np.pi) % (2 * np.pi)\n        # PolarAxes does not use the theta transforms here, but apply them for\n        # backwards-compatibility if not being used by it.\n        if self._apply_theta_transforms and self._axis is not None:\n            theta -= self._axis.get_theta_offset()\n            theta *= self._axis.get_theta_direction()\n            theta %= 2 * np.pi\n        if self._use_rmin and self._axis is not None:\n            r += self._axis.get_rorigin()\n            r *= self._axis.get_rsign()\n        return np.column_stack([theta, r])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.PolarAffine.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAffine.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__/scale_transform",
          "name": "scale_transform",
          "qname": "lib.matplotlib.projections.polar.PolarAffine.__init__.scale_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__/limits",
          "name": "limits",
          "qname": "lib.matplotlib.projections.polar.PolarAffine.__init__.limits",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The affine part of the polar projection.  Scales the output so\nthat maximum radius rests on the edge of the axes circle.",
      "docstring": "*limits* is the view limit of the data.  The only part of\nits bounds that is used is the y limits (for the radius limits).\nThe theta range is handled by the non-affine transform.",
      "code": "    def __init__(self, scale_transform, limits):\n        \"\"\"\n        *limits* is the view limit of the data.  The only part of\n        its bounds that is used is the y limits (for the radius limits).\n        The theta range is handled by the non-affine transform.\n        \"\"\"\n        super().__init__()\n        self._scale_transform = scale_transform\n        self._limits = limits\n        self.set_children(scale_transform, limits)\n        self._mtx = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/get_matrix",
      "name": "get_matrix",
      "qname": "lib.matplotlib.projections.polar.PolarAffine.get_matrix",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/get_matrix/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAffine.get_matrix.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            limits_scaled = self._limits.transformed(self._scale_transform)\n            yscale = limits_scaled.ymax - limits_scaled.ymin\n            affine = mtransforms.Affine2D() \\\n                .scale(0.5 / yscale) \\\n                .translate(0.5, 0.5)\n            self._mtx = affine.get_matrix()\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/theta_offset",
          "name": "theta_offset",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.theta_offset",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/theta_direction",
          "name": "theta_direction",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.theta_direction",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/rlabel_position",
          "name": "rlabel_position",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.rlabel_position",
          "default_value": "22.5",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A polar graph projection, where the input dimensions are *theta*, *r*.\n\nTheta starts pointing east and goes anti-clockwise.",
      "docstring": "",
      "code": "    def __init__(self, *args,\n                 theta_offset=0, theta_direction=1, rlabel_position=22.5,\n                 **kwargs):\n        # docstring inherited\n        self._default_theta_offset = theta_offset\n        self._default_theta_direction = theta_direction\n        self._default_rlabel_position = np.deg2rad(rlabel_position)\n        super().__init__(*args, **kwargs)\n        self.use_sticky_edges = True\n        self.set_aspect('equal', adjustable='box', anchor='C')\n        self.clear()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_pan",
      "name": "can_pan",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.can_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.can_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether this axes supports the pan/zoom button functionality.\n\nFor polar axes, this is slightly misleading. Both panning and\nzooming are performed by the same button. Panning is performed\nin azimuth while zooming is done along the radial.",
      "docstring": "Return whether this axes supports the pan/zoom button functionality.\n\nFor polar axes, this is slightly misleading. Both panning and\nzooming are performed by the same button. Panning is performed\nin azimuth while zooming is done along the radial.",
      "code": "    def can_pan(self):\n        \"\"\"\n        Return whether this axes supports the pan/zoom button functionality.\n\n        For polar axes, this is slightly misleading. Both panning and\n        zooming are performed by the same button. Panning is performed\n        in azimuth while zooming is done along the radial.\n        \"\"\"\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_zoom",
      "name": "can_zoom",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.can_zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.can_zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether this axes supports the zoom box button functionality.\n\nPolar axes do not support zoom boxes.",
      "docstring": "Return whether this axes supports the zoom box button functionality.\n\nPolar axes do not support zoom boxes.",
      "code": "    def can_zoom(self):\n        \"\"\"\n        Return whether this axes supports the zoom box button functionality.\n\n        Polar axes do not support zoom boxes.\n        \"\"\"\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/clear",
      "name": "clear",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def clear(self):\n        # docstring inherited\n        super().clear()\n\n        self.title.set_y(1.05)\n\n        start = self.spines.get('start', None)\n        if start:\n            start.set_visible(False)\n        end = self.spines.get('end', None)\n        if end:\n            end.set_visible(False)\n        self.set_xlim(0.0, 2 * np.pi)\n\n        self.grid(mpl.rcParams['polaraxes.grid'])\n        inner = self.spines.get('inner', None)\n        if inner:\n            inner.set_visible(False)\n\n        self.set_rorigin(None)\n        self.set_theta_offset(self._default_theta_offset)\n        self.set_theta_direction(self._default_theta_direction)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan",
      "name": "drag_pan",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/button",
          "name": "button",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.button",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/key",
          "name": "key",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.key",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/y",
          "name": "y",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def drag_pan(self, button, key, x, y):\n        p = self._pan_start\n\n        if p.mode == 'drag_r_labels':\n            (startt, startr), (t, r) = p.trans_inverse.transform(\n                [(p.x, p.y), (x, y)])\n\n            # Deal with theta\n            dt = np.rad2deg(startt - t)\n            self.set_rlabel_position(p.r_label_angle - dt)\n\n            trans, vert1, horiz1 = self.get_yaxis_text1_transform(0.0)\n            trans, vert2, horiz2 = self.get_yaxis_text2_transform(0.0)\n            for t in self.yaxis.majorTicks + self.yaxis.minorTicks:\n                t.label1.set_va(vert1)\n                t.label1.set_ha(horiz1)\n                t.label2.set_va(vert2)\n                t.label2.set_ha(horiz2)\n\n        elif p.mode == 'zoom':\n            (startt, startr), (t, r) = p.trans_inverse.transform(\n                [(p.x, p.y), (x, y)])\n\n            # Deal with r\n            scale = r / startr\n            self.set_rmax(p.rmax / scale)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw",
      "name": "draw",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.draw.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self, renderer):\n        self._unstale_viewLim()\n        thetamin, thetamax = np.rad2deg(self._realViewLim.intervalx)\n        if thetamin > thetamax:\n            thetamin, thetamax = thetamax, thetamin\n        rmin, rmax = ((self._realViewLim.intervaly - self.get_rorigin()) *\n                      self.get_rsign())\n        if isinstance(self.patch, mpatches.Wedge):\n            # Backwards-compatibility: Any subclassed Axes might override the\n            # patch to not be the Wedge that PolarAxes uses.\n            center = self.transWedge.transform((0.5, 0.5))\n            self.patch.set_center(center)\n            self.patch.set_theta1(thetamin)\n            self.patch.set_theta2(thetamax)\n\n            edge, _ = self.transWedge.transform((1, 0))\n            radius = edge - center[0]\n            width = min(radius * (rmax - rmin) / rmax, radius)\n            self.patch.set_radius(radius)\n            self.patch.set_width(width)\n\n            inner_width = radius - width\n            inner = self.spines.get('inner', None)\n            if inner:\n                inner.set_visible(inner_width != 0.0)\n\n        visible = not _is_full_circle_deg(thetamin, thetamax)\n        # For backwards compatibility, any subclassed Axes might override the\n        # spines to not include start/end that PolarAxes uses.\n        start = self.spines.get('start', None)\n        end = self.spines.get('end', None)\n        if start:\n            start.set_visible(visible)\n        if end:\n            end.set_visible(visible)\n        if visible:\n            yaxis_text_transform = self._yaxis_transform\n        else:\n            yaxis_text_transform = self._r_label_position + self.transData\n        if self._yaxis_text_transform != yaxis_text_transform:\n            self._yaxis_text_transform.set(yaxis_text_transform)\n            self.yaxis.reset_ticks()\n            self.yaxis.set_clip_path(self.patch)\n\n        super().draw(renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/end_pan",
      "name": "end_pan",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.end_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/end_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.end_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def end_pan(self):\n        del self._pan_start"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord",
      "name": "format_coord",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.format_coord",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.format_coord.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord/theta",
          "name": "theta",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.format_coord.theta",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord/r",
          "name": "r",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.format_coord.r",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def format_coord(self, theta, r):\n        # docstring inherited\n        screen_xy = self.transData.transform((theta, r))\n        screen_xys = screen_xy + np.stack(\n            np.meshgrid([-1, 0, 1], [-1, 0, 1])).reshape((2, -1)).T\n        ts, rs = self.transData.inverted().transform(screen_xys).T\n        delta_t = abs((ts - theta + np.pi) % (2 * np.pi) - np.pi).max()\n        delta_t_halfturns = delta_t / np.pi\n        delta_t_degrees = delta_t_halfturns * 180\n        delta_r = abs(rs - r).max()\n        if theta < 0:\n            theta += 2 * np.pi\n        theta_halfturns = theta / np.pi\n        theta_degrees = theta_halfturns * 180\n\n        # See ScalarFormatter.format_data_short.  For r, use #g-formatting\n        # (as for linear axes), but for theta, use f-formatting as scientific\n        # notation doesn't make sense and the trailing dot is ugly.\n        def format_sig(value, delta, opt, fmt):\n            # For \"f\", only count digits after decimal point.\n            prec = (max(0, -math.floor(math.log10(delta))) if fmt == \"f\" else\n                    cbook._g_sig_digits(value, delta))\n            return f\"{value:-{opt}.{prec}{fmt}}\"\n\n        return ('\\N{GREEK SMALL LETTER THETA}={}\\N{GREEK SMALL LETTER PI} '\n                '({}\\N{DEGREE SIGN}), r={}').format(\n                    format_sig(theta_halfturns, delta_t_halfturns, \"\", \"f\"),\n                    format_sig(theta_degrees, delta_t_degrees, \"\", \"f\"),\n                    format_sig(r, delta_r, \"#\", \"g\"),\n                )"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_data_ratio",
      "name": "get_data_ratio",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_data_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_data_ratio/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_data_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the aspect ratio of the data itself.  For a polar plot,\nthis should always be 1.0",
      "docstring": "Return the aspect ratio of the data itself.  For a polar plot,\nthis should always be 1.0",
      "code": "    def get_data_ratio(self):\n        \"\"\"\n        Return the aspect ratio of the data itself.  For a polar plot,\n        this should always be 1.0\n        \"\"\"\n        return 1.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rlabel_position",
      "name": "get_rlabel_position",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rlabel_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rlabel_position/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rlabel_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Returns\n-------\nfloat\n    The theta position of the radius labels in degrees.",
      "code": "    def get_rlabel_position(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The theta position of the radius labels in degrees.\n        \"\"\"\n        return np.rad2deg(self._r_label_position.get_matrix()[0, 2])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmax",
      "name": "get_rmax",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rmax",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmax/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rmax.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Returns\n-------\nfloat\n    Outer radial limit.",
      "code": "    def get_rmax(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            Outer radial limit.\n        \"\"\"\n        return self.viewLim.ymax"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmin",
      "name": "get_rmin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rmin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rmin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Returns\n-------\nfloat\n    The inner radial limit.",
      "code": "    def get_rmin(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The inner radial limit.\n        \"\"\"\n        return self.viewLim.ymin"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rorigin",
      "name": "get_rorigin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rorigin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rorigin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rorigin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Returns\n-------\nfloat",
      "code": "    def get_rorigin(self):\n        \"\"\"\n        Returns\n        -------\n        float\n        \"\"\"\n        return self._originViewLim.y0"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rsign",
      "name": "get_rsign",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rsign",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rsign/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rsign.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_rsign(self):\n        return np.sign(self._originViewLim.y1 - self._originViewLim.y0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_direction",
      "name": "get_theta_direction",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_theta_direction",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_direction/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_theta_direction.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the direction in which theta increases.\n\n-1:\n   Theta increases in the clockwise direction\n\n1:\n   Theta increases in the counterclockwise direction",
      "docstring": "Get the direction in which theta increases.\n\n-1:\n   Theta increases in the clockwise direction\n\n1:\n   Theta increases in the counterclockwise direction",
      "code": "    def get_theta_direction(self):\n        \"\"\"\n        Get the direction in which theta increases.\n\n        -1:\n           Theta increases in the clockwise direction\n\n        1:\n           Theta increases in the counterclockwise direction\n        \"\"\"\n        return self._direction.get_matrix()[0, 0]"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_offset",
      "name": "get_theta_offset",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_theta_offset",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_offset/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_theta_offset.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the offset for the location of 0 in radians.",
      "docstring": "Get the offset for the location of 0 in radians.",
      "code": "    def get_theta_offset(self):\n        \"\"\"\n        Get the offset for the location of 0 in radians.\n        \"\"\"\n        return self._theta_offset.get_matrix()[0, 2]"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamax",
      "name": "get_thetamax",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_thetamax",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamax/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_thetamax.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the maximum theta limit in degrees.",
      "docstring": "Return the maximum theta limit in degrees.",
      "code": "    def get_thetamax(self):\n        \"\"\"Return the maximum theta limit in degrees.\"\"\"\n        return np.rad2deg(self.viewLim.xmax)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamin",
      "name": "get_thetamin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_thetamin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_thetamin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the minimum theta limit in degrees.",
      "docstring": "Get the minimum theta limit in degrees.",
      "code": "    def get_thetamin(self):\n        \"\"\"Get the minimum theta limit in degrees.\"\"\"\n        return np.rad2deg(self.viewLim.xmin)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text1_transform",
      "name": "get_xaxis_text1_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text1_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text1_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text1_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text1_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text1_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text2_transform",
      "name": "get_xaxis_text2_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text2_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text2_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text2_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text2_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text2_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_text2_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_transform",
      "name": "get_xaxis_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_transform/which",
          "name": "which",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_transform.which",
          "default_value": "'grid'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_transform(self, which='grid'):\n        _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._xaxis_transform"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text1_transform",
      "name": "get_yaxis_text1_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text1_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text1_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text1_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text1_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text1_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_text1_transform(self, pad):\n        thetamin, thetamax = self._realViewLim.intervalx\n        if _is_full_circle_rad(thetamin, thetamax):\n            return self._yaxis_text_transform, 'bottom', 'left'\n        elif self.get_theta_direction() > 0:\n            halign = 'left'\n            pad_shift = _ThetaShift(self, pad, 'min')\n        else:\n            halign = 'right'\n            pad_shift = _ThetaShift(self, pad, 'max')\n        return self._yaxis_text_transform + pad_shift, 'center', halign"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text2_transform",
      "name": "get_yaxis_text2_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text2_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text2_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text2_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text2_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text2_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_text2_transform(self, pad):\n        if self.get_theta_direction() > 0:\n            halign = 'right'\n            pad_shift = _ThetaShift(self, pad, 'max')\n        else:\n            halign = 'left'\n            pad_shift = _ThetaShift(self, pad, 'min')\n        return self._yaxis_text_transform + pad_shift, 'center', halign"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_transform",
      "name": "get_yaxis_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_transform/which",
          "name": "which",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform.which",
          "default_value": "'grid'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_transform(self, which='grid'):\n        if which in ('tick1', 'tick2'):\n            return self._yaxis_text_transform\n        elif which == 'grid':\n            return self._yaxis_transform\n        else:\n            _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids",
      "name": "set_rgrids",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/radii",
          "name": "radii",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.radii",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple with floats",
            "default_value": "",
            "description": "The radii for the radial gridlines"
          },
          "type": {
            "kind": "NamedType",
            "name": "tuple with floats"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/labels",
          "name": "labels",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.labels",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple with strings or None",
            "default_value": "",
            "description": "The labels to use at each radial gridline. The\n`matplotlib.ticker.ScalarFormatter` will be used if None."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "tuple with strings"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/angle",
          "name": "angle",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.angle",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The angular position of the radius labels in degrees."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/fmt",
          "name": "fmt",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.fmt",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or None",
            "default_value": "",
            "description": "Format string used in `matplotlib.ticker.FormatStrFormatter`.\nFor example '%f'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the radial gridlines on a polar plot.",
      "docstring": "Set the radial gridlines on a polar plot.\n\nParameters\n----------\nradii : tuple with floats\n    The radii for the radial gridlines\n\nlabels : tuple with strings or None\n    The labels to use at each radial gridline. The\n    `matplotlib.ticker.ScalarFormatter` will be used if None.\n\nangle : float\n    The angular position of the radius labels in degrees.\n\nfmt : str or None\n    Format string used in `matplotlib.ticker.FormatStrFormatter`.\n    For example '%f'.\n\nReturns\n-------\nlines : list of `.lines.Line2D`\n    The radial gridlines.\n\nlabels : list of `.text.Text`\n    The tick labels.\n\nOther Parameters\n----------------\n**kwargs\n    *kwargs* are optional `.Text` properties for the labels.\n\nSee Also\n--------\n.PolarAxes.set_thetagrids\n.Axis.get_gridlines\n.Axis.get_ticklabels",
      "code": "    def set_rgrids(self, radii, labels=None, angle=None, fmt=None, **kwargs):\n        \"\"\"\n        Set the radial gridlines on a polar plot.\n\n        Parameters\n        ----------\n        radii : tuple with floats\n            The radii for the radial gridlines\n\n        labels : tuple with strings or None\n            The labels to use at each radial gridline. The\n            `matplotlib.ticker.ScalarFormatter` will be used if None.\n\n        angle : float\n            The angular position of the radius labels in degrees.\n\n        fmt : str or None\n            Format string used in `matplotlib.ticker.FormatStrFormatter`.\n            For example '%f'.\n\n        Returns\n        -------\n        lines : list of `.lines.Line2D`\n            The radial gridlines.\n\n        labels : list of `.text.Text`\n            The tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            *kwargs* are optional `.Text` properties for the labels.\n\n        See Also\n        --------\n        .PolarAxes.set_thetagrids\n        .Axis.get_gridlines\n        .Axis.get_ticklabels\n        \"\"\"\n        # Make sure we take into account unitized data\n        radii = self.convert_xunits(radii)\n        radii = np.asarray(radii)\n\n        self.set_yticks(radii)\n        if labels is not None:\n            self.set_yticklabels(labels)\n        elif fmt is not None:\n            self.yaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))\n        if angle is None:\n            angle = self.get_rlabel_position()\n        self.set_rlabel_position(angle)\n        for t in self.yaxis.get_ticklabels():\n            t._internal_update(kwargs)\n        return self.yaxis.get_gridlines(), self.yaxis.get_ticklabels()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlabel_position",
      "name": "set_rlabel_position",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlabel_position/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlabel_position/value",
          "name": "value",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "number",
            "default_value": "",
            "description": "The angular position of the radius labels in degrees."
          },
          "type": {
            "kind": "NamedType",
            "name": "number"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Update the theta position of the radius labels.",
      "docstring": "Update the theta position of the radius labels.\n\nParameters\n----------\nvalue : number\n    The angular position of the radius labels in degrees.",
      "code": "    def set_rlabel_position(self, value):\n        \"\"\"\n        Update the theta position of the radius labels.\n\n        Parameters\n        ----------\n        value : number\n            The angular position of the radius labels in degrees.\n        \"\"\"\n        self._r_label_position.clear().translate(np.deg2rad(value), 0.0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim",
      "name": "set_rlim",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim",
      "decorators": [
        "_api.make_keyword_only('3.6', 'emit')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/bottom",
          "name": "bottom",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.bottom",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/top",
          "name": "top",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.top",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/emit",
          "name": "emit",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.emit",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/auto",
          "name": "auto",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.auto",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the radial axis view limits.\n\nThis function behaves like `.Axes.set_ylim`, but additionally supports\n*rmin* and *rmax* as aliases for *bottom* and *top*.",
      "docstring": "Set the radial axis view limits.\n\nThis function behaves like `.Axes.set_ylim`, but additionally supports\n*rmin* and *rmax* as aliases for *bottom* and *top*.\n\nSee Also\n--------\n.Axes.set_ylim",
      "code": "    @_api.make_keyword_only(\"3.6\", \"emit\")\n    def set_rlim(self, bottom=None, top=None, emit=True, auto=False, **kwargs):\n        \"\"\"\n        Set the radial axis view limits.\n\n        This function behaves like `.Axes.set_ylim`, but additionally supports\n        *rmin* and *rmax* as aliases for *bottom* and *top*.\n\n        See Also\n        --------\n        .Axes.set_ylim\n        \"\"\"\n        if 'rmin' in kwargs:\n            if bottom is None:\n                bottom = kwargs.pop('rmin')\n            else:\n                raise ValueError('Cannot supply both positional \"bottom\"'\n                                 'argument and kwarg \"rmin\"')\n        if 'rmax' in kwargs:\n            if top is None:\n                top = kwargs.pop('rmax')\n            else:\n                raise ValueError('Cannot supply both positional \"top\"'\n                                 'argument and kwarg \"rmax\"')\n        return self.set_ylim(bottom=bottom, top=top, emit=emit, auto=auto,\n                             **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmax",
      "name": "set_rmax",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmax",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmax/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmax.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmax/rmax",
          "name": "rmax",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmax.rmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the outer radial limit.",
      "docstring": "Set the outer radial limit.\n\nParameters\n----------\nrmax : float",
      "code": "    def set_rmax(self, rmax):\n        \"\"\"\n        Set the outer radial limit.\n\n        Parameters\n        ----------\n        rmax : float\n        \"\"\"\n        self.viewLim.y1 = rmax"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmin",
      "name": "set_rmin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmin/rmin",
          "name": "rmin",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmin.rmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the inner radial limit.",
      "docstring": "Set the inner radial limit.\n\nParameters\n----------\nrmin : float",
      "code": "    def set_rmin(self, rmin):\n        \"\"\"\n        Set the inner radial limit.\n\n        Parameters\n        ----------\n        rmin : float\n        \"\"\"\n        self.viewLim.y0 = rmin"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rorigin",
      "name": "set_rorigin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rorigin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rorigin/rorigin",
          "name": "rorigin",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin.rorigin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Update the radial origin.",
      "docstring": "Update the radial origin.\n\nParameters\n----------\nrorigin : float",
      "code": "    def set_rorigin(self, rorigin):\n        \"\"\"\n        Update the radial origin.\n\n        Parameters\n        ----------\n        rorigin : float\n        \"\"\"\n        self._originViewLim.locked_y0 = rorigin"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale",
      "name": "set_rscale",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rscale",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rscale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rscale.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rscale.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_rscale(self, *args, **kwargs):\n        return Axes.set_yscale(self, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks",
      "name": "set_rticks",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rticks",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rticks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rticks.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rticks.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_rticks(self, *args, **kwargs):\n        return Axes.set_yticks(self, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_direction",
      "name": "set_theta_direction",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_direction",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_direction/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_direction.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_direction/direction",
          "name": "direction",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_direction.direction",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the direction in which theta increases.\n\nclockwise, -1:\n   Theta increases in the clockwise direction\n\ncounterclockwise, anticlockwise, 1:\n   Theta increases in the counterclockwise direction",
      "docstring": "Set the direction in which theta increases.\n\nclockwise, -1:\n   Theta increases in the clockwise direction\n\ncounterclockwise, anticlockwise, 1:\n   Theta increases in the counterclockwise direction",
      "code": "    def set_theta_direction(self, direction):\n        \"\"\"\n        Set the direction in which theta increases.\n\n        clockwise, -1:\n           Theta increases in the clockwise direction\n\n        counterclockwise, anticlockwise, 1:\n           Theta increases in the counterclockwise direction\n        \"\"\"\n        mtx = self._direction.get_matrix()\n        if direction in ('clockwise', -1):\n            mtx[0, 0] = -1\n        elif direction in ('counterclockwise', 'anticlockwise', 1):\n            mtx[0, 0] = 1\n        else:\n            _api.check_in_list(\n                [-1, 1, 'clockwise', 'counterclockwise', 'anticlockwise'],\n                direction=direction)\n        self._direction.invalidate()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_offset",
      "name": "set_theta_offset",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_offset",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_offset/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_offset.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_offset/offset",
          "name": "offset",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_offset.offset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the offset for the location of 0 in radians.",
      "docstring": "Set the offset for the location of 0 in radians.",
      "code": "    def set_theta_offset(self, offset):\n        \"\"\"\n        Set the offset for the location of 0 in radians.\n        \"\"\"\n        mtx = self._theta_offset.get_matrix()\n        mtx[0, 2] = offset\n        self._theta_offset.invalidate()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location",
      "name": "set_theta_zero_location",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_zero_location",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_zero_location.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location/loc",
          "name": "loc",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_zero_location.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "May be one of \"N\", \"NW\", \"W\", \"SW\", \"S\", \"SE\", \"E\", or \"NE\"."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location/offset",
          "name": "offset",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_zero_location.offset",
          "default_value": "0.0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0",
            "description": "An offset in degrees to apply from the specified *loc*. **Note:**\nthis offset is *always* applied counter-clockwise regardless of\nthe direction setting."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the location of theta's zero.\n\nThis simply calls `set_theta_offset` with the correct value in radians.",
      "docstring": "Set the location of theta's zero.\n\nThis simply calls `set_theta_offset` with the correct value in radians.\n\nParameters\n----------\nloc : str\n    May be one of \"N\", \"NW\", \"W\", \"SW\", \"S\", \"SE\", \"E\", or \"NE\".\noffset : float, default: 0\n    An offset in degrees to apply from the specified *loc*. **Note:**\n    this offset is *always* applied counter-clockwise regardless of\n    the direction setting.",
      "code": "    def set_theta_zero_location(self, loc, offset=0.0):\n        \"\"\"\n        Set the location of theta's zero.\n\n        This simply calls `set_theta_offset` with the correct value in radians.\n\n        Parameters\n        ----------\n        loc : str\n            May be one of \"N\", \"NW\", \"W\", \"SW\", \"S\", \"SE\", \"E\", or \"NE\".\n        offset : float, default: 0\n            An offset in degrees to apply from the specified *loc*. **Note:**\n            this offset is *always* applied counter-clockwise regardless of\n            the direction setting.\n        \"\"\"\n        mapping = {\n            'N': np.pi * 0.5,\n            'NW': np.pi * 0.75,\n            'W': np.pi,\n            'SW': np.pi * 1.25,\n            'S': np.pi * 1.5,\n            'SE': np.pi * 1.75,\n            'E': 0,\n            'NE': np.pi * 0.25}\n        return self.set_theta_offset(mapping[loc] + np.deg2rad(offset))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids",
      "name": "set_thetagrids",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/angles",
          "name": "angles",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.angles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple with floats, degrees",
            "default_value": "",
            "description": "The angles of the theta gridlines."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "tuple with floats"
              },
              {
                "kind": "NamedType",
                "name": "degrees"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/labels",
          "name": "labels",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.labels",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple with strings or None",
            "default_value": "",
            "description": "The labels to use at each theta gridline. The\n`.projections.polar.ThetaFormatter` will be used if None."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "tuple with strings"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/fmt",
          "name": "fmt",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.fmt",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or None",
            "default_value": "",
            "description": "Format string used in `matplotlib.ticker.FormatStrFormatter`.\nFor example '%f'. Note that the angle that is used is in\nradians."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the theta gridlines in a polar plot.",
      "docstring": "Set the theta gridlines in a polar plot.\n\nParameters\n----------\nangles : tuple with floats, degrees\n    The angles of the theta gridlines.\n\nlabels : tuple with strings or None\n    The labels to use at each theta gridline. The\n    `.projections.polar.ThetaFormatter` will be used if None.\n\nfmt : str or None\n    Format string used in `matplotlib.ticker.FormatStrFormatter`.\n    For example '%f'. Note that the angle that is used is in\n    radians.\n\nReturns\n-------\nlines : list of `.lines.Line2D`\n    The theta gridlines.\n\nlabels : list of `.text.Text`\n    The tick labels.\n\nOther Parameters\n----------------\n**kwargs\n    *kwargs* are optional `.Text` properties for the labels.\n\nSee Also\n--------\n.PolarAxes.set_rgrids\n.Axis.get_gridlines\n.Axis.get_ticklabels",
      "code": "    def set_thetagrids(self, angles, labels=None, fmt=None, **kwargs):\n        \"\"\"\n        Set the theta gridlines in a polar plot.\n\n        Parameters\n        ----------\n        angles : tuple with floats, degrees\n            The angles of the theta gridlines.\n\n        labels : tuple with strings or None\n            The labels to use at each theta gridline. The\n            `.projections.polar.ThetaFormatter` will be used if None.\n\n        fmt : str or None\n            Format string used in `matplotlib.ticker.FormatStrFormatter`.\n            For example '%f'. Note that the angle that is used is in\n            radians.\n\n        Returns\n        -------\n        lines : list of `.lines.Line2D`\n            The theta gridlines.\n\n        labels : list of `.text.Text`\n            The tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            *kwargs* are optional `.Text` properties for the labels.\n\n        See Also\n        --------\n        .PolarAxes.set_rgrids\n        .Axis.get_gridlines\n        .Axis.get_ticklabels\n        \"\"\"\n\n        # Make sure we take into account unitized data\n        angles = self.convert_yunits(angles)\n        angles = np.deg2rad(angles)\n        self.set_xticks(angles)\n        if labels is not None:\n            self.set_xticklabels(labels)\n        elif fmt is not None:\n            self.xaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))\n        for t in self.xaxis.get_ticklabels():\n            t._internal_update(kwargs)\n        return self.xaxis.get_ticklines(), self.xaxis.get_ticklabels()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim",
      "name": "set_thetalim",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetalim",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetalim.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetalim.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetalim.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the minimum and maximum theta values.\n\nCan take the following signatures:\n\n- ``set_thetalim(minval, maxval)``: Set the limits in radians.\n- ``set_thetalim(thetamin=minval, thetamax=maxval)``: Set the limits\n  in degrees.\n\nwhere minval and maxval are the minimum and maximum limits. Values are\nwrapped in to the range :math:`[0, 2\\pi]` (in radians), so for example\nit is possible to do ``set_thetalim(-np.pi / 2, np.pi / 2)`` to have\nan axis symmetric around 0. A ValueError is raised if the absolute\nangle difference is larger than a full circle.",
      "docstring": "Set the minimum and maximum theta values.\n\nCan take the following signatures:\n\n- ``set_thetalim(minval, maxval)``: Set the limits in radians.\n- ``set_thetalim(thetamin=minval, thetamax=maxval)``: Set the limits\n  in degrees.\n\nwhere minval and maxval are the minimum and maximum limits. Values are\nwrapped in to the range :math:`[0, 2\\pi]` (in radians), so for example\nit is possible to do ``set_thetalim(-np.pi / 2, np.pi / 2)`` to have\nan axis symmetric around 0. A ValueError is raised if the absolute\nangle difference is larger than a full circle.",
      "code": "    def set_thetalim(self, *args, **kwargs):\n        r\"\"\"\n        Set the minimum and maximum theta values.\n\n        Can take the following signatures:\n\n        - ``set_thetalim(minval, maxval)``: Set the limits in radians.\n        - ``set_thetalim(thetamin=minval, thetamax=maxval)``: Set the limits\n          in degrees.\n\n        where minval and maxval are the minimum and maximum limits. Values are\n        wrapped in to the range :math:`[0, 2\\pi]` (in radians), so for example\n        it is possible to do ``set_thetalim(-np.pi / 2, np.pi / 2)`` to have\n        an axis symmetric around 0. A ValueError is raised if the absolute\n        angle difference is larger than a full circle.\n        \"\"\"\n        orig_lim = self.get_xlim()  # in radians\n        if 'thetamin' in kwargs:\n            kwargs['xmin'] = np.deg2rad(kwargs.pop('thetamin'))\n        if 'thetamax' in kwargs:\n            kwargs['xmax'] = np.deg2rad(kwargs.pop('thetamax'))\n        new_min, new_max = self.set_xlim(*args, **kwargs)\n        # Parsing all permutations of *args, **kwargs is tricky; it is simpler\n        # to let set_xlim() do it and then validate the limits.\n        if abs(new_max - new_min) > 2 * np.pi:\n            self.set_xlim(orig_lim)  # un-accept the change\n            raise ValueError(\"The angle range must be less than a full circle\")\n        return tuple(np.rad2deg((new_min, new_max)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamax",
      "name": "set_thetamax",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamax",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamax/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamax.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamax/thetamax",
          "name": "thetamax",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamax.thetamax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the maximum theta limit in degrees.",
      "docstring": "Set the maximum theta limit in degrees.",
      "code": "    def set_thetamax(self, thetamax):\n        \"\"\"Set the maximum theta limit in degrees.\"\"\"\n        self.viewLim.x1 = np.deg2rad(thetamax)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamin",
      "name": "set_thetamin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamin/thetamin",
          "name": "thetamin",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamin.thetamin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the minimum theta limit in degrees.",
      "docstring": "Set the minimum theta limit in degrees.",
      "code": "    def set_thetamin(self, thetamin):\n        \"\"\"Set the minimum theta limit in degrees.\"\"\"\n        self.viewLim.x0 = np.deg2rad(thetamin)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale",
      "name": "set_yscale",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_yscale",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_yscale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_yscale.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_yscale.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_yscale(self, *args, **kwargs):\n        super().set_yscale(*args, **kwargs)\n        self.yaxis.set_major_locator(\n            self.RadialLocator(self.yaxis.get_major_locator(), self))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan",
      "name": "start_pan",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan/y",
          "name": "y",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan/button",
          "name": "button",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan.button",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def start_pan(self, x, y, button):\n        angle = np.deg2rad(self.get_rlabel_position())\n        mode = ''\n        if button == 1:\n            epsilon = np.pi / 45.0\n            t, r = self.transData.inverted().transform((x, y))\n            if angle - epsilon <= t <= angle + epsilon:\n                mode = 'drag_r_labels'\n        elif button == 3:\n            mode = 'zoom'\n\n        self._pan_start = types.SimpleNamespace(\n            rmax=self.get_rmax(),\n            trans=self.transData.frozen(),\n            trans_inverse=self.transData.inverted().frozen(),\n            r_label_angle=self.get_rlabel_position(),\n            x=x,\n            y=y,\n            mode=mode)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__/axis",
          "name": "axis",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__.axis",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__/use_rmin",
          "name": "use_rmin",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__.use_rmin",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__/_apply_theta_transforms",
          "name": "_apply_theta_transforms",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__._apply_theta_transforms",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The base polar transform.\n\nThis transform maps polar coordinates ``(theta, r)`` into Cartesian\ncoordinates ``(x, y) = (r * cos(theta), r * sin(theta))`` (but does not\nhandle positioning in screen space).\n\nPath segments at a fixed radius are automatically transformed to circular\narcs as long as ``path._interpolation_steps > 1``.",
      "docstring": "",
      "code": "    def __init__(self, axis=None, use_rmin=True,\n                 _apply_theta_transforms=True):\n        super().__init__()\n        self._axis = axis\n        self._use_rmin = use_rmin\n        self._apply_theta_transforms = _apply_theta_transforms"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.polar.PolarTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def inverted(self):\n        # docstring inherited\n        return PolarAxes.InvertedPolarTransform(self._axis, self._use_rmin,\n                                                self._apply_theta_transforms)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_non_affine/tr",
          "name": "tr",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_non_affine.tr",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def transform_non_affine(self, tr):\n        # docstring inherited\n        t, r = np.transpose(tr)\n        # PolarAxes does not use the theta transforms here, but apply them for\n        # backwards-compatibility if not being used by it.\n        if self._apply_theta_transforms and self._axis is not None:\n            t *= self._axis.get_theta_direction()\n            t += self._axis.get_theta_offset()\n        if self._use_rmin and self._axis is not None:\n            r = (r - self._axis.get_rorigin()) * self._axis.get_rsign()\n        r = np.where(r >= 0, r, np.nan)\n        return np.column_stack([r * np.cos(t), r * np.sin(t)])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_path_non_affine",
      "name": "transform_path_non_affine",
      "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_path_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_path_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_path_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_path_non_affine/path",
          "name": "path",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_path_non_affine.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def transform_path_non_affine(self, path):\n        # docstring inherited\n        if not len(path) or path._interpolation_steps == 1:\n            return Path(self.transform_non_affine(path.vertices), path.codes)\n        xys = []\n        codes = []\n        last_t = last_r = None\n        for trs, c in path.iter_segments():\n            trs = trs.reshape((-1, 2))\n            if c == Path.LINETO:\n                (t, r), = trs\n                if t == last_t:  # Same angle: draw a straight line.\n                    xys.extend(self.transform_non_affine(trs))\n                    codes.append(Path.LINETO)\n                elif r == last_r:  # Same radius: draw an arc.\n                    # The following is complicated by Path.arc() being\n                    # \"helpful\" and unwrapping the angles, but we don't want\n                    # that behavior here.\n                    last_td, td = np.rad2deg([last_t, t])\n                    if self._use_rmin and self._axis is not None:\n                        r = ((r - self._axis.get_rorigin())\n                             * self._axis.get_rsign())\n                    if last_td <= td:\n                        while td - last_td > 360:\n                            arc = Path.arc(last_td, last_td + 360)\n                            xys.extend(arc.vertices[1:] * r)\n                            codes.extend(arc.codes[1:])\n                            last_td += 360\n                        arc = Path.arc(last_td, td)\n                        xys.extend(arc.vertices[1:] * r)\n                        codes.extend(arc.codes[1:])\n                    else:\n                        # The reverse version also relies on the fact that all\n                        # codes but the first one are the same.\n                        while last_td - td > 360:\n                            arc = Path.arc(last_td - 360, last_td)\n                            xys.extend(arc.vertices[::-1][1:] * r)\n                            codes.extend(arc.codes[1:])\n                            last_td -= 360\n                        arc = Path.arc(td, last_td)\n                        xys.extend(arc.vertices[::-1][1:] * r)\n                        codes.extend(arc.codes[1:])\n                else:  # Interpolate.\n                    trs = cbook.simple_linear_interpolation(\n                        np.row_stack([(last_t, last_r), trs]),\n                        path._interpolation_steps)[1:]\n                    xys.extend(self.transform_non_affine(trs))\n                    codes.extend([Path.LINETO] * len(trs))\n            else:  # Not a straight line.\n                xys.extend(self.transform_non_affine(trs))\n                codes.extend([c] * len(trs))\n            last_t, last_r = trs[-1]\n        return Path(xys, codes)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.RadialAxis.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialAxis.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.RadialAxis.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.RadialAxis.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A radial Axis.\n\nThis overrides certain properties of a `.YAxis` to provide special-casing\nfor a radial axis.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.sticky_edges.y.append(0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/clear",
      "name": "clear",
      "qname": "lib.matplotlib.projections.polar.RadialAxis.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialAxis.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def clear(self):\n        # docstring inherited\n        super().clear()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __call__(self):\n        # Ensure previous behaviour with full circle non-annular views.\n        if self._axes:\n            if _is_full_circle_rad(*self._axes.viewLim.intervalx):\n                rorigin = self._axes.get_rorigin() * self._axes.get_rsign()\n                if self._axes.get_rmin() <= rorigin:\n                    return [tick for tick in self.base() if tick > rorigin]\n        return self.base()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__/base",
          "name": "base",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.__init__.base",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__/axes",
          "name": "axes",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.__init__.axes",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to locate radius ticks.\n\nEnsures that all ticks are strictly positive.  For all other tasks, it\ndelegates to the base `.Locator` (which may be different depending on the\nscale of the *r*-axis).",
      "docstring": "",
      "code": "    def __init__(self, base, axes=None):\n        self.base = base\n        self._axes = axes"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular",
      "name": "nonsingular",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.nonsingular",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.nonsingular.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.nonsingular.vmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.nonsingular.vmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def nonsingular(self, vmin, vmax):\n        # docstring inherited\n        return ((0, 1) if (vmin, vmax) == (-np.inf, np.inf)  # Init. limits.\n                else self.base.nonsingular(vmin, vmax))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/set_axis",
      "name": "set_axis",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.set_axis",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/set_axis/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.set_axis.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/set_axis/axis",
          "name": "axis",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.set_axis.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_axis(self, axis):\n        self.base.set_axis(axis)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits",
      "name": "view_limits",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.view_limits",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.view_limits.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.view_limits.vmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.view_limits.vmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def view_limits(self, vmin, vmax):\n        vmin, vmax = self.base.view_limits(vmin, vmax)\n        if vmax > vmin:\n            # this allows inverted r/y-lims\n            vmin = min(0, vmin)\n        return mtransforms.nonsingular(vmin, vmax)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.RadialTick.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialTick.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.RadialTick.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.RadialTick.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A radial-axis tick.\n\nThis subclass of `.YTick` provides radial ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\naxes limits.  This results in ticks that are correctly perpendicular to\nthe spine. Labels are also rotated to be perpendicular to the spine, when\n'auto' rotation is enabled.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.label1.set_rotation_mode('anchor')\n        self.label2.set_rotation_mode('anchor')"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/update_position",
      "name": "update_position",
      "qname": "lib.matplotlib.projections.polar.RadialTick.update_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/update_position/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialTick.update_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/update_position/loc",
          "name": "loc",
          "qname": "lib.matplotlib.projections.polar.RadialTick.update_position.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        thetamin = axes.get_thetamin()\n        thetamax = axes.get_thetamax()\n        direction = axes.get_theta_direction()\n        offset_rad = axes.get_theta_offset()\n        offset = np.rad2deg(offset_rad)\n        full = _is_full_circle_deg(thetamin, thetamax)\n\n        if full:\n            angle = (axes.get_rlabel_position() * direction +\n                     offset) % 360 - 90\n            tick_angle = 0\n        else:\n            angle = (thetamin * direction + offset) % 360 - 90\n            if direction > 0:\n                tick_angle = np.deg2rad(angle)\n            else:\n                tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        if full:\n            ha = self.label1.get_horizontalalignment()\n            va = self.label1.get_verticalalignment()\n        else:\n            ha, va = self._determine_anchor(mode, angle, direction > 0)\n        self.label1.set_horizontalalignment(ha)\n        self.label1.set_verticalalignment(va)\n        self.label1.set_rotation(text_angle)\n\n        marker = self.tick1line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        if full:\n            self.label2.set_visible(False)\n            self.tick2line.set_visible(False)\n        angle = (thetamax * direction + offset) % 360 - 90\n        if direction > 0:\n            tick_angle = np.deg2rad(angle)\n        else:\n            tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        ha, va = self._determine_anchor(mode, angle, direction < 0)\n        self.label2.set_ha(ha)\n        self.label2.set_va(va)\n        self.label2.set_rotation(text_angle)\n\n        marker = self.tick2line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/clear",
      "name": "clear",
      "qname": "lib.matplotlib.projections.polar.ThetaAxis.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaAxis.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def clear(self):\n        # docstring inherited\n        super().clear()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.projections.polar.ThetaFormatter.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaFormatter.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.polar.ThetaFormatter.__call__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__/pos",
          "name": "pos",
          "qname": "lib.matplotlib.projections.polar.ThetaFormatter.__call__.pos",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __call__(self, x, pos=None):\n        vmin, vmax = self.axis.get_view_interval()\n        d = np.rad2deg(abs(vmax - vmin))\n        digits = max(-int(np.log10(d) - 1.5), 0)\n        # Use Unicode rather than mathtext with \\circ, so that it will work\n        # correctly with any arbitrary font (assuming it has a degree sign),\n        # whereas $5\\circ$ will only work correctly with one of the supported\n        # math fonts (Computer Modern and STIX).\n        return (\"{value:0.{digits:d}f}\\N{DEGREE SIGN}\"\n                .format(value=np.rad2deg(x), digits=digits))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __call__(self):\n        lim = self.axis.get_view_interval()\n        if _is_full_circle_deg(lim[0], lim[1]):\n            return np.arange(8) * 2 * np.pi / 8\n        else:\n            return np.deg2rad(self.base())"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__init__/base",
          "name": "base",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.__init__.base",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to locate theta ticks.\n\nThis will work the same as the base locator except in the case that the\nview spans the entire circle. In such cases, the previously used default\nlocations of every 45 degrees are returned.",
      "docstring": "",
      "code": "    def __init__(self, base):\n        self.base = base\n        self.axis = self.base.axis = _AxisWrapper(self.base.axis)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/refresh",
      "name": "refresh",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.refresh",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/refresh/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.refresh.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def refresh(self):\n        # docstring inherited\n        return self.base.refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/set_axis",
      "name": "set_axis",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.set_axis",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/set_axis/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.set_axis.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/set_axis/axis",
          "name": "axis",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.set_axis.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_axis(self, axis):\n        self.axis = _AxisWrapper(axis)\n        self.base.set_axis(self.axis)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits",
      "name": "view_limits",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.view_limits",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.view_limits.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.view_limits.vmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.view_limits.vmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def view_limits(self, vmin, vmax):\n        vmin, vmax = np.rad2deg((vmin, vmax))\n        return np.deg2rad(self.base.view_limits(vmin, vmax))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__/axes",
          "name": "axes",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__.axes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A theta-axis tick.\n\nThis subclass of `.XTick` provides angular ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\ntick location. This results in ticks that are correctly perpendicular to\nthe arc spine.\n\nWhen 'auto' rotation is enabled, labels are also rotated to be parallel to\nthe spine. The label padding is also applied here since it's not possible\nto use a generic axes transform to produce tick-specific padding.",
      "docstring": "",
      "code": "    def __init__(self, axes, *args, **kwargs):\n        self._text1_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        self._text2_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        super().__init__(axes, *args, **kwargs)\n        self.label1.set(\n            rotation_mode='anchor',\n            transform=self.label1.get_transform() + self._text1_translate)\n        self.label2.set(\n            rotation_mode='anchor',\n            transform=self.label2.get_transform() + self._text2_translate)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/update_position",
      "name": "update_position",
      "qname": "lib.matplotlib.projections.polar.ThetaTick.update_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/update_position/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.update_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/update_position/loc",
          "name": "loc",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.update_position.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        angle = loc * axes.get_theta_direction() + axes.get_theta_offset()\n        text_angle = np.rad2deg(angle) % 360 - 90\n        angle -= np.pi / 2\n\n        marker = self.tick1line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        marker = self.tick2line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans\n\n        mode, user_angle = self._labelrotation\n        if mode == 'default':\n            text_angle = user_angle\n        else:\n            if text_angle > 90:\n                text_angle -= 180\n            elif text_angle < -90:\n                text_angle += 180\n            text_angle += user_angle\n        self.label1.set_rotation(text_angle)\n        self.label2.set_rotation(text_angle)\n\n        # This extra padding helps preserve the look from previous releases but\n        # is also needed because labels are anchored to their center.\n        pad = self._pad + 7\n        self._update_padding(pad,\n                             self._loc * axes.get_theta_direction() +\n                             axes.get_theta_offset())"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.ProjectionRegistry.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A mapping of registered projection names to projection classes.",
      "docstring": "",
      "code": "    def __init__(self):\n        self._all_projection_types = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_class",
      "name": "get_projection_class",
      "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_class",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_class/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_class/name",
          "name": "name",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_class.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get a projection class from its *name*.",
      "docstring": "Get a projection class from its *name*.",
      "code": "    def get_projection_class(self, name):\n        \"\"\"Get a projection class from its *name*.\"\"\"\n        return self._all_projection_types[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_names",
      "name": "get_projection_names",
      "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_names",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_names/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the names of all projections currently registered.",
      "docstring": "Return the names of all projections currently registered.",
      "code": "    def get_projection_names(self):\n        \"\"\"Return the names of all projections currently registered.\"\"\"\n        return sorted(self._all_projection_types)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/register",
      "name": "register",
      "qname": "lib.matplotlib.projections.ProjectionRegistry.register",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/register/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.register.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/register/projections",
          "name": "projections",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.register.projections",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Register a new set of projections.",
      "docstring": "Register a new set of projections.",
      "code": "    def register(self, *projections):\n        \"\"\"Register a new set of projections.\"\"\"\n        for projection in projections:\n            name = projection.name\n            self._all_projection_types[name] = projection"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/get_projection_class",
      "name": "get_projection_class",
      "qname": "lib.matplotlib.projections.get_projection_class",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/get_projection_class/projection",
          "name": "projection",
          "qname": "lib.matplotlib.projections.get_projection_class.projection",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get a projection class from its name.\n\nIf *projection* is None, a standard rectilinear projection is returned.",
      "docstring": "Get a projection class from its name.\n\nIf *projection* is None, a standard rectilinear projection is returned.",
      "code": "def get_projection_class(projection=None):\n    \"\"\"\n    Get a projection class from its name.\n\n    If *projection* is None, a standard rectilinear projection is returned.\n    \"\"\"\n    if projection is None:\n        projection = 'rectilinear'\n\n    try:\n        return projection_registry.get_projection_class(projection)\n    except KeyError as err:\n        raise ValueError(\"Unknown projection %r\" % projection) from err"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/register_projection",
      "name": "register_projection",
      "qname": "lib.matplotlib.projections.register_projection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/register_projection/cls",
          "name": "cls",
          "qname": "lib.matplotlib.projections.register_projection.cls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def register_projection(cls):\n    projection_registry.register(cls)"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/MathDirective/run",
      "name": "run",
      "qname": "lib.matplotlib.sphinxext.mathmpl.MathDirective.run",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/MathDirective/run/self",
          "name": "self",
          "qname": "lib.matplotlib.sphinxext.mathmpl.MathDirective.run.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def run(self):\n        latex = ''.join(self.content)\n        node = latex_math(self.block_text)\n        node['latex'] = latex\n        node['fontset'] = self.options.get('fontset', 'cm')\n        node['fontsize'] = self.options.get('fontsize',\n                                            setup.app.config.mathmpl_fontsize)\n        return [node]"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/fontset_choice",
      "name": "fontset_choice",
      "qname": "lib.matplotlib.sphinxext.mathmpl.fontset_choice",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/fontset_choice/arg",
          "name": "arg",
          "qname": "lib.matplotlib.sphinxext.mathmpl.fontset_choice.arg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def fontset_choice(arg):\n    return directives.choice(arg, mathtext.MathTextParser._font_type_mapping)"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex2html",
      "name": "latex2html",
      "qname": "lib.matplotlib.sphinxext.mathmpl.latex2html",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex2html/node",
          "name": "node",
          "qname": "lib.matplotlib.sphinxext.mathmpl.latex2html.node",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex2html/source",
          "name": "source",
          "qname": "lib.matplotlib.sphinxext.mathmpl.latex2html.source",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def latex2html(node, source):\n    inline = isinstance(node.parent, nodes.TextElement)\n    latex = node['latex']\n    fontset = node['fontset']\n    fontsize = node['fontsize']\n    name = 'math-{}'.format(\n        hashlib.md5(f'{latex}{fontset}{fontsize}'.encode()).hexdigest()[-10:])\n\n    destdir = Path(setup.app.builder.outdir, '_images', 'mathmpl')\n    destdir.mkdir(parents=True, exist_ok=True)\n\n    dest = destdir / f'{name}.png'\n    depth = latex2png(latex, dest, fontset, fontsize=fontsize)\n\n    srcset = []\n    for size in setup.app.config.mathmpl_srcset:\n        filename = f'{name}-{size.replace(\".\", \"_\")}.png'\n        latex2png(latex, destdir / filename, fontset, fontsize=fontsize,\n                  dpi=100 * float(size[:-1]))\n        srcset.append(\n            f'{setup.app.builder.imgpath}/mathmpl/{filename} {size}')\n    if srcset:\n        srcset = (f'srcset=\"{setup.app.builder.imgpath}/mathmpl/{name}.png, ' +\n                  ', '.join(srcset) + '\" ')\n\n    if inline:\n        cls = ''\n    else:\n        cls = 'class=\"center\" '\n    if inline and depth != 0:\n        style = 'style=\"position: relative; bottom: -%dpx\"' % (depth + 1)\n    else:\n        style = ''\n\n    return (f'<img src=\"{setup.app.builder.imgpath}/mathmpl/{name}.png\"'\n            f' {srcset}{cls}{style}/>')"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex2png",
      "name": "latex2png",
      "qname": "lib.matplotlib.sphinxext.mathmpl.latex2png",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex2png/latex",
          "name": "latex",
          "qname": "lib.matplotlib.sphinxext.mathmpl.latex2png.latex",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex2png/filename",
          "name": "filename",
          "qname": "lib.matplotlib.sphinxext.mathmpl.latex2png.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex2png/fontset",
          "name": "fontset",
          "qname": "lib.matplotlib.sphinxext.mathmpl.latex2png.fontset",
          "default_value": "'cm'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex2png/fontsize",
          "name": "fontsize",
          "qname": "lib.matplotlib.sphinxext.mathmpl.latex2png.fontsize",
          "default_value": "10",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/latex2png/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.sphinxext.mathmpl.latex2png.dpi",
          "default_value": "100",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def latex2png(latex, filename, fontset='cm', fontsize=10, dpi=100):\n    with mpl.rc_context({'mathtext.fontset': fontset, 'font.size': fontsize}):\n        try:\n            depth = mathtext.math_to_image(\n                f\"${latex}$\", filename, dpi=dpi, format=\"png\")\n        except Exception:\n            _api.warn_external(f\"Could not render math expression {latex}\")\n            depth = 0\n    return depth"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/math_role",
      "name": "math_role",
      "qname": "lib.matplotlib.sphinxext.mathmpl.math_role",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/math_role/role",
          "name": "role",
          "qname": "lib.matplotlib.sphinxext.mathmpl.math_role.role",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/math_role/rawtext",
          "name": "rawtext",
          "qname": "lib.matplotlib.sphinxext.mathmpl.math_role.rawtext",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/math_role/text",
          "name": "text",
          "qname": "lib.matplotlib.sphinxext.mathmpl.math_role.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/math_role/lineno",
          "name": "lineno",
          "qname": "lib.matplotlib.sphinxext.mathmpl.math_role.lineno",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/math_role/inliner",
          "name": "inliner",
          "qname": "lib.matplotlib.sphinxext.mathmpl.math_role.inliner",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/math_role/options",
          "name": "options",
          "qname": "lib.matplotlib.sphinxext.mathmpl.math_role.options",
          "default_value": "{}",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/math_role/content",
          "name": "content",
          "qname": "lib.matplotlib.sphinxext.mathmpl.math_role.content",
          "default_value": "[]",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def math_role(role, rawtext, text, lineno, inliner,\n              options={}, content=[]):\n    i = rawtext.find('`')\n    latex = rawtext[i+1:-1]\n    node = latex_math(rawtext)\n    node['latex'] = latex\n    node['fontset'] = options.get('fontset', 'cm')\n    node['fontsize'] = options.get('fontsize',\n                                   setup.app.config.mathmpl_fontsize)\n    return [node], []"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/setup",
      "name": "setup",
      "qname": "lib.matplotlib.sphinxext.mathmpl.setup",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.mathmpl/setup/app",
          "name": "app",
          "qname": "lib.matplotlib.sphinxext.mathmpl.setup.app",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def setup(app):\n    setup.app = app\n    app.add_config_value('mathmpl_fontsize', 10.0, True)\n    app.add_config_value('mathmpl_srcset', [], True)\n    try:\n        app.connect('config-inited', _config_inited)  # Sphinx 1.8+\n    except ExtensionError:\n        app.connect('env-updated', lambda app, env: _config_inited(app, None))\n\n    # Add visit/depart methods to HTML-Translator:\n    def visit_latex_math_html(self, node):\n        source = self.document.attributes['source']\n        self.body.append(latex2html(node, source))\n\n    def depart_latex_math_html(self, node):\n        pass\n\n    # Add visit/depart methods to LaTeX-Translator:\n    def visit_latex_math_latex(self, node):\n        inline = isinstance(node.parent, nodes.TextElement)\n        if inline:\n            self.body.append('$%s$' % node['latex'])\n        else:\n            self.body.extend(['\\\\begin{equation}',\n                              node['latex'],\n                              '\\\\end{equation}'])\n\n    def depart_latex_math_latex(self, node):\n        pass\n\n    app.add_node(latex_math,\n                 html=(visit_latex_math_html, depart_latex_math_html),\n                 latex=(visit_latex_math_latex, depart_latex_math_latex))\n    app.add_role('mathmpl', math_role)\n    app.add_directive('mathmpl', MathDirective)\n    if sphinx.version_info < (1, 8):\n        app.add_role('math', math_role)\n        app.add_directive('math', MathDirective)\n\n    metadata = {'parallel_read_safe': True, 'parallel_write_safe': True}\n    return metadata"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/__init__/basename",
          "name": "basename",
          "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile.__init__.basename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/__init__/dirname",
          "name": "dirname",
          "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile.__init__.dirname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, basename, dirname):\n        self.basename = basename\n        self.dirname = dirname\n        self.formats = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/filename",
      "name": "filename",
      "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile.filename",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/filename/self",
          "name": "self",
          "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile.filename.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/filename/format",
          "name": "format",
          "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile.filename.format",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def filename(self, format):\n        return os.path.join(self.dirname, \"%s.%s\" % (self.basename, format))"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/filenames",
      "name": "filenames",
      "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile.filenames",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/ImageFile/filenames/self",
          "name": "self",
          "qname": "lib.matplotlib.sphinxext.plot_directive.ImageFile.filenames.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def filenames(self):\n        return [self.filename(fmt) for fmt in self.formats]"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/PlotDirective/run",
      "name": "run",
      "qname": "lib.matplotlib.sphinxext.plot_directive.PlotDirective.run",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/PlotDirective/run/self",
          "name": "self",
          "qname": "lib.matplotlib.sphinxext.plot_directive.PlotDirective.run.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Run the plot directive.",
      "docstring": "Run the plot directive.",
      "code": "    def run(self):\n        \"\"\"Run the plot directive.\"\"\"\n        try:\n            return run(self.arguments, self.content, self.options,\n                       self.state_machine, self.state, self.lineno)\n        except Exception as e:\n            raise self.error(str(e))"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/clear_state",
      "name": "clear_state",
      "qname": "lib.matplotlib.sphinxext.plot_directive.clear_state",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/clear_state/plot_rcparams",
          "name": "plot_rcparams",
          "qname": "lib.matplotlib.sphinxext.plot_directive.clear_state.plot_rcparams",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/clear_state/close",
          "name": "close",
          "qname": "lib.matplotlib.sphinxext.plot_directive.clear_state.close",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def clear_state(plot_rcparams, close=True):\n    if close:\n        plt.close('all')\n    matplotlib.rc_file_defaults()\n    matplotlib.rcParams.update(plot_rcparams)"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/contains_doctest",
      "name": "contains_doctest",
      "qname": "lib.matplotlib.sphinxext.plot_directive.contains_doctest",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/contains_doctest/text",
          "name": "text",
          "qname": "lib.matplotlib.sphinxext.plot_directive.contains_doctest.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def contains_doctest(text):\n    try:\n        # check if it's valid Python as-is\n        compile(text, '<string>', 'exec')\n        return False\n    except SyntaxError:\n        pass\n    r = re.compile(r'^\\s*>>>', re.M)\n    m = r.search(text)\n    return bool(m)"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/get_plot_formats",
      "name": "get_plot_formats",
      "qname": "lib.matplotlib.sphinxext.plot_directive.get_plot_formats",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/get_plot_formats/config",
          "name": "config",
          "qname": "lib.matplotlib.sphinxext.plot_directive.get_plot_formats.config",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_plot_formats(config):\n    default_dpi = {'png': 80, 'hires.png': 200, 'pdf': 200}\n    formats = []\n    plot_formats = config.plot_formats\n    for fmt in plot_formats:\n        if isinstance(fmt, str):\n            if ':' in fmt:\n                suffix, dpi = fmt.split(':')\n                formats.append((str(suffix), int(dpi)))\n            else:\n                formats.append((fmt, default_dpi.get(fmt, 80)))\n        elif isinstance(fmt, (tuple, list)) and len(fmt) == 2:\n            formats.append((str(fmt[0]), int(fmt[1])))\n        else:\n            raise PlotError('invalid image format \"%r\" in plot_formats' % fmt)\n    return formats"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/mark_plot_labels",
      "name": "mark_plot_labels",
      "qname": "lib.matplotlib.sphinxext.plot_directive.mark_plot_labels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/mark_plot_labels/app",
          "name": "app",
          "qname": "lib.matplotlib.sphinxext.plot_directive.mark_plot_labels.app",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/mark_plot_labels/document",
          "name": "document",
          "qname": "lib.matplotlib.sphinxext.plot_directive.mark_plot_labels.document",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "To make plots referenceable, we need to move the reference from the\n\"htmlonly\" (or \"latexonly\") node to the actual figure node itself.",
      "docstring": "To make plots referenceable, we need to move the reference from the\n\"htmlonly\" (or \"latexonly\") node to the actual figure node itself.",
      "code": "def mark_plot_labels(app, document):\n    \"\"\"\n    To make plots referenceable, we need to move the reference from the\n    \"htmlonly\" (or \"latexonly\") node to the actual figure node itself.\n    \"\"\"\n    for name, explicit in document.nametypes.items():\n        if not explicit:\n            continue\n        labelid = document.nameids[name]\n        if labelid is None:\n            continue\n        node = document.ids[labelid]\n        if node.tagname in ('html_only', 'latex_only'):\n            for n in node:\n                if n.tagname == 'figure':\n                    sectname = name\n                    for c in n:\n                        if c.tagname == 'caption':\n                            sectname = c.astext()\n                            break\n\n                    node['ids'].remove(labelid)\n                    node['names'].remove(name)\n                    n['ids'].append(labelid)\n                    n['names'].append(name)\n                    document.settings.env.labels[name] = \\\n                        document.settings.env.docname, labelid, sectname\n                    break"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/out_of_date",
      "name": "out_of_date",
      "qname": "lib.matplotlib.sphinxext.plot_directive.out_of_date",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/out_of_date/original",
          "name": "original",
          "qname": "lib.matplotlib.sphinxext.plot_directive.out_of_date.original",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/out_of_date/derived",
          "name": "derived",
          "qname": "lib.matplotlib.sphinxext.plot_directive.out_of_date.derived",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/out_of_date/includes",
          "name": "includes",
          "qname": "lib.matplotlib.sphinxext.plot_directive.out_of_date.includes",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether *derived* is out-of-date relative to *original* or any of\nthe RST files included in it using the RST include directive (*includes*).\n*derived* and *original* are full paths, and *includes* is optionally a\nlist of full paths which may have been included in the *original*.",
      "docstring": "Return whether *derived* is out-of-date relative to *original* or any of\nthe RST files included in it using the RST include directive (*includes*).\n*derived* and *original* are full paths, and *includes* is optionally a\nlist of full paths which may have been included in the *original*.",
      "code": "def out_of_date(original, derived, includes=None):\n    \"\"\"\n    Return whether *derived* is out-of-date relative to *original* or any of\n    the RST files included in it using the RST include directive (*includes*).\n    *derived* and *original* are full paths, and *includes* is optionally a\n    list of full paths which may have been included in the *original*.\n    \"\"\"\n    if not os.path.exists(derived):\n        return True\n\n    if includes is None:\n        includes = []\n    files_to_check = [original, *includes]\n\n    def out_of_date_one(original, derived_mtime):\n        return (os.path.exists(original) and\n                derived_mtime < os.stat(original).st_mtime)\n\n    derived_mtime = os.stat(derived).st_mtime\n    return any(out_of_date_one(f, derived_mtime) for f in files_to_check)"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures",
      "name": "render_figures",
      "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/code",
          "name": "code",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/code_path",
          "name": "code_path",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.code_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/output_dir",
          "name": "output_dir",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.output_dir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/output_base",
          "name": "output_base",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.output_base",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/context",
          "name": "context",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.context",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/function_name",
          "name": "function_name",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.function_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/config",
          "name": "config",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.config",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/context_reset",
          "name": "context_reset",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.context_reset",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/close_figs",
          "name": "close_figs",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.close_figs",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/render_figures/code_includes",
          "name": "code_includes",
          "qname": "lib.matplotlib.sphinxext.plot_directive.render_figures.code_includes",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Run a pyplot script and save the images in *output_dir*.\n\nSave the images under *output_dir* with file names derived from\n*output_base*",
      "docstring": "Run a pyplot script and save the images in *output_dir*.\n\nSave the images under *output_dir* with file names derived from\n*output_base*",
      "code": "def render_figures(code, code_path, output_dir, output_base, context,\n                   function_name, config, context_reset=False,\n                   close_figs=False,\n                   code_includes=None):\n    \"\"\"\n    Run a pyplot script and save the images in *output_dir*.\n\n    Save the images under *output_dir* with file names derived from\n    *output_base*\n    \"\"\"\n    formats = get_plot_formats(config)\n\n    # Try to determine if all images already exist\n\n    is_doctest, code_pieces = _split_code_at_show(code)\n\n    # Look for single-figure output files first\n    all_exists = True\n    img = ImageFile(output_base, output_dir)\n    for format, dpi in formats:\n        if context or out_of_date(code_path, img.filename(format),\n                                  includes=code_includes):\n            all_exists = False\n            break\n        img.formats.append(format)\n\n    if all_exists:\n        return [(code, [img])]\n\n    # Then look for multi-figure output files\n    results = []\n    all_exists = True\n    for i, code_piece in enumerate(code_pieces):\n        images = []\n        for j in itertools.count():\n            if len(code_pieces) > 1:\n                img = ImageFile('%s_%02d_%02d' % (output_base, i, j),\n                                output_dir)\n            else:\n                img = ImageFile('%s_%02d' % (output_base, j), output_dir)\n            for fmt, dpi in formats:\n                if context or out_of_date(code_path, img.filename(fmt),\n                                          includes=code_includes):\n                    all_exists = False\n                    break\n                img.formats.append(fmt)\n\n            # assume that if we have one, we have them all\n            if not all_exists:\n                all_exists = (j > 0)\n                break\n            images.append(img)\n        if not all_exists:\n            break\n        results.append((code_piece, images))\n\n    if all_exists:\n        return results\n\n    # We didn't find the files, so build them\n\n    results = []\n    ns = plot_context if context else {}\n\n    if context_reset:\n        clear_state(config.plot_rcparams)\n        plot_context.clear()\n\n    close_figs = not context or close_figs\n\n    for i, code_piece in enumerate(code_pieces):\n\n        if not context or config.plot_apply_rcparams:\n            clear_state(config.plot_rcparams, close_figs)\n        elif close_figs:\n            plt.close('all')\n\n        _run_code(doctest.script_from_examples(code_piece) if is_doctest\n                  else code_piece,\n                  code_path, ns, function_name)\n\n        images = []\n        fig_managers = _pylab_helpers.Gcf.get_all_fig_managers()\n        for j, figman in enumerate(fig_managers):\n            if len(fig_managers) == 1 and len(code_pieces) == 1:\n                img = ImageFile(output_base, output_dir)\n            elif len(code_pieces) == 1:\n                img = ImageFile(\"%s_%02d\" % (output_base, j), output_dir)\n            else:\n                img = ImageFile(\"%s_%02d_%02d\" % (output_base, i, j),\n                                output_dir)\n            images.append(img)\n            for fmt, dpi in formats:\n                try:\n                    figman.canvas.figure.savefig(img.filename(fmt), dpi=dpi)\n                except Exception as err:\n                    raise PlotError(traceback.format_exc()) from err\n                img.formats.append(fmt)\n\n        results.append((code_piece, images))\n\n    if not context or config.plot_apply_rcparams:\n        clear_state(config.plot_rcparams, close=not context)\n\n    return results"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run",
      "name": "run",
      "qname": "lib.matplotlib.sphinxext.plot_directive.run",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run/arguments",
          "name": "arguments",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run.arguments",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run/content",
          "name": "content",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run/options",
          "name": "options",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run.options",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run/state_machine",
          "name": "state_machine",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run.state_machine",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run/state",
          "name": "state",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run/lineno",
          "name": "lineno",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run.lineno",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def run(arguments, content, options, state_machine, state, lineno):\n    document = state_machine.document\n    config = document.settings.env.config\n    nofigs = 'nofigs' in options\n\n    formats = get_plot_formats(config)\n    default_fmt = formats[0][0]\n\n    options.setdefault('include-source', config.plot_include_source)\n    if 'class' in options:\n        # classes are parsed into a list of string, and output by simply\n        # printing the list, abusing the fact that RST guarantees to strip\n        # non-conforming characters\n        options['class'] = ['plot-directive'] + options['class']\n    else:\n        options.setdefault('class', ['plot-directive'])\n    keep_context = 'context' in options\n    context_opt = None if not keep_context else options['context']\n\n    rst_file = document.attributes['source']\n    rst_dir = os.path.dirname(rst_file)\n\n    if len(arguments):\n        if not config.plot_basedir:\n            source_file_name = os.path.join(setup.app.builder.srcdir,\n                                            directives.uri(arguments[0]))\n        else:\n            source_file_name = os.path.join(setup.confdir, config.plot_basedir,\n                                            directives.uri(arguments[0]))\n\n        # If there is content, it will be passed as a caption.\n        caption = '\\n'.join(content)\n\n        # Enforce unambiguous use of captions.\n        if \"caption\" in options:\n            if caption:\n                raise ValueError(\n                    'Caption specified in both content and options.'\n                    ' Please remove ambiguity.'\n                )\n            # Use caption option\n            caption = options[\"caption\"]\n\n        # If the optional function name is provided, use it\n        if len(arguments) == 2:\n            function_name = arguments[1]\n        else:\n            function_name = None\n\n        code = Path(source_file_name).read_text(encoding='utf-8')\n        output_base = os.path.basename(source_file_name)\n    else:\n        source_file_name = rst_file\n        code = textwrap.dedent(\"\\n\".join(map(str, content)))\n        counter = document.attributes.get('_plot_counter', 0) + 1\n        document.attributes['_plot_counter'] = counter\n        base, ext = os.path.splitext(os.path.basename(source_file_name))\n        output_base = '%s-%d.py' % (base, counter)\n        function_name = None\n        caption = options.get('caption', '')\n\n    base, source_ext = os.path.splitext(output_base)\n    if source_ext in ('.py', '.rst', '.txt'):\n        output_base = base\n    else:\n        source_ext = ''\n\n    # ensure that LaTeX includegraphics doesn't choke in foo.bar.pdf filenames\n    output_base = output_base.replace('.', '-')\n\n    # is it in doctest format?\n    is_doctest = contains_doctest(code)\n    if 'format' in options:\n        if options['format'] == 'python':\n            is_doctest = False\n        else:\n            is_doctest = True\n\n    # determine output directory name fragment\n    source_rel_name = relpath(source_file_name, setup.confdir)\n    source_rel_dir = os.path.dirname(source_rel_name).lstrip(os.path.sep)\n\n    # build_dir: where to place output files (temporarily)\n    build_dir = os.path.join(os.path.dirname(setup.app.doctreedir),\n                             'plot_directive',\n                             source_rel_dir)\n    # get rid of .. in paths, also changes pathsep\n    # see note in Python docs for warning about symbolic links on Windows.\n    # need to compare source and dest paths at end\n    build_dir = os.path.normpath(build_dir)\n    os.makedirs(build_dir, exist_ok=True)\n\n    # output_dir: final location in the builder's directory\n    dest_dir = os.path.abspath(os.path.join(setup.app.builder.outdir,\n                                            source_rel_dir))\n    os.makedirs(dest_dir, exist_ok=True)\n\n    # how to link to files from the RST file\n    dest_dir_link = os.path.join(relpath(setup.confdir, rst_dir),\n                                 source_rel_dir).replace(os.path.sep, '/')\n    try:\n        build_dir_link = relpath(build_dir, rst_dir).replace(os.path.sep, '/')\n    except ValueError:\n        # on Windows, relpath raises ValueError when path and start are on\n        # different mounts/drives\n        build_dir_link = build_dir\n    source_link = dest_dir_link + '/' + output_base + source_ext\n\n    # get list of included rst files so that the output is updated when any\n    # plots in the included files change. These attributes are modified by the\n    # include directive (see the docutils.parsers.rst.directives.misc module).\n    try:\n        source_file_includes = [os.path.join(os.getcwd(), t[0])\n                                for t in state.document.include_log]\n    except AttributeError:\n        # the document.include_log attribute only exists in docutils >=0.17,\n        # before that we need to inspect the state machine\n        possible_sources = {os.path.join(setup.confdir, t[0])\n                            for t in state_machine.input_lines.items}\n        source_file_includes = [f for f in possible_sources\n                                if os.path.isfile(f)]\n    # remove the source file itself from the includes\n    try:\n        source_file_includes.remove(source_file_name)\n    except ValueError:\n        pass\n\n    # make figures\n    try:\n        results = render_figures(code,\n                                 source_file_name,\n                                 build_dir,\n                                 output_base,\n                                 keep_context,\n                                 function_name,\n                                 config,\n                                 context_reset=context_opt == 'reset',\n                                 close_figs=context_opt == 'close-figs',\n                                 code_includes=source_file_includes)\n        errors = []\n    except PlotError as err:\n        reporter = state.memo.reporter\n        sm = reporter.system_message(\n            2, \"Exception occurred in plotting {}\\n from {}:\\n{}\".format(\n                output_base, source_file_name, err),\n            line=lineno)\n        results = [(code, [])]\n        errors = [sm]\n\n    # Properly indent the caption\n    caption = '\\n' + '\\n'.join('      ' + line.strip()\n                               for line in caption.split('\\n'))\n\n    # generate output restructuredtext\n    total_lines = []\n    for j, (code_piece, images) in enumerate(results):\n        if options['include-source']:\n            if is_doctest:\n                lines = ['', *code_piece.splitlines()]\n            else:\n                lines = ['.. code-block:: python', '',\n                         *textwrap.indent(code_piece, '    ').splitlines()]\n            source_code = \"\\n\".join(lines)\n        else:\n            source_code = \"\"\n\n        if nofigs:\n            images = []\n\n        opts = [\n            ':%s: %s' % (key, val) for key, val in options.items()\n            if key in ('alt', 'height', 'width', 'scale', 'align', 'class')]\n\n        # Not-None src_link signals the need for a source link in the generated\n        # html\n        if j == 0 and config.plot_html_show_source_link:\n            src_link = source_link\n        else:\n            src_link = None\n\n        result = jinja2.Template(config.plot_template or TEMPLATE).render(\n            default_fmt=default_fmt,\n            dest_dir=dest_dir_link,\n            build_dir=build_dir_link,\n            source_link=src_link,\n            multi_image=len(images) > 1,\n            options=opts,\n            images=images,\n            source_code=source_code,\n            html_show_formats=config.plot_html_show_formats and len(images),\n            caption=caption)\n\n        total_lines.extend(result.split(\"\\n\"))\n        total_lines.extend(\"\\n\")\n\n    if total_lines:\n        state_machine.insert_input(total_lines, source=source_file_name)\n\n    # copy image files to builder's output directory, if necessary\n    Path(dest_dir).mkdir(parents=True, exist_ok=True)\n\n    for code_piece, images in results:\n        for img in images:\n            for fn in img.filenames():\n                destimg = os.path.join(dest_dir, os.path.basename(fn))\n                if fn != destimg:\n                    shutil.copyfile(fn, destimg)\n\n    # copy script (if necessary)\n    if config.plot_html_show_source_link:\n        Path(dest_dir, output_base + source_ext).write_text(\n            doctest.script_from_examples(code)\n            if source_file_name == rst_file and is_doctest\n            else code,\n            encoding='utf-8')\n\n    return errors"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run_code",
      "name": "run_code",
      "qname": "lib.matplotlib.sphinxext.plot_directive.run_code",
      "decorators": [
        "_api.deprecated('3.5')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run_code/code",
          "name": "code",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run_code.code",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run_code/code_path",
          "name": "code_path",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run_code.code_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run_code/ns",
          "name": "ns",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run_code.ns",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/run_code/function_name",
          "name": "function_name",
          "qname": "lib.matplotlib.sphinxext.plot_directive.run_code.function_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Import a Python module from a path, and run the function given by\nname, if function_name is not None.",
      "docstring": "Import a Python module from a path, and run the function given by\nname, if function_name is not None.",
      "code": "@_api.deprecated(\"3.5\")\ndef run_code(code, code_path, ns=None, function_name=None):\n    \"\"\"\n    Import a Python module from a path, and run the function given by\n    name, if function_name is not None.\n    \"\"\"\n    _run_code(unescape_doctest(code), code_path, ns, function_name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/setup",
      "name": "setup",
      "qname": "lib.matplotlib.sphinxext.plot_directive.setup",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/setup/app",
          "name": "app",
          "qname": "lib.matplotlib.sphinxext.plot_directive.setup.app",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def setup(app):\n    setup.app = app\n    setup.config = app.config\n    setup.confdir = app.confdir\n    app.add_directive('plot', PlotDirective)\n    app.add_config_value('plot_pre_code', None, True)\n    app.add_config_value('plot_include_source', False, True)\n    app.add_config_value('plot_html_show_source_link', True, True)\n    app.add_config_value('plot_formats', ['png', 'hires.png', 'pdf'], True)\n    app.add_config_value('plot_basedir', None, True)\n    app.add_config_value('plot_html_show_formats', True, True)\n    app.add_config_value('plot_rcparams', {}, True)\n    app.add_config_value('plot_apply_rcparams', False, True)\n    app.add_config_value('plot_working_directory', None, True)\n    app.add_config_value('plot_template', None, True)\n    app.connect('doctree-read', mark_plot_labels)\n    app.add_css_file('plot_directive.css')\n    app.connect('build-finished', _copy_css_file)\n    metadata = {'parallel_read_safe': True, 'parallel_write_safe': True,\n                'version': matplotlib.__version__}\n    return metadata"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/split_code_at_show",
      "name": "split_code_at_show",
      "qname": "lib.matplotlib.sphinxext.plot_directive.split_code_at_show",
      "decorators": [
        "_api.deprecated('3.5')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/split_code_at_show/text",
          "name": "text",
          "qname": "lib.matplotlib.sphinxext.plot_directive.split_code_at_show.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Split code at plt.show().",
      "docstring": "Split code at plt.show().",
      "code": "@_api.deprecated(\"3.5\")\ndef split_code_at_show(text):\n    \"\"\"Split code at plt.show().\"\"\"\n    return _split_code_at_show(text)[1]"
    },
    {
      "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/unescape_doctest",
      "name": "unescape_doctest",
      "qname": "lib.matplotlib.sphinxext.plot_directive.unescape_doctest",
      "decorators": [
        "_api.deprecated('3.5', alternative='doctest.script_from_examples')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.sphinxext.plot_directive/unescape_doctest/text",
          "name": "text",
          "qname": "lib.matplotlib.sphinxext.plot_directive.unescape_doctest.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Extract code from a piece of text, which contains either Python code\nor doctests.",
      "docstring": "Extract code from a piece of text, which contains either Python code\nor doctests.",
      "code": "@_api.deprecated(\"3.5\", alternative=\"doctest.script_from_examples\")\ndef unescape_doctest(text):\n    \"\"\"\n    Extract code from a piece of text, which contains either Python code\n    or doctests.\n    \"\"\"\n    if not contains_doctest(text):\n        return text\n    code = \"\"\n    for line in text.split(\"\\n\"):\n        m = re.match(r'^\\s*(>>>|\\.\\.\\.) (.*)$', line)\n        if m:\n            code += m.group(2) + \"\\n\"\n        elif line.strip():\n            code += \"# \" + line.strip() + \"\\n\"\n        else:\n            code += \"\\n\"\n    return code"
    },
    {
      "id": "matplotlib/lib.matplotlib.style.core/context",
      "name": "context",
      "qname": "lib.matplotlib.style.core.context",
      "decorators": [
        "contextlib.contextmanager"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.style.core/context/style",
          "name": "style",
          "qname": "lib.matplotlib.style.core.context.style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str, dict, Path or list",
            "default_value": "",
            "description": "A style specification. Valid options are:\n\n+------+-------------------------------------------------------------+\n| str  | The name of a style or a path/URL to a style file. For a    |\n|      | list of available style names, see `.style.available`.      |\n+------+-------------------------------------------------------------+\n| dict | Dictionary with valid key/value pairs for                   |\n|      | `matplotlib.rcParams`.                                      |\n+------+-------------------------------------------------------------+\n| Path | A path-like object which is a path to a style file.         |\n+------+-------------------------------------------------------------+\n| list | A list of style specifiers (str, Path or dict) applied from |\n|      | first to last in the list.                                  |\n+------+-------------------------------------------------------------+"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "Path"
              },
              {
                "kind": "NamedType",
                "name": "list"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.style.core/context/after_reset",
          "name": "after_reset",
          "qname": "lib.matplotlib.style.core.context.after_reset",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "If True, apply style after resetting settings to their defaults;\notherwise, apply style on top of the current settings."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Context manager for using style settings temporarily.",
      "docstring": "Context manager for using style settings temporarily.\n\nParameters\n----------\nstyle : str, dict, Path or list\n    A style specification. Valid options are:\n\n    +------+-------------------------------------------------------------+\n    | str  | The name of a style or a path/URL to a style file. For a    |\n    |      | list of available style names, see `.style.available`.      |\n    +------+-------------------------------------------------------------+\n    | dict | Dictionary with valid key/value pairs for                   |\n    |      | `matplotlib.rcParams`.                                      |\n    +------+-------------------------------------------------------------+\n    | Path | A path-like object which is a path to a style file.         |\n    +------+-------------------------------------------------------------+\n    | list | A list of style specifiers (str, Path or dict) applied from |\n    |      | first to last in the list.                                  |\n    +------+-------------------------------------------------------------+\n\nafter_reset : bool\n    If True, apply style after resetting settings to their defaults;\n    otherwise, apply style on top of the current settings.",
      "code": "@contextlib.contextmanager\ndef context(style, after_reset=False):\n    \"\"\"\n    Context manager for using style settings temporarily.\n\n    Parameters\n    ----------\n    style : str, dict, Path or list\n        A style specification. Valid options are:\n\n        +------+-------------------------------------------------------------+\n        | str  | The name of a style or a path/URL to a style file. For a    |\n        |      | list of available style names, see `.style.available`.      |\n        +------+-------------------------------------------------------------+\n        | dict | Dictionary with valid key/value pairs for                   |\n        |      | `matplotlib.rcParams`.                                      |\n        +------+-------------------------------------------------------------+\n        | Path | A path-like object which is a path to a style file.         |\n        +------+-------------------------------------------------------------+\n        | list | A list of style specifiers (str, Path or dict) applied from |\n        |      | first to last in the list.                                  |\n        +------+-------------------------------------------------------------+\n\n    after_reset : bool\n        If True, apply style after resetting settings to their defaults;\n        otherwise, apply style on top of the current settings.\n    \"\"\"\n    with mpl.rc_context():\n        if after_reset:\n            mpl.rcdefaults()\n        use(style)\n        yield"
    },
    {
      "id": "matplotlib/lib.matplotlib.style.core/iter_user_libraries",
      "name": "iter_user_libraries",
      "qname": "lib.matplotlib.style.core.iter_user_libraries",
      "decorators": [
        "_api.deprecated('3.5')"
      ],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.5\")\ndef iter_user_libraries():\n    for stylelib_path in USER_LIBRARY_PATHS:\n        stylelib_path = os.path.expanduser(stylelib_path)\n        if os.path.exists(stylelib_path) and os.path.isdir(stylelib_path):\n            yield stylelib_path"
    },
    {
      "id": "matplotlib/lib.matplotlib.style.core/load_base_library",
      "name": "load_base_library",
      "qname": "lib.matplotlib.style.core.load_base_library",
      "decorators": [
        "_api.deprecated('3.5')"
      ],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Load style library defined in this package.",
      "docstring": "Load style library defined in this package.",
      "code": "@_api.deprecated(\"3.5\")\ndef load_base_library():\n    \"\"\"Load style library defined in this package.\"\"\"\n    library = read_style_directory(BASE_LIBRARY_PATH)\n    return library"
    },
    {
      "id": "matplotlib/lib.matplotlib.style.core/read_style_directory",
      "name": "read_style_directory",
      "qname": "lib.matplotlib.style.core.read_style_directory",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.style.core/read_style_directory/style_dir",
          "name": "style_dir",
          "qname": "lib.matplotlib.style.core.read_style_directory.style_dir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return dictionary of styles defined in *style_dir*.",
      "docstring": "Return dictionary of styles defined in *style_dir*.",
      "code": "def read_style_directory(style_dir):\n    \"\"\"Return dictionary of styles defined in *style_dir*.\"\"\"\n    styles = dict()\n    for path in Path(style_dir).glob(f\"*.{STYLE_EXTENSION}\"):\n        with warnings.catch_warnings(record=True) as warns:\n            styles[path.stem] = rc_params_from_file(\n                path, use_default_template=False)\n        for w in warns:\n            _log.warning('In %s: %s', path, w.message)\n    return styles"
    },
    {
      "id": "matplotlib/lib.matplotlib.style.core/reload_library",
      "name": "reload_library",
      "qname": "lib.matplotlib.style.core.reload_library",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Reload the style library.",
      "docstring": "Reload the style library.",
      "code": "def reload_library():\n    \"\"\"Reload the style library.\"\"\"\n    global library\n    library = update_user_library(_base_library)\n    available[:] = sorted(library.keys())"
    },
    {
      "id": "matplotlib/lib.matplotlib.style.core/update_nested_dict",
      "name": "update_nested_dict",
      "qname": "lib.matplotlib.style.core.update_nested_dict",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.style.core/update_nested_dict/main_dict",
          "name": "main_dict",
          "qname": "lib.matplotlib.style.core.update_nested_dict.main_dict",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.style.core/update_nested_dict/new_dict",
          "name": "new_dict",
          "qname": "lib.matplotlib.style.core.update_nested_dict.new_dict",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Update nested dict (only level of nesting) with new values.\n\nUnlike `dict.update`, this assumes that the values of the parent dict are\ndicts (or dict-like), so you shouldn't replace the nested dict if it\nalready exists. Instead you should update the sub-dict.",
      "docstring": "Update nested dict (only level of nesting) with new values.\n\nUnlike `dict.update`, this assumes that the values of the parent dict are\ndicts (or dict-like), so you shouldn't replace the nested dict if it\nalready exists. Instead you should update the sub-dict.",
      "code": "def update_nested_dict(main_dict, new_dict):\n    \"\"\"\n    Update nested dict (only level of nesting) with new values.\n\n    Unlike `dict.update`, this assumes that the values of the parent dict are\n    dicts (or dict-like), so you shouldn't replace the nested dict if it\n    already exists. Instead you should update the sub-dict.\n    \"\"\"\n    # update named styles specified by user\n    for name, rc_dict in new_dict.items():\n        main_dict.setdefault(name, {}).update(rc_dict)\n    return main_dict"
    },
    {
      "id": "matplotlib/lib.matplotlib.style.core/update_user_library",
      "name": "update_user_library",
      "qname": "lib.matplotlib.style.core.update_user_library",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.style.core/update_user_library/library",
          "name": "library",
          "qname": "lib.matplotlib.style.core.update_user_library.library",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Update style library with user-defined rc files.",
      "docstring": "Update style library with user-defined rc files.",
      "code": "def update_user_library(library):\n    \"\"\"Update style library with user-defined rc files.\"\"\"\n    for stylelib_path in map(os.path.expanduser, USER_LIBRARY_PATHS):\n        styles = read_style_directory(stylelib_path)\n        update_nested_dict(library, styles)\n    return library"
    },
    {
      "id": "matplotlib/lib.matplotlib.style.core/use",
      "name": "use",
      "qname": "lib.matplotlib.style.core.use",
      "decorators": [
        "_docstring.Substitution('\\n'.join(map('- {}'.format, sorted(STYLE_BLACKLIST, key=str.lower))))"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.style.core/use/style",
          "name": "style",
          "qname": "lib.matplotlib.style.core.use.style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str, dict, Path or list",
            "default_value": "",
            "description": "A style specification. Valid options are:\n\n+------+-------------------------------------------------------------+\n| str  | The name of a style or a path/URL to a style file. For a    |\n|      | list of available style names, see `.style.available`.      |\n+------+-------------------------------------------------------------+\n| dict | Dictionary with valid key/value pairs for                   |\n|      | `matplotlib.rcParams`.                                      |\n+------+-------------------------------------------------------------+\n| Path | A path-like object which is a path to a style file.         |\n+------+-------------------------------------------------------------+\n| list | A list of style specifiers (str, Path or dict) applied from |\n|      | first to last in the list.                                  |\n+------+-------------------------------------------------------------+"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "Path"
              },
              {
                "kind": "NamedType",
                "name": "list"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use Matplotlib style settings from a style specification.\n\nThe style name of 'default' is reserved for reverting back to\nthe default style settings.\n\n.. note::\n\n   This updates the `.rcParams` with the settings from the style.\n   `.rcParams` not defined in the style are kept.",
      "docstring": "Use Matplotlib style settings from a style specification.\n\nThe style name of 'default' is reserved for reverting back to\nthe default style settings.\n\n.. note::\n\n   This updates the `.rcParams` with the settings from the style.\n   `.rcParams` not defined in the style are kept.\n\nParameters\n----------\nstyle : str, dict, Path or list\n    A style specification. Valid options are:\n\n    +------+-------------------------------------------------------------+\n    | str  | The name of a style or a path/URL to a style file. For a    |\n    |      | list of available style names, see `.style.available`.      |\n    +------+-------------------------------------------------------------+\n    | dict | Dictionary with valid key/value pairs for                   |\n    |      | `matplotlib.rcParams`.                                      |\n    +------+-------------------------------------------------------------+\n    | Path | A path-like object which is a path to a style file.         |\n    +------+-------------------------------------------------------------+\n    | list | A list of style specifiers (str, Path or dict) applied from |\n    |      | first to last in the list.                                  |\n    +------+-------------------------------------------------------------+\n\nNotes\n-----\nThe following `.rcParams` are not related to style and will be ignored if\nfound in a style specification:\n\n%s",
      "code": "@_docstring.Substitution(\n    \"\\n\".join(map(\"- {}\".format, sorted(STYLE_BLACKLIST, key=str.lower)))\n)\ndef use(style):\n    \"\"\"\n    Use Matplotlib style settings from a style specification.\n\n    The style name of 'default' is reserved for reverting back to\n    the default style settings.\n\n    .. note::\n\n       This updates the `.rcParams` with the settings from the style.\n       `.rcParams` not defined in the style are kept.\n\n    Parameters\n    ----------\n    style : str, dict, Path or list\n        A style specification. Valid options are:\n\n        +------+-------------------------------------------------------------+\n        | str  | The name of a style or a path/URL to a style file. For a    |\n        |      | list of available style names, see `.style.available`.      |\n        +------+-------------------------------------------------------------+\n        | dict | Dictionary with valid key/value pairs for                   |\n        |      | `matplotlib.rcParams`.                                      |\n        +------+-------------------------------------------------------------+\n        | Path | A path-like object which is a path to a style file.         |\n        +------+-------------------------------------------------------------+\n        | list | A list of style specifiers (str, Path or dict) applied from |\n        |      | first to last in the list.                                  |\n        +------+-------------------------------------------------------------+\n\n    Notes\n    -----\n    The following `.rcParams` are not related to style and will be ignored if\n    found in a style specification:\n\n    %s\n    \"\"\"\n    if isinstance(style, (str, Path)) or hasattr(style, 'keys'):\n        # If name is a single str, Path or dict, make it a single element list.\n        styles = [style]\n    else:\n        styles = style\n\n    style_alias = {'mpl20': 'default', 'mpl15': 'classic'}\n\n    def fix_style(s):\n        if isinstance(s, str):\n            s = style_alias.get(s, s)\n            if s in [\n                \"seaborn\",\n                \"seaborn-bright\",\n                \"seaborn-colorblind\",\n                \"seaborn-dark\",\n                \"seaborn-darkgrid\",\n                \"seaborn-dark-palette\",\n                \"seaborn-deep\",\n                \"seaborn-muted\",\n                \"seaborn-notebook\",\n                \"seaborn-paper\",\n                \"seaborn-pastel\",\n                \"seaborn-poster\",\n                \"seaborn-talk\",\n                \"seaborn-ticks\",\n                \"seaborn-white\",\n                \"seaborn-whitegrid\",\n            ]:\n                _api.warn_deprecated(\n                    \"3.6\", message=\"The seaborn styles shipped by Matplotlib \"\n                    \"are deprecated since %(since)s, as they no longer \"\n                    \"correspond to the styles shipped by seaborn. However, \"\n                    \"they will remain available as 'seaborn-v0_8-<style>'. \"\n                    \"Alternatively, directly use the seaborn API instead.\")\n                s = s.replace(\"seaborn\", \"seaborn-v0_8\")\n        return s\n\n    for style in map(fix_style, styles):\n        if not isinstance(style, (str, Path)):\n            _apply_style(style)\n        elif style == 'default':\n            # Deprecation warnings were already handled when creating\n            # rcParamsDefault, no need to reemit them here.\n            with _api.suppress_matplotlib_deprecation_warning():\n                _apply_style(rcParamsDefault, warn=False)\n        elif style in library:\n            _apply_style(library[style])\n        else:\n            try:\n                rc = rc_params_from_file(style, use_default_template=False)\n                _apply_style(rc)\n            except IOError as err:\n                raise IOError(\n                    \"{!r} not found in the style library and input is not a \"\n                    \"valid URL or path; see `style.available` for list of \"\n                    \"available styles\".format(style)) from err"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.compare/calculate_rms",
      "name": "calculate_rms",
      "qname": "lib.matplotlib.testing.compare.calculate_rms",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/calculate_rms/expected_image",
          "name": "expected_image",
          "qname": "lib.matplotlib.testing.compare.calculate_rms.expected_image",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/calculate_rms/actual_image",
          "name": "actual_image",
          "qname": "lib.matplotlib.testing.compare.calculate_rms.actual_image",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Calculate the per-pixel errors, then compute the root mean square error.",
      "docstring": "Calculate the per-pixel errors, then compute the root mean square error.",
      "code": "def calculate_rms(expected_image, actual_image):\n    \"\"\"\n    Calculate the per-pixel errors, then compute the root mean square error.\n    \"\"\"\n    if expected_image.shape != actual_image.shape:\n        raise ImageComparisonFailure(\n            \"Image sizes do not match expected size: {} \"\n            \"actual size {}\".format(expected_image.shape, actual_image.shape))\n    # Convert to float to avoid overflowing finite integer types.\n    return np.sqrt(((expected_image - actual_image).astype(float) ** 2).mean())"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.compare/comparable_formats",
      "name": "comparable_formats",
      "qname": "lib.matplotlib.testing.compare.comparable_formats",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the list of file formats that `.compare_images` can compare\non this system.",
      "docstring": "Return the list of file formats that `.compare_images` can compare\non this system.\n\nReturns\n-------\nlist of str\n    E.g. ``['png', 'pdf', 'svg', 'eps']``.",
      "code": "def comparable_formats():\n    \"\"\"\n    Return the list of file formats that `.compare_images` can compare\n    on this system.\n\n    Returns\n    -------\n    list of str\n        E.g. ``['png', 'pdf', 'svg', 'eps']``.\n\n    \"\"\"\n    return ['png', *converter]"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.compare/compare_images",
      "name": "compare_images",
      "qname": "lib.matplotlib.testing.compare.compare_images",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/compare_images/expected",
          "name": "expected",
          "qname": "lib.matplotlib.testing.compare.compare_images.expected",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The filename of the expected image."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/compare_images/actual",
          "name": "actual",
          "qname": "lib.matplotlib.testing.compare.compare_images.actual",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The filename of the actual image."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/compare_images/tol",
          "name": "tol",
          "qname": "lib.matplotlib.testing.compare.compare_images.tol",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The tolerance (a color value difference, where 255 is the\nmaximal difference).  The test fails if the average pixel\ndifference is greater than this value."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/compare_images/in_decorator",
          "name": "in_decorator",
          "qname": "lib.matplotlib.testing.compare.compare_images.in_decorator",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Determines the output format. If called from image_comparison\ndecorator, this should be True. (default=False)"
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Compare two \"image\" files checking differences within a tolerance.\n\nThe two given filenames may point to files which are convertible to\nPNG via the `.converter` dictionary. The underlying RMS is calculated\nwith the `.calculate_rms` function.",
      "docstring": "Compare two \"image\" files checking differences within a tolerance.\n\nThe two given filenames may point to files which are convertible to\nPNG via the `.converter` dictionary. The underlying RMS is calculated\nwith the `.calculate_rms` function.\n\nParameters\n----------\nexpected : str\n    The filename of the expected image.\nactual : str\n    The filename of the actual image.\ntol : float\n    The tolerance (a color value difference, where 255 is the\n    maximal difference).  The test fails if the average pixel\n    difference is greater than this value.\nin_decorator : bool\n    Determines the output format. If called from image_comparison\n    decorator, this should be True. (default=False)\n\nReturns\n-------\nNone or dict or str\n    Return *None* if the images are equal within the given tolerance.\n\n    If the images differ, the return value depends on  *in_decorator*.\n    If *in_decorator* is true, a dict with the following entries is\n    returned:\n\n    - *rms*: The RMS of the image difference.\n    - *expected*: The filename of the expected image.\n    - *actual*: The filename of the actual image.\n    - *diff_image*: The filename of the difference image.\n    - *tol*: The comparison tolerance.\n\n    Otherwise, a human-readable multi-line string representation of this\n    information is returned.\n\nExamples\n--------\n::\n\n    img1 = \"./baseline/plot.png\"\n    img2 = \"./output/plot.png\"\n    compare_images(img1, img2, 0.001)",
      "code": "def compare_images(expected, actual, tol, in_decorator=False):\n    \"\"\"\n    Compare two \"image\" files checking differences within a tolerance.\n\n    The two given filenames may point to files which are convertible to\n    PNG via the `.converter` dictionary. The underlying RMS is calculated\n    with the `.calculate_rms` function.\n\n    Parameters\n    ----------\n    expected : str\n        The filename of the expected image.\n    actual : str\n        The filename of the actual image.\n    tol : float\n        The tolerance (a color value difference, where 255 is the\n        maximal difference).  The test fails if the average pixel\n        difference is greater than this value.\n    in_decorator : bool\n        Determines the output format. If called from image_comparison\n        decorator, this should be True. (default=False)\n\n    Returns\n    -------\n    None or dict or str\n        Return *None* if the images are equal within the given tolerance.\n\n        If the images differ, the return value depends on  *in_decorator*.\n        If *in_decorator* is true, a dict with the following entries is\n        returned:\n\n        - *rms*: The RMS of the image difference.\n        - *expected*: The filename of the expected image.\n        - *actual*: The filename of the actual image.\n        - *diff_image*: The filename of the difference image.\n        - *tol*: The comparison tolerance.\n\n        Otherwise, a human-readable multi-line string representation of this\n        information is returned.\n\n    Examples\n    --------\n    ::\n\n        img1 = \"./baseline/plot.png\"\n        img2 = \"./output/plot.png\"\n        compare_images(img1, img2, 0.001)\n\n    \"\"\"\n    actual = os.fspath(actual)\n    if not os.path.exists(actual):\n        raise Exception(\"Output image %s does not exist.\" % actual)\n    if os.stat(actual).st_size == 0:\n        raise Exception(\"Output image file %s is empty.\" % actual)\n\n    # Convert the image to png\n    expected = os.fspath(expected)\n    if not os.path.exists(expected):\n        raise IOError('Baseline image %r does not exist.' % expected)\n    extension = expected.split('.')[-1]\n    if extension != 'png':\n        actual = convert(actual, cache=True)\n        expected = convert(expected, cache=True)\n\n    # open the image files\n    expected_image = _load_image(expected)\n    actual_image = _load_image(actual)\n\n    actual_image, expected_image = crop_to_same(\n        actual, actual_image, expected, expected_image)\n\n    diff_image = make_test_filename(actual, 'failed-diff')\n\n    if tol <= 0:\n        if np.array_equal(expected_image, actual_image):\n            return None\n\n    # convert to signed integers, so that the images can be subtracted without\n    # overflow\n    expected_image = expected_image.astype(np.int16)\n    actual_image = actual_image.astype(np.int16)\n\n    rms = calculate_rms(expected_image, actual_image)\n\n    if rms <= tol:\n        return None\n\n    save_diff_image(expected, actual, diff_image)\n\n    results = dict(rms=rms, expected=str(expected),\n                   actual=str(actual), diff=str(diff_image), tol=tol)\n\n    if not in_decorator:\n        # Then the results should be a string suitable for stdout.\n        template = ['Error: Image files did not match.',\n                    'RMS Value: {rms}',\n                    'Expected:  \\n    {expected}',\n                    'Actual:    \\n    {actual}',\n                    'Difference:\\n    {diff}',\n                    'Tolerance: \\n    {tol}', ]\n        results = '\\n  '.join([line.format(**results) for line in template])\n    return results"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.compare/convert",
      "name": "convert",
      "qname": "lib.matplotlib.testing.compare.convert",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/convert/filename",
          "name": "filename",
          "qname": "lib.matplotlib.testing.compare.convert.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/convert/cache",
          "name": "cache",
          "qname": "lib.matplotlib.testing.compare.convert.cache",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert the named file to png; return the name of the created file.\n\nIf *cache* is True, the result of the conversion is cached in\n`matplotlib.get_cachedir() + '/test_cache/'`.  The caching is based on a\nhash of the exact contents of the input file.  Old cache entries are\nautomatically deleted as needed to keep the size of the cache capped to\ntwice the size of all baseline images.",
      "docstring": "Convert the named file to png; return the name of the created file.\n\nIf *cache* is True, the result of the conversion is cached in\n`matplotlib.get_cachedir() + '/test_cache/'`.  The caching is based on a\nhash of the exact contents of the input file.  Old cache entries are\nautomatically deleted as needed to keep the size of the cache capped to\ntwice the size of all baseline images.",
      "code": "def convert(filename, cache):\n    \"\"\"\n    Convert the named file to png; return the name of the created file.\n\n    If *cache* is True, the result of the conversion is cached in\n    `matplotlib.get_cachedir() + '/test_cache/'`.  The caching is based on a\n    hash of the exact contents of the input file.  Old cache entries are\n    automatically deleted as needed to keep the size of the cache capped to\n    twice the size of all baseline images.\n    \"\"\"\n    path = Path(filename)\n    if not path.exists():\n        raise IOError(f\"{path} does not exist\")\n    if path.suffix[1:] not in converter:\n        import pytest\n        pytest.skip(f\"Don't know how to convert {path.suffix} files to png\")\n    newpath = path.parent / f\"{path.stem}_{path.suffix[1:]}.png\"\n\n    # Only convert the file if the destination doesn't already exist or\n    # is out of date.\n    if not newpath.exists() or newpath.stat().st_mtime < path.stat().st_mtime:\n        cache_dir = _get_cache_path() if cache else None\n\n        if cache_dir is not None:\n            _register_conversion_cache_cleaner_once()\n            hash_value = get_file_hash(path)\n            cached_path = cache_dir / (hash_value + newpath.suffix)\n            if cached_path.exists():\n                _log.debug(\"For %s: reusing cached conversion.\", filename)\n                shutil.copyfile(cached_path, newpath)\n                return str(newpath)\n\n        _log.debug(\"For %s: converting to png.\", filename)\n        convert = converter[path.suffix[1:]]\n        if path.suffix == \".svg\":\n            contents = path.read_text()\n            if 'style=\"font:' in contents:\n                # for svg.fonttype = none, we explicitly patch the font search\n                # path so that fonts shipped by Matplotlib are found.\n                convert = _svg_with_matplotlib_fonts_converter\n        convert(path, newpath)\n\n        if cache_dir is not None:\n            _log.debug(\"For %s: caching conversion result.\", filename)\n            shutil.copyfile(newpath, cached_path)\n\n    return str(newpath)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.compare/crop_to_same",
      "name": "crop_to_same",
      "qname": "lib.matplotlib.testing.compare.crop_to_same",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/crop_to_same/actual_path",
          "name": "actual_path",
          "qname": "lib.matplotlib.testing.compare.crop_to_same.actual_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/crop_to_same/actual_image",
          "name": "actual_image",
          "qname": "lib.matplotlib.testing.compare.crop_to_same.actual_image",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/crop_to_same/expected_path",
          "name": "expected_path",
          "qname": "lib.matplotlib.testing.compare.crop_to_same.expected_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/crop_to_same/expected_image",
          "name": "expected_image",
          "qname": "lib.matplotlib.testing.compare.crop_to_same.expected_image",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def crop_to_same(actual_path, actual_image, expected_path, expected_image):\n    # clip the images to the same size -- this is useful only when\n    # comparing eps to pdf\n    if actual_path[-7:-4] == 'eps' and expected_path[-7:-4] == 'pdf':\n        aw, ah, ad = actual_image.shape\n        ew, eh, ed = expected_image.shape\n        actual_image = actual_image[int(aw / 2 - ew / 2):int(\n            aw / 2 + ew / 2), int(ah / 2 - eh / 2):int(ah / 2 + eh / 2)]\n    return actual_image, expected_image"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.compare/get_cache_dir",
      "name": "get_cache_dir",
      "qname": "lib.matplotlib.testing.compare.get_cache_dir",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_cache_dir():\n    return str(_get_cache_path())"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.compare/get_file_hash",
      "name": "get_file_hash",
      "qname": "lib.matplotlib.testing.compare.get_file_hash",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/get_file_hash/path",
          "name": "path",
          "qname": "lib.matplotlib.testing.compare.get_file_hash.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/get_file_hash/block_size",
          "name": "block_size",
          "qname": "lib.matplotlib.testing.compare.get_file_hash.block_size",
          "default_value": "2**20",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_file_hash(path, block_size=2 ** 20):\n    md5 = hashlib.md5()\n    with open(path, 'rb') as fd:\n        while True:\n            data = fd.read(block_size)\n            if not data:\n                break\n            md5.update(data)\n\n    if Path(path).suffix == '.pdf':\n        md5.update(str(mpl._get_executable_info(\"gs\").version)\n                   .encode('utf-8'))\n    elif Path(path).suffix == '.svg':\n        md5.update(str(mpl._get_executable_info(\"inkscape\").version)\n                   .encode('utf-8'))\n\n    return md5.hexdigest()"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.compare/make_test_filename",
      "name": "make_test_filename",
      "qname": "lib.matplotlib.testing.compare.make_test_filename",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/make_test_filename/fname",
          "name": "fname",
          "qname": "lib.matplotlib.testing.compare.make_test_filename.fname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/make_test_filename/purpose",
          "name": "purpose",
          "qname": "lib.matplotlib.testing.compare.make_test_filename.purpose",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Make a new filename by inserting *purpose* before the file's extension.",
      "docstring": "Make a new filename by inserting *purpose* before the file's extension.",
      "code": "def make_test_filename(fname, purpose):\n    \"\"\"\n    Make a new filename by inserting *purpose* before the file's extension.\n    \"\"\"\n    base, ext = os.path.splitext(fname)\n    return '%s-%s%s' % (base, purpose, ext)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.compare/save_diff_image",
      "name": "save_diff_image",
      "qname": "lib.matplotlib.testing.compare.save_diff_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/save_diff_image/expected",
          "name": "expected",
          "qname": "lib.matplotlib.testing.compare.save_diff_image.expected",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "File path of expected image."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/save_diff_image/actual",
          "name": "actual",
          "qname": "lib.matplotlib.testing.compare.save_diff_image.actual",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "File path of actual image."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.compare/save_diff_image/output",
          "name": "output",
          "qname": "lib.matplotlib.testing.compare.save_diff_image.output",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "File path to save difference image to."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Parameters\n----------\nexpected : str\n    File path of expected image.\nactual : str\n    File path of actual image.\noutput : str\n    File path to save difference image to.",
      "code": "def save_diff_image(expected, actual, output):\n    \"\"\"\n    Parameters\n    ----------\n    expected : str\n        File path of expected image.\n    actual : str\n        File path of actual image.\n    output : str\n        File path to save difference image to.\n    \"\"\"\n    expected_image = _load_image(expected)\n    actual_image = _load_image(actual)\n    actual_image, expected_image = crop_to_same(\n        actual, actual_image, expected, expected_image)\n    expected_image = np.array(expected_image).astype(float)\n    actual_image = np.array(actual_image).astype(float)\n    if expected_image.shape != actual_image.shape:\n        raise ImageComparisonFailure(\n            \"Image sizes do not match expected size: {} \"\n            \"actual size {}\".format(expected_image.shape, actual_image.shape))\n    abs_diff = np.abs(expected_image - actual_image)\n\n    # expand differences in luminance domain\n    abs_diff *= 10\n    abs_diff = np.clip(abs_diff, 0, 255).astype(np.uint8)\n\n    if abs_diff.shape[2] == 4:  # Hard-code the alpha channel to fully solid\n        abs_diff[:, :, 3] = 255\n\n    Image.fromarray(abs_diff).save(output, format=\"png\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.conftest/mpl_image_comparison_parameters",
      "name": "mpl_image_comparison_parameters",
      "qname": "lib.matplotlib.testing.conftest.mpl_image_comparison_parameters",
      "decorators": [
        "pytest.fixture",
        "_api.deprecated('3.5', alternative='none')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.conftest/mpl_image_comparison_parameters/request",
          "name": "request",
          "qname": "lib.matplotlib.testing.conftest.mpl_image_comparison_parameters.request",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.conftest/mpl_image_comparison_parameters/extension",
          "name": "extension",
          "qname": "lib.matplotlib.testing.conftest.mpl_image_comparison_parameters.extension",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@pytest.fixture\n@_api.deprecated(\"3.5\", alternative=\"none\")\ndef mpl_image_comparison_parameters(request, extension):\n    # This fixture is applied automatically by the image_comparison decorator.\n    #\n    # The sole purpose of this fixture is to provide an indirect method of\n    # obtaining parameters *without* modifying the decorated function\n    # signature. In this way, the function signature can stay the same and\n    # pytest won't get confused.\n    # We annotate the decorated function with any parameters captured by this\n    # fixture so that they can be used by the wrapper in image_comparison.\n    baseline_images, = request.node.get_closest_marker('baseline_images').args\n    if baseline_images is None:\n        # Allow baseline image list to be produced on the fly based on current\n        # parametrization.\n        baseline_images = request.getfixturevalue('baseline_images')\n\n    func = request.function\n    with cbook._setattr_cm(func.__wrapped__,\n                           parameters=(baseline_images, extension)):\n        yield"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.conftest/mpl_test_settings",
      "name": "mpl_test_settings",
      "qname": "lib.matplotlib.testing.conftest.mpl_test_settings",
      "decorators": [
        "pytest.fixture(autouse=True)"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.conftest/mpl_test_settings/request",
          "name": "request",
          "qname": "lib.matplotlib.testing.conftest.mpl_test_settings.request",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@pytest.fixture(autouse=True)\ndef mpl_test_settings(request):\n    from matplotlib.testing.decorators import _cleanup_cm\n\n    with _cleanup_cm():\n\n        backend = None\n        backend_marker = request.node.get_closest_marker('backend')\n        prev_backend = matplotlib.get_backend()\n        if backend_marker is not None:\n            assert len(backend_marker.args) == 1, \\\n                \"Marker 'backend' must specify 1 backend.\"\n            backend, = backend_marker.args\n            skip_on_importerror = backend_marker.kwargs.get(\n                'skip_on_importerror', False)\n\n            # special case Qt backend importing to avoid conflicts\n            if backend.lower().startswith('qt5'):\n                if any(sys.modules.get(k) for k in ('PyQt4', 'PySide')):\n                    pytest.skip('Qt4 binding already imported')\n\n        # Default of cleanup and image_comparison too.\n        style = [\"classic\", \"_classic_test_patch\"]\n        style_marker = request.node.get_closest_marker('style')\n        if style_marker is not None:\n            assert len(style_marker.args) == 1, \\\n                \"Marker 'style' must specify 1 style.\"\n            _api.warn_deprecated(\"3.5\", name=\"style\", obj_type=\"pytest marker\",\n                                 alternative=\"@mpl.style.context(...)\")\n            style, = style_marker.args\n\n        matplotlib.testing.setup()\n        with _api.suppress_matplotlib_deprecation_warning():\n            if backend is not None:\n                # This import must come after setup() so it doesn't load the\n                # default backend prematurely.\n                import matplotlib.pyplot as plt\n                try:\n                    plt.switch_backend(backend)\n                except ImportError as exc:\n                    # Should only occur for the cairo backend tests, if neither\n                    # pycairo nor cairocffi are installed.\n                    if 'cairo' in backend.lower() or skip_on_importerror:\n                        pytest.skip(\"Failed to switch to backend {} ({}).\"\n                                    .format(backend, exc))\n                    else:\n                        raise\n            matplotlib.style.use(style)\n        try:\n            yield\n        finally:\n            matplotlib.use(prev_backend)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.conftest/pd",
      "name": "pd",
      "qname": "lib.matplotlib.testing.conftest.pd",
      "decorators": [
        "pytest.fixture"
      ],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Fixture to import and configure pandas.",
      "docstring": "Fixture to import and configure pandas.",
      "code": "@pytest.fixture\ndef pd():\n    \"\"\"Fixture to import and configure pandas.\"\"\"\n    pd = pytest.importorskip('pandas')\n    try:\n        from pandas.plotting import (\n            deregister_matplotlib_converters as deregister)\n        deregister()\n    except ImportError:\n        pass\n    return pd"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.conftest/pytest_configure",
      "name": "pytest_configure",
      "qname": "lib.matplotlib.testing.conftest.pytest_configure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.conftest/pytest_configure/config",
          "name": "config",
          "qname": "lib.matplotlib.testing.conftest.pytest_configure.config",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def pytest_configure(config):\n    # config is initialized here rather than in pytest.ini so that `pytest\n    # --pyargs matplotlib` (which would not find pytest.ini) works.  The only\n    # entries in pytest.ini set minversion (which is checked earlier),\n    # testpaths/python_files, as they are required to properly find the tests\n    for key, value in [\n        (\"markers\", \"flaky: (Provided by pytest-rerunfailures.)\"),\n        (\"markers\", \"timeout: (Provided by pytest-timeout.)\"),\n        (\"markers\", \"backend: Set alternate Matplotlib backend temporarily.\"),\n        (\"markers\",\n         \"style: Set alternate Matplotlib style temporarily (deprecated).\"),\n        (\"markers\", \"baseline_images: Compare output against references.\"),\n        (\"markers\", \"pytz: Tests that require pytz to be installed.\"),\n        (\"filterwarnings\", \"error\"),\n        (\"filterwarnings\",\n         \"ignore:.*The py23 module has been deprecated:DeprecationWarning\"),\n        (\"filterwarnings\",\n         r\"ignore:DynamicImporter.find_spec\\(\\) not found; \"\n         r\"falling back to find_module\\(\\):ImportWarning\"),\n    ]:\n        config.addinivalue_line(key, value)\n\n    matplotlib.use('agg', force=True)\n    matplotlib._called_from_pytest = True\n    matplotlib._init_tests()"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.conftest/pytest_unconfigure",
      "name": "pytest_unconfigure",
      "qname": "lib.matplotlib.testing.conftest.pytest_unconfigure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.conftest/pytest_unconfigure/config",
          "name": "config",
          "qname": "lib.matplotlib.testing.conftest.pytest_unconfigure.config",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def pytest_unconfigure(config):\n    matplotlib._called_from_pytest = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.conftest/xr",
      "name": "xr",
      "qname": "lib.matplotlib.testing.conftest.xr",
      "decorators": [
        "pytest.fixture"
      ],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Fixture to import xarray.",
      "docstring": "Fixture to import xarray.",
      "code": "@pytest.fixture\ndef xr():\n    \"\"\"Fixture to import xarray.\"\"\"\n    xr = pytest.importorskip('xarray')\n    return xr"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.decorators/CleanupTestCase/setUpClass",
      "name": "setUpClass",
      "qname": "lib.matplotlib.testing.decorators.CleanupTestCase.setUpClass",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/CleanupTestCase/setUpClass/cls",
          "name": "cls",
          "qname": "lib.matplotlib.testing.decorators.CleanupTestCase.setUpClass.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def setUpClass(cls):\n        cls._cm = _cleanup_cm().__enter__()"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.decorators/CleanupTestCase/tearDownClass",
      "name": "tearDownClass",
      "qname": "lib.matplotlib.testing.decorators.CleanupTestCase.tearDownClass",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/CleanupTestCase/tearDownClass/cls",
          "name": "cls",
          "qname": "lib.matplotlib.testing.decorators.CleanupTestCase.tearDownClass.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def tearDownClass(cls):\n        cls._cm.__exit__(None, None, None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.decorators/check_figures_equal",
      "name": "check_figures_equal",
      "qname": "lib.matplotlib.testing.decorators.check_figures_equal",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/check_figures_equal/extensions",
          "name": "extensions",
          "qname": "lib.matplotlib.testing.decorators.check_figures_equal.extensions",
          "default_value": "('png', 'pdf', 'svg')",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "list",
            "default_value": "[\"png\", \"pdf\", \"svg\"]",
            "description": "The extensions to test."
          },
          "type": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/check_figures_equal/tol",
          "name": "tol",
          "qname": "lib.matplotlib.testing.decorators.check_figures_equal.tol",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The RMS threshold above which the test is considered failed."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Decorator for test cases that generate and compare two figures.\n\nThe decorated function must take two keyword arguments, *fig_test*\nand *fig_ref*, and draw the test and reference images on them.\nAfter the function returns, the figures are saved and compared.\n\nThis decorator should be preferred over `image_comparison` when possible in\norder to keep the size of the test suite from ballooning.",
      "docstring": "Decorator for test cases that generate and compare two figures.\n\nThe decorated function must take two keyword arguments, *fig_test*\nand *fig_ref*, and draw the test and reference images on them.\nAfter the function returns, the figures are saved and compared.\n\nThis decorator should be preferred over `image_comparison` when possible in\norder to keep the size of the test suite from ballooning.\n\nParameters\n----------\nextensions : list, default: [\"png\", \"pdf\", \"svg\"]\n    The extensions to test.\ntol : float\n    The RMS threshold above which the test is considered failed.\n\nRaises\n------\nRuntimeError\n    If any new figures are created (and not subsequently closed) inside\n    the test function.\n\nExamples\n--------\nCheck that calling `.Axes.plot` with a single argument plots it against\n``[0, 1, 2, ...]``::\n\n    @check_figures_equal()\n    def test_plot(fig_test, fig_ref):\n        fig_test.subplots().plot([1, 3, 5])\n        fig_ref.subplots().plot([0, 1, 2], [1, 3, 5])",
      "code": "def check_figures_equal(*, extensions=(\"png\", \"pdf\", \"svg\"), tol=0):\n    \"\"\"\n    Decorator for test cases that generate and compare two figures.\n\n    The decorated function must take two keyword arguments, *fig_test*\n    and *fig_ref*, and draw the test and reference images on them.\n    After the function returns, the figures are saved and compared.\n\n    This decorator should be preferred over `image_comparison` when possible in\n    order to keep the size of the test suite from ballooning.\n\n    Parameters\n    ----------\n    extensions : list, default: [\"png\", \"pdf\", \"svg\"]\n        The extensions to test.\n    tol : float\n        The RMS threshold above which the test is considered failed.\n\n    Raises\n    ------\n    RuntimeError\n        If any new figures are created (and not subsequently closed) inside\n        the test function.\n\n    Examples\n    --------\n    Check that calling `.Axes.plot` with a single argument plots it against\n    ``[0, 1, 2, ...]``::\n\n        @check_figures_equal()\n        def test_plot(fig_test, fig_ref):\n            fig_test.subplots().plot([1, 3, 5])\n            fig_ref.subplots().plot([0, 1, 2], [1, 3, 5])\n\n    \"\"\"\n    ALLOWED_CHARS = set(string.digits + string.ascii_letters + '_-[]()')\n    KEYWORD_ONLY = inspect.Parameter.KEYWORD_ONLY\n\n    def decorator(func):\n        import pytest\n\n        _, result_dir = _image_directories(func)\n        old_sig = inspect.signature(func)\n\n        if not {\"fig_test\", \"fig_ref\"}.issubset(old_sig.parameters):\n            raise ValueError(\"The decorated function must have at least the \"\n                             \"parameters 'fig_ref' and 'fig_test', but your \"\n                             f\"function has the signature {old_sig}\")\n\n        @pytest.mark.parametrize(\"ext\", extensions)\n        def wrapper(*args, ext, request, **kwargs):\n            if 'ext' in old_sig.parameters:\n                kwargs['ext'] = ext\n            if 'request' in old_sig.parameters:\n                kwargs['request'] = request\n\n            file_name = \"\".join(c for c in request.node.name\n                                if c in ALLOWED_CHARS)\n            try:\n                fig_test = plt.figure(\"test\")\n                fig_ref = plt.figure(\"reference\")\n                with _collect_new_figures() as figs:\n                    func(*args, fig_test=fig_test, fig_ref=fig_ref, **kwargs)\n                if figs:\n                    raise RuntimeError('Number of open figures changed during '\n                                       'test. Make sure you are plotting to '\n                                       'fig_test or fig_ref, or if this is '\n                                       'deliberate explicitly close the '\n                                       'new figure(s) inside the test.')\n                test_image_path = result_dir / (file_name + \".\" + ext)\n                ref_image_path = result_dir / (file_name + \"-expected.\" + ext)\n                fig_test.savefig(test_image_path)\n                fig_ref.savefig(ref_image_path)\n                _raise_on_image_difference(\n                    ref_image_path, test_image_path, tol=tol\n                )\n            finally:\n                plt.close(fig_test)\n                plt.close(fig_ref)\n\n        parameters = [\n            param\n            for param in old_sig.parameters.values()\n            if param.name not in {\"fig_test\", \"fig_ref\"}\n        ]\n        if 'ext' not in old_sig.parameters:\n            parameters += [inspect.Parameter(\"ext\", KEYWORD_ONLY)]\n        if 'request' not in old_sig.parameters:\n            parameters += [inspect.Parameter(\"request\", KEYWORD_ONLY)]\n        new_sig = old_sig.replace(parameters=parameters)\n        wrapper.__signature__ = new_sig\n\n        # reach a bit into pytest internals to hoist the marks from\n        # our wrapped function\n        new_marks = getattr(func, \"pytestmark\", []) + wrapper.pytestmark\n        wrapper.pytestmark = new_marks\n\n        return wrapper\n\n    return decorator"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.decorators/check_freetype_version",
      "name": "check_freetype_version",
      "qname": "lib.matplotlib.testing.decorators.check_freetype_version",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of the existing code of _check_freetype_version')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/check_freetype_version/ver",
          "name": "ver",
          "qname": "lib.matplotlib.testing.decorators.check_freetype_version.ver",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of the existing code \"\n                 \"of _check_freetype_version\")\ndef check_freetype_version(ver):\n    return _check_freetype_version(ver)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.decorators/cleanup",
      "name": "cleanup",
      "qname": "lib.matplotlib.testing.decorators.cleanup",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of the existing code, including the private function _cleanup_cm')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/cleanup/style",
          "name": "style",
          "qname": "lib.matplotlib.testing.decorators.cleanup.style",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str, dict, or list",
            "default_value": "",
            "description": "The style(s) to apply.  Defaults to ``[\"classic\",\n\"_classic_test_patch\"]``."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "list"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A decorator to ensure that any global state is reset before\nrunning a test.",
      "docstring": "A decorator to ensure that any global state is reset before\nrunning a test.\n\nParameters\n----------\nstyle : str, dict, or list, optional\n    The style(s) to apply.  Defaults to ``[\"classic\",\n    \"_classic_test_patch\"]``.",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of the existing code, \"\n                 \"including the private function _cleanup_cm\")\ndef cleanup(style=None):\n    \"\"\"\n    A decorator to ensure that any global state is reset before\n    running a test.\n\n    Parameters\n    ----------\n    style : str, dict, or list, optional\n        The style(s) to apply.  Defaults to ``[\"classic\",\n        \"_classic_test_patch\"]``.\n    \"\"\"\n\n    # If cleanup is used without arguments, *style* will be a callable, and we\n    # pass it directly to the wrapper generator.  If cleanup if called with an\n    # argument, it is a string naming a style, and the function will be passed\n    # as an argument to what we return.  This is a confusing, but somewhat\n    # standard, pattern for writing a decorator with optional arguments.\n\n    def make_cleanup(func):\n        if inspect.isgeneratorfunction(func):\n            @functools.wraps(func)\n            def wrapped_callable(*args, **kwargs):\n                with _cleanup_cm(), matplotlib.style.context(style):\n                    yield from func(*args, **kwargs)\n        else:\n            @functools.wraps(func)\n            def wrapped_callable(*args, **kwargs):\n                with _cleanup_cm(), matplotlib.style.context(style):\n                    func(*args, **kwargs)\n\n        return wrapped_callable\n\n    if callable(style):\n        result = make_cleanup(style)\n        # Default of mpl_test_settings fixture and image_comparison too.\n        style = [\"classic\", \"_classic_test_patch\"]\n        return result\n    else:\n        return make_cleanup"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.decorators/image_comparison",
      "name": "image_comparison",
      "qname": "lib.matplotlib.testing.decorators.image_comparison",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/image_comparison/baseline_images",
          "name": "baseline_images",
          "qname": "lib.matplotlib.testing.decorators.image_comparison.baseline_images",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "list or None",
            "default_value": "",
            "description": "A list of strings specifying the names of the images generated by\ncalls to `.Figure.savefig`.\n\nIf *None*, the test function must use the ``baseline_images`` fixture,\neither as a parameter or with `pytest.mark.usefixtures`. This value is\nonly allowed when using pytest."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "list"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/image_comparison/extensions",
          "name": "extensions",
          "qname": "lib.matplotlib.testing.decorators.image_comparison.extensions",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or list of str",
            "default_value": "",
            "description": "The list of extensions to test, e.g. ``['png', 'pdf']``.\n\nIf *None*, defaults to all supported extensions: png, pdf, and svg.\n\nWhen testing a single extension, it can be directly included in the\nnames passed to *baseline_images*.  In that case, *extensions* must not\nbe set.\n\nIn order to keep the size of the test suite from ballooning, we only\ninclude the ``svg`` or ``pdf`` outputs if the test is explicitly\nexercising a feature dependent on that backend (see also the\n`check_figures_equal` decorator for that purpose)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "list of str"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/image_comparison/tol",
          "name": "tol",
          "qname": "lib.matplotlib.testing.decorators.image_comparison.tol",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0",
            "description": "The RMS threshold above which the test is considered failed.\n\nDue to expected small differences in floating-point calculations, on\n32-bit systems an additional 0.06 is added to this threshold."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/image_comparison/freetype_version",
          "name": "freetype_version",
          "qname": "lib.matplotlib.testing.decorators.image_comparison.freetype_version",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or tuple",
            "default_value": "",
            "description": "The expected freetype version or range of versions for this test to\npass."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "tuple"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/image_comparison/remove_text",
          "name": "remove_text",
          "qname": "lib.matplotlib.testing.decorators.image_comparison.remove_text",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Remove the title and tick text from the figure before comparison.  This\nis useful to make the baseline images independent of variations in text\nrendering between different versions of FreeType.\n\nThis does not remove other, more deliberate, text, such as legends and\nannotations."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/image_comparison/savefig_kwarg",
          "name": "savefig_kwarg",
          "qname": "lib.matplotlib.testing.decorators.image_comparison.savefig_kwarg",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "Optional arguments that are passed to the savefig method."
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/image_comparison/style",
          "name": "style",
          "qname": "lib.matplotlib.testing.decorators.image_comparison.style",
          "default_value": "('classic', '_classic_test_patch')",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str, dict, or list",
            "default_value": "",
            "description": "The optional style(s) to apply to the image test. The test itself\ncan also apply additional styles if desired. Defaults to ``[\"classic\",\n\"_classic_test_patch\"]``."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "list"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Compare images generated by the test with those specified in\n*baseline_images*, which must correspond, else an `ImageComparisonFailure`\nexception will be raised.",
      "docstring": "Compare images generated by the test with those specified in\n*baseline_images*, which must correspond, else an `ImageComparisonFailure`\nexception will be raised.\n\nParameters\n----------\nbaseline_images : list or None\n    A list of strings specifying the names of the images generated by\n    calls to `.Figure.savefig`.\n\n    If *None*, the test function must use the ``baseline_images`` fixture,\n    either as a parameter or with `pytest.mark.usefixtures`. This value is\n    only allowed when using pytest.\n\nextensions : None or list of str\n    The list of extensions to test, e.g. ``['png', 'pdf']``.\n\n    If *None*, defaults to all supported extensions: png, pdf, and svg.\n\n    When testing a single extension, it can be directly included in the\n    names passed to *baseline_images*.  In that case, *extensions* must not\n    be set.\n\n    In order to keep the size of the test suite from ballooning, we only\n    include the ``svg`` or ``pdf`` outputs if the test is explicitly\n    exercising a feature dependent on that backend (see also the\n    `check_figures_equal` decorator for that purpose).\n\ntol : float, default: 0\n    The RMS threshold above which the test is considered failed.\n\n    Due to expected small differences in floating-point calculations, on\n    32-bit systems an additional 0.06 is added to this threshold.\n\nfreetype_version : str or tuple\n    The expected freetype version or range of versions for this test to\n    pass.\n\nremove_text : bool\n    Remove the title and tick text from the figure before comparison.  This\n    is useful to make the baseline images independent of variations in text\n    rendering between different versions of FreeType.\n\n    This does not remove other, more deliberate, text, such as legends and\n    annotations.\n\nsavefig_kwarg : dict\n    Optional arguments that are passed to the savefig method.\n\nstyle : str, dict, or list\n    The optional style(s) to apply to the image test. The test itself\n    can also apply additional styles if desired. Defaults to ``[\"classic\",\n    \"_classic_test_patch\"]``.",
      "code": "def image_comparison(baseline_images, extensions=None, tol=0,\n                     freetype_version=None, remove_text=False,\n                     savefig_kwarg=None,\n                     # Default of mpl_test_settings fixture and cleanup too.\n                     style=(\"classic\", \"_classic_test_patch\")):\n    \"\"\"\n    Compare images generated by the test with those specified in\n    *baseline_images*, which must correspond, else an `ImageComparisonFailure`\n    exception will be raised.\n\n    Parameters\n    ----------\n    baseline_images : list or None\n        A list of strings specifying the names of the images generated by\n        calls to `.Figure.savefig`.\n\n        If *None*, the test function must use the ``baseline_images`` fixture,\n        either as a parameter or with `pytest.mark.usefixtures`. This value is\n        only allowed when using pytest.\n\n    extensions : None or list of str\n        The list of extensions to test, e.g. ``['png', 'pdf']``.\n\n        If *None*, defaults to all supported extensions: png, pdf, and svg.\n\n        When testing a single extension, it can be directly included in the\n        names passed to *baseline_images*.  In that case, *extensions* must not\n        be set.\n\n        In order to keep the size of the test suite from ballooning, we only\n        include the ``svg`` or ``pdf`` outputs if the test is explicitly\n        exercising a feature dependent on that backend (see also the\n        `check_figures_equal` decorator for that purpose).\n\n    tol : float, default: 0\n        The RMS threshold above which the test is considered failed.\n\n        Due to expected small differences in floating-point calculations, on\n        32-bit systems an additional 0.06 is added to this threshold.\n\n    freetype_version : str or tuple\n        The expected freetype version or range of versions for this test to\n        pass.\n\n    remove_text : bool\n        Remove the title and tick text from the figure before comparison.  This\n        is useful to make the baseline images independent of variations in text\n        rendering between different versions of FreeType.\n\n        This does not remove other, more deliberate, text, such as legends and\n        annotations.\n\n    savefig_kwarg : dict\n        Optional arguments that are passed to the savefig method.\n\n    style : str, dict, or list\n        The optional style(s) to apply to the image test. The test itself\n        can also apply additional styles if desired. Defaults to ``[\"classic\",\n        \"_classic_test_patch\"]``.\n    \"\"\"\n\n    if baseline_images is not None:\n        # List of non-empty filename extensions.\n        baseline_exts = [*filter(None, {Path(baseline).suffix[1:]\n                                        for baseline in baseline_images})]\n        if baseline_exts:\n            if extensions is not None:\n                raise ValueError(\n                    \"When including extensions directly in 'baseline_images', \"\n                    \"'extensions' cannot be set as well\")\n            if len(baseline_exts) > 1:\n                raise ValueError(\n                    \"When including extensions directly in 'baseline_images', \"\n                    \"all baselines must share the same suffix\")\n            extensions = baseline_exts\n            baseline_images = [  # Chop suffix out from baseline_images.\n                Path(baseline).stem for baseline in baseline_images]\n    if extensions is None:\n        # Default extensions to test, if not set via baseline_images.\n        extensions = ['png', 'pdf', 'svg']\n    if savefig_kwarg is None:\n        savefig_kwarg = dict()  # default no kwargs to savefig\n    if sys.maxsize <= 2**32:\n        tol += 0.06\n    return _pytest_image_comparison(\n        baseline_images=baseline_images, extensions=extensions, tol=tol,\n        freetype_version=freetype_version, remove_text=remove_text,\n        savefig_kwargs=savefig_kwarg, style=style)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.decorators/remove_ticks_and_titles",
      "name": "remove_ticks_and_titles",
      "qname": "lib.matplotlib.testing.decorators.remove_ticks_and_titles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.decorators/remove_ticks_and_titles/figure",
          "name": "figure",
          "qname": "lib.matplotlib.testing.decorators.remove_ticks_and_titles.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def remove_ticks_and_titles(figure):\n    figure.suptitle(\"\")\n    null_formatter = ticker.NullFormatter()\n    def remove_ticks(ax):\n        \"\"\"Remove ticks in *ax* and all its child Axes.\"\"\"\n        ax.set_title(\"\")\n        ax.xaxis.set_major_formatter(null_formatter)\n        ax.xaxis.set_minor_formatter(null_formatter)\n        ax.yaxis.set_major_formatter(null_formatter)\n        ax.yaxis.set_minor_formatter(null_formatter)\n        try:\n            ax.zaxis.set_major_formatter(null_formatter)\n            ax.zaxis.set_minor_formatter(null_formatter)\n        except AttributeError:\n            pass\n        for child in ax.child_axes:\n            remove_ticks(child)\n    for ax in figure.get_axes():\n        remove_ticks(ax)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__abs__",
      "name": "__abs__",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__abs__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__abs__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__abs__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the absolute value of the duration.",
      "docstring": "Return the absolute value of the duration.",
      "code": "    def __abs__(self):\n        \"\"\"Return the absolute value of the duration.\"\"\"\n        return Duration(self._frame, abs(self._seconds))"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__add__",
      "name": "__add__",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__add__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__add__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__add__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__add__/rhs",
          "name": "rhs",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__add__.rhs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add two Durations.\n\n= ERROR CONDITIONS\n- If the input rhs is not in the same frame, an error is thrown.\n\n= INPUT VARIABLES\n- rhs     The Duration to add.\n\n= RETURN VALUE\n- Returns the sum of ourselves and the input Duration.",
      "docstring": "Add two Durations.\n\n= ERROR CONDITIONS\n- If the input rhs is not in the same frame, an error is thrown.\n\n= INPUT VARIABLES\n- rhs     The Duration to add.\n\n= RETURN VALUE\n- Returns the sum of ourselves and the input Duration.",
      "code": "    def __add__(self, rhs):\n        \"\"\"\n        Add two Durations.\n\n        = ERROR CONDITIONS\n        - If the input rhs is not in the same frame, an error is thrown.\n\n        = INPUT VARIABLES\n        - rhs     The Duration to add.\n\n        = RETURN VALUE\n        - Returns the sum of ourselves and the input Duration.\n        \"\"\"\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        if isinstance(rhs, U.Epoch):\n            return rhs + self\n\n        self.checkSameFrame(rhs, \"add\")\n        return Duration(self._frame, self._seconds + rhs._seconds)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__bool__",
      "name": "__bool__",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__bool__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__bool__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__bool__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __bool__(self):\n        return self._seconds != 0"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__init__/frame",
          "name": "frame",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__init__.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__init__/seconds",
          "name": "seconds",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__init__.seconds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Class Duration in development.",
      "docstring": "Create a new Duration object.\n\n= ERROR CONDITIONS\n- If the input frame is not in the allowed list, an error is thrown.\n\n= INPUT VARIABLES\n- frame     The frame of the duration.  Must be 'ET' or 'UTC'\n- seconds  The number of seconds in the Duration.",
      "code": "    def __init__(self, frame, seconds):\n        \"\"\"\n        Create a new Duration object.\n\n        = ERROR CONDITIONS\n        - If the input frame is not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - frame     The frame of the duration.  Must be 'ET' or 'UTC'\n        - seconds  The number of seconds in the Duration.\n        \"\"\"\n        _api.check_in_list(self.allowed, frame=frame)\n        self._frame = frame\n        self._seconds = seconds"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__mul__",
      "name": "__mul__",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__mul__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__mul__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__mul__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__mul__/rhs",
          "name": "rhs",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__mul__.rhs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Scale a UnitDbl by a value.\n\n= INPUT VARIABLES\n- rhs     The scalar to multiply by.\n\n= RETURN VALUE\n- Returns the scaled Duration.",
      "docstring": "Scale a UnitDbl by a value.\n\n= INPUT VARIABLES\n- rhs     The scalar to multiply by.\n\n= RETURN VALUE\n- Returns the scaled Duration.",
      "code": "    def __mul__(self, rhs):\n        \"\"\"\n        Scale a UnitDbl by a value.\n\n        = INPUT VARIABLES\n        - rhs     The scalar to multiply by.\n\n        = RETURN VALUE\n        - Returns the scaled Duration.\n        \"\"\"\n        return Duration(self._frame, self._seconds * float(rhs))"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__neg__",
      "name": "__neg__",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__neg__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__neg__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__neg__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the negative value of this Duration.",
      "docstring": "Return the negative value of this Duration.",
      "code": "    def __neg__(self):\n        \"\"\"Return the negative value of this Duration.\"\"\"\n        return Duration(self._frame, -self._seconds)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Print the Duration.",
      "docstring": "Print the Duration.",
      "code": "    def __repr__(self):\n        \"\"\"Print the Duration.\"\"\"\n        return \"Duration('%s', %g)\" % (self._frame, self._seconds)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__str__",
      "name": "__str__",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__str__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Print the Duration.",
      "docstring": "Print the Duration.",
      "code": "    def __str__(self):\n        \"\"\"Print the Duration.\"\"\"\n        return \"%g %s\" % (self._seconds, self._frame)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__sub__",
      "name": "__sub__",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__sub__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__sub__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__sub__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/__sub__/rhs",
          "name": "rhs",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.__sub__.rhs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subtract two Durations.\n\n= ERROR CONDITIONS\n- If the input rhs is not in the same frame, an error is thrown.\n\n= INPUT VARIABLES\n- rhs     The Duration to subtract.\n\n= RETURN VALUE\n- Returns the difference of ourselves and the input Duration.",
      "docstring": "Subtract two Durations.\n\n= ERROR CONDITIONS\n- If the input rhs is not in the same frame, an error is thrown.\n\n= INPUT VARIABLES\n- rhs     The Duration to subtract.\n\n= RETURN VALUE\n- Returns the difference of ourselves and the input Duration.",
      "code": "    def __sub__(self, rhs):\n        \"\"\"\n        Subtract two Durations.\n\n        = ERROR CONDITIONS\n        - If the input rhs is not in the same frame, an error is thrown.\n\n        = INPUT VARIABLES\n        - rhs     The Duration to subtract.\n\n        = RETURN VALUE\n        - Returns the difference of ourselves and the input Duration.\n        \"\"\"\n        self.checkSameFrame(rhs, \"sub\")\n        return Duration(self._frame, self._seconds - rhs._seconds)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/checkSameFrame",
      "name": "checkSameFrame",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.checkSameFrame",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/checkSameFrame/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.checkSameFrame.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/checkSameFrame/rhs",
          "name": "rhs",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.checkSameFrame.rhs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/checkSameFrame/func",
          "name": "func",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.checkSameFrame.func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Check to see if frames are the same.\n\n= ERROR CONDITIONS\n- If the frame of the rhs Duration is not the same as our frame,\n  an error is thrown.\n\n= INPUT VARIABLES\n- rhs     The Duration to check for the same frame\n- func    The name of the function doing the check.",
      "docstring": "Check to see if frames are the same.\n\n= ERROR CONDITIONS\n- If the frame of the rhs Duration is not the same as our frame,\n  an error is thrown.\n\n= INPUT VARIABLES\n- rhs     The Duration to check for the same frame\n- func    The name of the function doing the check.",
      "code": "    def checkSameFrame(self, rhs, func):\n        \"\"\"\n        Check to see if frames are the same.\n\n        = ERROR CONDITIONS\n        - If the frame of the rhs Duration is not the same as our frame,\n          an error is thrown.\n\n        = INPUT VARIABLES\n        - rhs     The Duration to check for the same frame\n        - func    The name of the function doing the check.\n        \"\"\"\n        if self._frame != rhs._frame:\n            raise ValueError(\n                f\"Cannot {func} Durations with different frames.\\n\"\n                f\"LHS: {self._frame}\\n\"\n                f\"RHS: {rhs._frame}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/frame",
      "name": "frame",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.frame",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/frame/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.frame.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the frame the duration is in.",
      "docstring": "Return the frame the duration is in.",
      "code": "    def frame(self):\n        \"\"\"Return the frame the duration is in.\"\"\"\n        return self._frame"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/seconds",
      "name": "seconds",
      "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.seconds",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Duration/Duration/seconds/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Duration.Duration.seconds.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the number of seconds in the Duration.",
      "docstring": "Return the number of seconds in the Duration.",
      "code": "    def seconds(self):\n        \"\"\"Return the number of seconds in the Duration.\"\"\"\n        return self._seconds"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__add__",
      "name": "__add__",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__add__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__add__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__add__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__add__/rhs",
          "name": "rhs",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__add__.rhs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a duration to an Epoch.\n\n= INPUT VARIABLES\n- rhs     The Epoch to subtract.\n\n= RETURN VALUE\n- Returns the difference of ourselves and the input Epoch.",
      "docstring": "Add a duration to an Epoch.\n\n= INPUT VARIABLES\n- rhs     The Epoch to subtract.\n\n= RETURN VALUE\n- Returns the difference of ourselves and the input Epoch.",
      "code": "    def __add__(self, rhs):\n        \"\"\"\n        Add a duration to an Epoch.\n\n        = INPUT VARIABLES\n        - rhs     The Epoch to subtract.\n\n        = RETURN VALUE\n        - Returns the difference of ourselves and the input Epoch.\n        \"\"\"\n        t = self\n        if self._frame != rhs.frame():\n            t = self.convert(rhs._frame)\n\n        sec = t._seconds + rhs.seconds()\n\n        return Epoch(t._frame, sec, t._jd)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__init__/frame",
          "name": "frame",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__init__.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__init__/sec",
          "name": "sec",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__init__.sec",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__init__/jd",
          "name": "jd",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__init__.jd",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__init__/daynum",
          "name": "daynum",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__init__.daynum",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__init__/dt",
          "name": "dt",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__init__.dt",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Create a new Epoch object.\n\nBuild an epoch 1 of 2 ways:\n\nUsing seconds past a Julian date:\n#   Epoch('ET', sec=1e8, jd=2451545)\n\nor using a matplotlib day number\n#   Epoch('ET', daynum=730119.5)\n\n= ERROR CONDITIONS\n- If the input units are not in the allowed list, an error is thrown.\n\n= INPUT VARIABLES\n- frame     The frame of the epoch.  Must be 'ET' or 'UTC'\n- sec        The number of seconds past the input JD.\n- jd         The Julian date of the epoch.\n- daynum    The matplotlib day number of the epoch.\n- dt         A python datetime instance.",
      "code": "    def __init__(self, frame, sec=None, jd=None, daynum=None, dt=None):\n        \"\"\"\n        Create a new Epoch object.\n\n        Build an epoch 1 of 2 ways:\n\n        Using seconds past a Julian date:\n        #   Epoch('ET', sec=1e8, jd=2451545)\n\n        or using a matplotlib day number\n        #   Epoch('ET', daynum=730119.5)\n\n        = ERROR CONDITIONS\n        - If the input units are not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - frame     The frame of the epoch.  Must be 'ET' or 'UTC'\n        - sec        The number of seconds past the input JD.\n        - jd         The Julian date of the epoch.\n        - daynum    The matplotlib day number of the epoch.\n        - dt         A python datetime instance.\n        \"\"\"\n        if ((sec is None and jd is not None) or\n                (sec is not None and jd is None) or\n                (daynum is not None and\n                 (sec is not None or jd is not None)) or\n                (daynum is None and dt is None and\n                 (sec is None or jd is None)) or\n                (daynum is not None and dt is not None) or\n                (dt is not None and (sec is not None or jd is not None)) or\n                ((dt is not None) and not isinstance(dt, DT.datetime))):\n            raise ValueError(\n                \"Invalid inputs.  Must enter sec and jd together, \"\n                \"daynum by itself, or dt (must be a python datetime).\\n\"\n                \"Sec = %s\\n\"\n                \"JD  = %s\\n\"\n                \"dnum= %s\\n\"\n                \"dt  = %s\" % (sec, jd, daynum, dt))\n\n        _api.check_in_list(self.allowed, frame=frame)\n        self._frame = frame\n\n        if dt is not None:\n            daynum = date2num(dt)\n\n        if daynum is not None:\n            # 1-JAN-0001 in JD = 1721425.5\n            jd = float(daynum) + 1721425.5\n            self._jd = math.floor(jd)\n            self._seconds = (jd - self._jd) * 86400.0\n\n        else:\n            self._seconds = float(sec)\n            self._jd = float(jd)\n\n            # Resolve seconds down to [ 0, 86400)\n            deltaDays = math.floor(self._seconds / 86400)\n            self._jd += deltaDays\n            self._seconds -= deltaDays * 86400.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Print the Epoch.",
      "docstring": "Print the Epoch.",
      "code": "    def __repr__(self):\n        \"\"\"Print the Epoch.\"\"\"\n        return str(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__str__",
      "name": "__str__",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__str__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Print the Epoch.",
      "docstring": "Print the Epoch.",
      "code": "    def __str__(self):\n        \"\"\"Print the Epoch.\"\"\"\n        return \"%22.15e %s\" % (self.julianDate(self._frame), self._frame)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__sub__",
      "name": "__sub__",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__sub__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__sub__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__sub__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/__sub__/rhs",
          "name": "rhs",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.__sub__.rhs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subtract two Epoch's or a Duration from an Epoch.\n\nValid:\nDuration = Epoch - Epoch\nEpoch = Epoch - Duration\n\n= INPUT VARIABLES\n- rhs     The Epoch to subtract.\n\n= RETURN VALUE\n- Returns either the duration between to Epoch's or the a new\n  Epoch that is the result of subtracting a duration from an epoch.",
      "docstring": "Subtract two Epoch's or a Duration from an Epoch.\n\nValid:\nDuration = Epoch - Epoch\nEpoch = Epoch - Duration\n\n= INPUT VARIABLES\n- rhs     The Epoch to subtract.\n\n= RETURN VALUE\n- Returns either the duration between to Epoch's or the a new\n  Epoch that is the result of subtracting a duration from an epoch.",
      "code": "    def __sub__(self, rhs):\n        \"\"\"\n        Subtract two Epoch's or a Duration from an Epoch.\n\n        Valid:\n        Duration = Epoch - Epoch\n        Epoch = Epoch - Duration\n\n        = INPUT VARIABLES\n        - rhs     The Epoch to subtract.\n\n        = RETURN VALUE\n        - Returns either the duration between to Epoch's or the a new\n          Epoch that is the result of subtracting a duration from an epoch.\n        \"\"\"\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        # Handle Epoch - Duration\n        if isinstance(rhs, U.Duration):\n            return self + -rhs\n\n        t = self\n        if self._frame != rhs._frame:\n            t = self.convert(rhs._frame)\n\n        days = t._jd - rhs._jd\n        sec = t._seconds - rhs._seconds\n\n        return U.Duration(rhs._frame, days*86400 + sec)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/convert",
      "name": "convert",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.convert",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/convert/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.convert.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/convert/frame",
          "name": "frame",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.convert.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def convert(self, frame):\n        if self._frame == frame:\n            return self\n\n        offset = self.allowed[self._frame][frame]\n\n        return Epoch(frame, self._seconds + offset, self._jd)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/frame",
      "name": "frame",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.frame",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/frame/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.frame.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def frame(self):\n        return self._frame"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/julianDate",
      "name": "julianDate",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.julianDate",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/julianDate/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.julianDate.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/julianDate/frame",
          "name": "frame",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.julianDate.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def julianDate(self, frame):\n        t = self\n        if frame != self._frame:\n            t = self.convert(frame)\n\n        return t._jd + t._seconds / 86400.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/range",
      "name": "range",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.range",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/range/start",
          "name": "start",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.range.start",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/range/stop",
          "name": "stop",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.range.stop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/range/step",
          "name": "step",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.range.step",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Generate a range of Epoch objects.\n\nSimilar to the Python range() method.  Returns the range [\nstart, stop) at the requested step.  Each element will be a\nEpoch object.\n\n= INPUT VARIABLES\n- start     The starting value of the range.\n- stop      The stop value of the range.\n- step      Step to use.\n\n= RETURN VALUE\n- Returns a list containing the requested Epoch values.",
      "docstring": "Generate a range of Epoch objects.\n\nSimilar to the Python range() method.  Returns the range [\nstart, stop) at the requested step.  Each element will be a\nEpoch object.\n\n= INPUT VARIABLES\n- start     The starting value of the range.\n- stop      The stop value of the range.\n- step      Step to use.\n\n= RETURN VALUE\n- Returns a list containing the requested Epoch values.",
      "code": "    @staticmethod\n    def range(start, stop, step):\n        \"\"\"\n        Generate a range of Epoch objects.\n\n        Similar to the Python range() method.  Returns the range [\n        start, stop) at the requested step.  Each element will be a\n        Epoch object.\n\n        = INPUT VARIABLES\n        - start     The starting value of the range.\n        - stop      The stop value of the range.\n        - step      Step to use.\n\n        = RETURN VALUE\n        - Returns a list containing the requested Epoch values.\n        \"\"\"\n        elems = []\n\n        i = 0\n        while True:\n            d = start + i * step\n            if d >= stop:\n                break\n\n            elems.append(d)\n            i += 1\n\n        return elems"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/secondsPast",
      "name": "secondsPast",
      "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.secondsPast",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/secondsPast/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.secondsPast.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/secondsPast/frame",
          "name": "frame",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.secondsPast.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.Epoch/Epoch/secondsPast/jd",
          "name": "jd",
          "qname": "lib.matplotlib.testing.jpl_units.Epoch.Epoch.secondsPast.jd",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def secondsPast(self, frame, jd):\n        t = self\n        if frame != self._frame:\n            t = self.convert(frame)\n\n        delta = t._jd - jd\n        return t._seconds + delta * 86400"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/axisinfo",
      "name": "axisinfo",
      "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.axisinfo",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/axisinfo/unit",
          "name": "unit",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.axisinfo.unit",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/axisinfo/axis",
          "name": "axis",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.axisinfo.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def axisinfo(unit, axis):\n        # docstring inherited\n        majloc = date_ticker.AutoDateLocator()\n        majfmt = date_ticker.AutoDateFormatter(majloc)\n        return units.AxisInfo(majloc=majloc, majfmt=majfmt, label=unit)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/convert",
      "name": "convert",
      "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.convert",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/convert/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.convert.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/convert/unit",
          "name": "unit",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.convert.unit",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/convert/axis",
          "name": "axis",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.convert.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def convert(value, unit, axis):\n        # docstring inherited\n\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        if not cbook.is_scalar_or_string(value):\n            return [EpochConverter.convert(x, unit, axis) for x in value]\n        if unit is None:\n            unit = EpochConverter.default_units(value, axis)\n        if isinstance(value, U.Duration):\n            return EpochConverter.duration2float(value)\n        else:\n            return EpochConverter.epoch2float(value, unit)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/default_units",
      "name": "default_units",
      "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.default_units",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/default_units/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.default_units.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/default_units/axis",
          "name": "axis",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.default_units.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def default_units(value, axis):\n        # docstring inherited\n        if cbook.is_scalar_or_string(value):\n            return value.frame()\n        else:\n            return EpochConverter.default_units(value[0], axis)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/duration2float",
      "name": "duration2float",
      "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.duration2float",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/duration2float/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.duration2float.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert a Duration value to a float suitable for plotting as a python\ndatetime object.\n\n= INPUT VARIABLES\n- value    A Duration or list of Durations that need to be converted.\n\n= RETURN VALUE\n- Returns the value parameter converted to floats.",
      "docstring": "Convert a Duration value to a float suitable for plotting as a python\ndatetime object.\n\n= INPUT VARIABLES\n- value    A Duration or list of Durations that need to be converted.\n\n= RETURN VALUE\n- Returns the value parameter converted to floats.",
      "code": "    @staticmethod\n    def duration2float(value):\n        \"\"\"\n        Convert a Duration value to a float suitable for plotting as a python\n        datetime object.\n\n        = INPUT VARIABLES\n        - value    A Duration or list of Durations that need to be converted.\n\n        = RETURN VALUE\n        - Returns the value parameter converted to floats.\n        \"\"\"\n        return value.seconds() / 86400.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/epoch2float",
      "name": "epoch2float",
      "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.epoch2float",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/epoch2float/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.epoch2float.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/epoch2float/unit",
          "name": "unit",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.epoch2float.unit",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert an Epoch value to a float suitable for plotting as a python\ndatetime object.\n\n= INPUT VARIABLES\n- value    An Epoch or list of Epochs that need to be converted.\n- unit     The units to use for an axis with Epoch data.\n\n= RETURN VALUE\n- Returns the value parameter converted to floats.",
      "docstring": "Convert an Epoch value to a float suitable for plotting as a python\ndatetime object.\n\n= INPUT VARIABLES\n- value    An Epoch or list of Epochs that need to be converted.\n- unit     The units to use for an axis with Epoch data.\n\n= RETURN VALUE\n- Returns the value parameter converted to floats.",
      "code": "    @staticmethod\n    def epoch2float(value, unit):\n        \"\"\"\n        Convert an Epoch value to a float suitable for plotting as a python\n        datetime object.\n\n        = INPUT VARIABLES\n        - value    An Epoch or list of Epochs that need to be converted.\n        - unit     The units to use for an axis with Epoch data.\n\n        = RETURN VALUE\n        - Returns the value parameter converted to floats.\n        \"\"\"\n        return value.julianDate(unit) - EpochConverter.jdRef"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/float2epoch",
      "name": "float2epoch",
      "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.float2epoch",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/float2epoch/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.float2epoch.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.EpochConverter/EpochConverter/float2epoch/unit",
          "name": "unit",
          "qname": "lib.matplotlib.testing.jpl_units.EpochConverter.EpochConverter.float2epoch.unit",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert a Matplotlib floating-point date into an Epoch of the specified\nunits.\n\n= INPUT VARIABLES\n- value     The Matplotlib floating-point date.\n- unit      The unit system to use for the Epoch.\n\n= RETURN VALUE\n- Returns the value converted to an Epoch in the specified time system.",
      "docstring": "Convert a Matplotlib floating-point date into an Epoch of the specified\nunits.\n\n= INPUT VARIABLES\n- value     The Matplotlib floating-point date.\n- unit      The unit system to use for the Epoch.\n\n= RETURN VALUE\n- Returns the value converted to an Epoch in the specified time system.",
      "code": "    @staticmethod\n    def float2epoch(value, unit):\n        \"\"\"\n        Convert a Matplotlib floating-point date into an Epoch of the specified\n        units.\n\n        = INPUT VARIABLES\n        - value     The Matplotlib floating-point date.\n        - unit      The unit system to use for the Epoch.\n\n        = RETURN VALUE\n        - Returns the value converted to an Epoch in the specified time system.\n        \"\"\"\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        secPastRef = value * 86400.0 * U.UnitDbl(1.0, 'sec')\n        return U.Epoch(unit, secPastRef, EpochConverter.jdRef)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/axisinfo",
      "name": "axisinfo",
      "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.axisinfo",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/axisinfo/unit",
          "name": "unit",
          "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.axisinfo.unit",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/axisinfo/axis",
          "name": "axis",
          "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.axisinfo.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def axisinfo(unit, axis):\n        # docstring inherited\n        return None"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/convert",
      "name": "convert",
      "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.convert",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/convert/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.convert.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/convert/unit",
          "name": "unit",
          "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.convert.unit",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/convert/axis",
          "name": "axis",
          "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.convert.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def convert(value, unit, axis):\n        # docstring inherited\n\n        if value == []:\n            return []\n\n        # we delay loading to make matplotlib happy\n        ax = axis.axes\n        if axis is ax.xaxis:\n            isXAxis = True\n        else:\n            isXAxis = False\n\n        axis.get_major_ticks()\n        ticks = axis.get_ticklocs()\n        labels = axis.get_ticklabels()\n\n        labels = [l.get_text() for l in labels if l.get_text()]\n\n        if not labels:\n            ticks = []\n            labels = []\n\n        if not np.iterable(value):\n            value = [value]\n\n        newValues = []\n        for v in value:\n            if v not in labels and v not in newValues:\n                newValues.append(v)\n\n        labels.extend(newValues)\n\n        # DISABLED: This is disabled because matplotlib bar plots do not\n        # DISABLED: recalculate the unit conversion of the data values\n        # DISABLED: this is due to design and is not really a bug.\n        # DISABLED: If this gets changed, then we can activate the following\n        # DISABLED: block of code.  Note that this works for line plots.\n        # DISABLED if unit:\n        # DISABLED     if unit.find(\"sorted\") > -1:\n        # DISABLED         labels.sort()\n        # DISABLED     if unit.find(\"inverted\") > -1:\n        # DISABLED         labels = labels[::-1]\n\n        # add padding (so they do not appear on the axes themselves)\n        labels = [''] + labels + ['']\n        ticks = list(range(len(labels)))\n        ticks[0] = 0.5\n        ticks[-1] = ticks[-1] - 0.5\n\n        axis.set_ticks(ticks)\n        axis.set_ticklabels(labels)\n        # we have to do the following lines to make ax.autoscale_view work\n        loc = axis.get_major_locator()\n        loc.set_bounds(ticks[0], ticks[-1])\n\n        if isXAxis:\n            ax.set_xlim(ticks[0], ticks[-1])\n        else:\n            ax.set_ylim(ticks[0], ticks[-1])\n\n        result = [ticks[labels.index(v)] for v in value]\n\n        ax.viewLim.ignore(-1)\n        return result"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/default_units",
      "name": "default_units",
      "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.default_units",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/default_units/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.default_units.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.StrConverter/StrConverter/default_units/axis",
          "name": "axis",
          "qname": "lib.matplotlib.testing.jpl_units.StrConverter.StrConverter.default_units.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def default_units(value, axis):\n        # docstring inherited\n        # The default behavior for string indexing.\n        return \"indexed\""
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__abs__",
      "name": "__abs__",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__abs__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__abs__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__abs__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the absolute value of this UnitDbl.",
      "docstring": "Return the absolute value of this UnitDbl.",
      "code": "    def __abs__(self):\n        \"\"\"Return the absolute value of this UnitDbl.\"\"\"\n        return UnitDbl(abs(self._value), self._units)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__bool__",
      "name": "__bool__",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__bool__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__bool__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__bool__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the truth value of a UnitDbl.",
      "docstring": "Return the truth value of a UnitDbl.",
      "code": "    def __bool__(self):\n        \"\"\"Return the truth value of a UnitDbl.\"\"\"\n        return bool(self._value)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__init__/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__init__.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__init__/units",
          "name": "units",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__init__.units",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Class UnitDbl in development.",
      "docstring": "Create a new UnitDbl object.\n\nUnits are internally converted to km, rad, and sec.  The only\nvalid inputs for units are [m, km, mile, rad, deg, sec, min, hour].\n\nThe field UnitDbl.value will contain the converted value.  Use\nthe convert() method to get a specific type of units back.\n\n= ERROR CONDITIONS\n- If the input units are not in the allowed list, an error is thrown.\n\n= INPUT VARIABLES\n- value     The numeric value of the UnitDbl.\n- units     The string name of the units the value is in.",
      "code": "    def __init__(self, value, units):\n        \"\"\"\n        Create a new UnitDbl object.\n\n        Units are internally converted to km, rad, and sec.  The only\n        valid inputs for units are [m, km, mile, rad, deg, sec, min, hour].\n\n        The field UnitDbl.value will contain the converted value.  Use\n        the convert() method to get a specific type of units back.\n\n        = ERROR CONDITIONS\n        - If the input units are not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - value     The numeric value of the UnitDbl.\n        - units     The string name of the units the value is in.\n        \"\"\"\n        data = _api.check_getitem(self.allowed, units=units)\n        self._value = float(value * data[0])\n        self._units = data[1]"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__neg__",
      "name": "__neg__",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__neg__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__neg__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__neg__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the negative value of this UnitDbl.",
      "docstring": "Return the negative value of this UnitDbl.",
      "code": "    def __neg__(self):\n        \"\"\"Return the negative value of this UnitDbl.\"\"\"\n        return UnitDbl(-self._value, self._units)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Print the UnitDbl.",
      "docstring": "Print the UnitDbl.",
      "code": "    def __repr__(self):\n        \"\"\"Print the UnitDbl.\"\"\"\n        return \"UnitDbl(%g, '%s')\" % (self._value, self._units)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__str__",
      "name": "__str__",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/__str__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Print the UnitDbl.",
      "docstring": "Print the UnitDbl.",
      "code": "    def __str__(self):\n        \"\"\"Print the UnitDbl.\"\"\"\n        return \"%g *%s\" % (self._value, self._units)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/checkSameUnits",
      "name": "checkSameUnits",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.checkSameUnits",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/checkSameUnits/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.checkSameUnits.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/checkSameUnits/rhs",
          "name": "rhs",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.checkSameUnits.rhs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/checkSameUnits/func",
          "name": "func",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.checkSameUnits.func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Check to see if units are the same.\n\n= ERROR CONDITIONS\n- If the units of the rhs UnitDbl are not the same as our units,\n  an error is thrown.\n\n= INPUT VARIABLES\n- rhs     The UnitDbl to check for the same units\n- func    The name of the function doing the check.",
      "docstring": "Check to see if units are the same.\n\n= ERROR CONDITIONS\n- If the units of the rhs UnitDbl are not the same as our units,\n  an error is thrown.\n\n= INPUT VARIABLES\n- rhs     The UnitDbl to check for the same units\n- func    The name of the function doing the check.",
      "code": "    def checkSameUnits(self, rhs, func):\n        \"\"\"\n        Check to see if units are the same.\n\n        = ERROR CONDITIONS\n        - If the units of the rhs UnitDbl are not the same as our units,\n          an error is thrown.\n\n        = INPUT VARIABLES\n        - rhs     The UnitDbl to check for the same units\n        - func    The name of the function doing the check.\n        \"\"\"\n        if self._units != rhs._units:\n            raise ValueError(f\"Cannot {func} units of different types.\\n\"\n                             f\"LHS: {self._units}\\n\"\n                             f\"RHS: {rhs._units}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/convert",
      "name": "convert",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.convert",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/convert/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.convert.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/convert/units",
          "name": "units",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.convert.units",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert the UnitDbl to a specific set of units.\n\n= ERROR CONDITIONS\n- If the input units are not in the allowed list, an error is thrown.\n\n= INPUT VARIABLES\n- units     The string name of the units to convert to.\n\n= RETURN VALUE\n- Returns the value of the UnitDbl in the requested units as a floating\n  point number.",
      "docstring": "Convert the UnitDbl to a specific set of units.\n\n= ERROR CONDITIONS\n- If the input units are not in the allowed list, an error is thrown.\n\n= INPUT VARIABLES\n- units     The string name of the units to convert to.\n\n= RETURN VALUE\n- Returns the value of the UnitDbl in the requested units as a floating\n  point number.",
      "code": "    def convert(self, units):\n        \"\"\"\n        Convert the UnitDbl to a specific set of units.\n\n        = ERROR CONDITIONS\n        - If the input units are not in the allowed list, an error is thrown.\n\n        = INPUT VARIABLES\n        - units     The string name of the units to convert to.\n\n        = RETURN VALUE\n        - Returns the value of the UnitDbl in the requested units as a floating\n          point number.\n        \"\"\"\n        if self._units == units:\n            return self._value\n        data = _api.check_getitem(self.allowed, units=units)\n        if self._units != data[1]:\n            raise ValueError(f\"Error trying to convert to different units.\\n\"\n                             f\"    Invalid conversion requested.\\n\"\n                             f\"    UnitDbl: {self}\\n\"\n                             f\"    Units:   {units}\\n\")\n        return self._value / data[0]"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/range",
      "name": "range",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.range",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/range/start",
          "name": "start",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.range.start",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/range/stop",
          "name": "stop",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.range.stop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/range/step",
          "name": "step",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.range.step",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Generate a range of UnitDbl objects.\n\nSimilar to the Python range() method.  Returns the range [\nstart, stop) at the requested step.  Each element will be a\nUnitDbl object.\n\n= INPUT VARIABLES\n- start     The starting value of the range.\n- stop      The stop value of the range.\n- step      Optional step to use.  If set to None, then a UnitDbl of\n              value 1 w/ the units of the start is used.\n\n= RETURN VALUE\n- Returns a list containing the requested UnitDbl values.",
      "docstring": "Generate a range of UnitDbl objects.\n\nSimilar to the Python range() method.  Returns the range [\nstart, stop) at the requested step.  Each element will be a\nUnitDbl object.\n\n= INPUT VARIABLES\n- start     The starting value of the range.\n- stop      The stop value of the range.\n- step      Optional step to use.  If set to None, then a UnitDbl of\n              value 1 w/ the units of the start is used.\n\n= RETURN VALUE\n- Returns a list containing the requested UnitDbl values.",
      "code": "    @staticmethod\n    def range(start, stop, step=None):\n        \"\"\"\n        Generate a range of UnitDbl objects.\n\n        Similar to the Python range() method.  Returns the range [\n        start, stop) at the requested step.  Each element will be a\n        UnitDbl object.\n\n        = INPUT VARIABLES\n        - start     The starting value of the range.\n        - stop      The stop value of the range.\n        - step      Optional step to use.  If set to None, then a UnitDbl of\n                      value 1 w/ the units of the start is used.\n\n        = RETURN VALUE\n        - Returns a list containing the requested UnitDbl values.\n        \"\"\"\n        if step is None:\n            step = UnitDbl(1, start._units)\n\n        elems = []\n\n        i = 0\n        while True:\n            d = start + i * step\n            if d >= stop:\n                break\n\n            elems.append(d)\n            i += 1\n\n        return elems"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/type",
      "name": "type",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.type",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDbl/UnitDbl/type/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDbl.UnitDbl.type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the type of UnitDbl data.",
      "docstring": "Return the type of UnitDbl data.",
      "code": "    def type(self):\n        \"\"\"Return the type of UnitDbl data.\"\"\"\n        return self._types[self._units]"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/axisinfo",
      "name": "axisinfo",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.axisinfo",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/axisinfo/unit",
          "name": "unit",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.axisinfo.unit",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/axisinfo/axis",
          "name": "axis",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.axisinfo.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def axisinfo(unit, axis):\n        # docstring inherited\n\n        # Delay-load due to circular dependencies.\n        import matplotlib.testing.jpl_units as U\n\n        # Check to see if the value used for units is a string unit value\n        # or an actual instance of a UnitDbl so that we can use the unit\n        # value for the default axis label value.\n        if unit:\n            label = unit if isinstance(unit, str) else unit.label()\n        else:\n            label = None\n\n        if label == \"deg\" and isinstance(axis.axes, polar.PolarAxes):\n            # If we want degrees for a polar plot, use the PolarPlotFormatter\n            majfmt = polar.PolarAxes.ThetaFormatter()\n        else:\n            majfmt = U.UnitDblFormatter(useOffset=False)\n\n        return units.AxisInfo(majfmt=majfmt, label=label)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/convert",
      "name": "convert",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.convert",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/convert/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.convert.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/convert/unit",
          "name": "unit",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.convert.unit",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/convert/axis",
          "name": "axis",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.convert.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def convert(value, unit, axis):\n        # docstring inherited\n        if not cbook.is_scalar_or_string(value):\n            return [UnitDblConverter.convert(x, unit, axis) for x in value]\n        # If no units were specified, then get the default units to use.\n        if unit is None:\n            unit = UnitDblConverter.default_units(value, axis)\n        # Convert the incoming UnitDbl value/values to float/floats\n        if isinstance(axis.axes, polar.PolarAxes) and value.type() == \"angle\":\n            # Guarantee that units are radians for polar plots.\n            return value.convert(\"rad\")\n        return value.convert(unit)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/default_units",
      "name": "default_units",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.default_units",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/default_units/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.default_units.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/UnitDblConverter/default_units/axis",
          "name": "axis",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.UnitDblConverter.default_units.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def default_units(value, axis):\n        # docstring inherited\n        # Determine the default units based on the user preferences set for\n        # default units when printing a UnitDbl.\n        if cbook.is_scalar_or_string(value):\n            return UnitDblConverter.defaults[value.type()]\n        else:\n            return UnitDblConverter.default_units(value[0], axis)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/rad_fn",
      "name": "rad_fn",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.rad_fn",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/rad_fn/x",
          "name": "x",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.rad_fn.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblConverter/rad_fn/pos",
          "name": "pos",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblConverter.rad_fn.pos",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Radian function formatter.",
      "docstring": "Radian function formatter.",
      "code": "def rad_fn(x, pos=None):\n    \"\"\"Radian function formatter.\"\"\"\n    n = int((x / np.pi) * 2.0 + 0.25)\n    if n == 0:\n        return str(x)\n    elif n == 1:\n        return r'$\\pi/2$'\n    elif n == 2:\n        return r'$\\pi$'\n    elif n % 2 == 0:\n        return fr'${n//2}\\pi$'\n    else:\n        return fr'${n}\\pi/2$'"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/__call__/x",
          "name": "x",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.__call__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/__call__/pos",
          "name": "pos",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.__call__.pos",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __call__(self, x, pos=None):\n        # docstring inherited\n        if len(self.locs) == 0:\n            return ''\n        else:\n            return '{:.12}'.format(x)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/format_data",
      "name": "format_data",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.format_data",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/format_data/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.format_data.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/format_data/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.format_data.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def format_data(self, value):\n        # docstring inherited\n        return '{:.12}'.format(value)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/format_data_short",
      "name": "format_data_short",
      "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.format_data_short",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/format_data_short/self",
          "name": "self",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.format_data_short.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.jpl_units.UnitDblFormatter/UnitDblFormatter/format_data_short/value",
          "name": "value",
          "qname": "lib.matplotlib.testing.jpl_units.UnitDblFormatter.UnitDblFormatter.format_data_short.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def format_data_short(self, value):\n        # docstring inherited\n        return '{:.12}'.format(value)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.jpl_units/register",
      "name": "register",
      "qname": "lib.matplotlib.testing.jpl_units.register",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Register the unit conversion classes with matplotlib.",
      "docstring": "Register the unit conversion classes with matplotlib.",
      "code": "def register():\n    \"\"\"Register the unit conversion classes with matplotlib.\"\"\"\n    import matplotlib.units as mplU\n\n    mplU.registry[str] = StrConverter()\n    mplU.registry[Epoch] = EpochConverter()\n    mplU.registry[Duration] = EpochConverter()\n    mplU.registry[UnitDbl] = UnitDblConverter()"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.widgets/click_and_drag",
      "name": "click_and_drag",
      "qname": "lib.matplotlib.testing.widgets.click_and_drag",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/click_and_drag/tool",
          "name": "tool",
          "qname": "lib.matplotlib.testing.widgets.click_and_drag.tool",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`matplotlib.widgets.Widget`",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "`matplotlib.widgets.Widget`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/click_and_drag/start",
          "name": "start",
          "qname": "lib.matplotlib.testing.widgets.click_and_drag.start",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "[float, float]",
            "default_value": "",
            "description": "Starting point in data coordinates."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "[float"
              },
              {
                "kind": "NamedType",
                "name": "float]"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/click_and_drag/end",
          "name": "end",
          "qname": "lib.matplotlib.testing.widgets.click_and_drag.end",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "[float, float]",
            "default_value": "",
            "description": "End point in data coordinates."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "[float"
              },
              {
                "kind": "NamedType",
                "name": "float]"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/click_and_drag/key",
          "name": "key",
          "qname": "lib.matplotlib.testing.widgets.click_and_drag.key",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or str",
            "default_value": "",
            "description": "An optional key that is pressed during the whole operation\n(see also `.KeyEvent`)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Helper to simulate a mouse drag operation.",
      "docstring": "Helper to simulate a mouse drag operation.\n\nParameters\n----------\ntool : `matplotlib.widgets.Widget`\nstart : [float, float]\n    Starting point in data coordinates.\nend : [float, float]\n    End point in data coordinates.\nkey : None or str\n     An optional key that is pressed during the whole operation\n     (see also `.KeyEvent`).",
      "code": "def click_and_drag(tool, start, end, key=None):\n    \"\"\"\n    Helper to simulate a mouse drag operation.\n\n    Parameters\n    ----------\n    tool : `matplotlib.widgets.Widget`\n    start : [float, float]\n        Starting point in data coordinates.\n    end : [float, float]\n        End point in data coordinates.\n    key : None or str\n         An optional key that is pressed during the whole operation\n         (see also `.KeyEvent`).\n    \"\"\"\n    if key is not None:\n        # Press key\n        do_event(tool, 'on_key_press', xdata=start[0], ydata=start[1],\n                 button=1, key=key)\n    # Click, move, and release mouse\n    do_event(tool, 'press', xdata=start[0], ydata=start[1], button=1)\n    do_event(tool, 'onmove', xdata=end[0], ydata=end[1], button=1)\n    do_event(tool, 'release', xdata=end[0], ydata=end[1], button=1)\n    if key is not None:\n        # Release key\n        do_event(tool, 'on_key_release', xdata=end[0], ydata=end[1],\n                 button=1, key=key)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.widgets/do_event",
      "name": "do_event",
      "qname": "lib.matplotlib.testing.widgets.do_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/do_event/tool",
          "name": "tool",
          "qname": "lib.matplotlib.testing.widgets.do_event.tool",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "matplotlib.widgets.RectangleSelector",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "matplotlib.widgets.RectangleSelector"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/do_event/etype",
          "name": "etype",
          "qname": "lib.matplotlib.testing.widgets.do_event.etype",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The event to trigger."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/do_event/button",
          "name": "button",
          "qname": "lib.matplotlib.testing.widgets.do_event.button",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or `MouseButton` or {'up', 'down'}",
            "default_value": "",
            "description": "The mouse button pressed in this event (see also `.MouseEvent`)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "up",
                  "down"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "`MouseButton`"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/do_event/xdata",
          "name": "xdata",
          "qname": "lib.matplotlib.testing.widgets.do_event.xdata",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "x coord of mouse in data coords."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/do_event/ydata",
          "name": "ydata",
          "qname": "lib.matplotlib.testing.widgets.do_event.ydata",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "y coord of mouse in data coords."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/do_event/key",
          "name": "key",
          "qname": "lib.matplotlib.testing.widgets.do_event.key",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or str",
            "default_value": "",
            "description": "The key pressed when the mouse event triggered (see also `.KeyEvent`)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/do_event/step",
          "name": "step",
          "qname": "lib.matplotlib.testing.widgets.do_event.step",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Number of scroll steps (positive for 'up', negative for 'down')."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Trigger an event on the given tool.",
      "docstring": "Trigger an event on the given tool.\n\nParameters\n----------\ntool : matplotlib.widgets.RectangleSelector\netype : str\n    The event to trigger.\nxdata : int\n    x coord of mouse in data coords.\nydata : int\n    y coord of mouse in data coords.\nbutton : None or `MouseButton` or {'up', 'down'}\n    The mouse button pressed in this event (see also `.MouseEvent`).\nkey : None or str\n    The key pressed when the mouse event triggered (see also `.KeyEvent`).\nstep : int\n    Number of scroll steps (positive for 'up', negative for 'down').",
      "code": "def do_event(tool, etype, button=1, xdata=0, ydata=0, key=None, step=1):\n    \"\"\"\n    Trigger an event on the given tool.\n\n    Parameters\n    ----------\n    tool : matplotlib.widgets.RectangleSelector\n    etype : str\n        The event to trigger.\n    xdata : int\n        x coord of mouse in data coords.\n    ydata : int\n        y coord of mouse in data coords.\n    button : None or `MouseButton` or {'up', 'down'}\n        The mouse button pressed in this event (see also `.MouseEvent`).\n    key : None or str\n        The key pressed when the mouse event triggered (see also `.KeyEvent`).\n    step : int\n        Number of scroll steps (positive for 'up', negative for 'down').\n    \"\"\"\n    event = mock_event(tool.ax, button, xdata, ydata, key, step)\n    func = getattr(tool, etype)\n    func(event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.widgets/get_ax",
      "name": "get_ax",
      "qname": "lib.matplotlib.testing.widgets.get_ax",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Create a plot and return its axes.",
      "docstring": "Create a plot and return its axes.",
      "code": "def get_ax():\n    \"\"\"Create a plot and return its axes.\"\"\"\n    fig, ax = plt.subplots(1, 1)\n    ax.plot([0, 200], [0, 200])\n    ax.set_aspect(1.0)\n    ax.figure.canvas.draw()\n    return ax"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.widgets/mock_event",
      "name": "mock_event",
      "qname": "lib.matplotlib.testing.widgets.mock_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/mock_event/ax",
          "name": "ax",
          "qname": "lib.matplotlib.testing.widgets.mock_event.ax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`matplotlib.axes.Axes`",
            "default_value": "",
            "description": "The axes the event will be in."
          },
          "type": {
            "kind": "NamedType",
            "name": "`matplotlib.axes.Axes`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/mock_event/button",
          "name": "button",
          "qname": "lib.matplotlib.testing.widgets.mock_event.button",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or `MouseButton` or {'up', 'down'}",
            "default_value": "",
            "description": "The mouse button pressed in this event (see also `.MouseEvent`)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "EnumType",
                "values": [
                  "up",
                  "down"
                ]
              },
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "`MouseButton`"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/mock_event/xdata",
          "name": "xdata",
          "qname": "lib.matplotlib.testing.widgets.mock_event.xdata",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "x coord of mouse in data coords."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/mock_event/ydata",
          "name": "ydata",
          "qname": "lib.matplotlib.testing.widgets.mock_event.ydata",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "y coord of mouse in data coords."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/mock_event/key",
          "name": "key",
          "qname": "lib.matplotlib.testing.widgets.mock_event.key",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or str",
            "default_value": "",
            "description": "The key pressed when the mouse event triggered (see also `.KeyEvent`)."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "str"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/mock_event/step",
          "name": "step",
          "qname": "lib.matplotlib.testing.widgets.mock_event.step",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Number of scroll steps (positive for 'up', negative for 'down')."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Create a mock event that can stand in for `.Event` and its subclasses.\n\nThis event is intended to be used in tests where it can be passed into\nevent handling functions.",
      "docstring": "Create a mock event that can stand in for `.Event` and its subclasses.\n\nThis event is intended to be used in tests where it can be passed into\nevent handling functions.\n\nParameters\n----------\nax : `matplotlib.axes.Axes`\n    The axes the event will be in.\nxdata : int\n    x coord of mouse in data coords.\nydata : int\n    y coord of mouse in data coords.\nbutton : None or `MouseButton` or {'up', 'down'}\n    The mouse button pressed in this event (see also `.MouseEvent`).\nkey : None or str\n    The key pressed when the mouse event triggered (see also `.KeyEvent`).\nstep : int\n    Number of scroll steps (positive for 'up', negative for 'down').\n\nReturns\n-------\nevent\n    A `.Event`\\-like Mock instance.",
      "code": "def mock_event(ax, button=1, xdata=0, ydata=0, key=None, step=1):\n    r\"\"\"\n    Create a mock event that can stand in for `.Event` and its subclasses.\n\n    This event is intended to be used in tests where it can be passed into\n    event handling functions.\n\n    Parameters\n    ----------\n    ax : `matplotlib.axes.Axes`\n        The axes the event will be in.\n    xdata : int\n        x coord of mouse in data coords.\n    ydata : int\n        y coord of mouse in data coords.\n    button : None or `MouseButton` or {'up', 'down'}\n        The mouse button pressed in this event (see also `.MouseEvent`).\n    key : None or str\n        The key pressed when the mouse event triggered (see also `.KeyEvent`).\n    step : int\n        Number of scroll steps (positive for 'up', negative for 'down').\n\n    Returns\n    -------\n    event\n        A `.Event`\\-like Mock instance.\n    \"\"\"\n    event = mock.Mock()\n    event.button = button\n    event.x, event.y = ax.transData.transform([(xdata, ydata),\n                                               (xdata, ydata)])[0]\n    event.xdata, event.ydata = xdata, ydata\n    event.inaxes = ax\n    event.canvas = ax.figure.canvas\n    event.key = key\n    event.step = step\n    event.guiEvent = None\n    event.name = 'Custom'\n    return event"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing.widgets/noop",
      "name": "noop",
      "qname": "lib.matplotlib.testing.widgets.noop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/noop/args",
          "name": "args",
          "qname": "lib.matplotlib.testing.widgets.noop.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing.widgets/noop/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.testing.widgets.noop.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def noop(*args, **kwargs):\n    pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing/set_font_settings_for_testing",
      "name": "set_font_settings_for_testing",
      "qname": "lib.matplotlib.testing.set_font_settings_for_testing",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def set_font_settings_for_testing():\n    mpl.rcParams['font.family'] = 'DejaVu Sans'\n    mpl.rcParams['text.hinting'] = 'none'\n    mpl.rcParams['text.hinting_factor'] = 8"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing/set_reproducibility_for_testing",
      "name": "set_reproducibility_for_testing",
      "qname": "lib.matplotlib.testing.set_reproducibility_for_testing",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def set_reproducibility_for_testing():\n    mpl.rcParams['svg.hashsalt'] = 'matplotlib'"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing/setup",
      "name": "setup",
      "qname": "lib.matplotlib.testing.setup",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def setup():\n    # The baseline images are created in this locale, so we should use\n    # it during all of the tests.\n\n    try:\n        locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n    except locale.Error:\n        try:\n            locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n        except locale.Error:\n            _log.warning(\n                \"Could not set locale to English/United States. \"\n                \"Some date-related tests may fail.\")\n\n    mpl.use('Agg')\n\n    with _api.suppress_matplotlib_deprecation_warning():\n        mpl.rcdefaults()  # Start with all defaults\n\n    # These settings *must* be hardcoded for running the comparison tests and\n    # are not necessarily the default values as specified in rcsetup.py.\n    set_font_settings_for_testing()\n    set_reproducibility_for_testing()"
    },
    {
      "id": "matplotlib/lib.matplotlib.testing/subprocess_run_helper",
      "name": "subprocess_run_helper",
      "qname": "lib.matplotlib.testing.subprocess_run_helper",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.testing/subprocess_run_helper/func",
          "name": "func",
          "qname": "lib.matplotlib.testing.subprocess_run_helper.func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "function",
            "default_value": "",
            "description": "The function to be run.  It must be in a module that is importable."
          },
          "type": {
            "kind": "NamedType",
            "name": "function"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing/subprocess_run_helper/args",
          "name": "args",
          "qname": "lib.matplotlib.testing.subprocess_run_helper.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Any additional command line arguments to be passed in\nthe first argument to ``subprocess.run``."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.testing/subprocess_run_helper/timeout",
          "name": "timeout",
          "qname": "lib.matplotlib.testing.subprocess_run_helper.timeout",
          "default_value": null,
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.testing/subprocess_run_helper/extra_env",
          "name": "extra_env",
          "qname": "lib.matplotlib.testing.subprocess_run_helper.extra_env",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "dict[str, str]",
            "default_value": "",
            "description": "Any additional environment variables to be set for the subprocess."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "str]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Run a function in a sub-process.",
      "docstring": "Run a function in a sub-process.\n\nParameters\n----------\nfunc : function\n    The function to be run.  It must be in a module that is importable.\n*args : str\n    Any additional command line arguments to be passed in\n    the first argument to ``subprocess.run``.\nextra_env : dict[str, str]\n    Any additional environment variables to be set for the subprocess.",
      "code": "def subprocess_run_helper(func, *args, timeout, extra_env=None):\n    \"\"\"\n    Run a function in a sub-process.\n\n    Parameters\n    ----------\n    func : function\n        The function to be run.  It must be in a module that is importable.\n    *args : str\n        Any additional command line arguments to be passed in\n        the first argument to ``subprocess.run``.\n    extra_env : dict[str, str]\n        Any additional environment variables to be set for the subprocess.\n    \"\"\"\n    target = func.__name__\n    module = func.__module__\n    proc = subprocess.run(\n        [sys.executable,\n         \"-c\",\n         f\"from {module} import {target}; {target}()\",\n         *args],\n        env={**os.environ, \"SOURCE_DATE_EPOCH\": \"0\", **(extra_env or {})},\n        timeout=timeout, check=True,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True)\n    return proc"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/__init__/x",
          "name": "x",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.__init__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "(npoints,) array-like",
            "default_value": "",
            "description": "Coordinates of grid points."
          },
          "type": {
            "kind": "NamedType",
            "name": "(npoints,) array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/__init__/y",
          "name": "y",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.__init__.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "(npoints,) array-like",
            "default_value": "",
            "description": "Coordinates of grid points."
          },
          "type": {
            "kind": "NamedType",
            "name": "(npoints,) array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/__init__/triangles",
          "name": "triangles",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.__init__.triangles",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "(ntri, 3) array-like of int",
            "default_value": "",
            "description": "For each triangle, the indices of the three points that make\nup the triangle, ordered in an anticlockwise manner.  If not\nspecified, the Delaunay triangulation is calculated."
          },
          "type": {
            "kind": "NamedType",
            "name": "(ntri, 3) array-like of int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/__init__/mask",
          "name": "mask",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.__init__.mask",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "(ntri,) array-like of bool",
            "default_value": "",
            "description": "Which triangles are masked out."
          },
          "type": {
            "kind": "NamedType",
            "name": "(ntri,) array-like of bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "An unstructured triangular grid consisting of npoints points and\nntri triangles.  The triangles can either be specified by the user\nor automatically generated using a Delaunay triangulation.",
      "docstring": "",
      "code": "    def __init__(self, x, y, triangles=None, mask=None):\n        from matplotlib import _qhull\n\n        self.x = np.asarray(x, dtype=np.float64)\n        self.y = np.asarray(y, dtype=np.float64)\n        if self.x.shape != self.y.shape or self.x.ndim != 1:\n            raise ValueError(\"x and y must be equal-length 1D arrays, but \"\n                             f\"found shapes {self.x.shape!r} and \"\n                             f\"{self.y.shape!r}\")\n\n        self.mask = None\n        self._edges = None\n        self._neighbors = None\n        self.is_delaunay = False\n\n        if triangles is None:\n            # No triangulation specified, so use matplotlib._qhull to obtain\n            # Delaunay triangulation.\n            self.triangles, self._neighbors = _qhull.delaunay(x, y)\n            self.is_delaunay = True\n        else:\n            # Triangulation specified. Copy, since we may correct triangle\n            # orientation.\n            try:\n                self.triangles = np.array(triangles, dtype=np.int32, order='C')\n            except ValueError as e:\n                raise ValueError('triangles must be a (N, 3) int array, not '\n                                 f'{triangles!r}') from e\n            if self.triangles.ndim != 2 or self.triangles.shape[1] != 3:\n                raise ValueError(\n                    'triangles must be a (N, 3) int array, but found shape '\n                    f'{self.triangles.shape!r}')\n            if self.triangles.max() >= len(self.x):\n                raise ValueError(\n                    'triangles are indices into the points and must be in the '\n                    f'range 0 <= i < {len(self.x)} but found value '\n                    f'{self.triangles.max()}')\n            if self.triangles.min() < 0:\n                raise ValueError(\n                    'triangles are indices into the points and must be in the '\n                    f'range 0 <= i < {len(self.x)} but found value '\n                    f'{self.triangles.min()}')\n\n        # Underlying C++ object is not created until first needed.\n        self._cpp_triangulation = None\n\n        # Default TriFinder not created until needed.\n        self._trifinder = None\n\n        self.set_mask(mask)"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/calculate_plane_coefficients",
      "name": "calculate_plane_coefficients",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation.calculate_plane_coefficients",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/calculate_plane_coefficients/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.calculate_plane_coefficients.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/calculate_plane_coefficients/z",
          "name": "z",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.calculate_plane_coefficients.z",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Calculate plane equation coefficients for all unmasked triangles from\nthe point (x, y) coordinates and specified z-array of shape (npoints).\nThe returned array has shape (npoints, 3) and allows z-value at (x, y)\nposition in triangle tri to be calculated using\n``z = array[tri, 0] * x  + array[tri, 1] * y + array[tri, 2]``.",
      "docstring": "Calculate plane equation coefficients for all unmasked triangles from\nthe point (x, y) coordinates and specified z-array of shape (npoints).\nThe returned array has shape (npoints, 3) and allows z-value at (x, y)\nposition in triangle tri to be calculated using\n``z = array[tri, 0] * x  + array[tri, 1] * y + array[tri, 2]``.",
      "code": "    def calculate_plane_coefficients(self, z):\n        \"\"\"\n        Calculate plane equation coefficients for all unmasked triangles from\n        the point (x, y) coordinates and specified z-array of shape (npoints).\n        The returned array has shape (npoints, 3) and allows z-value at (x, y)\n        position in triangle tri to be calculated using\n        ``z = array[tri, 0] * x  + array[tri, 1] * y + array[tri, 2]``.\n        \"\"\"\n        return self.get_cpp_triangulation().calculate_plane_coefficients(z)"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/edges@getter",
      "name": "edges",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation.edges",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/edges@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.edges.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return integer array of shape (nedges, 2) containing all edges of\nnon-masked triangles.\n\nEach row defines an edge by its start point index and end point\nindex.  Each edge appears only once, i.e. for an edge between points\n*i*  and *j*, there will only be either *(i, j)* or *(j, i)*.",
      "docstring": "Return integer array of shape (nedges, 2) containing all edges of\nnon-masked triangles.\n\nEach row defines an edge by its start point index and end point\nindex.  Each edge appears only once, i.e. for an edge between points\n*i*  and *j*, there will only be either *(i, j)* or *(j, i)*.",
      "code": "    @property\n    def edges(self):\n        \"\"\"\n        Return integer array of shape (nedges, 2) containing all edges of\n        non-masked triangles.\n\n        Each row defines an edge by its start point index and end point\n        index.  Each edge appears only once, i.e. for an edge between points\n        *i*  and *j*, there will only be either *(i, j)* or *(j, i)*.\n        \"\"\"\n        if self._edges is None:\n            self._edges = self.get_cpp_triangulation().get_edges()\n        return self._edges"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_cpp_triangulation",
      "name": "get_cpp_triangulation",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation.get_cpp_triangulation",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_cpp_triangulation/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.get_cpp_triangulation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the underlying C++ Triangulation object, creating it\nif necessary.",
      "docstring": "Return the underlying C++ Triangulation object, creating it\nif necessary.",
      "code": "    def get_cpp_triangulation(self):\n        \"\"\"\n        Return the underlying C++ Triangulation object, creating it\n        if necessary.\n        \"\"\"\n        from matplotlib import _tri\n        if self._cpp_triangulation is None:\n            self._cpp_triangulation = _tri.Triangulation(\n                self.x, self.y, self.triangles, self.mask, self._edges,\n                self._neighbors, not self.is_delaunay)\n        return self._cpp_triangulation"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_from_args_and_kwargs",
      "name": "get_from_args_and_kwargs",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation.get_from_args_and_kwargs",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_from_args_and_kwargs/args",
          "name": "args",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.get_from_args_and_kwargs.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_from_args_and_kwargs/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.get_from_args_and_kwargs.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a Triangulation object from the args and kwargs, and\nthe remaining args and kwargs with the consumed values removed.\n\nThere are two alternatives: either the first argument is a\nTriangulation object, in which case it is returned, or the args\nand kwargs are sufficient to create a new Triangulation to\nreturn.  In the latter case, see Triangulation.__init__ for\nthe possible args and kwargs.",
      "docstring": "Return a Triangulation object from the args and kwargs, and\nthe remaining args and kwargs with the consumed values removed.\n\nThere are two alternatives: either the first argument is a\nTriangulation object, in which case it is returned, or the args\nand kwargs are sufficient to create a new Triangulation to\nreturn.  In the latter case, see Triangulation.__init__ for\nthe possible args and kwargs.",
      "code": "    @staticmethod\n    def get_from_args_and_kwargs(*args, **kwargs):\n        \"\"\"\n        Return a Triangulation object from the args and kwargs, and\n        the remaining args and kwargs with the consumed values removed.\n\n        There are two alternatives: either the first argument is a\n        Triangulation object, in which case it is returned, or the args\n        and kwargs are sufficient to create a new Triangulation to\n        return.  In the latter case, see Triangulation.__init__ for\n        the possible args and kwargs.\n        \"\"\"\n        if isinstance(args[0], Triangulation):\n            triangulation, *args = args\n            if 'triangles' in kwargs:\n                _api.warn_external(\n                    \"Passing the keyword 'triangles' has no effect when also \"\n                    \"passing a Triangulation\")\n            if 'mask' in kwargs:\n                _api.warn_external(\n                    \"Passing the keyword 'mask' has no effect when also \"\n                    \"passing a Triangulation\")\n        else:\n            x, y, triangles, mask, args, kwargs = \\\n                Triangulation._extract_triangulation_params(args, kwargs)\n            triangulation = Triangulation(x, y, triangles, mask)\n        return triangulation, args, kwargs"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_masked_triangles",
      "name": "get_masked_triangles",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation.get_masked_triangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_masked_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.get_masked_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return an array of triangles taking the mask into account.",
      "docstring": "Return an array of triangles taking the mask into account.",
      "code": "    def get_masked_triangles(self):\n        \"\"\"\n        Return an array of triangles taking the mask into account.\n        \"\"\"\n        if self.mask is not None:\n            return self.triangles[~self.mask]\n        else:\n            return self.triangles"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_trifinder",
      "name": "get_trifinder",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation.get_trifinder",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/get_trifinder/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.get_trifinder.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the default `matplotlib.tri.TriFinder` of this\ntriangulation, creating it if necessary.  This allows the same\nTriFinder object to be easily shared.",
      "docstring": "Return the default `matplotlib.tri.TriFinder` of this\ntriangulation, creating it if necessary.  This allows the same\nTriFinder object to be easily shared.",
      "code": "    def get_trifinder(self):\n        \"\"\"\n        Return the default `matplotlib.tri.TriFinder` of this\n        triangulation, creating it if necessary.  This allows the same\n        TriFinder object to be easily shared.\n        \"\"\"\n        if self._trifinder is None:\n            # Default TriFinder class.\n            from matplotlib.tri.trifinder import TrapezoidMapTriFinder\n            self._trifinder = TrapezoidMapTriFinder(self)\n        return self._trifinder"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/neighbors@getter",
      "name": "neighbors",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation.neighbors",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/neighbors@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.neighbors.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return integer array of shape (ntri, 3) containing neighbor triangles.\n\nFor each triangle, the indices of the three triangles that\nshare the same edges, or -1 if there is no such neighboring\ntriangle.  ``neighbors[i, j]`` is the triangle that is the neighbor\nto the edge from point index ``triangles[i, j]`` to point index\n``triangles[i, (j+1)%3]``.",
      "docstring": "Return integer array of shape (ntri, 3) containing neighbor triangles.\n\nFor each triangle, the indices of the three triangles that\nshare the same edges, or -1 if there is no such neighboring\ntriangle.  ``neighbors[i, j]`` is the triangle that is the neighbor\nto the edge from point index ``triangles[i, j]`` to point index\n``triangles[i, (j+1)%3]``.",
      "code": "    @property\n    def neighbors(self):\n        \"\"\"\n        Return integer array of shape (ntri, 3) containing neighbor triangles.\n\n        For each triangle, the indices of the three triangles that\n        share the same edges, or -1 if there is no such neighboring\n        triangle.  ``neighbors[i, j]`` is the triangle that is the neighbor\n        to the edge from point index ``triangles[i, j]`` to point index\n        ``triangles[i, (j+1)%3]``.\n        \"\"\"\n        if self._neighbors is None:\n            self._neighbors = self.get_cpp_triangulation().get_neighbors()\n        return self._neighbors"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/set_mask",
      "name": "set_mask",
      "qname": "lib.matplotlib.tri.triangulation.Triangulation.set_mask",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/set_mask/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.set_mask.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triangulation/Triangulation/set_mask/mask",
          "name": "mask",
          "qname": "lib.matplotlib.tri.triangulation.Triangulation.set_mask.mask",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "None or bool array of length ntri",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "None"
              },
              {
                "kind": "NamedType",
                "name": "bool array of length ntri"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set or clear the mask array.",
      "docstring": "Set or clear the mask array.\n\nParameters\n----------\nmask : None or bool array of length ntri",
      "code": "    def set_mask(self, mask):\n        \"\"\"\n        Set or clear the mask array.\n\n        Parameters\n        ----------\n        mask : None or bool array of length ntri\n        \"\"\"\n        if mask is None:\n            self.mask = None\n        else:\n            self.mask = np.asarray(mask, dtype=bool)\n            if self.mask.shape != (self.triangles.shape[0],):\n                raise ValueError('mask array must have same length as '\n                                 'triangles array')\n\n        # Set mask in C++ Triangulation.\n        if self._cpp_triangulation is not None:\n            self._cpp_triangulation.set_mask(self.mask)\n\n        # Clear derived fields so they are recalculated when needed.\n        self._edges = None\n        self._neighbors = None\n\n        # Recalculate TriFinder if it exists.\n        if self._trifinder is not None:\n            self._trifinder._initialize()"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tricontour/TriContourSet/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.tricontour.TriContourSet.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/TriContourSet/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.tricontour.TriContourSet.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/TriContourSet/__init__/ax",
          "name": "ax",
          "qname": "lib.matplotlib.tri.tricontour.TriContourSet.__init__.ax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/TriContourSet/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.tri.tricontour.TriContourSet.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/TriContourSet/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.tri.tricontour.TriContourSet.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Create and store a set of contour lines or filled regions for\na triangular grid.\n\nThis class is typically not instantiated directly by the user but by\n`~.Axes.tricontour` and `~.Axes.tricontourf`.\n\n%(contour_set_attributes)s",
      "docstring": "Draw triangular grid contour lines or filled regions,\ndepending on whether keyword arg *filled* is False\n(default) or True.\n\nThe first argument of the initializer must be an `~.axes.Axes`\nobject.  The remaining arguments and keyword arguments\nare described in the docstring of `~.Axes.tricontour`.",
      "code": "    def __init__(self, ax, *args, **kwargs):\n        \"\"\"\n        Draw triangular grid contour lines or filled regions,\n        depending on whether keyword arg *filled* is False\n        (default) or True.\n\n        The first argument of the initializer must be an `~.axes.Axes`\n        object.  The remaining arguments and keyword arguments\n        are described in the docstring of `~.Axes.tricontour`.\n        \"\"\"\n        super().__init__(ax, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tricontour/tricontour",
      "name": "tricontour",
      "qname": "lib.matplotlib.tri.tricontour.tricontour",
      "decorators": [
        "_docstring.Substitution(func='tricontour', type='lines')",
        "_docstring.dedent_interpd"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/tricontour/ax",
          "name": "ax",
          "qname": "lib.matplotlib.tri.tricontour.tricontour.ax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/tricontour/args",
          "name": "args",
          "qname": "lib.matplotlib.tri.tricontour.tricontour.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/tricontour/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.tri.tricontour.tricontour.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "%(_tricontour_doc)s\n\nlinewidths : float or array-like, default: :rc:`contour.linewidth`\n    The line width of the contour lines.\n\n    If a number, all levels will be plotted with this linewidth.\n\n    If a sequence, the levels in ascending order will be plotted with\n    the linewidths in the order specified.\n\n    If None, this falls back to :rc:`lines.linewidth`.\n\nlinestyles : {*None*, 'solid', 'dashed', 'dashdot', 'dotted'}, optional\n    If *linestyles* is *None*, the default is 'solid' unless the lines are\n    monochrome.  In that case, negative contours will take their linestyle\n    from :rc:`contour.negative_linestyle` setting.\n\n    *linestyles* can also be an iterable of the above strings specifying a\n    set of linestyles to be used. If this iterable is shorter than the\n    number of contour levels it will be repeated as necessary.",
      "docstring": "%(_tricontour_doc)s\n\nlinewidths : float or array-like, default: :rc:`contour.linewidth`\n    The line width of the contour lines.\n\n    If a number, all levels will be plotted with this linewidth.\n\n    If a sequence, the levels in ascending order will be plotted with\n    the linewidths in the order specified.\n\n    If None, this falls back to :rc:`lines.linewidth`.\n\nlinestyles : {*None*, 'solid', 'dashed', 'dashdot', 'dotted'}, optional\n    If *linestyles* is *None*, the default is 'solid' unless the lines are\n    monochrome.  In that case, negative contours will take their linestyle\n    from :rc:`contour.negative_linestyle` setting.\n\n    *linestyles* can also be an iterable of the above strings specifying a\n    set of linestyles to be used. If this iterable is shorter than the\n    number of contour levels it will be repeated as necessary.",
      "code": "@_docstring.Substitution(func='tricontour', type='lines')\n@_docstring.dedent_interpd\ndef tricontour(ax, *args, **kwargs):\n    \"\"\"\n    %(_tricontour_doc)s\n\n    linewidths : float or array-like, default: :rc:`contour.linewidth`\n        The line width of the contour lines.\n\n        If a number, all levels will be plotted with this linewidth.\n\n        If a sequence, the levels in ascending order will be plotted with\n        the linewidths in the order specified.\n\n        If None, this falls back to :rc:`lines.linewidth`.\n\n    linestyles : {*None*, 'solid', 'dashed', 'dashdot', 'dotted'}, optional\n        If *linestyles* is *None*, the default is 'solid' unless the lines are\n        monochrome.  In that case, negative contours will take their linestyle\n        from :rc:`contour.negative_linestyle` setting.\n\n        *linestyles* can also be an iterable of the above strings specifying a\n        set of linestyles to be used. If this iterable is shorter than the\n        number of contour levels it will be repeated as necessary.\n    \"\"\"\n    kwargs['filled'] = False\n    return TriContourSet(ax, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tricontour/tricontourf",
      "name": "tricontourf",
      "qname": "lib.matplotlib.tri.tricontour.tricontourf",
      "decorators": [
        "_docstring.Substitution(func='tricontourf', type='regions')",
        "_docstring.dedent_interpd"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/tricontourf/ax",
          "name": "ax",
          "qname": "lib.matplotlib.tri.tricontour.tricontourf.ax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/tricontourf/args",
          "name": "args",
          "qname": "lib.matplotlib.tri.tricontour.tricontourf.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tricontour/tricontourf/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.tri.tricontour.tricontourf.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "%(_tricontour_doc)s\n\nhatches : list[str], optional\n    A list of cross hatch patterns to use on the filled areas.\n    If None, no hatching will be added to the contour.\n    Hatching is supported in the PostScript, PDF, SVG and Agg\n    backends only.",
      "docstring": "%(_tricontour_doc)s\n\nhatches : list[str], optional\n    A list of cross hatch patterns to use on the filled areas.\n    If None, no hatching will be added to the contour.\n    Hatching is supported in the PostScript, PDF, SVG and Agg\n    backends only.\n\nNotes\n-----\n`.tricontourf` fills intervals that are closed at the top; that is, for\nboundaries *z1* and *z2*, the filled region is::\n\n    z1 < Z <= z2\n\nexcept for the lowest interval, which is closed on both sides (i.e. it\nincludes the lowest value).",
      "code": "@_docstring.Substitution(func='tricontourf', type='regions')\n@_docstring.dedent_interpd\ndef tricontourf(ax, *args, **kwargs):\n    \"\"\"\n    %(_tricontour_doc)s\n\n    hatches : list[str], optional\n        A list of cross hatch patterns to use on the filled areas.\n        If None, no hatching will be added to the contour.\n        Hatching is supported in the PostScript, PDF, SVG and Agg\n        backends only.\n\n    Notes\n    -----\n    `.tricontourf` fills intervals that are closed at the top; that is, for\n    boundaries *z1* and *z2*, the filled region is::\n\n        z1 < Z <= z2\n\n    except for the lowest interval, which is closed on both sides (i.e. it\n    includes the lowest value).\n    \"\"\"\n    kwargs['filled'] = True\n    return TriContourSet(ax, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.tri.trifinder.TrapezoidMapTriFinder.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.trifinder.TrapezoidMapTriFinder.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/__call__/x",
          "name": "x",
          "qname": "lib.matplotlib.tri.trifinder.TrapezoidMapTriFinder.__call__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/__call__/y",
          "name": "y",
          "qname": "lib.matplotlib.tri.trifinder.TrapezoidMapTriFinder.__call__.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return an array containing the indices of the triangles in which the\nspecified *x*, *y* points lie, or -1 for points that do not lie within\na triangle.\n\n*x*, *y* are array-like x and y coordinates of the same shape and any\nnumber of dimensions.\n\nReturns integer array with the same shape and *x* and *y*.",
      "docstring": "Return an array containing the indices of the triangles in which the\nspecified *x*, *y* points lie, or -1 for points that do not lie within\na triangle.\n\n*x*, *y* are array-like x and y coordinates of the same shape and any\nnumber of dimensions.\n\nReturns integer array with the same shape and *x* and *y*.",
      "code": "    def __call__(self, x, y):\n        \"\"\"\n        Return an array containing the indices of the triangles in which the\n        specified *x*, *y* points lie, or -1 for points that do not lie within\n        a triangle.\n\n        *x*, *y* are array-like x and y coordinates of the same shape and any\n        number of dimensions.\n\n        Returns integer array with the same shape and *x* and *y*.\n        \"\"\"\n        x = np.asarray(x, dtype=np.float64)\n        y = np.asarray(y, dtype=np.float64)\n        if x.shape != y.shape:\n            raise ValueError(\"x and y must be array-like with the same shape\")\n\n        # C++ does the heavy lifting, and expects 1D arrays.\n        indices = (self._cpp_trifinder.find_many(x.ravel(), y.ravel())\n                   .reshape(x.shape))\n        return indices"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.trifinder.TrapezoidMapTriFinder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.trifinder.TrapezoidMapTriFinder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trifinder/TrapezoidMapTriFinder/__init__/triangulation",
          "name": "triangulation",
          "qname": "lib.matplotlib.tri.trifinder.TrapezoidMapTriFinder.__init__.triangulation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "`~matplotlib.tri.TriFinder` class implemented using the trapezoid\nmap algorithm from the book \"Computational Geometry, Algorithms and\nApplications\", second edition, by M. de Berg, M. van Kreveld, M. Overmars\nand O. Schwarzkopf.\n\nThe triangulation must be valid, i.e. it must not have duplicate points,\ntriangles formed from colinear points, or overlapping triangles.  The\nalgorithm has some tolerance to triangles formed from colinear points, but\nthis should not be relied upon.",
      "docstring": "",
      "code": "    def __init__(self, triangulation):\n        from matplotlib import _tri\n        super().__init__(triangulation)\n        self._cpp_trifinder = _tri.TrapezoidMapTriFinder(\n            triangulation.get_cpp_triangulation())\n        self._initialize()"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trifinder/TriFinder/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.trifinder.TriFinder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.trifinder/TriFinder/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.trifinder.TriFinder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trifinder/TriFinder/__init__/triangulation",
          "name": "triangulation",
          "qname": "lib.matplotlib.tri.trifinder.TriFinder.__init__.triangulation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for classes used to find the triangles of a\nTriangulation in which (x, y) points lie.\n\nRather than instantiate an object of a class derived from TriFinder, it is\nusually better to use the function `.Triangulation.get_trifinder`.\n\nDerived classes implement __call__(x, y) where x and y are array-like point\ncoordinates of the same shape.",
      "docstring": "",
      "code": "    def __init__(self, triangulation):\n        _api.check_isinstance(Triangulation, triangulation=triangulation)\n        self._triangulation = triangulation"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__call__/x",
          "name": "x",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__call__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__call__/y",
          "name": "y",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__call__.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __call__(self, x, y):\n        return self._interpolate_multikeys(x, y, tri_index=None,\n                                           return_keys=('z',))[0]"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__init__/triangulation",
          "name": "triangulation",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__init__.triangulation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.tri.Triangulation`",
            "default_value": "",
            "description": "The triangulation to interpolate over."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.tri.Triangulation`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__init__/z",
          "name": "z",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__init__.z",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "(npoints,) array-like",
            "default_value": "",
            "description": "Array of values, defined at grid points, to interpolate between."
          },
          "type": {
            "kind": "NamedType",
            "name": "(npoints,) array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__init__/kind",
          "name": "kind",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__init__.kind",
          "default_value": "'min_E'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "{'min_E', 'geom', 'user'}",
            "default_value": "",
            "description": "Choice of the smoothing algorithm, in order to compute\nthe interpolant derivatives (defaults to 'min_E'):\n\n- if 'min_E': (default) The derivatives at each node is computed\n  to minimize a bending energy.\n- if 'geom': The derivatives at each node is computed as a\n  weighted average of relevant triangle normals. To be used for\n  speed optimization (large grids).\n- if 'user': The user provides the argument *dz*, no computation\n  is hence needed."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "min_E",
              "user",
              "geom"
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__init__/trifinder",
          "name": "trifinder",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__init__.trifinder",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.tri.TriFinder`",
            "default_value": "",
            "description": "If not specified, the Triangulation's default TriFinder will\nbe used by calling `.Triangulation.get_trifinder`."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.tri.TriFinder`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/__init__/dz",
          "name": "dz",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.__init__.dz",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple of array-likes (dzdx, dzdy)",
            "default_value": "",
            "description": "Used only if  *kind* ='user'. In this case *dz* must be provided as\n(dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as *z* and\nare the interpolant first derivatives at the *triangulation* points."
          },
          "type": {
            "kind": "NamedType",
            "name": "tuple of array-likes (dzdx, dzdy)"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Cubic interpolator on a triangular grid.\n\nIn one-dimension - on a segment - a cubic interpolating function is\ndefined by the values of the function and its derivative at both ends.\nThis is almost the same in 2D inside a triangle, except that the values\nof the function and its 2 derivatives have to be defined at each triangle\nnode.\n\nThe CubicTriInterpolator takes the value of the function at each node -\nprovided by the user - and internally computes the value of the\nderivatives, resulting in a smooth interpolation.\n(As a special feature, the user can also impose the value of the\nderivatives at each node, but this is not supposed to be the common\nusage.)",
      "docstring": "",
      "code": "    def __init__(self, triangulation, z, kind='min_E', trifinder=None,\n                 dz=None):\n        super().__init__(triangulation, z, trifinder)\n\n        # Loads the underlying c++ _triangulation.\n        # (During loading, reordering of triangulation._triangles may occur so\n        # that all final triangles are now anti-clockwise)\n        self._triangulation.get_cpp_triangulation()\n\n        # To build the stiffness matrix and avoid zero-energy spurious modes\n        # we will only store internally the valid (unmasked) triangles and\n        # the necessary (used) points coordinates.\n        # 2 renumbering tables need to be computed and stored:\n        #  - a triangle renum table in order to translate the result from a\n        #    TriFinder instance into the internal stored triangle number.\n        #  - a node renum table to overwrite the self._z values into the new\n        #    (used) node numbering.\n        tri_analyzer = TriAnalyzer(self._triangulation)\n        (compressed_triangles, compressed_x, compressed_y, tri_renum,\n         node_renum) = tri_analyzer._get_compressed_triangulation()\n        self._triangles = compressed_triangles\n        self._tri_renum = tri_renum\n        # Taking into account the node renumbering in self._z:\n        valid_node = (node_renum != -1)\n        self._z[node_renum[valid_node]] = self._z[valid_node]\n\n        # Computing scale factors\n        self._unit_x = np.ptp(compressed_x)\n        self._unit_y = np.ptp(compressed_y)\n        self._pts = np.column_stack([compressed_x / self._unit_x,\n                                     compressed_y / self._unit_y])\n        # Computing triangle points\n        self._tris_pts = self._pts[self._triangles]\n        # Computing eccentricities\n        self._eccs = self._compute_tri_eccentricities(self._tris_pts)\n        # Computing dof estimations for HCT triangle shape function\n        _api.check_in_list(['user', 'geom', 'min_E'], kind=kind)\n        self._dof = self._compute_dof(kind, dz=dz)\n        # Loading HCT element\n        self._ReferenceElement = _ReducedHCT_Element()"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/gradient",
      "name": "gradient",
      "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.gradient",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/gradient/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.gradient.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/gradient/x",
          "name": "x",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.gradient.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/CubicTriInterpolator/gradient/y",
          "name": "y",
          "qname": "lib.matplotlib.tri.triinterpolate.CubicTriInterpolator.gradient.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def gradient(self, x, y):\n        return self._interpolate_multikeys(x, y, tri_index=None,\n                                           return_keys=('dzdx', 'dzdy'))"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__call__/x",
          "name": "x",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.__call__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__call__/y",
          "name": "y",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.__call__.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __call__(self, x, y):\n        return self._interpolate_multikeys(x, y, tri_index=None,\n                                           return_keys=('z',))[0]"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__init__/triangulation",
          "name": "triangulation",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.__init__.triangulation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.tri.Triangulation`",
            "default_value": "",
            "description": "The triangulation to interpolate over."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.tri.Triangulation`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__init__/z",
          "name": "z",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.__init__.z",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "(npoints,) array-like",
            "default_value": "",
            "description": "Array of values, defined at grid points, to interpolate between."
          },
          "type": {
            "kind": "NamedType",
            "name": "(npoints,) array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/__init__/trifinder",
          "name": "trifinder",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.__init__.trifinder",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.tri.TriFinder`",
            "default_value": "",
            "description": "If this is not specified, the Triangulation's default TriFinder will\nbe used by calling `.Triangulation.get_trifinder`."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.tri.TriFinder`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Linear interpolator on a triangular grid.\n\nEach triangle is represented by a plane so that an interpolated value at\npoint (x, y) lies on the plane of the triangle containing (x, y).\nInterpolated values are therefore continuous across the triangulation, but\ntheir first derivatives are discontinuous at edges between triangles.",
      "docstring": "",
      "code": "    def __init__(self, triangulation, z, trifinder=None):\n        super().__init__(triangulation, z, trifinder)\n\n        # Store plane coefficients for fast interpolation calculations.\n        self._plane_coefficients = \\\n            self._triangulation.calculate_plane_coefficients(self._z)"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/gradient",
      "name": "gradient",
      "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.gradient",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/gradient/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.gradient.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/gradient/x",
          "name": "x",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.gradient.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/LinearTriInterpolator/gradient/y",
          "name": "y",
          "qname": "lib.matplotlib.tri.triinterpolate.LinearTriInterpolator.gradient.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def gradient(self, x, y):\n        return self._interpolate_multikeys(x, y, tri_index=None,\n                                           return_keys=('dzdx', 'dzdy'))"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triinterpolate/TriInterpolator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.triinterpolate.TriInterpolator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/TriInterpolator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.triinterpolate.TriInterpolator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/TriInterpolator/__init__/triangulation",
          "name": "triangulation",
          "qname": "lib.matplotlib.tri.triinterpolate.TriInterpolator.__init__.triangulation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/TriInterpolator/__init__/z",
          "name": "z",
          "qname": "lib.matplotlib.tri.triinterpolate.TriInterpolator.__init__.z",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triinterpolate/TriInterpolator/__init__/trifinder",
          "name": "trifinder",
          "qname": "lib.matplotlib.tri.triinterpolate.TriInterpolator.__init__.trifinder",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for classes used to interpolate on a triangular grid.\n\nDerived classes implement the following methods:\n\n- ``__call__(x, y)``,\n  where x, y are array-like point coordinates of the same shape, and\n  that returns a masked array of the same shape containing the\n  interpolated z-values.\n\n- ``gradient(x, y)``,\n  where x, y are array-like point coordinates of the same\n  shape, and that returns a list of 2 masked arrays of the same shape\n  containing the 2 derivatives of the interpolator (derivatives of\n  interpolated z values with respect to x and y).",
      "docstring": "",
      "code": "    def __init__(self, triangulation, z, trifinder=None):\n        _api.check_isinstance(Triangulation, triangulation=triangulation)\n        self._triangulation = triangulation\n\n        self._z = np.asarray(z)\n        if self._z.shape != self._triangulation.x.shape:\n            raise ValueError(\"z array must have same length as triangulation x\"\n                             \" and y arrays\")\n\n        _api.check_isinstance((TriFinder, None), trifinder=trifinder)\n        self._trifinder = trifinder or self._triangulation.get_trifinder()\n\n        # Default scaling factors : 1.0 (= no scaling)\n        # Scaling may be used for interpolations for which the order of\n        # magnitude of x, y has an impact on the interpolant definition.\n        # Please refer to :meth:`_interpolate_multikeys` for details.\n        self._unit_x = 1.0\n        self._unit_y = 1.0\n\n        # Default triangle renumbering: None (= no renumbering)\n        # Renumbering may be used to avoid unnecessary computations\n        # if complex calculations are done inside the Interpolator.\n        # Please refer to :meth:`_interpolate_multikeys` for details.\n        self._tri_renum = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor",
      "name": "tripcolor",
      "qname": "lib.matplotlib.tri.tripcolor.tripcolor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/ax",
          "name": "ax",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.ax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/args",
          "name": "args",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.alpha",
          "default_value": "1.0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/norm",
          "name": "norm",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.norm",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/cmap",
          "name": "cmap",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.cmap",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.vmin",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.vmax",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/shading",
          "name": "shading",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.shading",
          "default_value": "'flat'",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "{'flat', 'gouraud'}",
            "default_value": "'flat'",
            "description": "If  'flat' and the color values *C* are defined at points, the color\nvalues used for each triangle are from the mean C of the triangle's\nthree points. If *shading* is 'gouraud' then color values must be\ndefined at points."
          },
          "type": {
            "kind": "EnumType",
            "values": [
              "gouraud",
              "flat"
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.facecolors",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Can be used alternatively to *C* to specify colors at the triangle\nfaces. This parameter takes precedence over *C*."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tripcolor/tripcolor/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.tri.tripcolor.tripcolor.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Create a pseudocolor plot of an unstructured triangular grid.\n\nCall signatures::\n\n  tripcolor(triangulation, C, *, ...)\n  tripcolor(x, y, C, *, [triangles=triangles], [mask=mask], ...)\n\nThe triangular grid can be specified either by passing a `.Triangulation`\nobject as the first parameter, or by passing the points *x*, *y* and\noptionally the *triangles* and a *mask*. See `.Triangulation` for an\nexplanation of these parameters.\n\nIt is possible to pass the triangles positionally, i.e.\n``tripcolor(x, y, triangles, C, ...)``. However, this is discouraged.\nFor more clarity, pass *triangles* via keyword argument.\n\nIf neither of *triangulation* or *triangles* are given, the triangulation\nis calculated on the fly. In this case, it does not make sense to provide\ncolors at the triangle faces via *C* or *facecolors* because there are\nmultiple possible triangulations for a group of points and you don't know\nwhich triangles will be constructed.",
      "docstring": "Create a pseudocolor plot of an unstructured triangular grid.\n\nCall signatures::\n\n  tripcolor(triangulation, C, *, ...)\n  tripcolor(x, y, C, *, [triangles=triangles], [mask=mask], ...)\n\nThe triangular grid can be specified either by passing a `.Triangulation`\nobject as the first parameter, or by passing the points *x*, *y* and\noptionally the *triangles* and a *mask*. See `.Triangulation` for an\nexplanation of these parameters.\n\nIt is possible to pass the triangles positionally, i.e.\n``tripcolor(x, y, triangles, C, ...)``. However, this is discouraged.\nFor more clarity, pass *triangles* via keyword argument.\n\nIf neither of *triangulation* or *triangles* are given, the triangulation\nis calculated on the fly. In this case, it does not make sense to provide\ncolors at the triangle faces via *C* or *facecolors* because there are\nmultiple possible triangulations for a group of points and you don't know\nwhich triangles will be constructed.\n\nParameters\n----------\ntriangulation : `.Triangulation`\n    An already created triangular grid.\nx, y, triangles, mask\n    Parameters defining the triangular grid. See `.Triangulation`.\n    This is mutually exclusive with specifying *triangulation*.\nC : array-like\n    The color values, either for the points or for the triangles. Which one\n    is automatically inferred from the length of *C*, i.e. does it match\n    the number of points or the number of triangles. If there are the same\n    number of points and triangles in the triangulation it is assumed that\n    color values are defined at points; to force the use of color values at\n    triangles use the keyword argument ``facecolors=C`` instead of just\n    ``C``.\n    This parameter is position-only.\nfacecolors : array-like, optional\n    Can be used alternatively to *C* to specify colors at the triangle\n    faces. This parameter takes precedence over *C*.\nshading : {'flat', 'gouraud'}, default: 'flat'\n    If  'flat' and the color values *C* are defined at points, the color\n    values used for each triangle are from the mean C of the triangle's\n    three points. If *shading* is 'gouraud' then color values must be\n    defined at points.\nother_parameters\n    All other parameters are the same as for `~.Axes.pcolor`.",
      "code": "def tripcolor(ax, *args, alpha=1.0, norm=None, cmap=None, vmin=None,\n              vmax=None, shading='flat', facecolors=None, **kwargs):\n    \"\"\"\n    Create a pseudocolor plot of an unstructured triangular grid.\n\n    Call signatures::\n\n      tripcolor(triangulation, C, *, ...)\n      tripcolor(x, y, C, *, [triangles=triangles], [mask=mask], ...)\n\n    The triangular grid can be specified either by passing a `.Triangulation`\n    object as the first parameter, or by passing the points *x*, *y* and\n    optionally the *triangles* and a *mask*. See `.Triangulation` for an\n    explanation of these parameters.\n\n    It is possible to pass the triangles positionally, i.e.\n    ``tripcolor(x, y, triangles, C, ...)``. However, this is discouraged.\n    For more clarity, pass *triangles* via keyword argument.\n\n    If neither of *triangulation* or *triangles* are given, the triangulation\n    is calculated on the fly. In this case, it does not make sense to provide\n    colors at the triangle faces via *C* or *facecolors* because there are\n    multiple possible triangulations for a group of points and you don't know\n    which triangles will be constructed.\n\n    Parameters\n    ----------\n    triangulation : `.Triangulation`\n        An already created triangular grid.\n    x, y, triangles, mask\n        Parameters defining the triangular grid. See `.Triangulation`.\n        This is mutually exclusive with specifying *triangulation*.\n    C : array-like\n        The color values, either for the points or for the triangles. Which one\n        is automatically inferred from the length of *C*, i.e. does it match\n        the number of points or the number of triangles. If there are the same\n        number of points and triangles in the triangulation it is assumed that\n        color values are defined at points; to force the use of color values at\n        triangles use the keyword argument ``facecolors=C`` instead of just\n        ``C``.\n        This parameter is position-only.\n    facecolors : array-like, optional\n        Can be used alternatively to *C* to specify colors at the triangle\n        faces. This parameter takes precedence over *C*.\n    shading : {'flat', 'gouraud'}, default: 'flat'\n        If  'flat' and the color values *C* are defined at points, the color\n        values used for each triangle are from the mean C of the triangle's\n        three points. If *shading* is 'gouraud' then color values must be\n        defined at points.\n    other_parameters\n        All other parameters are the same as for `~.Axes.pcolor`.\n    \"\"\"\n    _api.check_in_list(['flat', 'gouraud'], shading=shading)\n\n    tri, args, kwargs = Triangulation.get_from_args_and_kwargs(*args, **kwargs)\n\n    # Parse the color to be in one of (the other variable will be None):\n    # - facecolors: if specified at the triangle faces\n    # - point_colors: if specified at the points\n    if facecolors is not None:\n        if args:\n            _api.warn_external(\n                \"Positional parameter C has no effect when the keyword \"\n                \"facecolors is given\")\n        point_colors = None\n        if len(facecolors) != len(tri.triangles):\n            raise ValueError(\"The length of facecolors must match the number \"\n                             \"of triangles\")\n    else:\n        # Color from positional parameter C\n        if not args:\n            raise TypeError(\n                \"tripcolor() missing 1 required positional argument: 'C'; or \"\n                \"1 required keyword-only argument: 'facecolors'\")\n        elif len(args) > 1:\n            _api.warn_deprecated(\n                \"3.6\", message=f\"Additional positional parameters \"\n                f\"{args[1:]!r} are ignored; support for them is deprecated \"\n                f\"since %(since)s and will be removed %(removal)s\")\n        C = np.asarray(args[0])\n        if len(C) == len(tri.x):\n            # having this before the len(tri.triangles) comparison gives\n            # precedence to nodes if there are as many nodes as triangles\n            point_colors = C\n            facecolors = None\n        elif len(C) == len(tri.triangles):\n            point_colors = None\n            facecolors = C\n        else:\n            raise ValueError('The length of C must match either the number '\n                             'of points or the number of triangles')\n\n    # Handling of linewidths, shading, edgecolors and antialiased as\n    # in Axes.pcolor\n    linewidths = (0.25,)\n    if 'linewidth' in kwargs:\n        kwargs['linewidths'] = kwargs.pop('linewidth')\n    kwargs.setdefault('linewidths', linewidths)\n\n    edgecolors = 'none'\n    if 'edgecolor' in kwargs:\n        kwargs['edgecolors'] = kwargs.pop('edgecolor')\n    ec = kwargs.setdefault('edgecolors', edgecolors)\n\n    if 'antialiased' in kwargs:\n        kwargs['antialiaseds'] = kwargs.pop('antialiased')\n    if 'antialiaseds' not in kwargs and ec.lower() == \"none\":\n        kwargs['antialiaseds'] = False\n\n    _api.check_isinstance((Normalize, None), norm=norm)\n    if shading == 'gouraud':\n        if facecolors is not None:\n            raise ValueError(\n                \"shading='gouraud' can only be used when the colors \"\n                \"are specified at the points, not at the faces.\")\n        collection = TriMesh(tri, alpha=alpha, array=point_colors,\n                             cmap=cmap, norm=norm, **kwargs)\n    else:  # 'flat'\n        # Vertices of triangles.\n        maskedTris = tri.get_masked_triangles()\n        verts = np.stack((tri.x[maskedTris], tri.y[maskedTris]), axis=-1)\n\n        # Color values.\n        if facecolors is None:\n            # One color per triangle, the mean of the 3 vertex color values.\n            colors = point_colors[maskedTris].mean(axis=1)\n        elif tri.mask is not None:\n            # Remove color values of masked triangles.\n            colors = facecolors[~tri.mask]\n        else:\n            colors = facecolors\n        collection = PolyCollection(verts, alpha=alpha, array=colors,\n                                    cmap=cmap, norm=norm, **kwargs)\n\n    collection._scale_norm(norm, vmin, vmax)\n    ax.grid(False)\n\n    minx = tri.x.min()\n    maxx = tri.x.max()\n    miny = tri.y.min()\n    maxy = tri.y.max()\n    corners = (minx, miny), (maxx, maxy)\n    ax.update_datalim(corners)\n    ax.autoscale_view()\n    ax.add_collection(collection)\n    return collection"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.triplot/triplot",
      "name": "triplot",
      "qname": "lib.matplotlib.tri.triplot.triplot",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.triplot/triplot/ax",
          "name": "ax",
          "qname": "lib.matplotlib.tri.triplot.triplot.ax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triplot/triplot/args",
          "name": "args",
          "qname": "lib.matplotlib.tri.triplot.triplot.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.triplot/triplot/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.tri.triplot.triplot.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw an unstructured triangular grid as lines and/or markers.\n\nCall signatures::\n\n  triplot(triangulation, ...)\n  triplot(x, y, [triangles], *, [mask=mask], ...)\n\nThe triangular grid can be specified either by passing a `.Triangulation`\nobject as the first parameter, or by passing the points *x*, *y* and\noptionally the *triangles* and a *mask*. If neither of *triangulation* or\n*triangles* are given, the triangulation is calculated on the fly.",
      "docstring": "Draw an unstructured triangular grid as lines and/or markers.\n\nCall signatures::\n\n  triplot(triangulation, ...)\n  triplot(x, y, [triangles], *, [mask=mask], ...)\n\nThe triangular grid can be specified either by passing a `.Triangulation`\nobject as the first parameter, or by passing the points *x*, *y* and\noptionally the *triangles* and a *mask*. If neither of *triangulation* or\n*triangles* are given, the triangulation is calculated on the fly.\n\nParameters\n----------\ntriangulation : `.Triangulation`\n    An already created triangular grid.\nx, y, triangles, mask\n    Parameters defining the triangular grid. See `.Triangulation`.\n    This is mutually exclusive with specifying *triangulation*.\nother_parameters\n    All other args and kwargs are forwarded to `~.Axes.plot`.\n\nReturns\n-------\nlines : `~matplotlib.lines.Line2D`\n    The drawn triangles edges.\nmarkers : `~matplotlib.lines.Line2D`\n    The drawn marker nodes.",
      "code": "def triplot(ax, *args, **kwargs):\n    \"\"\"\n    Draw an unstructured triangular grid as lines and/or markers.\n\n    Call signatures::\n\n      triplot(triangulation, ...)\n      triplot(x, y, [triangles], *, [mask=mask], ...)\n\n    The triangular grid can be specified either by passing a `.Triangulation`\n    object as the first parameter, or by passing the points *x*, *y* and\n    optionally the *triangles* and a *mask*. If neither of *triangulation* or\n    *triangles* are given, the triangulation is calculated on the fly.\n\n    Parameters\n    ----------\n    triangulation : `.Triangulation`\n        An already created triangular grid.\n    x, y, triangles, mask\n        Parameters defining the triangular grid. See `.Triangulation`.\n        This is mutually exclusive with specifying *triangulation*.\n    other_parameters\n        All other args and kwargs are forwarded to `~.Axes.plot`.\n\n    Returns\n    -------\n    lines : `~matplotlib.lines.Line2D`\n        The drawn triangles edges.\n    markers : `~matplotlib.lines.Line2D`\n        The drawn marker nodes.\n    \"\"\"\n    import matplotlib.axes\n\n    tri, args, kwargs = Triangulation.get_from_args_and_kwargs(*args, **kwargs)\n    x, y, edges = (tri.x, tri.y, tri.edges)\n\n    # Decode plot format string, e.g., 'ro-'\n    fmt = args[0] if args else \"\"\n    linestyle, marker, color = matplotlib.axes._base._process_plot_format(fmt)\n\n    # Insert plot format string into a copy of kwargs (kwargs values prevail).\n    kw = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n    for key, val in zip(('linestyle', 'marker', 'color'),\n                        (linestyle, marker, color)):\n        if val is not None:\n            kw.setdefault(key, val)\n\n    # Draw lines without markers.\n    # Note 1: If we drew markers here, most markers would be drawn more than\n    #         once as they belong to several edges.\n    # Note 2: We insert nan values in the flattened edges arrays rather than\n    #         plotting directly (triang.x[edges].T, triang.y[edges].T)\n    #         as it considerably speeds-up code execution.\n    linestyle = kw['linestyle']\n    kw_lines = {\n        **kw,\n        'marker': 'None',  # No marker to draw.\n        'zorder': kw.get('zorder', 1),  # Path default zorder is used.\n    }\n    if linestyle not in [None, 'None', '', ' ']:\n        tri_lines_x = np.insert(x[edges], 2, np.nan, axis=1)\n        tri_lines_y = np.insert(y[edges], 2, np.nan, axis=1)\n        tri_lines = ax.plot(tri_lines_x.ravel(), tri_lines_y.ravel(),\n                            **kw_lines)\n    else:\n        tri_lines = ax.plot([], [], **kw_lines)\n\n    # Draw markers separately.\n    marker = kw['marker']\n    kw_markers = {\n        **kw,\n        'linestyle': 'None',  # No line to draw.\n    }\n    kw_markers.pop('label', None)\n    if marker not in [None, 'None', '', ' ']:\n        tri_markers = ax.plot(x, y, **kw_markers)\n    else:\n        tri_markers = ax.plot([], [], **kw_markers)\n\n    return tri_lines + tri_markers"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trirefine/TriRefiner/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.trirefine.TriRefiner.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/TriRefiner/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.trirefine.TriRefiner.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/TriRefiner/__init__/triangulation",
          "name": "triangulation",
          "qname": "lib.matplotlib.tri.trirefine.TriRefiner.__init__.triangulation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Abstract base class for classes implementing mesh refinement.\n\nA TriRefiner encapsulates a Triangulation object and provides tools for\nmesh refinement and interpolation.\n\nDerived classes must implement:\n\n- ``refine_triangulation(return_tri_index=False, **kwargs)`` , where\n  the optional keyword arguments *kwargs* are defined in each\n  TriRefiner concrete implementation, and which returns:\n\n  - a refined triangulation,\n  - optionally (depending on *return_tri_index*), for each\n    point of the refined triangulation: the index of\n    the initial triangulation triangle to which it belongs.\n\n- ``refine_field(z, triinterpolator=None, **kwargs)``, where:\n\n  - *z* array of field values (to refine) defined at the base\n    triangulation nodes,\n  - *triinterpolator* is an optional `~matplotlib.tri.TriInterpolator`,\n  - the other optional keyword arguments *kwargs* are defined in\n    each TriRefiner concrete implementation;\n\n  and which returns (as a tuple) a refined triangular mesh and the\n  interpolated values of the field at the refined triangulation nodes.",
      "docstring": "",
      "code": "    def __init__(self, triangulation):\n        _api.check_isinstance(Triangulation, triangulation=triangulation)\n        self._triangulation = triangulation"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/__init__/triangulation",
          "name": "triangulation",
          "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.__init__.triangulation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.tri.Triangulation`",
            "default_value": "",
            "description": "The encapsulated triangulation (to be refined)"
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.tri.Triangulation`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Uniform mesh refinement by recursive subdivisions.",
      "docstring": "",
      "code": "    def __init__(self, triangulation):\n        super().__init__(triangulation)"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_field",
      "name": "refine_field",
      "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.refine_field",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_field/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.refine_field.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_field/z",
          "name": "z",
          "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.refine_field.z",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "(npoints,) array-like",
            "default_value": "",
            "description": "Values of the field to refine, defined at the nodes of the\nencapsulated triangulation. (``n_points`` is the number of points\nin the initial triangulation)"
          },
          "type": {
            "kind": "NamedType",
            "name": "(npoints,) array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_field/triinterpolator",
          "name": "triinterpolator",
          "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.refine_field.triinterpolator",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.tri.TriInterpolator`",
            "default_value": "",
            "description": "Interpolator used for field interpolation. If not specified,\na `~matplotlib.tri.CubicTriInterpolator` will be used."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.tri.TriInterpolator`"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_field/subdiv",
          "name": "subdiv",
          "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.refine_field.subdiv",
          "default_value": "3",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "3",
            "description": "Recursion level for the subdivision.\nEach triangle is divided into ``4**subdiv`` child triangles."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Refine a field defined on the encapsulated triangulation.",
      "docstring": "Refine a field defined on the encapsulated triangulation.\n\nParameters\n----------\nz : (npoints,) array-like\n    Values of the field to refine, defined at the nodes of the\n    encapsulated triangulation. (``n_points`` is the number of points\n    in the initial triangulation)\ntriinterpolator : `~matplotlib.tri.TriInterpolator`, optional\n    Interpolator used for field interpolation. If not specified,\n    a `~matplotlib.tri.CubicTriInterpolator` will be used.\nsubdiv : int, default: 3\n    Recursion level for the subdivision.\n    Each triangle is divided into ``4**subdiv`` child triangles.\n\nReturns\n-------\nrefi_tri : `~matplotlib.tri.Triangulation`\n     The returned refined triangulation.\nrefi_z : 1D array of length: *refi_tri* node count.\n     The returned interpolated field (at *refi_tri* nodes).",
      "code": "    def refine_field(self, z, triinterpolator=None, subdiv=3):\n        \"\"\"\n        Refine a field defined on the encapsulated triangulation.\n\n        Parameters\n        ----------\n        z : (npoints,) array-like\n            Values of the field to refine, defined at the nodes of the\n            encapsulated triangulation. (``n_points`` is the number of points\n            in the initial triangulation)\n        triinterpolator : `~matplotlib.tri.TriInterpolator`, optional\n            Interpolator used for field interpolation. If not specified,\n            a `~matplotlib.tri.CubicTriInterpolator` will be used.\n        subdiv : int, default: 3\n            Recursion level for the subdivision.\n            Each triangle is divided into ``4**subdiv`` child triangles.\n\n        Returns\n        -------\n        refi_tri : `~matplotlib.tri.Triangulation`\n             The returned refined triangulation.\n        refi_z : 1D array of length: *refi_tri* node count.\n             The returned interpolated field (at *refi_tri* nodes).\n        \"\"\"\n        if triinterpolator is None:\n            interp = matplotlib.tri.CubicTriInterpolator(\n                self._triangulation, z)\n        else:\n            _api.check_isinstance(matplotlib.tri.TriInterpolator,\n                                  triinterpolator=triinterpolator)\n            interp = triinterpolator\n\n        refi_tri, found_index = self.refine_triangulation(\n            subdiv=subdiv, return_tri_index=True)\n        refi_z = interp._interpolate_multikeys(\n            refi_tri.x, refi_tri.y, tri_index=found_index)[0]\n        return refi_tri, refi_z"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_triangulation",
      "name": "refine_triangulation",
      "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.refine_triangulation",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_triangulation/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.refine_triangulation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_triangulation/return_tri_index",
          "name": "return_tri_index",
          "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.refine_triangulation.return_tri_index",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "Whether an index table indicating the father triangle index of each\npoint is returned."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.trirefine/UniformTriRefiner/refine_triangulation/subdiv",
          "name": "subdiv",
          "qname": "lib.matplotlib.tri.trirefine.UniformTriRefiner.refine_triangulation.subdiv",
          "default_value": "3",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "3",
            "description": "Recursion level for the subdivision.\nEach triangle is divided into ``4**subdiv`` child triangles;\nhence, the default results in 64 refined subtriangles for each\ntriangle of the initial triangulation."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Compute an uniformly refined triangulation *refi_triangulation* of\nthe encapsulated :attr:`triangulation`.\n\nThis function refines the encapsulated triangulation by splitting each\nfather triangle into 4 child sub-triangles built on the edges midside\nnodes, recursing *subdiv* times.  In the end, each triangle is hence\ndivided into ``4**subdiv`` child triangles.",
      "docstring": "Compute an uniformly refined triangulation *refi_triangulation* of\nthe encapsulated :attr:`triangulation`.\n\nThis function refines the encapsulated triangulation by splitting each\nfather triangle into 4 child sub-triangles built on the edges midside\nnodes, recursing *subdiv* times.  In the end, each triangle is hence\ndivided into ``4**subdiv`` child triangles.\n\nParameters\n----------\nreturn_tri_index : bool, default: False\n    Whether an index table indicating the father triangle index of each\n    point is returned.\nsubdiv : int, default: 3\n    Recursion level for the subdivision.\n    Each triangle is divided into ``4**subdiv`` child triangles;\n    hence, the default results in 64 refined subtriangles for each\n    triangle of the initial triangulation.\n\nReturns\n-------\nrefi_triangulation : `~matplotlib.tri.Triangulation`\n    The refined triangulation.\nfound_index : int array\n    Index of the initial triangulation containing triangle, for each\n    point of *refi_triangulation*.\n    Returned only if *return_tri_index* is set to True.",
      "code": "    def refine_triangulation(self, return_tri_index=False, subdiv=3):\n        \"\"\"\n        Compute an uniformly refined triangulation *refi_triangulation* of\n        the encapsulated :attr:`triangulation`.\n\n        This function refines the encapsulated triangulation by splitting each\n        father triangle into 4 child sub-triangles built on the edges midside\n        nodes, recursing *subdiv* times.  In the end, each triangle is hence\n        divided into ``4**subdiv`` child triangles.\n\n        Parameters\n        ----------\n        return_tri_index : bool, default: False\n            Whether an index table indicating the father triangle index of each\n            point is returned.\n        subdiv : int, default: 3\n            Recursion level for the subdivision.\n            Each triangle is divided into ``4**subdiv`` child triangles;\n            hence, the default results in 64 refined subtriangles for each\n            triangle of the initial triangulation.\n\n        Returns\n        -------\n        refi_triangulation : `~matplotlib.tri.Triangulation`\n            The refined triangulation.\n        found_index : int array\n            Index of the initial triangulation containing triangle, for each\n            point of *refi_triangulation*.\n            Returned only if *return_tri_index* is set to True.\n        \"\"\"\n        refi_triangulation = self._triangulation\n        ntri = refi_triangulation.triangles.shape[0]\n\n        # Computes the triangulation ancestors numbers in the reference\n        # triangulation.\n        ancestors = np.arange(ntri, dtype=np.int32)\n        for _ in range(subdiv):\n            refi_triangulation, ancestors = self._refine_triangulation_once(\n                refi_triangulation, ancestors)\n        refi_npts = refi_triangulation.x.shape[0]\n        refi_triangles = refi_triangulation.triangles\n\n        # Now we compute found_index table if needed\n        if return_tri_index:\n            # We have to initialize found_index with -1 because some nodes\n            # may very well belong to no triangle at all, e.g., in case of\n            # Delaunay Triangulation with DuplicatePointWarning.\n            found_index = np.full(refi_npts, -1, dtype=np.int32)\n            tri_mask = self._triangulation.mask\n            if tri_mask is None:\n                found_index[refi_triangles] = np.repeat(ancestors,\n                                                        3).reshape(-1, 3)\n            else:\n                # There is a subtlety here: we want to avoid whenever possible\n                # that refined points container is a masked triangle (which\n                # would result in artifacts in plots).\n                # So we impose the numbering from masked ancestors first,\n                # then overwrite it with unmasked ancestor numbers.\n                ancestor_mask = tri_mask[ancestors]\n                found_index[refi_triangles[ancestor_mask, :]\n                            ] = np.repeat(ancestors[ancestor_mask],\n                                          3).reshape(-1, 3)\n                found_index[refi_triangles[~ancestor_mask, :]\n                            ] = np.repeat(ancestors[~ancestor_mask],\n                                          3).reshape(-1, 3)\n            return refi_triangulation, found_index\n        else:\n            return refi_triangulation"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/__init__/triangulation",
          "name": "triangulation",
          "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.__init__.triangulation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`~matplotlib.tri.Triangulation`",
            "default_value": "",
            "description": "The encapsulated triangulation to analyze."
          },
          "type": {
            "kind": "NamedType",
            "name": "`~matplotlib.tri.Triangulation`"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Define basic tools for triangular mesh analysis and improvement.\n\nA TriAnalyzer encapsulates a `.Triangulation` object and provides basic\ntools for mesh analysis and mesh improvement.",
      "docstring": "",
      "code": "    def __init__(self, triangulation):\n        _api.check_isinstance(Triangulation, triangulation=triangulation)\n        self._triangulation = triangulation"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/circle_ratios",
      "name": "circle_ratios",
      "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.circle_ratios",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/circle_ratios/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.circle_ratios.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/circle_ratios/rescale",
          "name": "rescale",
          "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.circle_ratios.rescale",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If True, internally rescale (based on `scale_factors`), so that the\n(unmasked) triangles fit exactly inside a unit square mesh."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a measure of the triangulation triangles flatness.\n\nThe ratio of the incircle radius over the circumcircle radius is a\nwidely used indicator of a triangle flatness.\nIt is always ``<= 0.5`` and ``== 0.5`` only for equilateral\ntriangles. Circle ratios below 0.01 denote very flat triangles.\n\nTo avoid unduly low values due to a difference of scale between the 2\naxis, the triangular mesh can first be rescaled to fit inside a unit\nsquare with `scale_factors` (Only if *rescale* is True, which is\nits default value).",
      "docstring": "Return a measure of the triangulation triangles flatness.\n\nThe ratio of the incircle radius over the circumcircle radius is a\nwidely used indicator of a triangle flatness.\nIt is always ``<= 0.5`` and ``== 0.5`` only for equilateral\ntriangles. Circle ratios below 0.01 denote very flat triangles.\n\nTo avoid unduly low values due to a difference of scale between the 2\naxis, the triangular mesh can first be rescaled to fit inside a unit\nsquare with `scale_factors` (Only if *rescale* is True, which is\nits default value).\n\nParameters\n----------\nrescale : bool, default: True\n    If True, internally rescale (based on `scale_factors`), so that the\n    (unmasked) triangles fit exactly inside a unit square mesh.\n\nReturns\n-------\nmasked array\n    Ratio of the incircle radius over the circumcircle radius, for\n    each 'rescaled' triangle of the encapsulated triangulation.\n    Values corresponding to masked triangles are masked out.",
      "code": "    def circle_ratios(self, rescale=True):\n        \"\"\"\n        Return a measure of the triangulation triangles flatness.\n\n        The ratio of the incircle radius over the circumcircle radius is a\n        widely used indicator of a triangle flatness.\n        It is always ``<= 0.5`` and ``== 0.5`` only for equilateral\n        triangles. Circle ratios below 0.01 denote very flat triangles.\n\n        To avoid unduly low values due to a difference of scale between the 2\n        axis, the triangular mesh can first be rescaled to fit inside a unit\n        square with `scale_factors` (Only if *rescale* is True, which is\n        its default value).\n\n        Parameters\n        ----------\n        rescale : bool, default: True\n            If True, internally rescale (based on `scale_factors`), so that the\n            (unmasked) triangles fit exactly inside a unit square mesh.\n\n        Returns\n        -------\n        masked array\n            Ratio of the incircle radius over the circumcircle radius, for\n            each 'rescaled' triangle of the encapsulated triangulation.\n            Values corresponding to masked triangles are masked out.\n\n        \"\"\"\n        # Coords rescaling\n        if rescale:\n            (kx, ky) = self.scale_factors\n        else:\n            (kx, ky) = (1.0, 1.0)\n        pts = np.vstack([self._triangulation.x*kx,\n                         self._triangulation.y*ky]).T\n        tri_pts = pts[self._triangulation.triangles]\n        # Computes the 3 side lengths\n        a = tri_pts[:, 1, :] - tri_pts[:, 0, :]\n        b = tri_pts[:, 2, :] - tri_pts[:, 1, :]\n        c = tri_pts[:, 0, :] - tri_pts[:, 2, :]\n        a = np.hypot(a[:, 0], a[:, 1])\n        b = np.hypot(b[:, 0], b[:, 1])\n        c = np.hypot(c[:, 0], c[:, 1])\n        # circumcircle and incircle radii\n        s = (a+b+c)*0.5\n        prod = s*(a+b-s)*(a+c-s)*(b+c-s)\n        # We have to deal with flat triangles with infinite circum_radius\n        bool_flat = (prod == 0.)\n        if np.any(bool_flat):\n            # Pathologic flow\n            ntri = tri_pts.shape[0]\n            circum_radius = np.empty(ntri, dtype=np.float64)\n            circum_radius[bool_flat] = np.inf\n            abc = a*b*c\n            circum_radius[~bool_flat] = abc[~bool_flat] / (\n                4.0*np.sqrt(prod[~bool_flat]))\n        else:\n            # Normal optimized flow\n            circum_radius = (a*b*c) / (4.0*np.sqrt(prod))\n        in_radius = (a*b*c) / (4.0*circum_radius*s)\n        circle_ratio = in_radius/circum_radius\n        mask = self._triangulation.mask\n        if mask is None:\n            return circle_ratio\n        else:\n            return np.ma.array(circle_ratio, mask=mask)"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/get_flat_tri_mask",
      "name": "get_flat_tri_mask",
      "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.get_flat_tri_mask",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/get_flat_tri_mask/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.get_flat_tri_mask.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/get_flat_tri_mask/min_circle_ratio",
          "name": "min_circle_ratio",
          "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.get_flat_tri_mask.min_circle_ratio",
          "default_value": "0.01",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0.01",
            "description": "Border triangles with incircle/circumcircle radii ratio r/R will\nbe removed if r/R < *min_circle_ratio*."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/get_flat_tri_mask/rescale",
          "name": "rescale",
          "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.get_flat_tri_mask.rescale",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "If True, first, internally rescale (based on `scale_factors`) so\nthat the (unmasked) triangles fit exactly inside a unit square\nmesh.  This rescaling accounts for the difference of scale which\nmight exist between the 2 axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Eliminate excessively flat border triangles from the triangulation.\n\nReturns a mask *new_mask* which allows to clean the encapsulated\ntriangulation from its border-located flat triangles\n(according to their :meth:`circle_ratios`).\nThis mask is meant to be subsequently applied to the triangulation\nusing `.Triangulation.set_mask`.\n*new_mask* is an extension of the initial triangulation mask\nin the sense that an initially masked triangle will remain masked.\n\nThe *new_mask* array is computed recursively; at each step flat\ntriangles are removed only if they share a side with the current mesh\nborder. Thus no new holes in the triangulated domain will be created.",
      "docstring": "Eliminate excessively flat border triangles from the triangulation.\n\nReturns a mask *new_mask* which allows to clean the encapsulated\ntriangulation from its border-located flat triangles\n(according to their :meth:`circle_ratios`).\nThis mask is meant to be subsequently applied to the triangulation\nusing `.Triangulation.set_mask`.\n*new_mask* is an extension of the initial triangulation mask\nin the sense that an initially masked triangle will remain masked.\n\nThe *new_mask* array is computed recursively; at each step flat\ntriangles are removed only if they share a side with the current mesh\nborder. Thus no new holes in the triangulated domain will be created.\n\nParameters\n----------\nmin_circle_ratio : float, default: 0.01\n    Border triangles with incircle/circumcircle radii ratio r/R will\n    be removed if r/R < *min_circle_ratio*.\nrescale : bool, default: True\n    If True, first, internally rescale (based on `scale_factors`) so\n    that the (unmasked) triangles fit exactly inside a unit square\n    mesh.  This rescaling accounts for the difference of scale which\n    might exist between the 2 axis.\n\nReturns\n-------\narray of bool\n    Mask to apply to encapsulated triangulation.\n    All the initially masked triangles remain masked in the\n    *new_mask*.\n\nNotes\n-----\nThe rationale behind this function is that a Delaunay\ntriangulation - of an unstructured set of points - sometimes contains\nalmost flat triangles at its border, leading to artifacts in plots\n(especially for high-resolution contouring).\nMasked with computed *new_mask*, the encapsulated\ntriangulation would contain no more unmasked border triangles\nwith a circle ratio below *min_circle_ratio*, thus improving the\nmesh quality for subsequent plots or interpolation.",
      "code": "    def get_flat_tri_mask(self, min_circle_ratio=0.01, rescale=True):\n        \"\"\"\n        Eliminate excessively flat border triangles from the triangulation.\n\n        Returns a mask *new_mask* which allows to clean the encapsulated\n        triangulation from its border-located flat triangles\n        (according to their :meth:`circle_ratios`).\n        This mask is meant to be subsequently applied to the triangulation\n        using `.Triangulation.set_mask`.\n        *new_mask* is an extension of the initial triangulation mask\n        in the sense that an initially masked triangle will remain masked.\n\n        The *new_mask* array is computed recursively; at each step flat\n        triangles are removed only if they share a side with the current mesh\n        border. Thus no new holes in the triangulated domain will be created.\n\n        Parameters\n        ----------\n        min_circle_ratio : float, default: 0.01\n            Border triangles with incircle/circumcircle radii ratio r/R will\n            be removed if r/R < *min_circle_ratio*.\n        rescale : bool, default: True\n            If True, first, internally rescale (based on `scale_factors`) so\n            that the (unmasked) triangles fit exactly inside a unit square\n            mesh.  This rescaling accounts for the difference of scale which\n            might exist between the 2 axis.\n\n        Returns\n        -------\n        array of bool\n            Mask to apply to encapsulated triangulation.\n            All the initially masked triangles remain masked in the\n            *new_mask*.\n\n        Notes\n        -----\n        The rationale behind this function is that a Delaunay\n        triangulation - of an unstructured set of points - sometimes contains\n        almost flat triangles at its border, leading to artifacts in plots\n        (especially for high-resolution contouring).\n        Masked with computed *new_mask*, the encapsulated\n        triangulation would contain no more unmasked border triangles\n        with a circle ratio below *min_circle_ratio*, thus improving the\n        mesh quality for subsequent plots or interpolation.\n        \"\"\"\n        # Recursively computes the mask_current_borders, true if a triangle is\n        # at the border of the mesh OR touching the border through a chain of\n        # invalid aspect ratio masked_triangles.\n        ntri = self._triangulation.triangles.shape[0]\n        mask_bad_ratio = self.circle_ratios(rescale) < min_circle_ratio\n\n        current_mask = self._triangulation.mask\n        if current_mask is None:\n            current_mask = np.zeros(ntri, dtype=bool)\n        valid_neighbors = np.copy(self._triangulation.neighbors)\n        renum_neighbors = np.arange(ntri, dtype=np.int32)\n        nadd = -1\n        while nadd != 0:\n            # The active wavefront is the triangles from the border (unmasked\n            # but with a least 1 neighbor equal to -1\n            wavefront = (np.min(valid_neighbors, axis=1) == -1) & ~current_mask\n            # The element from the active wavefront will be masked if their\n            # circle ratio is bad.\n            added_mask = wavefront & mask_bad_ratio\n            current_mask = added_mask | current_mask\n            nadd = np.sum(added_mask)\n\n            # now we have to update the tables valid_neighbors\n            valid_neighbors[added_mask, :] = -1\n            renum_neighbors[added_mask] = -1\n            valid_neighbors = np.where(valid_neighbors == -1, -1,\n                                       renum_neighbors[valid_neighbors])\n\n        return np.ma.filled(current_mask, True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/scale_factors@getter",
      "name": "scale_factors",
      "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.scale_factors",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.tri.tritools/TriAnalyzer/scale_factors@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.tri.tritools.TriAnalyzer.scale_factors.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Factors to rescale the triangulation into a unit square.",
      "docstring": "Factors to rescale the triangulation into a unit square.\n\nReturns\n-------\n(float, float)\n    Scaling factors (kx, ky) so that the triangulation\n    ``[triangulation.x * kx, triangulation.y * ky]``\n    fits exactly inside a unit square.",
      "code": "    @property\n    def scale_factors(self):\n        \"\"\"\n        Factors to rescale the triangulation into a unit square.\n\n        Returns\n        -------\n        (float, float)\n            Scaling factors (kx, ky) so that the triangulation\n            ``[triangulation.x * kx, triangulation.y * ky]``\n            fits exactly inside a unit square.\n        \"\"\"\n        compressed_triangles = self._triangulation.get_masked_triangles()\n        node_used = (np.bincount(np.ravel(compressed_triangles),\n                                 minlength=self._triangulation.x.size) != 0)\n        return (1 / np.ptp(self._triangulation.x[node_used]),\n                1 / np.ptp(self._triangulation.y[node_used]))"
    }
  ]
}