{
  "schemaVersion": 1,
  "distribution": "",
  "package": "matplotlib",
  "version": "",
  "modules": [],
  "classes": [
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg",
      "name": "FigureCanvasAgg",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/draw",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_rgb",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_argb",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/buffer_rgba",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/_print_pil",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_to_buffer",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasAgg(FigureCanvasBase):\n    # docstring inherited\n\n    _lastKey = None  # Overwritten per-instance on the first draw.\n\n    def copy_from_bbox(self, bbox):\n        renderer = self.get_renderer()\n        return renderer.copy_from_bbox(bbox)\n\n    def restore_region(self, region, bbox=None, xy=None):\n        renderer = self.get_renderer()\n        return renderer.restore_region(region, bbox, xy)\n\n    def draw(self):\n        # docstring inherited\n        self.renderer = self.get_renderer()\n        self.renderer.clear()\n        # Acquire a lock on the shared font cache.\n        with RendererAgg.lock, \\\n             (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self.figure.draw(self.renderer)\n            # A GUI class may be need to update a window using this draw, so\n            # don't forget to call the superclass.\n            super().draw()\n\n    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n\n    def tostring_rgb(self):\n        \"\"\"\n        Get the image as RGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_rgb()\n\n    def tostring_argb(self):\n        \"\"\"\n        Get the image as ARGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_argb()\n\n    def buffer_rgba(self):\n        \"\"\"\n        Get the image as a `memoryview` to the renderer's buffer.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.buffer_rgba()\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_raw(self, filename_or_obj, *args):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        with cbook.open_file_cm(filename_or_obj, \"wb\") as fh:\n            fh.write(renderer.buffer_rgba())\n\n    print_rgba = print_raw\n\n    def _print_pil(self, filename_or_obj, fmt, pil_kwargs, metadata=None):\n        \"\"\"\n        Draw the canvas, then save it using `.image.imsave` (to which\n        *pil_kwargs* and *metadata* are forwarded).\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n        mpl.image.imsave(\n            filename_or_obj, self.buffer_rgba(), format=fmt, origin=\"upper\",\n            dpi=self.figure.dpi, metadata=metadata, pil_kwargs=pil_kwargs)\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_png(self, filename_or_obj, *args,\n                  metadata=None, pil_kwargs=None):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for Matplotlib\n            will be used.  This can be removed by setting it to *None*.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            Keyword arguments passed to `PIL.Image.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n        self._print_pil(filename_or_obj, \"png\", pil_kwargs, metadata)\n\n    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        return (bytes(renderer.buffer_rgba()),\n                (int(renderer.width), int(renderer.height)))\n\n    # Note that these methods should typically be called via savefig() and\n    # print_figure(), and the latter ensures that `self.figure.dpi` already\n    # matches the dpi kwarg (if any).\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_jpg(self, filename_or_obj, *args, pil_kwargs=None):\n        # savefig() has already applied savefig.facecolor; we now set it to\n        # white to make imsave() blend semi-transparent figures against an\n        # assumed white background.\n        with mpl.rc_context({\"savefig.facecolor\": \"white\"}):\n            self._print_pil(filename_or_obj, \"jpeg\", pil_kwargs)\n\n    print_jpeg = print_jpg\n\n    def print_tif(self, filename_or_obj, *, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"tiff\", pil_kwargs)\n\n    print_tiff = print_tif\n\n    def print_webp(self, filename_or_obj, *, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"webp\", pil_kwargs)\n\n    print_jpg.__doc__, print_tif.__doc__, print_webp.__doc__ = map(\n        \"\"\"\n        Write the figure to a {} file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.\n        \"\"\".format, [\"JPEG\", \"TIFF\", \"WebP\"])",
      "instance_attributes": [
        {
          "name": "renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererAgg"
          }
        },
        {
          "name": "_lastKey",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg",
      "name": "RendererAgg",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__getstate__",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/_update_methods",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/_prepare_font",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/buffer_rgba",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_argb",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgb",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/clear",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_image_nocomposite",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_scale_image",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/start_filter",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles",
      "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles",
      "code": "class RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    # we want to cache the fonts at the class level so that when\n    # multiple figures are created we can reuse them.  This helps with\n    # a bug on windows where the creation of too many figures leads to\n    # too many open file handles.  However, storing them at the class\n    # level is not thread safe.  The solution here is to let the\n    # FigureCanvas acquire a lock on the fontd at the start of the\n    # draw, and release it when it is done.  This allows multiple\n    # renderers to share the cached fonts, but only one figure can\n    # draw at time and so the font cache is used by only one\n    # renderer at a time.\n\n    lock = threading.RLock()\n\n    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('Agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangle = self._renderer.draw_gouraud_triangle\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        nmax = mpl.rcParams['agg.path.chunksize']  # here at least for testing\n        npts = path.vertices.shape[0]\n\n        if (npts > nmax > 100 and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts / nmax)\n            chsize = int(np.ceil(npts / nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1, :]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO  # move to end of last chunk\n                p = Path(v, c)\n                p.simplify_threshold = path.simplify_threshold\n                try:\n                    self._renderer.draw_path(gc, p, transform, rgbFace)\n                except OverflowError:\n                    msg = (\n                        \"Exceeded cell block limit in Agg.\\n\\n\"\n                        \"Please reduce the value of \"\n                        f\"rcParams['agg.path.chunksize'] (currently {nmax}) \"\n                        \"or increase the path simplification threshold\"\n                        \"(rcParams['path.simplify_threshold'] = \"\n                        f\"{mpl.rcParams['path.simplify_threshold']:.2f} by \"\n                        \"default and path.simplify_threshold = \"\n                        f\"{path.simplify_threshold:.2f} on the input).\"\n                    )\n                    raise OverflowError(msg) from None\n        else:\n            try:\n                self._renderer.draw_path(gc, path, transform, rgbFace)\n            except OverflowError:\n                cant_chunk = ''\n                if rgbFace is not None:\n                    cant_chunk += \"- can not split filled path\\n\"\n                if gc.get_hatch() is not None:\n                    cant_chunk += \"- can not split hatched path\\n\"\n                if not path.should_simplify:\n                    cant_chunk += \"- path.should_simplify is False\\n\"\n                if len(cant_chunk):\n                    msg = (\n                        \"Exceeded cell block limit in Agg, however for the \"\n                        \"following reasons:\\n\\n\"\n                        f\"{cant_chunk}\\n\"\n                        \"we can not automatically split up this path to draw.\"\n                        \"\\n\\nPlease manually simplify your path.\"\n                    )\n\n                else:\n                    inc_threshold = (\n                        \"or increase the path simplification threshold\"\n                        \"(rcParams['path.simplify_threshold'] = \"\n                        f\"{mpl.rcParams['path.simplify_threshold']} \"\n                        \"by default and path.simplify_threshold \"\n                        f\"= {path.simplify_threshold} \"\n                        \"on the input).\"\n                        )\n                    if nmax > 100:\n                        msg = (\n                            \"Exceeded cell block limit in Agg.  Please reduce \"\n                            \"the value of rcParams['agg.path.chunksize'] \"\n                            f\"(currently {nmax}) {inc_threshold}\"\n                        )\n                    else:\n                        msg = (\n                            \"Exceeded cell block limit in Agg.  Please set \"\n                            \"the value of rcParams['agg.path.chunksize'], \"\n                            f\"(currently {nmax}) to be greater than 100 \"\n                            + inc_threshold\n                        )\n\n                raise OverflowError(msg) from None\n\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw mathtext using :mod:`matplotlib.mathtext`.\"\"\"\n        ox, oy, width, height, descent, font_image = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        xd = descent * sin(radians(angle))\n        yd = descent * cos(radians(angle))\n        x = round(x + ox + xd)\n        y = round(y - oy + yd)\n        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc)\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n        font = self._prepare_font(prop)\n        # We pass '0' for angle here, since it will be rotated (in raster\n        # space) in the following call to draw_text_image).\n        font.set_text(s, 0, flags=get_hinting_flag())\n        font.draw_glyphs_to_bitmap(\n            antialiased=mpl.rcParams['text.antialiased'])\n        d = font.get_descent() / 64.0\n        # The descent needs to be adjusted for the angle.\n        xo, yo = font.get_bitmap_offset()\n        xo /= 64.0\n        yo /= 64.0\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xo + xd)\n        y = round(y + yo + yd)\n        self._renderer.draw_text_image(font, x, y + 1, angle, gc)\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        _api.check_in_list([\"TeX\", True, False], ismath=ismath)\n        if ismath == \"TeX\":\n            # todo: handle props\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(\n                s, fontsize, renderer=self)\n            return w, h, d\n\n        if ismath:\n            ox, oy, width, height, descent, font_image = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        font = self._prepare_font(prop)\n        font.set_text(s, 0.0, flags=get_hinting_flag())\n        w, h = font.get_width_height()  # width and height of unrotated string\n        d = font.get_descent()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d /= 64.0\n        return w, h, d\n\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        # todo, handle props, angle, origins\n        size = prop.get_size_in_points()\n\n        texmanager = self.get_texmanager()\n\n        Z = texmanager.get_grey(s, size, self.dpi)\n        Z = np.array(Z * 255.0, np.uint8)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xd)\n        y = round(y + yd)\n        self._renderer.draw_text_image(Z, x, y, angle, gc)\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def _prepare_font(self, font_prop):\n        \"\"\"\n        Get the `.FT2Font` for *font_prop*, clear its buffer, and set its size.\n        \"\"\"\n        font = get_font(_fontManager._find_fonts_by_props(font_prop))\n        font.clear()\n        size = font_prop.get_size_in_points()\n        font.set_size(size, self.dpi)\n        return font\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * self.dpi / 72\n\n    def buffer_rgba(self):\n        return memoryview(self._renderer)\n\n    def tostring_argb(self):\n        return np.asarray(self._renderer).take([3, 0, 1, 2], axis=2).tobytes()\n\n    def tostring_rgb(self):\n        return np.asarray(self._renderer).take([0, 1, 2], axis=2).tobytes()\n\n    def clear(self):\n        self._renderer.clear()\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n\n        # It is generally faster to composite each image directly to\n        # the Figure, and there's no file size benefit to compositing\n        # with the Agg backend\n        return True\n\n    def option_scale_image(self):\n        # docstring inherited\n        return False\n\n    def restore_region(self, region, bbox=None, xy=None):\n        \"\"\"\n        Restore the saved region. If bbox (instance of BboxBase, or\n        its extents) is given, only the region specified by the bbox\n        will be restored. *xy* (a pair of floats) optionally\n        specifies the new position (the LLC of the original region,\n        not the LLC of the bbox) where the region will be restored.\n\n        >>> region = renderer.copy_from_bbox()\n        >>> x1, y1, x2, y2 = region.get_extents()\n        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n        ...                         xy=(x1-dx, y1))\n\n        \"\"\"\n        if bbox is not None or xy is not None:\n            if bbox is None:\n                x1, y1, x2, y2 = region.get_extents()\n            elif isinstance(bbox, BboxBase):\n                x1, y1, x2, y2 = bbox.extents\n            else:\n                x1, y1, x2, y2 = bbox\n\n            if xy is None:\n                ox, oy = x1, y1\n            else:\n                ox, oy = xy\n\n            # The incoming data is float, but the _renderer type-checking wants\n            # to see integers.\n            self._renderer.restore_region(region, int(x1), int(y1),\n                                          int(x2), int(y2), int(ox), int(oy))\n\n        else:\n            self._renderer.restore_region(region)\n\n    def start_filter(self):\n        \"\"\"\n        Start filtering. It simply create a new canvas (the old one is saved).\n        \"\"\"\n        self._filter_renderers.append(self._renderer)\n        self._renderer = _RendererAgg(int(self.width), int(self.height),\n                                      self.dpi)\n        self._update_methods()\n\n    def stop_filter(self, post_processing):\n        \"\"\"\n        Save the plot in the current canvas as a image and apply\n        the *post_processing* function.\n\n           def post_processing(image, dpi):\n             # ny, nx, depth = image.shape\n             # image (numpy array) has RGBA channels and has a depth of 4.\n             ...\n             # create a new_image (numpy array of 4 channels, size can be\n             # different). The resulting image may have offsets from\n             # lower-left corner of the original image\n             return new_image, offset_x, offset_y\n\n        The saved renderer is restored and the returned image from\n        post_processing is plotted (using draw_image) on it.\n        \"\"\"\n        orig_img = np.asarray(self.buffer_rgba())\n        slice_y, slice_x = cbook._get_nonzero_slices(orig_img[..., 3])\n        cropped_img = orig_img[slice_y, slice_x]\n\n        self._renderer = self._filter_renderers.pop()\n        self._update_methods()\n\n        if cropped_img.size:\n            img, ox, oy = post_processing(cropped_img / 255, self.dpi)\n            gc = self.new_gc()\n            if img.dtype.kind == 'f':\n                img = np.asarray(img * 255., np.uint8)\n            self._renderer.draw_image(\n                gc, slice_x.start + ox, int(self.height) - slice_y.stop + oy,\n                img[::-1])",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "_renderer",
          "types": null
        },
        {
          "name": "_filter_renderers",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "mathtext_parser",
          "types": null
        },
        {
          "name": "bbox",
          "types": null
        },
        {
          "name": "draw_gouraud_triangle",
          "types": null
        },
        {
          "name": "draw_gouraud_triangles",
          "types": null
        },
        {
          "name": "draw_image",
          "types": null
        },
        {
          "name": "draw_markers",
          "types": null
        },
        {
          "name": "draw_path_collection",
          "types": null
        },
        {
          "name": "draw_quad_mesh",
          "types": null
        },
        {
          "name": "copy_from_bbox",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo",
      "name": "FigureCanvasCairo",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/_renderer@getter",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/get_renderer",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/_get_printed_image_surface",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/_save"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasCairo(FigureCanvasBase):\n    @property\n    def _renderer(self):\n        # In theory, _renderer should be set in __init__, but GUI canvas\n        # subclasses (FigureCanvasFooCairo) don't always interact well with\n        # multiple inheritance (FigureCanvasFoo inits but doesn't super-init\n        # FigureCanvasCairo), so initialize it in the getter instead.\n        if not hasattr(self, \"_cached_renderer\"):\n            self._cached_renderer = RendererCairo(self.figure.dpi)\n        return self._cached_renderer\n\n    def get_renderer(self):\n        return self._renderer\n\n    def copy_from_bbox(self, bbox):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"copy_from_bbox only works when rendering to an ImageSurface\")\n        sw = surface.get_width()\n        sh = surface.get_height()\n        x0 = math.ceil(bbox.x0)\n        x1 = math.floor(bbox.x1)\n        y0 = math.ceil(sh - bbox.y1)\n        y1 = math.floor(sh - bbox.y0)\n        if not (0 <= x0 and x1 <= sw and bbox.x0 <= bbox.x1\n                and 0 <= y0 and y1 <= sh and bbox.y0 <= bbox.y1):\n            raise ValueError(\"Invalid bbox\")\n        sls = slice(y0, y0 + max(y1 - y0, 0)), slice(x0, x0 + max(x1 - x0, 0))\n        data = (np.frombuffer(surface.get_data(), np.uint32)\n                .reshape((sh, sw))[sls].copy())\n        return _CairoRegion(sls, data)\n\n    def restore_region(self, region):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"restore_region only works when rendering to an ImageSurface\")\n        surface.flush()\n        sw = surface.get_width()\n        sh = surface.get_height()\n        sly, slx = region._slices\n        (np.frombuffer(surface.get_data(), np.uint32)\n         .reshape((sh, sw))[sly, slx]) = region._data\n        surface.mark_dirty_rectangle(\n            slx.start, sly.start, slx.stop - slx.start, sly.stop - sly.start)\n\n    def print_png(self, fobj):\n        self._get_printed_image_surface().write_to_png(fobj)\n\n    def print_rgba(self, fobj):\n        width, height = self.get_width_height()\n        buf = self._get_printed_image_surface().get_data()\n        fobj.write(cbook._premultiplied_argb32_to_unmultiplied_rgba8888(\n            np.asarray(buf).reshape((width, height, 4))))\n\n    print_raw = print_rgba\n\n    def _get_printed_image_surface(self):\n        self._renderer.dpi = self.figure.dpi\n        width, height = self.get_width_height()\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_context(cairo.Context(surface))\n        self.figure.draw(self._renderer)\n        return surface\n\n    def _save(self, fmt, fobj, *, orientation='portrait'):\n        # save PDF/PS/SVG\n\n        dpi = 72\n        self.figure.dpi = dpi\n        w_in, h_in = self.figure.get_size_inches()\n        width_in_points, height_in_points = w_in * dpi, h_in * dpi\n\n        if orientation == 'landscape':\n            width_in_points, height_in_points = (\n                height_in_points, width_in_points)\n\n        if fmt == 'ps':\n            if not hasattr(cairo, 'PSSurface'):\n                raise RuntimeError('cairo has not been compiled with PS '\n                                   'support enabled')\n            surface = cairo.PSSurface(fobj, width_in_points, height_in_points)\n        elif fmt == 'pdf':\n            if not hasattr(cairo, 'PDFSurface'):\n                raise RuntimeError('cairo has not been compiled with PDF '\n                                   'support enabled')\n            surface = cairo.PDFSurface(fobj, width_in_points, height_in_points)\n        elif fmt in ('svg', 'svgz'):\n            if not hasattr(cairo, 'SVGSurface'):\n                raise RuntimeError('cairo has not been compiled with SVG '\n                                   'support enabled')\n            if fmt == 'svgz':\n                if isinstance(fobj, str):\n                    fobj = gzip.GzipFile(fobj, 'wb')\n                else:\n                    fobj = gzip.GzipFile(None, 'wb', fileobj=fobj)\n            surface = cairo.SVGSurface(fobj, width_in_points, height_in_points)\n        else:\n            raise ValueError(\"Unknown format: {!r}\".format(fmt))\n\n        self._renderer.dpi = self.figure.dpi\n        self._renderer.set_context(cairo.Context(surface))\n        ctx = self._renderer.gc.ctx\n\n        if orientation == 'landscape':\n            ctx.rotate(np.pi / 2)\n            ctx.translate(0, -height_in_points)\n            # Perhaps add an '%%Orientation: Landscape' comment?\n\n        self.figure.draw(self._renderer)\n\n        ctx.show_page()\n        surface.finish()\n        if fmt == 'svgz':\n            fobj.close()\n\n    print_pdf = functools.partialmethod(_save, \"pdf\")\n    print_ps = functools.partialmethod(_save, \"ps\")\n    print_svg = functools.partialmethod(_save, \"svg\")\n    print_svgz = functools.partialmethod(_save, \"svgz\")",
      "instance_attributes": [
        {
          "name": "_cached_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererCairo"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo",
      "name": "GraphicsContextCairo",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/restore",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_antialiased",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/get_rgb",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class GraphicsContextCairo(GraphicsContextBase):\n    _joind = {\n        'bevel':  cairo.LINE_JOIN_BEVEL,\n        'miter':  cairo.LINE_JOIN_MITER,\n        'round':  cairo.LINE_JOIN_ROUND,\n    }\n\n    _capd = {\n        'butt':        cairo.LINE_CAP_BUTT,\n        'projecting':  cairo.LINE_CAP_SQUARE,\n        'round':       cairo.LINE_CAP_ROUND,\n    }\n\n    def __init__(self, renderer):\n        super().__init__()\n        self.renderer = renderer\n\n    def restore(self):\n        self.ctx.restore()\n\n    def set_alpha(self, alpha):\n        super().set_alpha(alpha)\n        _alpha = self.get_alpha()\n        rgb = self._rgb\n        if self.get_forced_alpha():\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], _alpha)\n        else:\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], rgb[3])\n\n    def set_antialiased(self, b):\n        self.ctx.set_antialias(\n            cairo.ANTIALIAS_DEFAULT if b else cairo.ANTIALIAS_NONE)\n\n    def set_capstyle(self, cs):\n        self.ctx.set_line_cap(_api.check_getitem(self._capd, capstyle=cs))\n        self._capstyle = cs\n\n    def set_clip_rectangle(self, rectangle):\n        if not rectangle:\n            return\n        x, y, w, h = np.round(rectangle.bounds)\n        ctx = self.ctx\n        ctx.new_path()\n        ctx.rectangle(x, self.renderer.height - h - y, w, h)\n        ctx.clip()\n\n    def set_clip_path(self, path):\n        if not path:\n            return\n        tpath, affine = path.get_transformed_path_and_affine()\n        ctx = self.ctx\n        ctx.new_path()\n        affine = (affine\n                  + Affine2D().scale(1, -1).translate(0, self.renderer.height))\n        _append_path(ctx, tpath, affine)\n        ctx.clip()\n\n    def set_dashes(self, offset, dashes):\n        self._dashes = offset, dashes\n        if dashes is None:\n            self.ctx.set_dash([], 0)  # switch dashes off\n        else:\n            self.ctx.set_dash(\n                list(self.renderer.points_to_pixels(np.asarray(dashes))),\n                offset)\n\n    def set_foreground(self, fg, isRGBA=None):\n        super().set_foreground(fg, isRGBA)\n        if len(self._rgb) == 3:\n            self.ctx.set_source_rgb(*self._rgb)\n        else:\n            self.ctx.set_source_rgba(*self._rgb)\n\n    def get_rgb(self):\n        return self.ctx.get_source().get_rgba()[:3]\n\n    def set_joinstyle(self, js):\n        self.ctx.set_line_join(_api.check_getitem(self._joind, joinstyle=js))\n        self._joinstyle = js\n\n    def set_linewidth(self, w):\n        self._linewidth = float(w)\n        self.ctx.set_line_width(self.renderer.points_to_pixels(w))",
      "instance_attributes": [
        {
          "name": "ctx",
          "types": null
        },
        {
          "name": "_alpha",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_forced_alpha",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "renderer",
          "types": null
        },
        {
          "name": "_capstyle",
          "types": null
        },
        {
          "name": "_dashes",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "_joinstyle",
          "types": null
        },
        {
          "name": "_linewidth",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo",
      "name": "RendererCairo",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_context",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/_fill_and_stroke",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/_draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererCairo(RendererBase):\n    def __init__(self, dpi):\n        self.dpi = dpi\n        self.gc = GraphicsContextCairo(renderer=self)\n        self.width = None\n        self.height = None\n        self.text_ctx = cairo.Context(\n           cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1))\n        super().__init__()\n\n    def set_context(self, ctx):\n        surface = ctx.get_target()\n        if hasattr(surface, \"get_width\") and hasattr(surface, \"get_height\"):\n            size = surface.get_width(), surface.get_height()\n        elif hasattr(surface, \"get_extents\"):  # GTK4 RecordingSurface.\n            ext = surface.get_extents()\n            size = ext.width, ext.height\n        else:  # vector surfaces.\n            ctx.save()\n            ctx.reset_clip()\n            rect, *rest = ctx.copy_clip_rectangle_list()\n            if rest:\n                raise TypeError(\"Cannot infer surface size\")\n            size = rect.width, rect.height\n            ctx.restore()\n        self.gc.ctx = ctx\n        self.width, self.height = size\n\n    @_api.deprecated(\"3.6\", alternative=\"set_context\")\n    def set_ctx_from_surface(self, surface):\n        self.gc.ctx = cairo.Context(surface)\n\n    @_api.deprecated(\"3.6\")\n    def set_width_height(self, width, height):\n        self.width = width\n        self.height = height\n\n    def _fill_and_stroke(self, ctx, fill_c, alpha, alpha_overrides):\n        if fill_c is not None:\n            ctx.save()\n            if len(fill_c) == 3 or alpha_overrides:\n                ctx.set_source_rgba(fill_c[0], fill_c[1], fill_c[2], alpha)\n            else:\n                ctx.set_source_rgba(fill_c[0], fill_c[1], fill_c[2], fill_c[3])\n            ctx.fill_preserve()\n            ctx.restore()\n        ctx.stroke()\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        ctx = gc.ctx\n        # Clip the path to the actual rendering extents if it isn't filled.\n        clip = (ctx.clip_extents()\n                if rgbFace is None and gc.get_hatch() is None\n                else None)\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n        ctx.new_path()\n        _append_path(ctx, path, transform, clip)\n        self._fill_and_stroke(\n            ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, transform,\n                     rgbFace=None):\n        # docstring inherited\n\n        ctx = gc.ctx\n        ctx.new_path()\n        # Create the path for the marker; it needs to be flipped here already!\n        _append_path(ctx, marker_path, marker_trans + Affine2D().scale(1, -1))\n        marker_path = ctx.copy_path_flat()\n\n        # Figure out whether the path has a fill\n        x1, y1, x2, y2 = ctx.fill_extents()\n        if x1 == 0 and y1 == 0 and x2 == 0 and y2 == 0:\n            filled = False\n            # No fill, just unset this (so we don't try to fill it later on)\n            rgbFace = None\n        else:\n            filled = True\n\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n\n        ctx.new_path()\n        for i, (vertices, codes) in enumerate(\n                path.iter_segments(transform, simplify=False)):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ctx.save()\n\n                # Translate and apply path\n                ctx.translate(x, y)\n                ctx.append_path(marker_path)\n\n                ctx.restore()\n\n                # Slower code path if there is a fill; we need to draw\n                # the fill and stroke for each marker at the same time.\n                # Also flush out the drawing every once in a while to\n                # prevent the paths from getting way too long.\n                if filled or i % 1000 == 0:\n                    self._fill_and_stroke(\n                        ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n        # Fast path, if there is no fill, draw everything in one step\n        if not filled:\n            self._fill_and_stroke(\n                ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n    def draw_image(self, gc, x, y, im):\n        im = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(im[::-1])\n        surface = cairo.ImageSurface.create_for_data(\n            im.ravel().data, cairo.FORMAT_ARGB32,\n            im.shape[1], im.shape[0], im.shape[1] * 4)\n        ctx = gc.ctx\n        y = self.height - y - im.shape[0]\n\n        ctx.save()\n        ctx.set_source_surface(surface, float(x), float(y))\n        ctx.paint()\n        ctx.restore()\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # Note: (x, y) are device/display coords, not user-coords, unlike other\n        # draw_* methods\n        if ismath:\n            self._draw_mathtext(gc, x, y, s, prop, angle)\n\n        else:\n            ctx = gc.ctx\n            ctx.new_path()\n            ctx.move_to(x, y)\n\n            ctx.save()\n            ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n            ctx.set_font_size(self.points_to_pixels(prop.get_size_in_points()))\n            opts = cairo.FontOptions()\n            opts.set_antialias(\n                cairo.ANTIALIAS_DEFAULT if mpl.rcParams[\"text.antialiased\"]\n                else cairo.ANTIALIAS_NONE)\n            ctx.set_font_options(opts)\n            if angle:\n                ctx.rotate(np.deg2rad(-angle))\n            ctx.show_text(s)\n            ctx.restore()\n\n    def _draw_mathtext(self, gc, x, y, s, prop, angle):\n        ctx = gc.ctx\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, self.dpi, prop)\n\n        ctx.save()\n        ctx.translate(x, y)\n        if angle:\n            ctx.rotate(np.deg2rad(-angle))\n\n        for font, fontsize, idx, ox, oy in glyphs:\n            ctx.new_path()\n            ctx.move_to(ox, -oy)\n            ctx.select_font_face(\n                *_cairo_font_args_from_font_prop(ttfFontProperty(font)))\n            ctx.set_font_size(self.points_to_pixels(fontsize))\n            ctx.show_text(chr(idx))\n\n        for ox, oy, w, h in rects:\n            ctx.new_path()\n            ctx.rectangle(ox, -oy, w, -h)\n            ctx.set_source_rgb(0, 0, 0)\n            ctx.fill_preserve()\n\n        ctx.restore()\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath == 'TeX':\n            return super().get_text_width_height_descent(s, prop, ismath)\n\n        if ismath:\n            width, height, descent, *_ = \\\n                self._text2path.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        ctx = self.text_ctx\n        # problem - scale remembers last setting and font can become\n        # enormous causing program to crash\n        # save/restore prevents the problem\n        ctx.save()\n        ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n        ctx.set_font_size(self.points_to_pixels(prop.get_size_in_points()))\n\n        y_bearing, w, h = ctx.text_extents(s)[1:4]\n        ctx.restore()\n\n        return w, h, h + y_bearing\n\n    def new_gc(self):\n        # docstring inherited\n        self.gc.ctx.save()\n        self.gc._alpha = 1\n        self.gc._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        return self.gc\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points / 72 * self.dpi",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "gc",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextCairo"
          }
        },
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "text_ctx",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3",
      "name": "FigureCanvasGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase",
        "Gtk.DrawingArea"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/destroy",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_mpl_coords",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_get_key",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_update_device_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_post_draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/flush_events"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK3(FigureCanvasBase, Gtk.DrawingArea):\n    required_interactive_framework = \"gtk3\"\n    _timer_cls = TimerGTK3\n    manager_class = _api.classproperty(lambda cls: FigureManagerGTK3)\n    # Setting this as a static constant prevents\n    # this resulting expression from leaking\n    event_mask = (Gdk.EventMask.BUTTON_PRESS_MASK\n                  | Gdk.EventMask.BUTTON_RELEASE_MASK\n                  | Gdk.EventMask.EXPOSURE_MASK\n                  | Gdk.EventMask.KEY_PRESS_MASK\n                  | Gdk.EventMask.KEY_RELEASE_MASK\n                  | Gdk.EventMask.ENTER_NOTIFY_MASK\n                  | Gdk.EventMask.LEAVE_NOTIFY_MASK\n                  | Gdk.EventMask.POINTER_MOTION_MASK\n                  | Gdk.EventMask.SCROLL_MASK)\n\n    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n\n    def destroy(self):\n        CloseEvent(\"close_event\", self)._process()\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        window = self.get_property(\"window\")\n        if window is not None:\n            window.set_cursor(_mpl_to_gtk_cursor(cursor))\n            context = GLib.MainContext.default()\n            context.iteration(True)\n\n    def _mpl_coords(self, event=None):\n        \"\"\"\n        Convert the position of a GTK event, or of the current cursor position\n        if *event* is None, to Matplotlib coordinates.\n\n        GTK use logical pixels, but the figure is scaled to physical pixels for\n        rendering.  Transform to physical pixels so that all of the down-stream\n        transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        if event is None:\n            window = self.get_window()\n            t, x, y, state = window.get_device_position(\n                window.get_display().get_device_manager().get_client_pointer())\n        else:\n            x, y = event.x, event.y\n        x = x * self.device_pixel_ratio\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height - y * self.device_pixel_ratio\n        return x, y\n\n    def scroll_event(self, widget, event):\n        step = 1 if event.direction == Gdk.ScrollDirection.UP else -1\n        MouseEvent(\"scroll_event\", self, *self._mpl_coords(event), step=step,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def button_release_event(self, widget, event):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def key_press_event(self, widget, event):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def key_release_event(self, widget, event):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?\n\n    def enter_notify_event(self, widget, event):\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      guiEvent=event)._process()\n\n    def leave_notify_event(self, widget, event):\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      guiEvent=event)._process()\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    def _get_key(self, event):\n        unikey = chr(Gdk.keyval_to_unicode(event.keyval))\n        key = cbook._unikey_or_keysym_to_mplkey(\n            unikey,\n            Gdk.keyval_name(event.keyval))\n        modifiers = [\n            (Gdk.ModifierType.CONTROL_MASK, 'ctrl'),\n            (Gdk.ModifierType.MOD1_MASK, 'alt'),\n            (Gdk.ModifierType.SHIFT_MASK, 'shift'),\n            (Gdk.ModifierType.MOD4_MASK, 'super'),\n        ]\n        for key_mask, prefix in modifiers:\n            if event.state & key_mask:\n                if not (prefix == 'shift' and unikey.isprintable()):\n                    key = f'{prefix}+{key}'\n        return key\n\n    def _update_device_pixel_ratio(self, *args, **kwargs):\n        # We need to be careful in cases with mixed resolution displays if\n        # device_pixel_ratio changes.\n        if self._set_device_pixel_ratio(self.get_scale_factor()):\n            # The easiest way to resize the canvas is to emit a resize event\n            # since we implement all the logic for resizing the canvas for that\n            # event.\n            self.queue_resize()\n            self.queue_draw()\n\n    def configure_event(self, widget, event):\n        if widget.get_property(\"window\") is None:\n            return\n        w = event.width * self.device_pixel_ratio\n        h = event.height * self.device_pixel_ratio\n        if w < 3 or h < 3:\n            return  # empty fig\n        # resize the figure (in inches)\n        dpi = self.figure.dpi\n        self.figure.set_size_inches(w / dpi, h / dpi, forward=False)\n        return False  # finish event propagation?\n\n    def _draw_rubberband(self, rect):\n        self._rubberband_rect = rect\n        # TODO: Only update the rubberband area.\n        self.queue_draw()\n\n    def _post_draw(self, widget, ctx):\n        if self._rubberband_rect is None:\n            return\n\n        x0, y0, w, h = (dim / self.device_pixel_ratio\n                        for dim in self._rubberband_rect)\n        x1 = x0 + w\n        y1 = y0 + h\n\n        # Draw the lines from x0, y0 towards x1, y1 so that the\n        # dashes don't \"jump\" when moving the zoom box.\n        ctx.move_to(x0, y0)\n        ctx.line_to(x0, y1)\n        ctx.move_to(x0, y0)\n        ctx.line_to(x1, y0)\n        ctx.move_to(x0, y1)\n        ctx.line_to(x1, y1)\n        ctx.move_to(x1, y0)\n        ctx.line_to(x1, y1)\n\n        ctx.set_antialias(1)\n        ctx.set_line_width(1)\n        ctx.set_dash((3, 3), 0)\n        ctx.set_source_rgb(0, 0, 0)\n        ctx.stroke_preserve()\n\n        ctx.set_dash((3, 3), 3)\n        ctx.set_source_rgb(1, 1, 1)\n        ctx.stroke()\n\n    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK3Agg or GTK3Cairo\n        pass\n\n    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()\n\n    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)\n\n    def flush_events(self):\n        # docstring inherited\n        context = GLib.MainContext.default()\n        while context.pending():\n            context.iteration(True)",
      "instance_attributes": [
        {
          "name": "_idle_draw_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_rubberband_rect",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3",
      "name": "FigureManagerGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3",
      "decorators": [],
      "superclasses": [
        "_FigureManagerGTK"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerGTK3(_FigureManagerGTK):\n    _toolbar2_class = NavigationToolbar2GTK3\n    _toolmanager_toolbar_class = ToolbarGTK3",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3",
      "name": "HelpGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK3)"
      ],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_normalize_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_is_valid_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_show_shortcuts_window",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_show_shortcuts_dialog",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpGTK3(backend_tools.ToolHelpBase):\n    def _normalize_shortcut(self, key):\n        \"\"\"\n        Convert Matplotlib key presses to GTK+ accelerator identifiers.\n\n        Related to `FigureCanvasGTK3._get_key`.\n        \"\"\"\n        special = {\n            'backspace': 'BackSpace',\n            'pagedown': 'Page_Down',\n            'pageup': 'Page_Up',\n            'scroll_lock': 'Scroll_Lock',\n        }\n\n        parts = key.split('+')\n        mods = ['<' + mod + '>' for mod in parts[:-1]]\n        key = parts[-1]\n\n        if key in special:\n            key = special[key]\n        elif len(key) > 1:\n            key = key.capitalize()\n        elif key.isupper():\n            mods += ['<shift>']\n\n        return ''.join(mods) + key\n\n    def _is_valid_shortcut(self, key):\n        \"\"\"\n        Check for a valid shortcut to be displayed.\n\n        - GTK will never send 'cmd+' (see `FigureCanvasGTK3._get_key`).\n        - The shortcut window only shows keyboard shortcuts, not mouse buttons.\n        \"\"\"\n        return 'cmd+' not in key and not key.startswith('MouseButton.')\n\n    def _show_shortcuts_window(self):\n        section = Gtk.ShortcutsSection()\n\n        for name, tool in sorted(self.toolmanager.tools.items()):\n            if not tool.description:\n                continue\n\n            # Putting everything in a separate group allows GTK to\n            # automatically split them into separate columns/pages, which is\n            # useful because we have lots of shortcuts, some with many keys\n            # that are very wide.\n            group = Gtk.ShortcutsGroup()\n            section.add(group)\n            # A hack to remove the title since we have no group naming.\n            group.forall(lambda widget, data: widget.set_visible(False), None)\n\n            shortcut = Gtk.ShortcutsShortcut(\n                accelerator=' '.join(\n                    self._normalize_shortcut(key)\n                    for key in self.toolmanager.get_tool_keymap(name)\n                    if self._is_valid_shortcut(key)),\n                title=tool.name,\n                subtitle=tool.description)\n            group.add(shortcut)\n\n        window = Gtk.ShortcutsWindow(\n            title='Help',\n            modal=True,\n            transient_for=self._figure.canvas.get_toplevel())\n        section.show()  # Must be done explicitly before add!\n        window.add(section)\n\n        window.show_all()\n\n    def _show_shortcuts_dialog(self):\n        dialog = Gtk.MessageDialog(\n            self._figure.canvas.get_toplevel(),\n            0, Gtk.MessageType.INFO, Gtk.ButtonsType.OK, self._get_help_text(),\n            title=\"Help\")\n        dialog.run()\n        dialog.destroy()\n\n    def trigger(self, *args):\n        if Gtk.check_version(3, 20, 0) is None:\n            self._show_shortcuts_window()\n        else:\n            self._show_shortcuts_dialog()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3",
      "name": "NavigationToolbar2GTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3",
      "decorators": [],
      "superclasses": [
        "_NavigationToolbar2GTK",
        "Gtk.Toolbar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2GTK3(_NavigationToolbar2GTK, Gtk.Toolbar):\n    @_api.delete_parameter(\"3.6\", \"window\")\n    def __init__(self, canvas, window=None):\n        self._win = window\n        GObject.GObject.__init__(self)\n\n        self.set_style(Gtk.ToolbarStyle.ICONS)\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.insert(Gtk.SeparatorToolItem(), -1)\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            self._gtk_ids[text] = button = (\n                Gtk.ToggleToolButton() if callback in ['zoom', 'pan'] else\n                Gtk.ToolButton())\n            button.set_label(text)\n            button.set_icon_widget(image)\n            # Save the handler id, so that we can block it as needed.\n            button._signal_handler = button.connect(\n                'clicked', getattr(self, callback))\n            button.set_tooltip_text(tooltip_text)\n            self.insert(button, -1)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        toolitem.set_expand(True)  # Push real message to the right.\n        toolitem.add(label)\n\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        self.message = Gtk.Label()\n        self.message.set_justify(Gtk.Justification.RIGHT)\n        toolitem.add(self.message)\n\n        self.show_all()\n\n        _NavigationToolbar2GTK.__init__(self, canvas)\n\n    win = _api.deprecated(\"3.6\")(property(lambda self: self._win))\n\n    def save_figure(self, *args):\n        dialog = Gtk.FileChooserDialog(\n            title=\"Save the figure\",\n            parent=self.canvas.get_toplevel(),\n            action=Gtk.FileChooserAction.SAVE,\n            buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,\n                     Gtk.STOCK_SAVE,   Gtk.ResponseType.OK),\n        )\n        for name, fmts \\\n                in self.canvas.get_supported_filetypes_grouped().items():\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(f'*.{fmt}')\n            dialog.add_filter(ff)\n            if self.canvas.get_default_filetype() in fmts:\n                dialog.set_filter(ff)\n\n        @functools.partial(dialog.connect, \"notify::filter\")\n        def on_notify_filter(*args):\n            name = dialog.get_filter().get_name()\n            fmt = self.canvas.get_supported_filetypes_grouped()[name][0]\n            dialog.set_current_name(\n                str(Path(dialog.get_current_name()).with_suffix(f'.{fmt}')))\n\n        dialog.set_current_folder(mpl.rcParams[\"savefig.directory\"])\n        dialog.set_current_name(self.canvas.get_default_filename())\n        dialog.set_do_overwrite_confirmation(True)\n\n        response = dialog.run()\n        fname = dialog.get_filename()\n        ff = dialog.get_filter()  # Doesn't autoadjust to filename :/\n        fmt = self.canvas.get_supported_filetypes_grouped()[ff.get_name()][0]\n        dialog.destroy()\n        if response != Gtk.ResponseType.OK:\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n        try:\n            self.canvas.figure.savefig(fname, format=fmt)\n        except Exception as e:\n            dialog = Gtk.MessageDialog(\n                parent=self.canvas.get_toplevel(), message_format=str(e),\n                type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK)\n            dialog.run()\n            dialog.destroy()",
      "instance_attributes": [
        {
          "name": "_win",
          "types": null
        },
        {
          "name": "_gtk_ids",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "message",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3",
      "name": "SaveFigureGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK3)"
      ],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureGTK3(backend_tools.SaveFigureBase):\n    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK3.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3",
      "name": "SetCursorGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3",
      "decorators": [
        "_api.deprecated('3.5', alternative='ToolSetCursor')"
      ],
      "superclasses": [
        "backend_tools.SetCursorBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SetCursorGTK3(backend_tools.SetCursorBase):\n    def set_cursor(self, cursor):\n        NavigationToolbar2GTK3.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3",
      "name": "ToolCopyToClipboardGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK3)"
      ],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardGTK3(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        window = self.canvas.get_window()\n        x, y, width, height = window.get_geometry()\n        pb = Gdk.pixbuf_get_from_window(window, x, y, width, height)\n        clipboard.set_image(pb)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3",
      "name": "ToolbarGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "Gtk.Box"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/_add_button",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/_call_tool",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/_add_separator",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarGTK3(ToolContainerBase, Gtk.Box):\n    _icon_extension = '-symbolic.svg'\n\n    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.pack_end(self._message, False, False, 0)\n        self.show_all()\n        self._groups = {}\n        self._toolitems = {}\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleToolButton()\n        else:\n            button = Gtk.ToolButton()\n        button.set_label(name)\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            button.set_icon_widget(image)\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        button.show_all()\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            toolbar = Gtk.Toolbar()\n            toolbar.set_style(Gtk.ToolbarStyle.ICONS)\n            self.pack_start(toolbar, False, False, 0)\n            toolbar.show_all()\n            self._groups[group] = toolbar\n        self._groups[group].insert(button, position)\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event(f'{name} not in toolbar', self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]\n\n    def _add_separator(self):\n        sep = Gtk.Separator()\n        sep.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self.pack_start(sep, False, True, 0)\n        sep.show_all()\n\n    def set_message(self, s):\n        self._message.set_label(s)",
      "instance_attributes": [
        {
          "name": "_message",
          "types": null
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_gtk3.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/__getattr__/cursord@getter"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    @_api.deprecated(\"3.5\", obj_type=\"\")\n    @property\n    def cursord(self):\n        try:\n            new_cursor = functools.partial(\n                Gdk.Cursor.new_from_name, Gdk.Display.get_default())\n            return {\n                Cursors.MOVE:          new_cursor(\"move\"),\n                Cursors.HAND:          new_cursor(\"pointer\"),\n                Cursors.POINTER:       new_cursor(\"default\"),\n                Cursors.SELECT_REGION: new_cursor(\"crosshair\"),\n                Cursors.WAIT:          new_cursor(\"wait\"),\n            }\n        except TypeError:\n            return {}\n\n    icon_filename = _api.deprecated(\"3.6\", obj_type=\"\")(property(\n        lambda self:\n        \"matplotlib.png\" if sys.platform == \"win32\" else \"matplotlib.svg\"))\n    window_icon = _api.deprecated(\"3.6\", obj_type=\"\")(property(\n        lambda self:\n        str(cbook._get_data_path(\"images\", __getattr__(\"icon_filename\")))))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg",
      "name": "FigureCanvasGTK3Agg",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg",
      "decorators": [],
      "superclasses": [
        "backend_agg.FigureCanvasAgg",
        "backend_gtk3.FigureCanvasGTK3"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK3Agg(backend_agg.FigureCanvasAgg,\n                          backend_gtk3.FigureCanvasGTK3):\n    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._bbox_queue = []\n\n    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        w = allocation.width * scale\n        h = allocation.height * scale\n\n        if not len(self._bbox_queue):\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            bbox_queue = [transforms.Bbox([[0, 0], [w, h]])]\n        else:\n            bbox_queue = self._bbox_queue\n\n        for bbox in bbox_queue:\n            x = int(bbox.x0)\n            y = h - int(bbox.y1)\n            width = int(bbox.x1) - int(bbox.x0)\n            height = int(bbox.y1) - int(bbox.y0)\n\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                np.asarray(self.copy_from_bbox(bbox)))\n            image = cairo.ImageSurface.create_for_data(\n                buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n            image.set_device_scale(scale, scale)\n            ctx.set_source_surface(image, x / scale, y / scale)\n            ctx.paint()\n\n        if len(self._bbox_queue):\n            self._bbox_queue = []\n\n        return False\n\n    def blit(self, bbox=None):\n        # If bbox is None, blit the entire canvas to gtk. Otherwise\n        # blit only the area defined by the bbox.\n        if bbox is None:\n            bbox = self.figure.bbox\n\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        x = int(bbox.x0 / scale)\n        y = allocation.height - int(bbox.y1 / scale)\n        width = (int(bbox.x1) - int(bbox.x0)) // scale\n        height = (int(bbox.y1) - int(bbox.y0)) // scale\n\n        self._bbox_queue.append(bbox)\n        self.queue_draw_area(x, y, width, height)",
      "instance_attributes": [
        {
          "name": "_bbox_queue",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureManagerGTK3Agg",
      "name": "FigureManagerGTK3Agg",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureManagerGTK3Agg",
      "decorators": [
        "_api.deprecated('3.6', alternative='backend_gtk3.FigureManagerGTK3')"
      ],
      "superclasses": [
        "backend_gtk3.FigureManagerGTK3"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerGTK3Agg(backend_gtk3.FigureManagerGTK3):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo",
      "name": "FigureCanvasGTK3Cairo",
      "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "FigureCanvasGTK3"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK3Cairo(FigureCanvasCairo, FigureCanvasGTK3):\n    def on_draw_event(self, widget, ctx):\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            scale = self.device_pixel_ratio\n            # Scale physical drawing to logical size.\n            ctx.scale(1 / scale, 1 / scale)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4",
      "name": "FigureCanvasGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase",
        "Gtk.DrawingArea"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/destroy",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_mpl_coords",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/leave_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_get_key",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_update_device_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_draw_func",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/_post_draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/flush_events"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK4(FigureCanvasBase, Gtk.DrawingArea):\n    required_interactive_framework = \"gtk4\"\n    supports_blit = False\n    _timer_cls = TimerGTK4\n    manager_class = _api.classproperty(lambda cls: FigureManagerGTK4)\n    _context_is_scaled = False\n\n    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self.set_hexpand(True)\n        self.set_vexpand(True)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.set_draw_func(self._draw_func)\n        self.connect('resize', self.resize_event)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n\n        click = Gtk.GestureClick()\n        click.set_button(0)  # All buttons.\n        click.connect('pressed', self.button_press_event)\n        click.connect('released', self.button_release_event)\n        self.add_controller(click)\n\n        key = Gtk.EventControllerKey()\n        key.connect('key-pressed', self.key_press_event)\n        key.connect('key-released', self.key_release_event)\n        self.add_controller(key)\n\n        motion = Gtk.EventControllerMotion()\n        motion.connect('motion', self.motion_notify_event)\n        motion.connect('enter', self.enter_notify_event)\n        motion.connect('leave', self.leave_notify_event)\n        self.add_controller(motion)\n\n        scroll = Gtk.EventControllerScroll.new(\n            Gtk.EventControllerScrollFlags.VERTICAL)\n        scroll.connect('scroll', self.scroll_event)\n        self.add_controller(scroll)\n\n        self.set_focusable(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")\n\n    def destroy(self):\n        self.close_event()\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        self.set_cursor_from_name(_backend_gtk.mpl_to_gtk_cursor_name(cursor))\n\n    def _mpl_coords(self, xy=None):\n        \"\"\"\n        Convert the *xy* position of a GTK event, or of the current cursor\n        position if *xy* is None, to Matplotlib coordinates.\n\n        GTK use logical pixels, but the figure is scaled to physical pixels for\n        rendering.  Transform to physical pixels so that all of the down-stream\n        transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        if xy is None:\n            surface = self.get_native().get_surface()\n            is_over, x, y, mask = surface.get_device_position(\n                self.get_display().get_default_seat().get_pointer())\n        else:\n            x, y = xy\n        x = x * self.device_pixel_ratio\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height - y * self.device_pixel_ratio\n        return x, y\n\n    def scroll_event(self, controller, dx, dy):\n        MouseEvent(\"scroll_event\", self,\n                   *self._mpl_coords(), step=dy)._process()\n        return True\n\n    def button_press_event(self, controller, n_press, x, y):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords((x, y)), controller.get_current_button()\n                   )._process()\n        self.grab_focus()\n\n    def button_release_event(self, controller, n_press, x, y):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords((x, y)), controller.get_current_button()\n                   )._process()\n\n    def key_press_event(self, controller, keyval, keycode, state):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(keyval, keycode, state), *self._mpl_coords()\n                 )._process()\n        return True\n\n    def key_release_event(self, controller, keyval, keycode, state):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(keyval, keycode, state), *self._mpl_coords()\n                 )._process()\n        return True\n\n    def motion_notify_event(self, controller, x, y):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._mpl_coords((x, y)))._process()\n\n    def leave_notify_event(self, controller):\n        LocationEvent(\"figure_leave_event\", self,\n                      *self._mpl_coords())._process()\n\n    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._mpl_coords((x, y)))._process()\n\n    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()\n\n    def _get_key(self, keyval, keycode, state):\n        unikey = chr(Gdk.keyval_to_unicode(keyval))\n        key = cbook._unikey_or_keysym_to_mplkey(\n            unikey,\n            Gdk.keyval_name(keyval))\n        modifiers = [\n            (Gdk.ModifierType.CONTROL_MASK, 'ctrl'),\n            (Gdk.ModifierType.ALT_MASK, 'alt'),\n            (Gdk.ModifierType.SHIFT_MASK, 'shift'),\n            (Gdk.ModifierType.SUPER_MASK, 'super'),\n        ]\n        for key_mask, prefix in modifiers:\n            if state & key_mask:\n                if not (prefix == 'shift' and unikey.isprintable()):\n                    key = f'{prefix}+{key}'\n        return key\n\n    def _update_device_pixel_ratio(self, *args, **kwargs):\n        # We need to be careful in cases with mixed resolution displays if\n        # device_pixel_ratio changes.\n        if self._set_device_pixel_ratio(self.get_scale_factor()):\n            self.draw()\n\n    def _draw_rubberband(self, rect):\n        self._rubberband_rect = rect\n        # TODO: Only update the rubberband area.\n        self.queue_draw()\n\n    def _draw_func(self, drawing_area, ctx, width, height):\n        self.on_draw_event(self, ctx)\n        self._post_draw(self, ctx)\n\n    def _post_draw(self, widget, ctx):\n        if self._rubberband_rect is None:\n            return\n\n        lw = 1\n        dash = 3\n        if not self._context_is_scaled:\n            x0, y0, w, h = (dim / self.device_pixel_ratio\n                            for dim in self._rubberband_rect)\n        else:\n            x0, y0, w, h = self._rubberband_rect\n            lw *= self.device_pixel_ratio\n            dash *= self.device_pixel_ratio\n        x1 = x0 + w\n        y1 = y0 + h\n\n        # Draw the lines from x0, y0 towards x1, y1 so that the\n        # dashes don't \"jump\" when moving the zoom box.\n        ctx.move_to(x0, y0)\n        ctx.line_to(x0, y1)\n        ctx.move_to(x0, y0)\n        ctx.line_to(x1, y0)\n        ctx.move_to(x0, y1)\n        ctx.line_to(x1, y1)\n        ctx.move_to(x1, y0)\n        ctx.line_to(x1, y1)\n\n        ctx.set_antialias(1)\n        ctx.set_line_width(lw)\n        ctx.set_dash((dash, dash), 0)\n        ctx.set_source_rgb(0, 0, 0)\n        ctx.stroke_preserve()\n\n        ctx.set_dash((dash, dash), dash)\n        ctx.set_source_rgb(1, 1, 1)\n        ctx.stroke()\n\n    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK4Agg or GTK4Cairo\n        pass\n\n    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()\n\n    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)\n\n    def flush_events(self):\n        # docstring inherited\n        context = GLib.MainContext.default()\n        while context.pending():\n            context.iteration(True)",
      "instance_attributes": [
        {
          "name": "_idle_draw_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_rubberband_rect",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureManagerGTK4",
      "name": "FigureManagerGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureManagerGTK4",
      "decorators": [],
      "superclasses": [
        "_FigureManagerGTK"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerGTK4(_FigureManagerGTK):\n    _toolbar2_class = NavigationToolbar2GTK4\n    _toolmanager_toolbar_class = ToolbarGTK4",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4",
      "name": "HelpGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.HelpGTK4",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK4)"
      ],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/_normalize_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/_is_valid_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpGTK4(backend_tools.ToolHelpBase):\n    def _normalize_shortcut(self, key):\n        \"\"\"\n        Convert Matplotlib key presses to GTK+ accelerator identifiers.\n\n        Related to `FigureCanvasGTK4._get_key`.\n        \"\"\"\n        special = {\n            'backspace': 'BackSpace',\n            'pagedown': 'Page_Down',\n            'pageup': 'Page_Up',\n            'scroll_lock': 'Scroll_Lock',\n        }\n\n        parts = key.split('+')\n        mods = ['<' + mod + '>' for mod in parts[:-1]]\n        key = parts[-1]\n\n        if key in special:\n            key = special[key]\n        elif len(key) > 1:\n            key = key.capitalize()\n        elif key.isupper():\n            mods += ['<shift>']\n\n        return ''.join(mods) + key\n\n    def _is_valid_shortcut(self, key):\n        \"\"\"\n        Check for a valid shortcut to be displayed.\n\n        - GTK will never send 'cmd+' (see `FigureCanvasGTK4._get_key`).\n        - The shortcut window only shows keyboard shortcuts, not mouse buttons.\n        \"\"\"\n        return 'cmd+' not in key and not key.startswith('MouseButton.')\n\n    def trigger(self, *args):\n        section = Gtk.ShortcutsSection()\n\n        for name, tool in sorted(self.toolmanager.tools.items()):\n            if not tool.description:\n                continue\n\n            # Putting everything in a separate group allows GTK to\n            # automatically split them into separate columns/pages, which is\n            # useful because we have lots of shortcuts, some with many keys\n            # that are very wide.\n            group = Gtk.ShortcutsGroup()\n            section.append(group)\n            # A hack to remove the title since we have no group naming.\n            child = group.get_first_child()\n            while child is not None:\n                child.set_visible(False)\n                child = child.get_next_sibling()\n\n            shortcut = Gtk.ShortcutsShortcut(\n                accelerator=' '.join(\n                    self._normalize_shortcut(key)\n                    for key in self.toolmanager.get_tool_keymap(name)\n                    if self._is_valid_shortcut(key)),\n                title=tool.name,\n                subtitle=tool.description)\n            group.append(shortcut)\n\n        window = Gtk.ShortcutsWindow(\n            title='Help',\n            modal=True,\n            transient_for=self._figure.canvas.get_root())\n        window.set_child(section)\n\n        window.show()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4",
      "name": "NavigationToolbar2GTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4",
      "decorators": [],
      "superclasses": [
        "_NavigationToolbar2GTK",
        "Gtk.Box"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/save_figure"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2GTK4(_NavigationToolbar2GTK, Gtk.Box):\n    @_api.delete_parameter(\"3.6\", \"window\")\n    def __init__(self, canvas, window=None):\n        self._win = window\n        Gtk.Box.__init__(self)\n\n        self.add_css_class('toolbar')\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.append(Gtk.Separator())\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))))\n            self._gtk_ids[text] = button = (\n                Gtk.ToggleButton() if callback in ['zoom', 'pan'] else\n                Gtk.Button())\n            button.set_child(image)\n            button.add_css_class('flat')\n            button.add_css_class('image-button')\n            # Save the handler id, so that we can block it as needed.\n            button._signal_handler = button.connect(\n                'clicked', getattr(self, callback))\n            button.set_tooltip_text(tooltip_text)\n            self.append(button)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self.message = Gtk.Label()\n        self.message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self.message)\n\n        _NavigationToolbar2GTK.__init__(self, canvas)\n\n    win = _api.deprecated(\"3.6\")(property(lambda self: self._win))\n\n    def save_figure(self, *args):\n        dialog = Gtk.FileChooserNative(\n            title='Save the figure',\n            transient_for=self.canvas.get_root(),\n            action=Gtk.FileChooserAction.SAVE,\n            modal=True)\n        self._save_dialog = dialog  # Must keep a reference.\n\n        ff = Gtk.FileFilter()\n        ff.set_name('All files')\n        ff.add_pattern('*')\n        dialog.add_filter(ff)\n        dialog.set_filter(ff)\n\n        formats = []\n        default_format = None\n        for i, (name, fmts) in enumerate(\n                self.canvas.get_supported_filetypes_grouped().items()):\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(f'*.{fmt}')\n            dialog.add_filter(ff)\n            formats.append(name)\n            if self.canvas.get_default_filetype() in fmts:\n                default_format = i\n        # Setting the choice doesn't always work, so make sure the default\n        # format is first.\n        formats = [formats[default_format], *formats[:default_format],\n                   *formats[default_format+1:]]\n        dialog.add_choice('format', 'File format', formats, formats)\n        dialog.set_choice('format', formats[default_format])\n\n        dialog.set_current_folder(Gio.File.new_for_path(\n            os.path.expanduser(mpl.rcParams['savefig.directory'])))\n        dialog.set_current_name(self.canvas.get_default_filename())\n\n        @functools.partial(dialog.connect, 'response')\n        def on_response(dialog, response):\n            file = dialog.get_file()\n            fmt = dialog.get_choice('format')\n            fmt = self.canvas.get_supported_filetypes_grouped()[fmt][0]\n            dialog.destroy()\n            self._save_dialog = None\n            if response != Gtk.ResponseType.ACCEPT:\n                return\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams['savefig.directory']:\n                parent = file.get_parent()\n                mpl.rcParams['savefig.directory'] = parent.get_path()\n            try:\n                self.canvas.figure.savefig(file.get_path(), format=fmt)\n            except Exception as e:\n                msg = Gtk.MessageDialog(\n                    transient_for=self.canvas.get_root(),\n                    message_type=Gtk.MessageType.ERROR,\n                    buttons=Gtk.ButtonsType.OK, modal=True,\n                    text=str(e))\n                msg.show()\n\n        dialog.show()",
      "instance_attributes": [
        {
          "name": "_win",
          "types": null
        },
        {
          "name": "_gtk_ids",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "message",
          "types": null
        },
        {
          "name": "_save_dialog",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4",
      "name": "SaveFigureGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK4)"
      ],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureGTK4(backend_tools.SaveFigureBase):\n    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK4.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4",
      "name": "ToolCopyToClipboardGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasGTK4)"
      ],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardGTK4(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        with io.BytesIO() as f:\n            self.canvas.print_rgba(f)\n            w, h = self.canvas.get_width_height()\n            pb = GdkPixbuf.Pixbuf.new_from_data(f.getbuffer(),\n                                                GdkPixbuf.Colorspace.RGB, True,\n                                                8, w, h, w*4)\n        clipboard = self.canvas.get_clipboard()\n        clipboard.set(pb)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4",
      "name": "ToolbarGTK4",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "Gtk.Box"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/_find_child_at_position",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/_add_button",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/_call_tool",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/_add_separator",
        "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarGTK4(ToolContainerBase, Gtk.Box):\n    _icon_extension = '-symbolic.svg'\n\n    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n\n        # Tool items are created later, but must appear before the message.\n        self._tool_box = Gtk.Box()\n        self.append(self._tool_box)\n        self._groups = {}\n        self._toolitems = {}\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self._message)\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleButton()\n        else:\n            button = Gtk.Button()\n        button.set_label(name)\n        button.add_css_class('flat')\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file))\n            button.set_child(image)\n            button.add_css_class('image-button')\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))\n\n    def _find_child_at_position(self, group, position):\n        children = [None]\n        child = self._groups[group].get_first_child()\n        while child is not None:\n            children.append(child)\n            child = child.get_next_sibling()\n        return children[position]\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            group_box = Gtk.Box()\n            self._tool_box.append(group_box)\n            self._groups[group] = group_box\n        self._groups[group].insert_child_after(\n            button, self._find_child_at_position(group, position))\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event(f'{name} not in toolbar', self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]\n\n    def _add_separator(self):\n        sep = Gtk.Separator()\n        sep.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self._tool_box.append(sep)\n\n    def set_message(self, s):\n        self._message.set_label(s)",
      "instance_attributes": [
        {
          "name": "_tool_box",
          "types": null
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_message",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg",
      "name": "FigureCanvasGTK4Agg",
      "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg",
      "decorators": [],
      "superclasses": [
        "backend_agg.FigureCanvasAgg",
        "backend_gtk4.FigureCanvasGTK4"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK4Agg(backend_agg.FigureCanvasAgg,\n                          backend_gtk4.FigureCanvasGTK4):\n\n    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n\n        Gtk.render_background(\n            self.get_style_context(), ctx,\n            allocation.x, allocation.y,\n            allocation.width, allocation.height)\n\n        buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n            np.asarray(self.get_renderer().buffer_rgba()))\n        height, width, _ = buf.shape\n        image = cairo.ImageSurface.create_for_data(\n            buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n        image.set_device_scale(scale, scale)\n        ctx.set_source_surface(image, 0, 0)\n        ctx.paint()\n\n        return False",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureManagerGTK4Agg",
      "name": "FigureManagerGTK4Agg",
      "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureManagerGTK4Agg",
      "decorators": [
        "_api.deprecated('3.6', alternative='backend_gtk4.FigureManagerGTK4')"
      ],
      "superclasses": [
        "backend_gtk4.FigureManagerGTK4"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerGTK4Agg(backend_gtk4.FigureManagerGTK4):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo",
      "name": "FigureCanvasGTK4Cairo",
      "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "FigureCanvasGTK4"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK4Cairo(FigureCanvasCairo, FigureCanvasGTK4):\n    _context_is_scaled = True\n\n    def on_draw_event(self, widget, ctx):\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            scale = self.device_pixel_ratio\n            # Scale physical drawing to logical size.\n            ctx.scale(1 / scale, 1 / scale)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac",
      "name": "FigureCanvasMac",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "_macosx.FigureCanvas",
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/_single_shot_timer",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/_draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n    # docstring inherited\n\n    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n    # class also inheriting from FCBase (this is the approach with other GUI\n    # toolkits).  However, writing an extension type inheriting from a Python\n    # base class is slightly tricky (the extension type must be a heap type),\n    # and we can just as well lift the FCBase base up one level, keeping it *at\n    # the end* to have the right method resolution order.\n\n    # Events such as button presses, mouse movements, and key presses are\n    # handled in C and events (MouseEvent, etc.) are triggered from there.\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n\n    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._draw_pending = False\n        self._is_drawing = False\n\n    def draw(self):\n        \"\"\"Render the figure and update the macosx canvas.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()\n\n    def draw_idle(self):\n        # docstring inherited\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            # Add a singleshot timer to the eventloop that will call back\n            # into the Python method _draw_idle to take care of the draw\n            self._single_shot_timer(self._draw_idle)\n\n    def _single_shot_timer(self, callback):\n        \"\"\"Add a single shot timer with the given callback\"\"\"\n        # We need to explicitly stop (called from delete) the timer after\n        # firing, otherwise segfaults will occur when trying to deallocate\n        # the singleshot timers.\n        def callback_func(callback, timer):\n            callback()\n            del timer\n        timer = self.new_timer(interval=0)\n        timer.add_callback(callback_func, callback, timer)\n        timer.start()\n\n    def _draw_idle(self):\n        \"\"\"\n        Draw method for singleshot timer\n\n        This draw method can be added to a singleshot timer, which can\n        accumulate draws while the eventloop is spinning. This method will\n        then only draw the first time and short-circuit the others.\n        \"\"\"\n        with self._idle_draw_cntx():\n            if not self._draw_pending:\n                # Short-circuit because our draw request has already been\n                # taken care of\n                return\n            self._draw_pending = False\n            self.draw()\n\n    def blit(self, bbox=None):\n        # docstring inherited\n        super().blit(bbox)\n        self.update()\n\n    def resize(self, width, height):\n        # Size from macOS is logical pixels, dpi is physical.\n        scale = self.figure.dpi / self.device_pixel_ratio\n        width /= scale\n        height /= scale\n        self.figure.set_size_inches(width, height, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()",
      "instance_attributes": [
        {
          "name": "_draw_pending",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_is_drawing",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac",
      "name": "FigureManagerMac",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac",
      "decorators": [],
      "superclasses": [
        "_macosx.FigureManager",
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/_close_button_pressed",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/close",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/show"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerMac(_macosx.FigureManager, FigureManagerBase):\n    _toolbar2_class = NavigationToolbar2Mac\n\n    def __init__(self, canvas, num):\n        self._shown = False\n        _macosx.FigureManager.__init__(self, canvas)\n        icon_path = str(cbook._get_data_path('images/matplotlib.pdf'))\n        _macosx.FigureManager.set_icon(icon_path)\n        FigureManagerBase.__init__(self, canvas, num)\n        if self.toolbar is not None:\n            self.toolbar.update()\n        if mpl.is_interactive():\n            self.show()\n            self.canvas.draw_idle()\n\n    def _close_button_pressed(self):\n        Gcf.destroy(self)\n        self.canvas.flush_events()\n\n    @_api.deprecated(\"3.6\")\n    def close(self):\n        return self._close_button_pressed()\n\n    def show(self):\n        if not self._shown:\n            self._show()\n            self._shown = True\n        if mpl.rcParams[\"figure.raise_window\"]:\n            self._raise()",
      "instance_attributes": [
        {
          "name": "_shown",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac",
      "name": "NavigationToolbar2Mac",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac",
      "decorators": [],
      "superclasses": [
        "_macosx.NavigationToolbar2",
        "NavigationToolbar2"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/prepare_configure_subplots"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2Mac(_macosx.NavigationToolbar2, NavigationToolbar2):\n\n    def __init__(self, canvas):\n        data_path = cbook._get_data_path('images')\n        _, tooltips, image_names, _ = zip(*NavigationToolbar2.toolitems)\n        _macosx.NavigationToolbar2.__init__(\n            self, canvas,\n            tuple(str(data_path / image_name) + \".pdf\"\n                  for image_name in image_names if image_name is not None),\n            tuple(tooltip for tooltip in tooltips if tooltip is not None))\n        NavigationToolbar2.__init__(self, canvas)\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.set_rubberband(int(x0), int(y0), int(x1), int(y1))\n\n    def remove_rubberband(self):\n        self.canvas.remove_rubberband()\n\n    def save_figure(self, *args):\n        directory = os.path.expanduser(mpl.rcParams['savefig.directory'])\n        filename = _macosx.choose_save_file('Save the figure',\n                                            directory,\n                                            self.canvas.get_default_filename())\n        if filename is None:  # Cancel\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(filename)\n        self.canvas.figure.savefig(filename)\n\n    @_api.deprecated(\"3.6\", alternative='configure_subplots()')\n    def prepare_configure_subplots(self):\n        toolfig = Figure(figsize=(6, 3))\n        canvas = FigureCanvasMac(toolfig)\n        toolfig.subplots_adjust(top=0.9)\n        # Need to keep a reference to the tool.\n        _tool = SubplotTool(self.canvas.figure, toolfig)\n        return canvas",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/TimerMac",
      "name": "TimerMac",
      "qname": "lib.matplotlib.backends.backend_macosx.TimerMac",
      "decorators": [],
      "superclasses": [
        "_macosx.Timer",
        "TimerBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using CFRunLoop timer events.",
      "docstring": "Subclass of `.TimerBase` using CFRunLoop timer events.",
      "code": "class TimerMac(_macosx.Timer, TimerBase):\n    \"\"\"Subclass of `.TimerBase` using CFRunLoop timer events.\"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer",
      "name": "MixedModeRenderer",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__",
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__",
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/start_rasterizing",
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/stop_rasterizing"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper class to implement a renderer that switches between\nvector and raster drawing.  An example may be a PDF writer, where\nmost things are drawn with PDF vector commands, but some very\ncomplex objects, such as quad meshes, are rasterised and then\noutput as images.",
      "docstring": "A helper class to implement a renderer that switches between\nvector and raster drawing.  An example may be a PDF writer, where\nmost things are drawn with PDF vector commands, but some very\ncomplex objects, such as quad meshes, are rasterised and then\noutput as images.",
      "code": "class MixedModeRenderer:\n    \"\"\"\n    A helper class to implement a renderer that switches between\n    vector and raster drawing.  An example may be a PDF writer, where\n    most things are drawn with PDF vector commands, but some very\n    complex objects, such as quad meshes, are rasterised and then\n    output as images.\n    \"\"\"\n    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        Parameters\n        ----------\n        figure : `matplotlib.figure.Figure`\n            The figure instance.\n        width : scalar\n            The width of the canvas in logical units\n        height : scalar\n            The height of the canvas in logical units\n        dpi : float\n            The dpi of the canvas\n        vector_renderer : `matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n        raster_renderer_class : `matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.dpi\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer\n\n    def __getattr__(self, attr):\n        # Proxy everything that hasn't been overridden to the base\n        # renderer. Things that *are* overridden can call methods\n        # on self._renderer directly, but must not cache/store\n        # methods (because things like RendererAgg change their\n        # methods on the fly in order to optimise proxying down\n        # to the underlying C implementation).\n        return getattr(self._renderer, attr)\n\n    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        `stop_rasterizing` is called) will be drawn with the raster backend.\n        \"\"\"\n        # change the dpi of the figure temporarily.\n        self.figure.dpi = self.dpi\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore)\n            self._bbox_inches_restore = r\n\n        self._raster_renderer = self._raster_renderer_class(\n            self._width*self.dpi, self._height*self.dpi, self.dpi)\n        self._renderer = self._raster_renderer\n\n    def stop_rasterizing(self):\n        \"\"\"\n        Exit \"raster\" mode.  All of the drawing that was done since\n        the last `start_rasterizing` call will be copied to the\n        vector backend by calling draw_image.\n        \"\"\"\n\n        self._renderer = self._vector_renderer\n\n        height = self._height * self.dpi\n        img = np.asarray(self._raster_renderer.buffer_rgba())\n        slice_y, slice_x = cbook._get_nonzero_slices(img[..., 3])\n        cropped_img = img[slice_y, slice_x]\n        if cropped_img.size:\n            gc = self._renderer.new_gc()\n            # TODO: If the mixedmode resolution differs from the figure's\n            #       dpi, the image must be scaled (dpi->_figdpi). Not all\n            #       backends support this.\n            self._renderer.draw_image(\n                gc,\n                slice_x.start * self._figdpi / self.dpi,\n                (height - slice_y.stop) * self._figdpi / self.dpi,\n                cropped_img[::-1])\n        self._raster_renderer = None\n\n        # restore the figure dpi.\n        self.figure.dpi = self._figdpi\n\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore,\n                                               self._figdpi)\n            self._bbox_inches_restore = r",
      "instance_attributes": [
        {
          "name": "_raster_renderer_class",
          "types": {
            "kind": "NamedType",
            "name": "type"
          }
        },
        {
          "name": "_width",
          "types": null
        },
        {
          "name": "_height",
          "types": null
        },
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "_vector_renderer",
          "types": null
        },
        {
          "name": "_raster_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererAgg"
          }
        },
        {
          "name": "figure",
          "types": null
        },
        {
          "name": "_figdpi",
          "types": null
        },
        {
          "name": "_bbox_inches_restore",
          "types": null
        },
        {
          "name": "_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererAgg"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket",
      "name": "CommSocket",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/is_open",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_close",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Manages the Comm connection between IPython and the browser (client).\n\nComms are 2 way, with the CommSocket being able to publish a message\nvia the send_json method, and handle a message with on_message. On the\nJS side figure.send_message and figure.ws.onmessage do the sending and\nreceiving respectively.",
      "docstring": "Manages the Comm connection between IPython and the browser (client).\n\nComms are 2 way, with the CommSocket being able to publish a message\nvia the send_json method, and handle a message with on_message. On the\nJS side figure.send_message and figure.ws.onmessage do the sending and\nreceiving respectively.",
      "code": "class CommSocket:\n    \"\"\"\n    Manages the Comm connection between IPython and the browser (client).\n\n    Comms are 2 way, with the CommSocket being able to publish a message\n    via the send_json method, and handle a message with on_message. On the\n    JS side figure.send_message and figure.ws.onmessage do the sending and\n    receiving respectively.\n\n    \"\"\"\n    def __init__(self, manager):\n        self.supports_binary = None\n        self.manager = manager\n        self.uuid = str(uuid.uuid4())\n        # Publish an output area with a unique ID. The javascript can then\n        # hook into this area.\n        display(HTML(\"<div id=%r></div>\" % self.uuid))\n        try:\n            self.comm = Comm('matplotlib', data={'id': self.uuid})\n        except AttributeError as err:\n            raise RuntimeError('Unable to create an IPython notebook Comm '\n                               'instance. Are you in the IPython '\n                               'notebook?') from err\n        self.comm.on_msg(self.on_message)\n\n        manager = self.manager\n        self._ext_close = False\n\n        def _on_close(close_message):\n            self._ext_close = True\n            manager.remove_comm(close_message['content']['comm_id'])\n            manager.clearup_closed()\n\n        self.comm.on_close(_on_close)\n\n    def is_open(self):\n        return not (self._ext_close or self.comm._closed)\n\n    def on_close(self):\n        # When the socket is closed, deregister the websocket with\n        # the FigureManager.\n        if self.is_open():\n            try:\n                self.comm.close()\n            except KeyError:\n                # apparently already cleaned it up?\n                pass\n\n    def send_json(self, content):\n        self.comm.send({'data': json.dumps(content)})\n\n    def send_binary(self, blob):\n        if self.supports_binary:\n            self.comm.send({'blob': 'image/png'}, buffers=[blob])\n        else:\n            # The comm is ASCII, so we send the image in base64 encoded data\n            # URL form.\n            data = b64encode(blob).decode('ascii')\n            data_uri = \"data:image/png;base64,{0}\".format(data)\n            self.comm.send({'data': data_uri})\n\n    def on_message(self, message):\n        # The 'supports_binary' message is relevant to the\n        # websocket itself.  The other messages get passed along\n        # to matplotlib as-is.\n\n        # Every message has a \"type\" and a \"figure_id\".\n        message = json.loads(message['content']['data'])\n        if message['type'] == 'closing':\n            self.on_close()\n            self.manager.clearup_closed()\n        elif message['type'] == 'supports_binary':\n            self.supports_binary = message['value']\n        else:\n            self.manager.handle_json(message)",
      "instance_attributes": [
        {
          "name": "supports_binary",
          "types": null
        },
        {
          "name": "manager",
          "types": null
        },
        {
          "name": "uuid",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "comm",
          "types": {
            "kind": "NamedType",
            "name": "Comm"
          }
        },
        {
          "name": "_ext_close",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureCanvasNbAgg",
      "name": "FigureCanvasNbAgg",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureCanvasNbAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasWebAggCore"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasNbAgg(FigureCanvasWebAggCore):\n    manager_class = FigureManagerNbAgg",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg",
      "name": "FigureManagerNbAgg",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg",
      "decorators": [],
      "superclasses": [
        "FigureManagerWebAgg"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/display_js",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/show",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/reshow",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/connected@getter",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/_create_comm",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/destroy",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/clearup_closed",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerNbAgg(FigureManagerWebAgg):\n    _toolbar2_class = ToolbarCls = NavigationIPy\n\n    def __init__(self, canvas, num):\n        self._shown = False\n        super().__init__(canvas, num)\n\n    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        canvas = canvas_class(figure)\n        manager = cls(canvas, num)\n        if is_interactive():\n            manager.show()\n            canvas.draw_idle()\n\n        def destroy(event):\n            canvas.mpl_disconnect(cid)\n            Gcf.destroy(manager)\n\n        cid = canvas.mpl_connect('close_event', destroy)\n        return manager\n\n    def display_js(self):\n        # XXX How to do this just once? It has to deal with multiple\n        # browser instances using the same kernel (require.js - but the\n        # file isn't static?).\n        display(Javascript(FigureManagerNbAgg.get_javascript()))\n\n    def show(self):\n        if not self._shown:\n            self.display_js()\n            self._create_comm()\n        else:\n            self.canvas.draw_idle()\n        self._shown = True\n        # plt.figure adds an event which makes the figure in focus the active\n        # one. Disable this behaviour, as it results in figures being put as\n        # the active figure after they have been shown, even in non-interactive\n        # mode.\n        if hasattr(self, '_cidgcf'):\n            self.canvas.mpl_disconnect(self._cidgcf)\n        if not is_interactive():\n            from matplotlib._pylab_helpers import Gcf\n            Gcf.figs.pop(self.num, None)\n\n    def reshow(self):\n        \"\"\"\n        A special method to re-show the figure in the notebook.\n\n        \"\"\"\n        self._shown = False\n        self.show()\n\n    @property\n    def connected(self):\n        return bool(self.web_sockets)\n\n    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = io.StringIO()\n        else:\n            output = stream\n        super().get_javascript(stream=output)\n        output.write((pathlib.Path(__file__).parent\n                      / \"web_backend/js/nbagg_mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n        if stream is None:\n            return output.getvalue()\n\n    def _create_comm(self):\n        comm = CommSocket(self)\n        self.add_web_socket(comm)\n        return comm\n\n    def destroy(self):\n        self._send_event('close')\n        # need to copy comms as callbacks will modify this list\n        for comm in list(self.web_sockets):\n            comm.on_close()\n        self.clearup_closed()\n\n    def clearup_closed(self):\n        \"\"\"Clear up any closed Comms.\"\"\"\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.is_open()}\n\n        if len(self.web_sockets) == 0:\n            self.canvas.close_event()\n\n    def remove_comm(self, comm_id):\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.comm.comm_id != comm_id}",
      "instance_attributes": [
        {
          "name": "_shown",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "web_sockets",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/NavigationIPy",
      "name": "NavigationIPy",
      "qname": "lib.matplotlib.backends.backend_nbagg.NavigationIPy",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2WebAgg"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationIPy(NavigationToolbar2WebAgg):\n\n    # Use the standard toolbar items + download button\n    toolitems = [(text, tooltip_text,\n                  _FONT_AWESOME_CLASSES[image_file], name_of_method)\n                 for text, tooltip_text, image_file, name_of_method\n                 in (NavigationToolbar2.toolitems +\n                     (('Download', 'Download plot', 'download', 'download'),))\n                 if image_file in _FONT_AWESOME_CLASSES]",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf",
      "name": "FigureCanvasPdf",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf",
        "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasPdf(FigureCanvasBase):\n    # docstring inherited\n\n    fixed_dpi = 72\n    filetypes = {'pdf': 'Portable Document Format'}\n\n    def get_default_filetype(self):\n        return 'pdf'\n\n    def print_pdf(self, filename, *,\n                  bbox_inches_restore=None, metadata=None):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # there are 72 pdf points to an inch\n        width, height = self.figure.get_size_inches()\n        if isinstance(filename, PdfPages):\n            file = filename._file\n        else:\n            file = PdfFile(filename, metadata=metadata)\n        try:\n            file.newPage(width, height)\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererPdf(file, dpi, height, width),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n            if not isinstance(filename, PdfPages):\n                file.finalize()\n        finally:\n            if isinstance(filename, PdfPages):  # finish off this page\n                file.endStream()\n            else:            # we opened the file above; now finish it off\n                file.close()\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf",
      "name": "GraphicsContextPdf",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/stroke",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/paint",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/push",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/pop",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/finalize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class GraphicsContextPdf(GraphicsContextBase):\n\n    def __init__(self, file):\n        super().__init__()\n        self._fillcolor = (0.0, 0.0, 0.0)\n        self._effective_alphas = (1.0, 1.0)\n        self.file = file\n        self.parent = None\n\n    def __repr__(self):\n        d = dict(self.__dict__)\n        del d['file']\n        del d['parent']\n        return repr(d)\n\n    def stroke(self):\n        \"\"\"\n        Predicate: does the path need to be stroked (its outline drawn)?\n        This tests for the various conditions that disable stroking\n        the path, in which case it would presumably be filled.\n        \"\"\"\n        # _linewidth > 0: in pdf a line of width 0 is drawn at minimum\n        #   possible device width, but e.g., agg doesn't draw at all\n        return (self._linewidth > 0 and self._alpha > 0 and\n                (len(self._rgb) <= 3 or self._rgb[3] != 0.0))\n\n    def fill(self, *args):\n        \"\"\"\n        Predicate: does the path need to be filled?\n\n        An optional argument can be used to specify an alternative\n        _fillcolor, as needed by RendererPdf.draw_markers.\n        \"\"\"\n        if len(args):\n            _fillcolor = args[0]\n        else:\n            _fillcolor = self._fillcolor\n        return (self._hatch or\n                (_fillcolor is not None and\n                 (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))\n\n    def paint(self):\n        \"\"\"\n        Return the appropriate pdf operator to cause the path to be\n        stroked, filled, or both.\n        \"\"\"\n        return Op.paint_path(self.fill(), self.stroke())\n\n    capstyles = {'butt': 0, 'round': 1, 'projecting': 2}\n    joinstyles = {'miter': 0, 'round': 1, 'bevel': 2}\n\n    def capstyle_cmd(self, style):\n        return [self.capstyles[style], Op.setlinecap]\n\n    def joinstyle_cmd(self, style):\n        return [self.joinstyles[style], Op.setlinejoin]\n\n    def linewidth_cmd(self, width):\n        return [width, Op.setlinewidth]\n\n    def dash_cmd(self, dashes):\n        offset, dash = dashes\n        if dash is None:\n            dash = []\n            offset = 0\n        return [list(dash), offset, Op.setdash]\n\n    def alpha_cmd(self, alpha, forced, effective_alphas):\n        name = self.file.alphaState(effective_alphas)\n        return [name, Op.setgstate]\n\n    def hatch_cmd(self, hatch, hatch_color):\n        if not hatch:\n            if self._fillcolor is not None:\n                return self.fillcolor_cmd(self._fillcolor)\n            else:\n                return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]\n        else:\n            hatch_style = (hatch_color, self._fillcolor, hatch)\n            name = self.file.hatchPattern(hatch_style)\n            return [Name('Pattern'), Op.setcolorspace_nonstroke,\n                    name, Op.setcolor_nonstroke]\n\n    def rgb_cmd(self, rgb):\n        if mpl.rcParams['pdf.inheritcolor']:\n            return []\n        if rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_stroke]\n        else:\n            return [*rgb[:3], Op.setrgb_stroke]\n\n    def fillcolor_cmd(self, rgb):\n        if rgb is None or mpl.rcParams['pdf.inheritcolor']:\n            return []\n        elif rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_nonstroke]\n        else:\n            return [*rgb[:3], Op.setrgb_nonstroke]\n\n    def push(self):\n        parent = GraphicsContextPdf(self.file)\n        parent.copy_properties(self)\n        parent.parent = self.parent\n        self.parent = parent\n        return [Op.gsave]\n\n    def pop(self):\n        assert self.parent is not None\n        self.copy_properties(self.parent)\n        self.parent = self.parent.parent\n        return [Op.grestore]\n\n    def clip_cmd(self, cliprect, clippath):\n        \"\"\"Set clip rectangle. Calls `.pop()` and `.push()`.\"\"\"\n        cmds = []\n        # Pop graphics state until we hit the right one or the stack is empty\n        while ((self._cliprect, self._clippath) != (cliprect, clippath)\n                and self.parent is not None):\n            cmds.extend(self.pop())\n        # Unless we hit the right one, set the clip polygon\n        if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n                self.parent is None):\n            cmds.extend(self.push())\n            if self._cliprect != cliprect:\n                cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n            if self._clippath != clippath:\n                path, affine = clippath.get_transformed_path_and_affine()\n                cmds.extend(\n                    PdfFile.pathOperations(path, affine, simplify=False) +\n                    [Op.clip, Op.endpath])\n        return cmds\n\n    commands = (\n        # must come first since may pop\n        (('_cliprect', '_clippath'), clip_cmd),\n        (('_alpha', '_forced_alpha', '_effective_alphas'), alpha_cmd),\n        (('_capstyle',), capstyle_cmd),\n        (('_fillcolor',), fillcolor_cmd),\n        (('_joinstyle',), joinstyle_cmd),\n        (('_linewidth',), linewidth_cmd),\n        (('_dashes',), dash_cmd),\n        (('_rgb',), rgb_cmd),\n        # must come after fillcolor and rgb\n        (('_hatch', '_hatch_color'), hatch_cmd),\n        )\n\n    def delta(self, other):\n        \"\"\"\n        Copy properties of other into self and return PDF commands\n        needed to transform self into other.\n        \"\"\"\n        cmds = []\n        fill_performed = False\n        for params, cmd in self.commands:\n            different = False\n            for p in params:\n                ours = getattr(self, p)\n                theirs = getattr(other, p)\n                try:\n                    if ours is None or theirs is None:\n                        different = ours is not theirs\n                    else:\n                        different = bool(ours != theirs)\n                except ValueError:\n                    ours = np.asarray(ours)\n                    theirs = np.asarray(theirs)\n                    different = (ours.shape != theirs.shape or\n                                 np.any(ours != theirs))\n                if different:\n                    break\n\n            # Need to update hatching if we also updated fillcolor\n            if params == ('_hatch', '_hatch_color') and fill_performed:\n                different = True\n\n            if different:\n                if params == ('_fillcolor',):\n                    fill_performed = True\n                theirs = [getattr(other, p) for p in params]\n                cmds.extend(cmd(self, *theirs))\n                for p in params:\n                    setattr(self, p, getattr(other, p))\n        return cmds\n\n    def copy_properties(self, other):\n        \"\"\"\n        Copy properties of other into self.\n        \"\"\"\n        super().copy_properties(other)\n        fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n        effective_alphas = getattr(other, '_effective_alphas',\n                                   self._effective_alphas)\n        self._fillcolor = fillcolor\n        self._effective_alphas = effective_alphas\n\n    def finalize(self):\n        \"\"\"\n        Make sure every pushed graphics state is popped.\n        \"\"\"\n        cmds = []\n        while self.parent is not None:\n            cmds.extend(self.pop())\n        return cmds",
      "instance_attributes": [
        {
          "name": "_fillcolor",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "_effective_alphas",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "file",
          "types": null
        },
        {
          "name": "parent",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextPdf"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name",
      "name": "Name",
      "qname": "lib.matplotlib.backends.backend_pdf.Name",
      "decorators": [
        "total_ordering"
      ],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__str__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__hash__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/hexify",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/pdfRepr"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF name object.",
      "docstring": "PDF name object.",
      "code": "class Name:\n    \"\"\"PDF name object.\"\"\"\n    __slots__ = ('name',)\n    _hexify = {c: '#%02x' % c\n               for c in {*range(256)} - {*range(ord('!'), ord('~') + 1)}}\n\n    def __init__(self, name):\n        if isinstance(name, Name):\n            self.name = name.name\n        else:\n            if isinstance(name, bytes):\n                name = name.decode('ascii')\n            self.name = name.translate(self._hexify).encode('ascii')\n\n    def __repr__(self):\n        return \"<Name %s>\" % self.name\n\n    def __str__(self):\n        return '/' + self.name.decode('ascii')\n\n    def __eq__(self, other):\n        return isinstance(other, Name) and self.name == other.name\n\n    def __lt__(self, other):\n        return isinstance(other, Name) and self.name < other.name\n\n    def __hash__(self):\n        return hash(self.name)\n\n    @staticmethod\n    @_api.deprecated(\"3.6\")\n    def hexify(match):\n        return '#%02x' % ord(match.group())\n\n    def pdfRepr(self):\n        return b'/' + self.name",
      "instance_attributes": [
        {
          "name": "name",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op",
      "name": "Op",
      "qname": "lib.matplotlib.backends.backend_pdf.Op",
      "decorators": [],
      "superclasses": [
        "Enum"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Op/pdfRepr",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF operators (not an exhaustive list).",
      "docstring": "PDF operators (not an exhaustive list).",
      "code": "class Op(Enum):\n    \"\"\"PDF operators (not an exhaustive list).\"\"\"\n\n    close_fill_stroke = b'b'\n    fill_stroke = b'B'\n    fill = b'f'\n    closepath = b'h'\n    close_stroke = b's'\n    stroke = b'S'\n    endpath = b'n'\n    begin_text = b'BT'\n    end_text = b'ET'\n    curveto = b'c'\n    rectangle = b're'\n    lineto = b'l'\n    moveto = b'm'\n    concat_matrix = b'cm'\n    use_xobject = b'Do'\n    setgray_stroke = b'G'\n    setgray_nonstroke = b'g'\n    setrgb_stroke = b'RG'\n    setrgb_nonstroke = b'rg'\n    setcolorspace_stroke = b'CS'\n    setcolorspace_nonstroke = b'cs'\n    setcolor_stroke = b'SCN'\n    setcolor_nonstroke = b'scn'\n    setdash = b'd'\n    setlinejoin = b'j'\n    setlinecap = b'J'\n    setgstate = b'gs'\n    gsave = b'q'\n    grestore = b'Q'\n    textpos = b'Td'\n    selectfont = b'Tf'\n    textmatrix = b'Tm'\n    show = b'Tj'\n    showkern = b'TJ'\n    setlinewidth = b'w'\n    clip = b'W'\n    shading = b'sh'\n\n    op = _api.deprecated('3.6')(property(lambda self: self.value))\n\n    def pdfRepr(self):\n        return self.value\n\n    @classmethod\n    def paint_path(cls, fill, stroke):\n        \"\"\"\n        Return the PDF operator to paint a path.\n\n        Parameters\n        ----------\n        fill : bool\n            Fill the path with the fill color.\n        stroke : bool\n            Stroke the outline of the path with the line color.\n        \"\"\"\n        if stroke:\n            if fill:\n                return cls.fill_stroke\n            else:\n                return cls.stroke\n        else:\n            if fill:\n                return cls.fill\n            else:\n                return cls.endpath",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator",
      "name": "Operator",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/pdfRepr"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Operator:\n    __slots__ = ('op',)\n\n    def __init__(self, op):\n        self.op = op\n\n    def __repr__(self):\n        return '<Operator %s>' % self.op\n\n    def pdfRepr(self):\n        return self.op",
      "instance_attributes": [
        {
          "name": "op",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile",
      "name": "PdfFile",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_get_subsetted_psname",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/finalize",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/close",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/endStream",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_write_annotations",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeFonts",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_write_afm_font",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_embedTeXFont",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_get_xobject_glyph_name",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_soft_mask_state",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeExtGSTates",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_write_soft_mask_groups",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeHatches",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeGouraudTriangles",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_unpack",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_writePng",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_writeImg",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeImages",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeMarkers",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePathCollectionTemplates",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeXref",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeInfoDict",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeTrailer"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF file object.",
      "docstring": "PDF file object.",
      "code": "class PdfFile:\n    \"\"\"PDF file object.\"\"\"\n\n    def __init__(self, filename, metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n\n        metadata : dict from strings to strings and dates\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        super().__init__()\n\n        self._object_seq = itertools.count(1)  # consumed by reserveObject\n        self.xrefTable = [[0, 65535, 'the zero object']]\n        self.passed_in_file_object = False\n        self.original_file_like = None\n        self.tell_base = 0\n        fh, opened = cbook.to_filehandle(filename, \"wb\", return_opened=True)\n        if not opened:\n            try:\n                self.tell_base = filename.tell()\n            except IOError:\n                fh = BytesIO()\n                self.original_file_like = filename\n            else:\n                fh = filename\n                self.passed_in_file_object = True\n\n        self.fh = fh\n        self.currentstream = None  # stream object to write to, if any\n        fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n        # Output some eight-bit chars as a comment so various utilities\n        # recognize the file as binary by looking at the first few\n        # lines (see note in section 3.4.1 of the PDF reference).\n        fh.write(b\"%\\254\\334 \\253\\272\\n\")\n\n        self.rootObject = self.reserveObject('root')\n        self.pagesObject = self.reserveObject('pages')\n        self.pageList = []\n        self.fontObject = self.reserveObject('fonts')\n        self._extGStateObject = self.reserveObject('extended graphics states')\n        self.hatchObject = self.reserveObject('tiling patterns')\n        self.gouraudObject = self.reserveObject('Gouraud triangles')\n        self.XObjectObject = self.reserveObject('external objects')\n        self.resourceObject = self.reserveObject('resources')\n\n        root = {'Type': Name('Catalog'),\n                'Pages': self.pagesObject}\n        self.writeObject(self.rootObject, root)\n\n        self.infoDict = _create_pdf_info_dict('pdf', metadata or {})\n\n        self.fontNames = {}     # maps filenames to internal font names\n        self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))\n        self.dviFontInfo = {}   # maps dvi font names to embedding information\n        # differently encoded Type-1 fonts may share the same descriptor\n        self.type1Descriptors = {}\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n\n        self.alphaStates = {}   # maps alpha values to graphics state objects\n        self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))\n        self._soft_mask_states = {}\n        self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))\n        self._soft_mask_groups = []\n        self.hatchPatterns = {}\n        self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))\n        self.gouraudTriangles = []\n\n        self._images = {}\n        self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n\n        self.markers = {}\n        self.multi_byte_charprocs = {}\n\n        self.paths = []\n\n        # A list of annotations for each page. Each entry is a tuple of the\n        # overall Annots object reference that's inserted into the page object,\n        # followed by a list of the actual annotations.\n        self._annotations = []\n        # For annotations added before a page is created; mostly for the\n        # purpose of newTextnote.\n        self.pageAnnotations = []\n\n        # The PDF spec recommends to include every procset\n        procsets = [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]\n\n        # Write resource dictionary.\n        # Possibly TODO: more general ExtGState (graphics state dictionaries)\n        #                ColorSpace Pattern Shading Properties\n        resources = {'Font': self.fontObject,\n                     'XObject': self.XObjectObject,\n                     'ExtGState': self._extGStateObject,\n                     'Pattern': self.hatchObject,\n                     'Shading': self.gouraudObject,\n                     'ProcSet': procsets}\n        self.writeObject(self.resourceObject, resources)\n\n    def newPage(self, width, height):\n        self.endStream()\n\n        self.width, self.height = width, height\n        contentObject = self.reserveObject('page contents')\n        annotsObject = self.reserveObject('annotations')\n        thePage = {'Type': Name('Page'),\n                   'Parent': self.pagesObject,\n                   'Resources': self.resourceObject,\n                   'MediaBox': [0, 0, 72 * width, 72 * height],\n                   'Contents': contentObject,\n                   'Annots': annotsObject,\n                   }\n        pageObject = self.reserveObject('page')\n        self.writeObject(pageObject, thePage)\n        self.pageList.append(pageObject)\n        self._annotations.append((annotsObject, self.pageAnnotations))\n\n        self.beginStream(contentObject.id,\n                         self.reserveObject('length of content stream'))\n        # Initialize the pdf graphics state to match the default Matplotlib\n        # graphics context (colorspace and joinstyle).\n        self.output(Name('DeviceRGB'), Op.setcolorspace_stroke)\n        self.output(Name('DeviceRGB'), Op.setcolorspace_nonstroke)\n        self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n\n        # Clear the list of annotations for the next page\n        self.pageAnnotations = []\n\n    def newTextnote(self, text, positionRect=[-100, -100, 0, 0]):\n        # Create a new annotation of type text\n        theNote = {'Type': Name('Annot'),\n                   'Subtype': Name('Text'),\n                   'Contents': text,\n                   'Rect': positionRect,\n                   }\n        self.pageAnnotations.append(theNote)\n\n    def _get_subsetted_psname(self, ps_name, charmap):\n        def toStr(n, base):\n            if n < base:\n                return string.ascii_uppercase[n]\n            else:\n                return (\n                    toStr(n // base, base) + string.ascii_uppercase[n % base]\n                )\n\n        # encode to string using base 26\n        hashed = hash(frozenset(charmap.keys())) % ((sys.maxsize + 1) * 2)\n        prefix = toStr(hashed, 26)\n\n        # get first 6 characters from prefix\n        return prefix[:6] + \"+\" + ps_name\n\n    def finalize(self):\n        \"\"\"Write out the various deferred objects and the pdf end matter.\"\"\"\n\n        self.endStream()\n        self._write_annotations()\n        self.writeFonts()\n        self.writeExtGSTates()\n        self._write_soft_mask_groups()\n        self.writeHatches()\n        self.writeGouraudTriangles()\n        xobjects = {\n            name: ob for image, name, ob in self._images.values()}\n        for tup in self.markers.values():\n            xobjects[tup[0]] = tup[1]\n        for name, value in self.multi_byte_charprocs.items():\n            xobjects[name] = value\n        for name, path, trans, ob, join, cap, padding, filled, stroked \\\n                in self.paths:\n            xobjects[name] = ob\n        self.writeObject(self.XObjectObject, xobjects)\n        self.writeImages()\n        self.writeMarkers()\n        self.writePathCollectionTemplates()\n        self.writeObject(self.pagesObject,\n                         {'Type': Name('Pages'),\n                          'Kids': self.pageList,\n                          'Count': len(self.pageList)})\n        self.writeInfoDict()\n\n        # Finalize the file\n        self.writeXref()\n        self.writeTrailer()\n\n    def close(self):\n        \"\"\"Flush all buffers and free all resources.\"\"\"\n\n        self.endStream()\n        if self.passed_in_file_object:\n            self.fh.flush()\n        else:\n            if self.original_file_like is not None:\n                self.original_file_like.write(self.fh.getvalue())\n            self.fh.close()\n\n    def write(self, data):\n        if self.currentstream is None:\n            self.fh.write(data)\n        else:\n            self.currentstream.write(data)\n\n    def output(self, *data):\n        self.write(_fill([pdfRepr(x) for x in data]))\n        self.write(b'\\n')\n\n    def beginStream(self, id, len, extra=None, png=None):\n        assert self.currentstream is None\n        self.currentstream = Stream(id, len, self, extra, png)\n\n    def endStream(self):\n        if self.currentstream is not None:\n            self.currentstream.end()\n            self.currentstream = None\n\n    def outputStream(self, ref, data, *, extra=None):\n        self.beginStream(ref.id, None, extra)\n        self.currentstream.write(data)\n        self.endStream()\n\n    def _write_annotations(self):\n        for annotsObject, annotations in self._annotations:\n            self.writeObject(annotsObject, annotations)\n\n    def fontName(self, fontprop):\n        \"\"\"\n        Select a font based on fontprop and return a name suitable for\n        Op.selectfont. If fontprop is a string, it will be interpreted\n        as the filename of the font.\n        \"\"\"\n\n        if isinstance(fontprop, str):\n            filenames = [fontprop]\n        elif mpl.rcParams['pdf.use14corefonts']:\n            filenames = _fontManager._find_fonts_by_props(\n                fontprop, fontext='afm', directory=RendererPdf._afm_font_dir\n            )\n        else:\n            filenames = _fontManager._find_fonts_by_props(fontprop)\n        first_Fx = None\n        for fname in filenames:\n            Fx = self.fontNames.get(fname)\n            if not first_Fx:\n                first_Fx = Fx\n            if Fx is None:\n                Fx = next(self._internal_font_seq)\n                self.fontNames[fname] = Fx\n                _log.debug('Assigning font %s = %r', Fx, fname)\n                if not first_Fx:\n                    first_Fx = Fx\n\n        # find_fontsprop's first value always adheres to\n        # findfont's value, so technically no behaviour change\n        return first_Fx\n\n    def dviFontName(self, dvifont):\n        \"\"\"\n        Given a dvi font object, return a name suitable for Op.selectfont.\n        This registers the font information in ``self.dviFontInfo`` if not yet\n        registered.\n        \"\"\"\n\n        dvi_info = self.dviFontInfo.get(dvifont.texname)\n        if dvi_info is not None:\n            return dvi_info.pdfname\n\n        tex_font_map = dviread.PsfontsMap(dviread._find_tex_file('pdftex.map'))\n        psfont = tex_font_map[dvifont.texname]\n        if psfont.filename is None:\n            raise ValueError(\n                \"No usable font file found for {} (TeX: {}); \"\n                \"the font may lack a Type-1 version\"\n                .format(psfont.psname, dvifont.texname))\n\n        pdfname = next(self._internal_font_seq)\n        _log.debug('Assigning font %s = %s (dvi)', pdfname, dvifont.texname)\n        self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(\n            dvifont=dvifont,\n            pdfname=pdfname,\n            fontfile=psfont.filename,\n            basefont=psfont.psname,\n            encodingfile=psfont.encoding,\n            effects=psfont.effects)\n        return pdfname\n\n    def writeFonts(self):\n        fonts = {}\n        for dviname, info in sorted(self.dviFontInfo.items()):\n            Fx = info.pdfname\n            _log.debug('Embedding Type-1 font %s from dvi.', dviname)\n            fonts[Fx] = self._embedTeXFont(info)\n        for filename in sorted(self.fontNames):\n            Fx = self.fontNames[filename]\n            _log.debug('Embedding font %s.', filename)\n            if filename.endswith('.afm'):\n                # from pdf.use14corefonts\n                _log.debug('Writing AFM font.')\n                fonts[Fx] = self._write_afm_font(filename)\n            else:\n                # a normal TrueType font\n                _log.debug('Writing TrueType font.')\n                chars = self._character_tracker.used.get(filename)\n                if chars:\n                    fonts[Fx] = self.embedTTF(filename, chars)\n        self.writeObject(self.fontObject, fonts)\n\n    def _write_afm_font(self, filename):\n        with open(filename, 'rb') as fh:\n            font = AFM(fh)\n        fontname = font.get_fontname()\n        fontdict = {'Type': Name('Font'),\n                    'Subtype': Name('Type1'),\n                    'BaseFont': Name(fontname),\n                    'Encoding': Name('WinAnsiEncoding')}\n        fontdictObject = self.reserveObject('font dictionary')\n        self.writeObject(fontdictObject, fontdict)\n        return fontdictObject\n\n    def _embedTeXFont(self, fontinfo):\n        _log.debug('Embedding TeX font %s - fontinfo=%s',\n                   fontinfo.dvifont.texname, fontinfo.__dict__)\n\n        # Widths\n        widthsObject = self.reserveObject('font widths')\n        self.writeObject(widthsObject, fontinfo.dvifont.widths)\n\n        # Font dictionary\n        fontdictObject = self.reserveObject('font dictionary')\n        fontdict = {\n            'Type':      Name('Font'),\n            'Subtype':   Name('Type1'),\n            'FirstChar': 0,\n            'LastChar':  len(fontinfo.dvifont.widths) - 1,\n            'Widths':    widthsObject,\n            }\n\n        # Encoding (if needed)\n        if fontinfo.encodingfile is not None:\n            fontdict['Encoding'] = {\n                'Type': Name('Encoding'),\n                'Differences': [\n                    0, *map(Name, dviread._parse_enc(fontinfo.encodingfile))],\n            }\n\n        # If no file is specified, stop short\n        if fontinfo.fontfile is None:\n            _log.warning(\n                \"Because of TeX configuration (pdftex.map, see updmap option \"\n                \"pdftexDownloadBase14) the font %s is not embedded. This is \"\n                \"deprecated as of PDF 1.5 and it may cause the consumer \"\n                \"application to show something that was not intended.\",\n                fontinfo.basefont)\n            fontdict['BaseFont'] = Name(fontinfo.basefont)\n            self.writeObject(fontdictObject, fontdict)\n            return fontdictObject\n\n        # We have a font file to embed - read it in and apply any effects\n        t1font = _type1font.Type1Font(fontinfo.fontfile)\n        if fontinfo.effects:\n            t1font = t1font.transform(fontinfo.effects)\n        fontdict['BaseFont'] = Name(t1font.prop['FontName'])\n\n        # Font descriptors may be shared between differently encoded\n        # Type-1 fonts, so only create a new descriptor if there is no\n        # existing descriptor for this font.\n        effects = (fontinfo.effects.get('slant', 0.0),\n                   fontinfo.effects.get('extend', 1.0))\n        fontdesc = self.type1Descriptors.get((fontinfo.fontfile, effects))\n        if fontdesc is None:\n            fontdesc = self.createType1Descriptor(t1font, fontinfo.fontfile)\n            self.type1Descriptors[(fontinfo.fontfile, effects)] = fontdesc\n        fontdict['FontDescriptor'] = fontdesc\n\n        self.writeObject(fontdictObject, fontdict)\n        return fontdictObject\n\n    def createType1Descriptor(self, t1font, fontfile):\n        # Create and write the font descriptor and the font file\n        # of a Type-1 font\n        fontdescObject = self.reserveObject('font descriptor')\n        fontfileObject = self.reserveObject('font file')\n\n        italic_angle = t1font.prop['ItalicAngle']\n        fixed_pitch = t1font.prop['isFixedPitch']\n\n        flags = 0\n        # fixed width\n        if fixed_pitch:\n            flags |= 1 << 0\n        # TODO: serif\n        if 0:\n            flags |= 1 << 1\n        # TODO: symbolic (most TeX fonts are)\n        if 1:\n            flags |= 1 << 2\n        # non-symbolic\n        else:\n            flags |= 1 << 5\n        # italic\n        if italic_angle:\n            flags |= 1 << 6\n        # TODO: all caps\n        if 0:\n            flags |= 1 << 16\n        # TODO: small caps\n        if 0:\n            flags |= 1 << 17\n        # TODO: force bold\n        if 0:\n            flags |= 1 << 18\n\n        ft2font = get_font(fontfile)\n\n        descriptor = {\n            'Type':        Name('FontDescriptor'),\n            'FontName':    Name(t1font.prop['FontName']),\n            'Flags':       flags,\n            'FontBBox':    ft2font.bbox,\n            'ItalicAngle': italic_angle,\n            'Ascent':      ft2font.ascender,\n            'Descent':     ft2font.descender,\n            'CapHeight':   1000,  # TODO: find this out\n            'XHeight':     500,  # TODO: this one too\n            'FontFile':    fontfileObject,\n            'FontFamily':  t1font.prop['FamilyName'],\n            'StemV':       50,  # TODO\n            # (see also revision 3874; but not all TeX distros have AFM files!)\n            # 'FontWeight': a number where 400 = Regular, 700 = Bold\n            }\n\n        self.writeObject(fontdescObject, descriptor)\n\n        self.outputStream(fontfileObject, b\"\".join(t1font.parts[:2]),\n                          extra={'Length1': len(t1font.parts[0]),\n                                 'Length2': len(t1font.parts[1]),\n                                 'Length3': 0})\n\n        return fontdescObject\n\n    def _get_xobject_glyph_name(self, filename, glyph_name):\n        Fx = self.fontName(filename)\n        return \"-\".join([\n            Fx.name.decode(),\n            os.path.splitext(os.path.basename(filename))[0],\n            glyph_name])\n\n    _identityToUnicodeCMap = b\"\"\"/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo\n<< /Registry (Adobe)\n   /Ordering (UCS)\n   /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000> <ffff>\nendcodespacerange\n%d beginbfrange\n%s\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend\"\"\"\n\n    def embedTTF(self, filename, characters):\n        \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n\n        font = get_font(filename)\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"\"\"Convert font coordinates to PDF glyph coordinates.\"\"\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Best(?) to round away from zero for bounding boxes and the like.\n            if value < 0:\n                return math.floor(value)\n            else:\n                return math.ceil(value)\n\n        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array.\n            rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict = {'Type': Name('XObject'),\n                                    'Subtype': Name('Form'),\n                                    'BBox': bbox}\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.outputStream(charprocObject, stream, extra=charprocDict)\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_glyph_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject\n\n        def embedTTFType42(font, characters, descriptor):\n            \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n            fontdescObject = self.reserveObject('font descriptor')\n            cidFontDictObject = self.reserveObject('CID font dictionary')\n            type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n            cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n            fontfileObject = self.reserveObject('font file stream')\n            wObject = self.reserveObject('Type 0 widths')\n            toUnicodeMapObject = self.reserveObject('ToUnicode map')\n\n            subset_str = \"\".join(chr(c) for c in characters)\n            _log.debug(\"SUBSET %s characters: %s\", filename, subset_str)\n            fontdata = _backend_pdf_ps.get_glyphs_subset(filename, subset_str)\n            _log.debug(\n                \"SUBSET %s %d -> %d\", filename,\n                os.stat(filename).st_size, fontdata.getbuffer().nbytes\n            )\n\n            # We need this ref for XObjects\n            full_font = font\n\n            # reload the font object from the subset\n            # (all the necessary data could probably be obtained directly\n            # using fontLib.ttLib)\n            font = FT2Font(fontdata)\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            self.outputStream(\n                fontfileObject, fontdata.getvalue(),\n                extra={'Length1': fontdata.getbuffer().nbytes})\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\0'] * 65536\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph = font.load_char(ccode,\n                                       flags=LOAD_NO_SCALE | LOAD_NO_HINTING)\n                widths.append((ccode, cvt(glyph.horiAdvance)))\n                if ccode < 65536:\n                    cid_to_gid_map[ccode] = chr(gind)\n                max_ccode = max(ccode, max_ccode)\n            widths.sort()\n            cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n\n            last_ccode = -2\n            w = []\n            max_width = 0\n            unicode_groups = []\n            for ccode, width in widths:\n                if ccode != last_ccode + 1:\n                    w.append(ccode)\n                    w.append([width])\n                    unicode_groups.append([ccode, ccode])\n                else:\n                    w[-1].append(width)\n                    unicode_groups[-1][1] = ccode\n                max_width = max(max_width, width)\n                last_ccode = ccode\n\n            unicode_bfrange = []\n            for start, end in unicode_groups:\n                # Ensure the CID map contains only chars from BMP\n                if start > 65535:\n                    continue\n                end = min(65535, end)\n\n                unicode_bfrange.append(\n                    b\"<%04x> <%04x> [%s]\" %\n                    (start, end,\n                     b\" \".join(b\"<%04x>\" % x for x in range(start, end+1))))\n            unicode_cmap = (self._identityToUnicodeCMap %\n                            (len(unicode_groups), b\"\\n\".join(unicode_bfrange)))\n\n            # Add XObjects for unsupported chars\n            glyph_ids = []\n            for ccode in characters:\n                if not _font_supports_glyph(fonttype, ccode):\n                    gind = full_font.get_char_index(ccode)\n                    glyph_ids.append(gind)\n\n            bbox = [cvt(x, nearest=False) for x in full_font.bbox]\n            rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Type': Name('XObject'),\n                                'Subtype': Name('Form'),\n                                'BBox': bbox}\n                # Each glyph includes bounding box information,\n                # but xpdf and ghostscript can't handle it in a\n                # Form XObject (they segfault!!!), so we remove it\n                # from the stream here.  It's not needed anyway,\n                # since the Form XObject includes it in its BBox\n                # value.\n                stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.outputStream(charprocObject, stream, extra=charprocDict)\n\n                name = self._get_xobject_glyph_name(filename, charname)\n                self.multi_byte_charprocs[name] = charprocObject\n\n            # CIDToGIDMap stream\n            cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n            self.outputStream(cidToGidMapObject, cid_to_gid_map)\n\n            # ToUnicode CMap\n            self.outputStream(toUnicodeMapObject, unicode_cmap)\n\n            descriptor['MaxWidth'] = max_width\n\n            # Write everything out\n            self.writeObject(cidFontDictObject, cidFontDict)\n            self.writeObject(type0FontDictObject, type0FontDict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(wObject, w)\n\n            return type0FontDictObject\n\n        # Beginning of main embedTTF function...\n\n        ps_name = self._get_subsetted_psname(\n            font.postscript_name,\n            font.get_charmap()\n        )\n        ps_name = ps_name.encode('ascii', 'replace')\n        ps_name = Name(ps_name)\n        pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n        post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n        ff = font.face_flags\n        sf = font.style_flags\n\n        flags = 0\n        symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n        if ff & FIXED_WIDTH:\n            flags |= 1 << 0\n        if 0:  # TODO: serif\n            flags |= 1 << 1\n        if symbolic:\n            flags |= 1 << 2\n        else:\n            flags |= 1 << 5\n        if sf & ITALIC:\n            flags |= 1 << 6\n        if 0:  # TODO: all caps\n            flags |= 1 << 16\n        if 0:  # TODO: small caps\n            flags |= 1 << 17\n        if 0:  # TODO: force bold\n            flags |= 1 << 18\n\n        descriptor = {\n            'Type': Name('FontDescriptor'),\n            'FontName': ps_name,\n            'Flags': flags,\n            'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n            'Ascent': cvt(font.ascender, nearest=False),\n            'Descent': cvt(font.descender, nearest=False),\n            'CapHeight': cvt(pclt['capHeight'], nearest=False),\n            'XHeight': cvt(pclt['xHeight']),\n            'ItalicAngle': post['italicAngle'][1],  # ???\n            'StemV': 0  # ???\n            }\n\n        if fonttype == 3:\n            return embedTTFType3(font, characters, descriptor)\n        elif fonttype == 42:\n            return embedTTFType42(font, characters, descriptor)\n\n    def alphaState(self, alpha):\n        \"\"\"Return name of an ExtGState that sets alpha to the given value.\"\"\"\n\n        state = self.alphaStates.get(alpha, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._alpha_state_seq)\n        self.alphaStates[alpha] = \\\n            (name, {'Type': Name('ExtGState'),\n                    'CA': alpha[0], 'ca': alpha[1]})\n        return name\n\n    def _soft_mask_state(self, smask):\n        \"\"\"\n        Return an ExtGState that sets the soft mask to the given shading.\n\n        Parameters\n        ----------\n        smask : Reference\n            Reference to a shading in DeviceGray color space, whose luminosity\n            is to be used as the alpha channel.\n\n        Returns\n        -------\n        Name\n        \"\"\"\n\n        state = self._soft_mask_states.get(smask, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._soft_mask_seq)\n        groupOb = self.reserveObject('transparency group for soft mask')\n        self._soft_mask_states[smask] = (\n            name,\n            {\n                'Type': Name('ExtGState'),\n                'AIS': False,\n                'SMask': {\n                    'Type': Name('Mask'),\n                    'S': Name('Luminosity'),\n                    'BC': [1],\n                    'G': groupOb\n                }\n            }\n        )\n        self._soft_mask_groups.append((\n            groupOb,\n            {\n                'Type': Name('XObject'),\n                'Subtype': Name('Form'),\n                'FormType': 1,\n                'Group': {\n                    'S': Name('Transparency'),\n                    'CS': Name('DeviceGray')\n                },\n                'Matrix': [1, 0, 0, 1, 0, 0],\n                'Resources': {'Shading': {'S': smask}},\n                'BBox': [0, 0, 1, 1]\n            },\n            [Name('S'), Op.shading]\n        ))\n        return name\n\n    def writeExtGSTates(self):\n        self.writeObject(\n            self._extGStateObject,\n            dict([\n                *self.alphaStates.values(),\n                *self._soft_mask_states.values()\n            ])\n        )\n\n    def _write_soft_mask_groups(self):\n        for ob, attributes, content in self._soft_mask_groups:\n            self.beginStream(ob.id, None, attributes)\n            self.output(*content)\n            self.endStream()\n\n    def hatchPattern(self, hatch_style):\n        # The colors may come in as numpy arrays, which aren't hashable\n        if hatch_style is not None:\n            edge, face, hatch = hatch_style\n            if edge is not None:\n                edge = tuple(edge)\n            if face is not None:\n                face = tuple(face)\n            hatch_style = (edge, face, hatch)\n\n        pattern = self.hatchPatterns.get(hatch_style, None)\n        if pattern is not None:\n            return pattern\n\n        name = next(self._hatch_pattern_seq)\n        self.hatchPatterns[hatch_style] = name\n        return name\n\n    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self.hatchPatterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n\n            stroke_rgb, fill_rgb, hatch = hatch_style\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_stroke)\n            if fill_rgb is not None:\n                self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n                            Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n\n            self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)\n\n            self.output(*self.pathOperations(\n                Path.hatch(hatch),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.fill_stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)\n\n    def addGouraudTriangles(self, points, colors):\n        \"\"\"\n        Add a Gouraud triangle shading.\n\n        Parameters\n        ----------\n        points : np.ndarray\n            Triangle vertices, shape (n, 3, 2)\n            where n = number of triangles, 3 = vertices, 2 = x, y.\n        colors : np.ndarray\n            Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n            as with points, but last dimension is either (gray,)\n            or (r, g, b, alpha).\n\n        Returns\n        -------\n        Name, Reference\n        \"\"\"\n        name = Name('GT%d' % len(self.gouraudTriangles))\n        ob = self.reserveObject(f'Gouraud triangle {name}')\n        self.gouraudTriangles.append((name, ob, points, colors))\n        return name, ob\n\n    def writeGouraudTriangles(self):\n        gouraudDict = dict()\n        for name, ob, points, colors in self.gouraudTriangles:\n            gouraudDict[name] = ob\n            shape = points.shape\n            flat_points = points.reshape((shape[0] * shape[1], 2))\n            colordim = colors.shape[2]\n            assert colordim in (1, 4)\n            flat_colors = colors.reshape((shape[0] * shape[1], colordim))\n            if colordim == 4:\n                # strip the alpha channel\n                colordim = 3\n            points_min = np.min(flat_points, axis=0) - (1 << 8)\n            points_max = np.max(flat_points, axis=0) + (1 << 8)\n            factor = 0xffffffff / (points_max - points_min)\n\n            self.beginStream(\n                ob.id, None,\n                {'ShadingType': 4,\n                 'BitsPerCoordinate': 32,\n                 'BitsPerComponent': 8,\n                 'BitsPerFlag': 8,\n                 'ColorSpace': Name(\n                     'DeviceRGB' if colordim == 3 else 'DeviceGray'\n                 ),\n                 'AntiAlias': False,\n                 'Decode': ([points_min[0], points_max[0],\n                             points_min[1], points_max[1]]\n                            + [0, 1] * colordim),\n                 })\n\n            streamarr = np.empty(\n                (shape[0] * shape[1],),\n                dtype=[('flags', 'u1'),\n                       ('points', '>u4', (2,)),\n                       ('colors', 'u1', (colordim,))])\n            streamarr['flags'] = 0\n            streamarr['points'] = (flat_points - points_min) * factor\n            streamarr['colors'] = flat_colors[:, :colordim] * 255.0\n\n            self.write(streamarr.tobytes())\n            self.endStream()\n        self.writeObject(self.gouraudObject, gouraudDict)\n\n    def imageObject(self, image):\n        \"\"\"Return name of an image XObject representing the given image.\"\"\"\n\n        entry = self._images.get(id(image), None)\n        if entry is not None:\n            return entry[1]\n\n        name = next(self._image_seq)\n        ob = self.reserveObject(f'image {name}')\n        self._images[id(image)] = (image, name, ob)\n        return name\n\n    def _unpack(self, im):\n        \"\"\"\n        Unpack image array *im* into ``(data, alpha)``, which have shape\n        ``(height, width, 3)`` (RGB) or ``(height, width, 1)`` (grayscale or\n        alpha), except that alpha is None if the image is fully opaque.\n        \"\"\"\n        im = im[::-1]\n        if im.ndim == 2:\n            return im, None\n        else:\n            rgb = im[:, :, :3]\n            rgb = np.array(rgb, order='C')\n            # PDF needs a separate alpha image\n            if im.shape[2] == 4:\n                alpha = im[:, :, 3][..., None]\n                if np.all(alpha == 255):\n                    alpha = None\n                else:\n                    alpha = np.array(alpha, order='C')\n            else:\n                alpha = None\n            return rgb, alpha\n\n    def _writePng(self, img):\n        \"\"\"\n        Write the image *img* into the pdf file using png\n        predictors with Flate compression.\n        \"\"\"\n        buffer = BytesIO()\n        img.save(buffer, format=\"png\")\n        buffer.seek(8)\n        png_data = b''\n        bit_depth = palette = None\n        while True:\n            length, type = struct.unpack(b'!L4s', buffer.read(8))\n            if type in [b'IHDR', b'PLTE', b'IDAT']:\n                data = buffer.read(length)\n                if len(data) != length:\n                    raise RuntimeError(\"truncated data\")\n                if type == b'IHDR':\n                    bit_depth = int(data[8])\n                elif type == b'PLTE':\n                    palette = data\n                elif type == b'IDAT':\n                    png_data += data\n            elif type == b'IEND':\n                break\n            else:\n                buffer.seek(length, 1)\n            buffer.seek(4, 1)   # skip CRC\n        return png_data, bit_depth, palette\n\n    def _writeImg(self, data, id, smask=None):\n        \"\"\"\n        Write the image *data*, of shape ``(height, width, 1)`` (grayscale) or\n        ``(height, width, 3)`` (RGB), as pdf object *id* and with the soft mask\n        (alpha channel) *smask*, which should be either None or a ``(height,\n        width, 1)`` array.\n        \"\"\"\n        height, width, color_channels = data.shape\n        obj = {'Type': Name('XObject'),\n               'Subtype': Name('Image'),\n               'Width': width,\n               'Height': height,\n               'ColorSpace': Name({1: 'DeviceGray',\n                                   3: 'DeviceRGB'}[color_channels]),\n               'BitsPerComponent': 8}\n        if smask:\n            obj['SMask'] = smask\n        if mpl.rcParams['pdf.compression']:\n            if data.shape[-1] == 1:\n                data = data.squeeze(axis=-1)\n            img = Image.fromarray(data)\n            img_colors = img.getcolors(maxcolors=256)\n            if color_channels == 3 and img_colors is not None:\n                # Convert to indexed color if there are 256 colors or fewer\n                # This can significantly reduce the file size\n                num_colors = len(img_colors)\n                # These constants were converted to IntEnums and deprecated in\n                # Pillow 9.2\n                dither = getattr(Image, 'Dither', Image).NONE\n                pmode = getattr(Image, 'Palette', Image).ADAPTIVE\n                img = img.convert(\n                    mode='P', dither=dither, palette=pmode, colors=num_colors\n                )\n                png_data, bit_depth, palette = self._writePng(img)\n                if bit_depth is None or palette is None:\n                    raise RuntimeError(\"invalid PNG header\")\n                palette = palette[:num_colors * 3]  # Trim padding\n                obj['ColorSpace'] = Verbatim(\n                    b'[/Indexed /DeviceRGB %d %s]'\n                    % (num_colors - 1, pdfRepr(palette)))\n                obj['BitsPerComponent'] = bit_depth\n                color_channels = 1\n            else:\n                png_data, _, _ = self._writePng(img)\n            png = {'Predictor': 10, 'Colors': color_channels, 'Columns': width}\n        else:\n            png = None\n        self.beginStream(\n            id,\n            self.reserveObject('length of image stream'),\n            obj,\n            png=png\n            )\n        if png:\n            self.currentstream.write(png_data)\n        else:\n            self.currentstream.write(data.tobytes())\n        self.endStream()\n\n    def writeImages(self):\n        for img, name, ob in self._images.values():\n            data, adata = self._unpack(img)\n            if adata is not None:\n                smaskObject = self.reserveObject(\"smask\")\n                self._writeImg(adata, smaskObject.id)\n            else:\n                smaskObject = None\n            self._writeImg(data, ob.id, smaskObject)\n\n    def markerObject(self, path, trans, fill, stroke, lw, joinstyle,\n                     capstyle):\n        \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n        # self.markers used by markerObject, writeMarkers, close:\n        # mapping from (path operations, fill?, stroke?) to\n        #   [name, object reference, bounding box, linewidth]\n        # This enables different draw_markers calls to share the XObject\n        # if the gc is sufficiently similar: colors etc can vary, but\n        # the choices of whether to fill and whether to stroke cannot.\n        # We need a bounding box enclosing all of the XObject path,\n        # but since line width may vary, we store the maximum of all\n        # occurring line widths in self.markers.\n        # close() is somewhat tightly coupled in that it expects the\n        # first two components of each value in self.markers to be the\n        # name and object reference.\n        pathops = self.pathOperations(path, trans, simplify=False)\n        key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)\n        result = self.markers.get(key)\n        if result is None:\n            name = Name('M%d' % len(self.markers))\n            ob = self.reserveObject('marker %d' % len(self.markers))\n            bbox = path.get_extents(trans)\n            self.markers[key] = [name, ob, bbox, lw]\n        else:\n            if result[-1] < lw:\n                result[-1] = lw\n            name = result[0]\n        return name\n\n    def writeMarkers(self):\n        for ((pathops, fill, stroke, joinstyle, capstyle),\n             (name, ob, bbox, lw)) in self.markers.items():\n            # bbox wraps the exact limits of the control points, so half a line\n            # will appear outside it. If the join style is miter and the line\n            # is not parallel to the edge, then the line will extend even\n            # further. From the PDF specification, Section 8.4.3.5, the miter\n            # limit is miterLength / lineWidth and from Table 52, the default\n            # is 10. With half the miter length outside, that works out to the\n            # following padding:\n            bbox = bbox.padded(lw * 5)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': list(bbox.extents)})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(fill, stroke))\n            self.endStream()\n\n    def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):\n        name = Name('P%d' % len(self.paths))\n        ob = self.reserveObject('path %d' % len(self.paths))\n        self.paths.append(\n            (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),\n             padding, filled, stroked))\n        return name\n\n    def writePathCollectionTemplates(self):\n        for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n             stroked) in self.paths:\n            pathops = self.pathOperations(path, trans, simplify=False)\n            bbox = path.get_extents(trans)\n            if not np.all(np.isfinite(bbox.extents)):\n                extents = [0, 0, 0, 0]\n            else:\n                bbox = bbox.padded(padding)\n                extents = list(bbox.extents)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': extents})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(filled, stroked))\n            self.endStream()\n\n    @staticmethod\n    def pathOperations(path, transform, clip=None, simplify=None, sketch=None):\n        return [Verbatim(_path.convert_to_string(\n            path, transform, clip, simplify, sketch,\n            6,\n            [Op.moveto.value, Op.lineto.value, b'', Op.curveto.value,\n             Op.closepath.value],\n            True))]\n\n    def writePath(self, path, transform, clip=False, sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72, self.height * 72)\n            simplify = path.should_simplify\n        else:\n            clip = None\n            simplify = False\n        cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n                                   sketch=sketch)\n        self.output(*cmds)\n\n    def reserveObject(self, name=''):\n        \"\"\"\n        Reserve an ID for an indirect object.\n\n        The name is used for debugging in case we forget to print out\n        the object with writeObject.\n        \"\"\"\n        id = next(self._object_seq)\n        self.xrefTable.append([None, 0, name])\n        return Reference(id)\n\n    def recordXref(self, id):\n        self.xrefTable[id][0] = self.fh.tell() - self.tell_base\n\n    def writeObject(self, object, contents):\n        self.recordXref(object.id)\n        object.write(contents, self)\n\n    def writeXref(self):\n        \"\"\"Write out the xref table.\"\"\"\n        self.startxref = self.fh.tell() - self.tell_base\n        self.write(b\"xref\\n0 %d\\n\" % len(self.xrefTable))\n        for i, (offset, generation, name) in enumerate(self.xrefTable):\n            if offset is None:\n                raise AssertionError(\n                    'No offset for object %d (%s)' % (i, name))\n            else:\n                key = b\"f\" if name == 'the zero object' else b\"n\"\n                text = b\"%010d %05d %b \\n\" % (offset, generation, key)\n                self.write(text)\n\n    def writeInfoDict(self):\n        \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n\n        self.infoObject = self.reserveObject('info')\n        self.writeObject(self.infoObject, self.infoDict)\n\n    def writeTrailer(self):\n        \"\"\"Write out the PDF trailer.\"\"\"\n\n        self.write(b\"trailer\\n\")\n        self.write(pdfRepr(\n            {'Size': len(self.xrefTable),\n             'Root': self.rootObject,\n             'Info': self.infoObject}))\n        # Could add 'ID'\n        self.write(b\"\\nstartxref\\n%d\\n%%%%EOF\\n\" % self.startxref)",
      "instance_attributes": [
        {
          "name": "_object_seq",
          "types": {
            "kind": "NamedType",
            "name": "count"
          }
        },
        {
          "name": "xrefTable",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "passed_in_file_object",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "original_file_like",
          "types": null
        },
        {
          "name": "tell_base",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "fh",
          "types": {
            "kind": "NamedType",
            "name": "BytesIO"
          }
        },
        {
          "name": "currentstream",
          "types": {
            "kind": "NamedType",
            "name": "Stream"
          }
        },
        {
          "name": "rootObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "pagesObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "pageList",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "fontObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "_extGStateObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "hatchObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "gouraudObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "XObjectObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "resourceObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "infoDict",
          "types": null
        },
        {
          "name": "fontNames",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_internal_font_seq",
          "types": null
        },
        {
          "name": "dviFontInfo",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "type1Descriptors",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_character_tracker",
          "types": null
        },
        {
          "name": "alphaStates",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_alpha_state_seq",
          "types": null
        },
        {
          "name": "_soft_mask_states",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_soft_mask_seq",
          "types": null
        },
        {
          "name": "_soft_mask_groups",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "hatchPatterns",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_hatch_pattern_seq",
          "types": null
        },
        {
          "name": "gouraudTriangles",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_images",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_image_seq",
          "types": null
        },
        {
          "name": "markers",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "multi_byte_charprocs",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "paths",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_annotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "pageAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "startxref",
          "types": null
        },
        {
          "name": "infoObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages",
      "name": "PdfPages",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__enter__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/close",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/infodict",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/get_pagecount",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file.",
      "docstring": "A multi-page PDF file.\n\nExamples\n--------\n>>> import matplotlib.pyplot as plt\n>>> # Initialize:\n>>> with PdfPages('foo.pdf') as pdf:\n...     # As many times as you like, create a figure fig and save it:\n...     fig = plt.figure()\n...     pdf.savefig(fig)\n...     # When no figure is specified the current figure is saved\n...     pdf.savefig()\n\nNotes\n-----\nIn reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid\nconfusion when using `~.pyplot.savefig` and forgetting the format argument.",
      "code": "class PdfPages:\n    \"\"\"\n    A multi-page PDF file.\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> # Initialize:\n    >>> with PdfPages('foo.pdf') as pdf:\n    ...     # As many times as you like, create a figure fig and save it:\n    ...     fig = plt.figure()\n    ...     pdf.savefig(fig)\n    ...     # When no figure is specified the current figure is saved\n    ...     pdf.savefig()\n\n    Notes\n    -----\n    In reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid\n    confusion when using `~.pyplot.savefig` and forgetting the format argument.\n    \"\"\"\n    __slots__ = ('_file', 'keep_empty')\n\n    def __init__(self, filename, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. The file is opened at once and any older file with the\n            same name is overwritten.\n\n        keep_empty : bool, optional\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        self._file = PdfFile(filename, metadata=metadata)\n        self.keep_empty = keep_empty\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        self._file.finalize()\n        self._file.close()\n        if (self.get_pagecount() == 0 and not self.keep_empty and\n                not self._file.passed_in_file_object):\n            os.remove(self._file.fh.name)\n        self._file = None\n\n    def infodict(self):\n        \"\"\"\n        Return a modifiable information dictionary object\n        (see PDF reference section 10.2.1 'Document Information\n        Dictionary').\n        \"\"\"\n        return self._file.infoDict\n\n    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, default: the active figure\n            The figure, or index of the figure, that is saved to the file.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n        # Force use of pdf backend, as PdfPages is tightly coupled with it.\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPdf(figure)\n            figure.savefig(self, format=\"pdf\", **kwargs)\n        finally:\n            figure.canvas = orig_canvas\n\n    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return len(self._file.pageList)\n\n    def attach_note(self, text, positionRect=[-100, -100, 0, 0]):\n        \"\"\"\n        Add a new text note to the page to be saved next. The optional\n        positionRect specifies the position of the new note on the\n        page. It is outside the page per default to make sure it is\n        invisible on printouts.\n        \"\"\"\n        self._file.newTextnote(text, positionRect)",
      "instance_attributes": [
        {
          "name": "_file",
          "types": {
            "kind": "NamedType",
            "name": "PdfFile"
          }
        },
        {
          "name": "keep_empty",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference",
      "name": "Reference",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/pdfRepr",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF reference object.\n\nUse PdfFile.reserveObject() to create References.",
      "docstring": "PDF reference object.\n\nUse PdfFile.reserveObject() to create References.",
      "code": "class Reference:\n    \"\"\"\n    PDF reference object.\n\n    Use PdfFile.reserveObject() to create References.\n    \"\"\"\n\n    def __init__(self, id):\n        self.id = id\n\n    def __repr__(self):\n        return \"<Reference %d>\" % self.id\n\n    def pdfRepr(self):\n        return b\"%d 0 R\" % self.id\n\n    def write(self, contents, file):\n        write = file.write\n        write(b\"%d 0 obj\\n\" % self.id)\n        write(pdfRepr(contents))\n        write(b\"\\nendobj\\n\")",
      "instance_attributes": [
        {
          "name": "id",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf",
      "name": "RendererPdf",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf",
      "decorators": [],
      "superclasses": [
        "_backend_pdf_ps.RendererPDFPSBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/finalize",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/get_image_magnification",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/_setup_textpos",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/_draw_xobject_glyph",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/new_gc"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererPdf(_backend_pdf_ps.RendererPDFPSBase):\n\n    _afm_font_dir = cbook._get_data_path(\"fonts/pdfcorefonts\")\n    _use_afm_rc_name = \"pdf.use14corefonts\"\n\n    def __init__(self, file, image_dpi, height, width):\n        super().__init__(width, height)\n        self.file = file\n        self.gc = self.new_gc()\n        self.image_dpi = image_dpi\n\n    def finalize(self):\n        self.file.output(*self.gc.finalize())\n\n    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc.get_rgb() is None:\n            # It should not matter what color here since linewidth should be\n            # 0 unless affected by global settings in rcParams, hence setting\n            # zero alpha just in case.\n            gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas\n\n    def get_image_magnification(self):\n        return self.image_dpi/72.0\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if transform is None:\n            # If there's no transform, alpha has already been applied\n            gc.set_alpha(1.0)\n\n        self.check_gc(gc)\n\n        w = 72.0 * w / self.image_dpi\n        h = 72.0 * h / self.image_dpi\n\n        imob = self.file.imageObject(im)\n\n        if transform is None:\n            self.file.output(Op.gsave,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n\n            self.file.output(Op.gsave,\n                             1, 0, 0, 1, x, y, Op.concat_matrix,\n                             tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        self.check_gc(gc, rgbFace)\n        self.file.writePath(\n            path, transform,\n            rgbFace is None and gc.get_hatch_path() is None,\n            gc.get_sketch_params())\n        self.file.output(self.gc.paint())\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # We can only reuse the objects if the presence of fill and\n        # stroke (and the amount of alpha for each) is the same for\n        # all of them\n        can_do_optimization = True\n        facecolors = np.asarray(facecolors)\n        edgecolors = np.asarray(edgecolors)\n\n        if not len(facecolors):\n            filled = False\n            can_do_optimization = not gc.get_hatch()\n        else:\n            if np.all(facecolors[:, 3] == facecolors[0, 3]):\n                filled = facecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        if not len(edgecolors):\n            stroked = False\n        else:\n            if np.all(np.asarray(linewidths) == 0.0):\n                stroked = False\n            elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):\n                stroked = edgecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is len_path * uses_per_path\n        # cost of XObject is len_path + 5 for the definition,\n        #    uses_per_path for the uses\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + uses_per_path + 5 < len_path * uses_per_path\n\n        if (not can_do_optimization) or (not should_do_optimization):\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        padding = np.max(linewidths)\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = self.file.pathCollectionObject(\n                gc, path, transform, padding, filled, stroked)\n            path_codes.append(name)\n\n        output = self.file.output\n        output(*self.gc.push())\n        lastx, lasty = 0, 0\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n\n            self.check_gc(gc0, rgbFace)\n            dx, dy = xo - lastx, yo - lasty\n            output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,\n                   Op.use_xobject)\n            lastx, lasty = xo, yo\n        output(*self.gc.pop())\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        # Same logic as in draw_path_collection\n        len_marker_path = len(marker_path)\n        uses = len(path)\n        if len_marker_path * uses < len_marker_path + uses + 5:\n            RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n                                      path, trans, rgbFace)\n            return\n\n        self.check_gc(gc, rgbFace)\n        fill = gc.fill(rgbFace)\n        stroke = gc.stroke()\n\n        output = self.file.output\n        marker = self.file.markerObject(\n            marker_path, marker_trans, fill, stroke, self.gc._linewidth,\n            gc.get_joinstyle(), gc.get_capstyle())\n\n        output(Op.gsave)\n        lastx, lasty = 0, 0\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.file.width*72, self.file.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                if not (0 <= x <= self.file.width * 72\n                        and 0 <= y <= self.file.height * 72):\n                    continue\n                dx, dy = x - lastx, y - lasty\n                output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n                       marker, Op.use_xobject)\n                lastx, lasty = x, y\n        output(Op.grestore)\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)\n\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        if len(points) == 0:\n            return\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] in (1, 4)\n\n        shape = points.shape\n        points = points.reshape((shape[0] * shape[1], 2))\n        tpoints = trans.transform(points)\n        tpoints = tpoints.reshape(shape)\n        name, _ = self.file.addGouraudTriangles(tpoints, colors)\n        output = self.file.output\n\n        if colors.shape[2] == 1:\n            # grayscale\n            gc.set_alpha(1.0)\n            self.check_gc(gc)\n            output(name, Op.shading)\n            return\n\n        alpha = colors[0, 0, 3]\n        if np.allclose(alpha, colors[:, :, 3]):\n            # single alpha value\n            gc.set_alpha(alpha)\n            self.check_gc(gc)\n            output(name, Op.shading)\n        else:\n            # varying alpha: use a soft mask\n            alpha = colors[:, :, 3][:, :, None]\n            _, smask_ob = self.file.addGouraudTriangles(tpoints, alpha)\n            gstate = self.file._soft_mask_state(smask_ob)\n            output(Op.gsave, gstate, Op.setgstate,\n                   name, Op.shading,\n                   Op.grestore)\n\n    def _setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0):\n        if angle == oldangle == 0:\n            self.file.output(x - oldx, y - oldy, Op.textpos)\n        else:\n            angle = math.radians(angle)\n            self.file.output(math.cos(angle), math.sin(angle),\n                             -math.sin(angle), math.cos(angle),\n                             x, y, Op.textmatrix)\n            self.file.output(0, 0, Op.textpos)\n\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        # TODO: fix positioning and encoding\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width, height, angle))\n\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        # Set up a global transformation matrix for the whole math expression\n        a = math.radians(angle)\n        self.file.output(Op.gsave)\n        self.file.output(math.cos(a), math.sin(a),\n                         -math.sin(a), math.cos(a),\n                         x, y, Op.concat_matrix)\n\n        self.check_gc(gc, gc._rgb)\n        prev_font = None, None\n        oldx, oldy = 0, 0\n        unsupported_chars = []\n\n        self.file.output(Op.begin_text)\n        for font, fontsize, num, ox, oy in glyphs:\n            self.file._character_tracker.track_glyph(font, num)\n            fontname = font.fname\n            if not _font_supports_glyph(fonttype, num):\n                # Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in\n                # Type 42) must be emitted separately (below).\n                unsupported_chars.append((font, fontsize, ox, oy, num))\n            else:\n                self._setup_textpos(ox, oy, 0, oldx, oldy)\n                oldx, oldy = ox, oy\n                if (fontname, fontsize) != prev_font:\n                    self.file.output(self.file.fontName(fontname), fontsize,\n                                     Op.selectfont)\n                    prev_font = fontname, fontsize\n                self.file.output(self.encode_string(chr(num), fonttype),\n                                 Op.show)\n        self.file.output(Op.end_text)\n\n        for font, fontsize, ox, oy, num in unsupported_chars:\n            self._draw_xobject_glyph(\n                font, fontsize, font.get_char_index(num), ox, oy)\n\n        # Draw any horizontal lines in the math layout\n        for ox, oy, width, height in rects:\n            self.file.output(Op.gsave, ox, oy, width, height,\n                             Op.rectangle, Op.fill, Op.grestore)\n\n        # Pop off the global transformation\n        self.file.output(Op.grestore)\n\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        texmanager = self.get_texmanager()\n        fontsize = prop.get_size_in_points()\n        dvifile = texmanager.make_dvi(s, fontsize)\n        with dviread.Dvi(dvifile, 72) as dvi:\n            page, = dvi\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, page.width, page.height, angle))\n\n        # Gather font information and do some setup for combining\n        # characters into strings. The variable seq will contain a\n        # sequence of font and text entries. A font entry is a list\n        # ['font', name, size] where name is a Name object for the\n        # font. A text entry is ['text', x, y, glyphs, x+w] where x\n        # and y are the starting coordinates, w is the width, and\n        # glyphs is a list; in this phase it will always contain just\n        # one one-character string, but later it may have longer\n        # strings interspersed with kern amounts.\n        oldfont, seq = None, []\n        for x1, y1, dvifont, glyph, width in page.text:\n            if dvifont != oldfont:\n                pdfname = self.file.dviFontName(dvifont)\n                seq += [['font', pdfname, dvifont.size]]\n                oldfont = dvifont\n            seq += [['text', x1, y1, [bytes([glyph])], x1+width]]\n\n        # Find consecutive text strings with constant y coordinate and\n        # combine into a sequence of strings and kerns, or just one\n        # string (if any kerns would be less than 0.1 points).\n        i, curx, fontsize = 0, 0, None\n        while i < len(seq)-1:\n            elt, nxt = seq[i:i+2]\n            if elt[0] == 'font':\n                fontsize = elt[2]\n            elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:\n                offset = elt[4] - nxt[1]\n                if abs(offset) < 0.1:\n                    elt[3][-1] += nxt[3][0]\n                    elt[4] += nxt[4]-nxt[1]\n                else:\n                    elt[3] += [offset*1000.0/fontsize, nxt[3][0]]\n                    elt[4] = nxt[4]\n                del seq[i+1]\n                continue\n            i += 1\n\n        # Create a transform to map the dvi contents to the canvas.\n        mytrans = Affine2D().rotate_deg(angle).translate(x, y)\n\n        # Output the text.\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        curx, cury, oldx, oldy = 0, 0, 0, 0\n        for elt in seq:\n            if elt[0] == 'font':\n                self.file.output(elt[1], elt[2], Op.selectfont)\n            elif elt[0] == 'text':\n                curx, cury = mytrans.transform((elt[1], elt[2]))\n                self._setup_textpos(curx, cury, angle, oldx, oldy)\n                oldx, oldy = curx, cury\n                if len(elt[3]) == 1:\n                    self.file.output(elt[3][0], Op.show)\n                else:\n                    self.file.output(elt[3], Op.showkern)\n            else:\n                assert False\n        self.file.output(Op.end_text)\n\n        # Then output the boxes (e.g., variable-length lines of square\n        # roots).\n        boxgc = self.new_gc()\n        boxgc.copy_properties(gc)\n        boxgc.set_linewidth(0)\n        pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.CLOSEPOLY]\n        for x1, y1, h, w in page.boxes:\n            path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],\n                         [0, 0]], pathops)\n            self.draw_path(boxgc, path, mytrans, gc._rgb)\n\n    def encode_string(self, s, fonttype):\n        if fonttype in (1, 3):\n            return s.encode('cp1252', 'replace')\n        return s.encode('utf-16be', 'replace')\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # TODO: combine consecutive texts into one BT/ET delimited section\n\n        self.check_gc(gc, gc._rgb)\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        fontsize = prop.get_size_in_points()\n\n        if mpl.rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            fonttype = 1\n        else:\n            font = self._get_font_ttf(prop)\n            self.file._character_tracker.track(font, s)\n            fonttype = mpl.rcParams['pdf.fonttype']\n\n        if gc.get_url() is not None:\n            font.set_text(s)\n            width, height = font.get_width_height()\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width / 64, height / 64, angle))\n\n        # If fonttype is neither 3 nor 42, emit the whole string at once\n        # without manual kerning.\n        if fonttype not in [3, 42]:\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            self._setup_textpos(x, y, angle)\n            self.file.output(self.encode_string(s, fonttype),\n                             Op.show, Op.end_text)\n\n        # A sequence of characters is broken into multiple chunks. The chunking\n        # serves two purposes:\n        #   - For Type 3 fonts, there is no way to access multibyte characters,\n        #     as they cannot have a CIDMap.  Therefore, in this case we break\n        #     the string into chunks, where each chunk contains either a string\n        #     of consecutive 1-byte characters or a single multibyte character.\n        #   - A sequence of 1-byte characters is split into chunks to allow for\n        #     kerning adjustments between consecutive chunks.\n        #\n        # Each chunk is emitted with a separate command: 1-byte characters use\n        # the regular text show command (TJ) with appropriate kerning between\n        # chunks, whereas multibyte characters use the XObject command (Do).\n        else:\n            # List of (ft_object, start_x, [prev_kern, char, char, ...]),\n            # w/o zero kerns.\n            singlebyte_chunks = []\n            # List of (ft_object, start_x, glyph_index).\n            multibyte_glyphs = []\n            prev_was_multibyte = True\n            prev_font = font\n            for item in _text_helpers.layout(\n                    s, font, kern_mode=KERNING_UNFITTED):\n                if _font_supports_glyph(fonttype, ord(item.char)):\n                    if prev_was_multibyte or item.ft_object != prev_font:\n                        singlebyte_chunks.append((item.ft_object, item.x, []))\n                        prev_font = item.ft_object\n                    if item.prev_kern:\n                        singlebyte_chunks[-1][2].append(item.prev_kern)\n                    singlebyte_chunks[-1][2].append(item.char)\n                    prev_was_multibyte = False\n                else:\n                    multibyte_glyphs.append(\n                        (item.ft_object, item.x, item.glyph_idx)\n                    )\n                    prev_was_multibyte = True\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = math.radians(angle)\n            self.file.output(math.cos(a), math.sin(a),\n                             -math.sin(a), math.cos(a),\n                             x, y, Op.concat_matrix)\n            # Emit all the 1-byte characters in a BT/ET group.\n\n            self.file.output(Op.begin_text)\n            prev_start_x = 0\n            for ft_object, start_x, kerns_or_chars in singlebyte_chunks:\n                ft_name = self.file.fontName(ft_object.fname)\n                self.file.output(ft_name, fontsize, Op.selectfont)\n                self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n                self.file.output(\n                    # See pdf spec \"Text space details\" for the 1000/fontsize\n                    # (aka. 1000/T_fs) factor.\n                    [-1000 * next(group) / fontsize if tp == float  # a kern\n                     else self.encode_string(\"\".join(group), fonttype)\n                     for tp, group in itertools.groupby(kerns_or_chars, type)],\n                    Op.showkern)\n                prev_start_x = start_x\n            self.file.output(Op.end_text)\n            # Then emit all the multibyte characters, one at a time.\n            for ft_object, start_x, glyph_idx in multibyte_glyphs:\n                self._draw_xobject_glyph(\n                    ft_object, fontsize, glyph_idx, start_x, 0\n                )\n            self.file.output(Op.grestore)\n\n    def _draw_xobject_glyph(self, font, fontsize, glyph_idx, x, y):\n        \"\"\"Draw a multibyte character from a Type 3 font as an XObject.\"\"\"\n        glyph_name = font.get_glyph_name(glyph_idx)\n        name = self.file._get_xobject_glyph_name(font.fname, glyph_name)\n        self.file.output(\n            Op.gsave,\n            0.001 * fontsize, 0, 0, 0.001 * fontsize, x, y, Op.concat_matrix,\n            Name(name), Op.use_xobject,\n            Op.grestore,\n        )\n\n    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPdf(self.file)",
      "instance_attributes": [
        {
          "name": "file",
          "types": null
        },
        {
          "name": "gc",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextPdf"
          }
        },
        {
          "name": "image_dpi",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream",
      "name": "Stream",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/_writeHeader",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/end",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/_flush"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF stream object.\n\nThis has no pdfRepr method. Instead, call begin(), then output the\ncontents of the stream by calling write(), and finally call end().",
      "docstring": "PDF stream object.\n\nThis has no pdfRepr method. Instead, call begin(), then output the\ncontents of the stream by calling write(), and finally call end().",
      "code": "class Stream:\n    \"\"\"\n    PDF stream object.\n\n    This has no pdfRepr method. Instead, call begin(), then output the\n    contents of the stream by calling write(), and finally call end().\n    \"\"\"\n    __slots__ = ('id', 'len', 'pdfFile', 'file', 'compressobj', 'extra', 'pos')\n\n    def __init__(self, id, len, file, extra=None, png=None):\n        \"\"\"\n        Parameters\n        ----------\n        id : int\n            Object id of the stream.\n        len : Reference or None\n            An unused Reference object for the length of the stream;\n            None means to use a memory buffer so the length can be inlined.\n        file : PdfFile\n            The underlying object to write the stream to.\n        extra : dict from Name to anything, or None\n            Extra key-value pairs to include in the stream header.\n        png : dict or None\n            If the data is already png encoded, the decode parameters.\n        \"\"\"\n        self.id = id            # object id\n        self.len = len          # id of length object\n        self.pdfFile = file\n        self.file = file.fh      # file to which the stream is written\n        self.compressobj = None  # compression object\n        if extra is None:\n            self.extra = dict()\n        else:\n            self.extra = extra.copy()\n        if png is not None:\n            self.extra.update({'Filter':      Name('FlateDecode'),\n                               'DecodeParms': png})\n\n        self.pdfFile.recordXref(self.id)\n        if mpl.rcParams['pdf.compression'] and not png:\n            self.compressobj = zlib.compressobj(\n                mpl.rcParams['pdf.compression'])\n        if self.len is None:\n            self.file = BytesIO()\n        else:\n            self._writeHeader()\n            self.pos = self.file.tell()\n\n    def _writeHeader(self):\n        write = self.file.write\n        write(b\"%d 0 obj\\n\" % self.id)\n        dict = self.extra\n        dict['Length'] = self.len\n        if mpl.rcParams['pdf.compression']:\n            dict['Filter'] = Name('FlateDecode')\n\n        write(pdfRepr(dict))\n        write(b\"\\nstream\\n\")\n\n    def end(self):\n        \"\"\"Finalize stream.\"\"\"\n\n        self._flush()\n        if self.len is None:\n            contents = self.file.getvalue()\n            self.len = len(contents)\n            self.file = self.pdfFile.fh\n            self._writeHeader()\n            self.file.write(contents)\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n        else:\n            length = self.file.tell() - self.pos\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n            self.pdfFile.writeObject(self.len, length)\n\n    def write(self, data):\n        \"\"\"Write some data on the stream.\"\"\"\n\n        if self.compressobj is None:\n            self.file.write(data)\n        else:\n            compressed = self.compressobj.compress(data)\n            self.file.write(compressed)\n\n    def _flush(self):\n        \"\"\"Flush the compression object.\"\"\"\n\n        if self.compressobj is not None:\n            compressed = self.compressobj.flush()\n            self.file.write(compressed)\n            self.compressobj = None",
      "instance_attributes": [
        {
          "name": "id",
          "types": null
        },
        {
          "name": "len",
          "types": null
        },
        {
          "name": "pdfFile",
          "types": null
        },
        {
          "name": "file",
          "types": {
            "kind": "NamedType",
            "name": "BytesIO"
          }
        },
        {
          "name": "compressobj",
          "types": null
        },
        {
          "name": "extra",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "pos",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim",
      "name": "Verbatim",
      "qname": "lib.matplotlib.backends.backend_pdf.Verbatim",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/pdfRepr"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Store verbatim PDF command content for later inclusion in the stream.",
      "docstring": "Store verbatim PDF command content for later inclusion in the stream.",
      "code": "class Verbatim:\n    \"\"\"Store verbatim PDF command content for later inclusion in the stream.\"\"\"\n    def __init__(self, x):\n        self._x = x\n\n    def pdfRepr(self):\n        return self._x",
      "instance_attributes": [
        {
          "name": "_x",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf",
      "name": "FigureCanvasPgf",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/_print_pgf_to_fh",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_renderer",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasPgf(FigureCanvasBase):\n    filetypes = {\"pgf\": \"LaTeX PGF picture\",\n                 \"pdf\": \"LaTeX compiled PGF picture\",\n                 \"png\": \"Portable Network Graphics\", }\n\n    def get_default_filetype(self):\n        return 'pdf'\n\n    def _print_pgf_to_fh(self, fh, *, bbox_inches_restore=None):\n\n        header_text = \"\"\"%% Creator: Matplotlib, PGF backend\n%%\n%% To include the figure in your LaTeX document, write\n%%   \\\\input{<filename>.pgf}\n%%\n%% Make sure the required packages are loaded in your preamble\n%%   \\\\usepackage{pgf}\n%%\n%% Also ensure that all the required font packages are loaded; for instance,\n%% the lmodern package is sometimes necessary when using math font.\n%%   \\\\usepackage{lmodern}\n%%\n%% Figures using additional raster images can only be included by \\\\input if\n%% they are in the same directory as the main LaTeX file. For loading figures\n%% from other directories you can use the `import` package\n%%   \\\\usepackage{import}\n%%\n%% and then include the figures with\n%%   \\\\import{<path to file>}{<filename>.pgf}\n%%\n\"\"\"\n\n        # append the preamble used by the backend as a comment for debugging\n        header_info_preamble = [\"%% Matplotlib used the following preamble\"]\n        for line in _get_preamble().splitlines():\n            header_info_preamble.append(\"%%   \" + line)\n        header_info_preamble.append(\"%%\")\n        header_info_preamble = \"\\n\".join(header_info_preamble)\n\n        # get figure size in inch\n        w, h = self.figure.get_figwidth(), self.figure.get_figheight()\n        dpi = self.figure.dpi\n\n        # create pgfpicture environment and write the pgf code\n        fh.write(header_text)\n        fh.write(header_info_preamble)\n        fh.write(\"\\n\")\n        _writeln(fh, r\"\\begingroup\")\n        _writeln(fh, r\"\\makeatletter\")\n        _writeln(fh, r\"\\begin{pgfpicture}\")\n        _writeln(fh,\n                 r\"\\pgfpathrectangle{\\pgfpointorigin}{\\pgfqpoint{%fin}{%fin}}\"\n                 % (w, h))\n        _writeln(fh, r\"\\pgfusepath{use as bounding box, clip}\")\n        renderer = MixedModeRenderer(self.figure, w, h, dpi,\n                                     RendererPgf(self.figure, fh),\n                                     bbox_inches_restore=bbox_inches_restore)\n        self.figure.draw(renderer)\n\n        # end the pgfpicture environment\n        _writeln(fh, r\"\\end{pgfpicture}\")\n        _writeln(fh, r\"\\makeatother\")\n        _writeln(fh, r\"\\endgroup\")\n\n    def print_pgf(self, fname_or_fh, **kwargs):\n        \"\"\"\n        Output pgf macros for drawing the figure so it can be included and\n        rendered in latex documents.\n        \"\"\"\n        with cbook.open_file_cm(fname_or_fh, \"w\", encoding=\"utf-8\") as file:\n            if not cbook.file_requires_unicode(file):\n                file = codecs.getwriter(\"utf-8\")(file)\n            self._print_pgf_to_fh(file, **kwargs)\n\n    def print_pdf(self, fname_or_fh, *, metadata=None, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf generated figure to pdf.\"\"\"\n        w, h = self.figure.get_size_inches()\n\n        info_dict = _create_pdf_info_dict('pgf', metadata or {})\n        pdfinfo = ','.join(\n            _metadata_to_str(k, v) for k, v in info_dict.items())\n\n        # print figure to pgf and compile it with latex\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            self.print_pgf(tmppath / \"figure.pgf\", **kwargs)\n            (tmppath / \"figure.tex\").write_text(\n                \"\\n\".join([\n                    r\"\\documentclass[12pt]{article}\",\n                    r\"\\usepackage[pdfinfo={%s}]{hyperref}\" % pdfinfo,\n                    r\"\\usepackage[papersize={%fin,%fin}, margin=0in]{geometry}\"\n                    % (w, h),\n                    r\"\\usepackage{pgf}\",\n                    _get_preamble(),\n                    r\"\\begin{document}\",\n                    r\"\\centering\",\n                    r\"\\input{figure.pgf}\",\n                    r\"\\end{document}\",\n                ]), encoding=\"utf-8\")\n            texcommand = mpl.rcParams[\"pgf.texsystem\"]\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 \"figure.tex\"], _log, cwd=tmpdir)\n            with (tmppath / \"figure.pdf\").open(\"rb\") as orig, \\\n                 cbook.open_file_cm(fname_or_fh, \"wb\") as dest:\n                shutil.copyfileobj(orig, dest)  # copy file contents to target\n\n    def print_png(self, fname_or_fh, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf figure to pdf and convert it to png.\"\"\"\n        converter = make_pdf_to_png_converter()\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            pdf_path = tmppath / \"figure.pdf\"\n            png_path = tmppath / \"figure.png\"\n            self.print_pdf(pdf_path, **kwargs)\n            converter(pdf_path, png_path, dpi=self.figure.dpi)\n            with png_path.open(\"rb\") as orig, \\\n                 cbook.open_file_cm(fname_or_fh, \"wb\") as dest:\n                shutil.copyfileobj(orig, dest)  # copy file contents to target\n\n    def get_renderer(self):\n        return RendererPgf(self.figure, None)\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError",
      "name": "LatexError",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__str__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class LatexError(Exception):\n    def __init__(self, message, latex_output=\"\"):\n        super().__init__(message)\n        self.latex_output = latex_output\n\n    def __str__(self):\n        s, = self.args\n        if self.latex_output:\n            s += \"\\n\" + self.latex_output\n        return s",
      "instance_attributes": [
        {
          "name": "latex_output",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager",
      "name": "LatexManager",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_build_latex_header",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_get_cached_or_new",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_get_cached_or_new_impl",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_stdin_writeln",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_expect",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_expect_prompt",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_setup_latex_process",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_get_box_metrics"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.",
      "docstring": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.",
      "code": "class LatexManager:\n    \"\"\"\n    The LatexManager opens an instance of the LaTeX application for\n    determining the metrics of text elements. The LaTeX environment can be\n    modified by setting fonts and/or a custom preamble in `.rcParams`.\n    \"\"\"\n\n    @staticmethod\n    def _build_latex_header():\n        latex_header = [\n            r\"\\documentclass{article}\",\n            # Include TeX program name as a comment for cache invalidation.\n            # TeX does not allow this to be the first line.\n            rf\"% !TeX program = {mpl.rcParams['pgf.texsystem']}\",\n            # Test whether \\includegraphics supports interpolate option.\n            r\"\\usepackage{graphicx}\",\n            _get_preamble(),\n            r\"\\begin{document}\",\n            r\"\\typeout{pgf_backend_query_start}\",\n        ]\n        return \"\\n\".join(latex_header)\n\n    @classmethod\n    def _get_cached_or_new(cls):\n        \"\"\"\n        Return the previous LatexManager if the header and tex system did not\n        change, or a new instance otherwise.\n        \"\"\"\n        return cls._get_cached_or_new_impl(cls._build_latex_header())\n\n    @classmethod\n    @functools.lru_cache(1)\n    def _get_cached_or_new_impl(cls, header):  # Helper for _get_cached_or_new.\n        return cls()\n\n    def _stdin_writeln(self, s):\n        if self.latex is None:\n            self._setup_latex_process()\n        self.latex.stdin.write(s)\n        self.latex.stdin.write(\"\\n\")\n        self.latex.stdin.flush()\n\n    def _expect(self, s):\n        s = list(s)\n        chars = []\n        while True:\n            c = self.latex.stdout.read(1)\n            chars.append(c)\n            if chars[-len(s):] == s:\n                break\n            if not c:\n                self.latex.kill()\n                self.latex = None\n                raise LatexError(\"LaTeX process halted\", \"\".join(chars))\n        return \"\".join(chars)\n\n    def _expect_prompt(self):\n        return self._expect(\"\\n*\")\n\n    def __init__(self):\n        # create a tmp directory for running latex, register it for deletion\n        self._tmpdir = TemporaryDirectory()\n        self.tmpdir = self._tmpdir.name\n        self._finalize_tmpdir = weakref.finalize(self, self._tmpdir.cleanup)\n\n        # test the LaTeX setup to ensure a clean startup of the subprocess\n        try:\n            self._setup_latex_process(expect_reply=False)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{self.latex.args[0]!r} not found.  Install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX \"\n                f\"implementation.\") from err\n        except OSError as err:\n            raise RuntimeError(\n                f\"Error starting process {self.latex.args[0]!r}\") from err\n        stdout, stderr = self.latex.communicate(\"\\n\\\\makeatletter\\\\@@end\\n\")\n        if self.latex.returncode != 0:\n            raise LatexError(\n                f\"LaTeX errored (probably missing font or error in preamble) \"\n                f\"while processing the following input:\\n\"\n                f\"{self._build_latex_header()}\",\n                stdout)\n\n        self.latex = None  # Will be set up on first use.\n        # Per-instance cache.\n        self._get_box_metrics = functools.lru_cache()(self._get_box_metrics)\n\n    str_cache = _api.deprecated(\"3.5\")(property(lambda self: {}))\n    texcommand = _api.deprecated(\"3.6\")(\n        property(lambda self: mpl.rcParams[\"pgf.texsystem\"]))\n    latex_header = _api.deprecated(\"3.6\")(\n        property(lambda self: self._build_latex_header()))\n\n    def _setup_latex_process(self, *, expect_reply=True):\n        # Open LaTeX process for real work; register it for deletion.  On\n        # Windows, we must ensure that the subprocess has quit before being\n        # able to delete the tmpdir in which it runs; in order to do so, we\n        # must first `kill()` it, and then `communicate()` with it.\n        self.latex = subprocess.Popen(\n            [mpl.rcParams[\"pgf.texsystem\"], \"-halt-on-error\"],\n            stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n            encoding=\"utf-8\", cwd=self.tmpdir)\n\n        def finalize_latex(latex):\n            latex.kill()\n            latex.communicate()\n\n        self._finalize_latex = weakref.finalize(\n            self, finalize_latex, self.latex)\n        # write header with 'pgf_backend_query_start' token\n        self._stdin_writeln(self._build_latex_header())\n        if expect_reply:  # read until 'pgf_backend_query_start' token appears\n            self._expect(\"*pgf_backend_query_start\")\n            self._expect_prompt()\n\n    def get_width_height_descent(self, text, prop):\n        \"\"\"\n        Get the width, total height, and descent (in TeX points) for a text\n        typeset by the current LaTeX environment.\n        \"\"\"\n        return self._get_box_metrics(_escape_and_apply_props(text, prop))\n\n    def _get_box_metrics(self, tex):\n        \"\"\"\n        Get the width, total height and descent (in TeX points) for a TeX\n        command's output in the current LaTeX environment.\n        \"\"\"\n        # This method gets wrapped in __init__ for per-instance caching.\n        self._stdin_writeln(  # Send textbox to TeX & request metrics typeout.\n            r\"\\sbox0{%s}\\typeout{\\the\\wd0,\\the\\ht0,\\the\\dp0}\" % tex)\n        try:\n            answer = self._expect_prompt()\n        except LatexError as err:\n            # Here and below, use '{}' instead of {!r} to avoid doubling all\n            # backslashes.\n            raise ValueError(\"Error measuring {}\\nLaTeX Output:\\n{}\"\n                             .format(tex, err.latex_output)) from err\n        try:\n            # Parse metrics from the answer string.  Last line is prompt, and\n            # next-to-last-line is blank line from \\typeout.\n            width, height, offset = answer.splitlines()[-3].split(\",\")\n        except Exception as err:\n            raise ValueError(\"Error measuring {}\\nLaTeX Output:\\n{}\"\n                             .format(tex, answer)) from err\n        w, h, o = float(width[:-2]), float(height[:-2]), float(offset[:-2])\n        # The height returned from LaTeX goes from base to top;\n        # the height Matplotlib expects goes from bottom to top.\n        return w, h + o, o",
      "instance_attributes": [
        {
          "name": "latex",
          "types": {
            "kind": "NamedType",
            "name": "Popen"
          }
        },
        {
          "name": "_tmpdir",
          "types": {
            "kind": "NamedType",
            "name": "TemporaryDirectory"
          }
        },
        {
          "name": "tmpdir",
          "types": null
        },
        {
          "name": "_finalize_tmpdir",
          "types": {
            "kind": "NamedType",
            "name": "finalize"
          }
        },
        {
          "name": "_get_box_metrics",
          "types": null
        },
        {
          "name": "_finalize_latex",
          "types": {
            "kind": "NamedType",
            "name": "finalize"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages",
      "name": "PdfPages",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/_write_header",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__enter__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/close",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/_run_latex",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/get_pagecount"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file using the pgf backend",
      "docstring": "A multi-page PDF file using the pgf backend\n\nExamples\n--------\n>>> import matplotlib.pyplot as plt\n>>> # Initialize:\n>>> with PdfPages('foo.pdf') as pdf:\n...     # As many times as you like, create a figure fig and save it:\n...     fig = plt.figure()\n...     pdf.savefig(fig)\n...     # When no figure is specified the current figure is saved\n...     pdf.savefig()",
      "code": "class PdfPages:\n    \"\"\"\n    A multi-page PDF file using the pgf backend\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> # Initialize:\n    >>> with PdfPages('foo.pdf') as pdf:\n    ...     # As many times as you like, create a figure fig and save it:\n    ...     fig = plt.figure()\n    ...     pdf.savefig(fig)\n    ...     # When no figure is specified the current figure is saved\n    ...     pdf.savefig()\n    \"\"\"\n    __slots__ = (\n        '_output_name',\n        'keep_empty',\n        '_n_figures',\n        '_file',\n        '_info_dict',\n        '_metadata',\n    )\n\n    def __init__(self, filename, *, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. Any older file with the same name is overwritten.\n\n        keep_empty : bool, default: True\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n\n            Note that some versions of LaTeX engines may ignore the 'Producer'\n            key and set it to themselves.\n        \"\"\"\n        self._output_name = filename\n        self._n_figures = 0\n        self.keep_empty = keep_empty\n        self._metadata = (metadata or {}).copy()\n        self._info_dict = _create_pdf_info_dict('pgf', self._metadata)\n        self._file = BytesIO()\n\n    def _write_header(self, width_inches, height_inches):\n        pdfinfo = ','.join(\n            _metadata_to_str(k, v) for k, v in self._info_dict.items())\n        latex_header = \"\\n\".join([\n            r\"\\documentclass[12pt]{article}\",\n            r\"\\usepackage[pdfinfo={%s}]{hyperref}\" % pdfinfo,\n            r\"\\usepackage[papersize={%fin,%fin}, margin=0in]{geometry}\"\n            % (width_inches, height_inches),\n            r\"\\usepackage{pgf}\",\n            _get_preamble(),\n            r\"\\setlength{\\parindent}{0pt}\",\n            r\"\\begin{document}%\",\n        ])\n        self._file.write(latex_header.encode('utf-8'))\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def close(self):\n        \"\"\"\n        Finalize this object, running LaTeX in a temporary directory\n        and moving the final pdf file to *filename*.\n        \"\"\"\n        self._file.write(rb'\\end{document}\\n')\n        if self._n_figures > 0:\n            self._run_latex()\n        elif self.keep_empty:\n            open(self._output_name, 'wb').close()\n        self._file.close()\n\n    def _run_latex(self):\n        texcommand = mpl.rcParams[\"pgf.texsystem\"]\n        with TemporaryDirectory() as tmpdir:\n            tex_source = pathlib.Path(tmpdir, \"pdf_pages.tex\")\n            tex_source.write_bytes(self._file.getvalue())\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 tex_source],\n                _log, cwd=tmpdir)\n            shutil.move(tex_source.with_suffix(\".pdf\"), self._output_name)\n\n    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, default: the active figure\n            The figure, or index of the figure, that is saved to the file.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPgf(figure)\n\n            width, height = figure.get_size_inches()\n            if self._n_figures == 0:\n                self._write_header(width, height)\n            else:\n                # \\pdfpagewidth and \\pdfpageheight exist on pdftex, xetex, and\n                # luatex<0.85; they were renamed to \\pagewidth and \\pageheight\n                # on luatex>=0.85.\n                self._file.write(\n                    br'\\newpage'\n                    br'\\ifdefined\\pdfpagewidth\\pdfpagewidth'\n                    br'\\else\\pagewidth\\fi=%ain'\n                    br'\\ifdefined\\pdfpageheight\\pdfpageheight'\n                    br'\\else\\pageheight\\fi=%ain'\n                    b'%%\\n' % (width, height)\n                )\n\n            figure.savefig(self._file, format=\"pgf\", **kwargs)\n            self._n_figures += 1\n        finally:\n            figure.canvas = orig_canvas\n\n    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return self._n_figures",
      "instance_attributes": [
        {
          "name": "_output_name",
          "types": null
        },
        {
          "name": "_n_figures",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "keep_empty",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_metadata",
          "types": null
        },
        {
          "name": "_info_dict",
          "types": null
        },
        {
          "name": "_file",
          "types": {
            "kind": "NamedType",
            "name": "BytesIO"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf",
      "name": "RendererPgf",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_print_pgf_clip",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_print_pgf_path_styles",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_print_pgf_path",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_pgf_path_draw",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_scale_image",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_image_nocomposite",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/flipy",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererPgf(RendererBase):\n\n    def __init__(self, figure, fh):\n        \"\"\"\n        Create a new PGF renderer that translates any drawing instruction\n        into text commands to be interpreted in a latex pgfpicture environment.\n\n        Attributes\n        ----------\n        figure : `matplotlib.figure.Figure`\n            Matplotlib figure to initialize height, width and dpi from.\n        fh : file-like\n            File handle for the output of the drawing commands.\n        \"\"\"\n\n        super().__init__()\n        self.dpi = figure.dpi\n        self.fh = fh\n        self.figure = figure\n        self.image_counter = 0\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        # convert from display units to in\n        f = 1. / self.dpi\n\n        # set style and clip\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n\n        # build marker definition\n        bl, tr = marker_path.get_extents(marker_trans).get_points()\n        coords = bl[0] * f, bl[1] * f, tr[0] * f, tr[1] * f\n        _writeln(self.fh,\n                 r\"\\pgfsys@defobject{currentmarker}\"\n                 r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}{\" % coords)\n        self._print_pgf_path(None, marker_path, marker_trans)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        _writeln(self.fh, r\"}\")\n\n        maxcoord = 16383 / 72.27 * self.dpi  # Max dimensions in LaTeX.\n        clip = (-maxcoord, -maxcoord, maxcoord, maxcoord)\n\n        # draw marker for each vertex\n        for point, code in path.iter_segments(trans, simplify=False,\n                                              clip=clip):\n            x, y = point[0] * f, point[1] * f\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            _writeln(self.fh, r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x, y))\n            _writeln(self.fh, r\"\\pgfsys@useobject{currentmarker}{}\")\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n        # draw the path\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n        self._print_pgf_path(gc, path, transform, rgbFace)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n        # if present, draw pattern on top\n        if gc.get_hatch():\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            self._print_pgf_path_styles(gc, rgbFace)\n\n            # combine clip and path for clipping\n            self._print_pgf_clip(gc)\n            self._print_pgf_path(gc, path, transform, rgbFace)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n            # build pattern definition\n            _writeln(self.fh,\n                     r\"\\pgfsys@defobject{currentpattern}\"\n                     r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}{\")\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            _writeln(self.fh,\n                     r\"\\pgfpathrectangle\"\n                     r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}\")\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n            scale = mpl.transforms.Affine2D().scale(self.dpi)\n            self._print_pgf_path(None, gc.get_hatch_path(), scale)\n            self._pgf_path_draw(stroke=True)\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n            _writeln(self.fh, r\"}\")\n            # repeat pattern, filling the bounding rect of the path\n            f = 1. / self.dpi\n            (xmin, ymin), (xmax, ymax) = \\\n                path.get_extents(transform).get_points()\n            xmin, xmax = f * xmin, f * xmax\n            ymin, ymax = f * ymin, f * ymax\n            repx, repy = math.ceil(xmax - xmin), math.ceil(ymax - ymin)\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformshift{%fin}{%fin}\" % (xmin, ymin))\n            for iy in range(repy):\n                for ix in range(repx):\n                    _writeln(self.fh, r\"\\pgfsys@useobject{currentpattern}{}\")\n                    _writeln(self.fh, r\"\\pgfsys@transformshift{1in}{0in}\")\n                _writeln(self.fh, r\"\\pgfsys@transformshift{-%din}{0in}\" % repx)\n                _writeln(self.fh, r\"\\pgfsys@transformshift{0in}{1in}\")\n\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def _print_pgf_clip(self, gc):\n        f = 1. / self.dpi\n        # check for clip box\n        bbox = gc.get_clip_rectangle()\n        if bbox:\n            p1, p2 = bbox.get_points()\n            w, h = p2 - p1\n            coords = p1[0] * f, p1[1] * f, w * f, h * f\n            _writeln(self.fh,\n                     r\"\\pgfpathrectangle\"\n                     r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}\"\n                     % coords)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n        # check for clip path\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            self._print_pgf_path(gc, clippath, clippath_trans)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n    def _print_pgf_path_styles(self, gc, rgbFace):\n        # cap style\n        capstyles = {\"butt\": r\"\\pgfsetbuttcap\",\n                     \"round\": r\"\\pgfsetroundcap\",\n                     \"projecting\": r\"\\pgfsetrectcap\"}\n        _writeln(self.fh, capstyles[gc.get_capstyle()])\n\n        # join style\n        joinstyles = {\"miter\": r\"\\pgfsetmiterjoin\",\n                      \"round\": r\"\\pgfsetroundjoin\",\n                      \"bevel\": r\"\\pgfsetbeveljoin\"}\n        _writeln(self.fh, joinstyles[gc.get_joinstyle()])\n\n        # filling\n        has_fill = rgbFace is not None\n\n        if gc.get_forced_alpha():\n            fillopacity = strokeopacity = gc.get_alpha()\n        else:\n            strokeopacity = gc.get_rgb()[3]\n            fillopacity = rgbFace[3] if has_fill and len(rgbFace) > 3 else 1.0\n\n        if has_fill:\n            _writeln(self.fh,\n                     r\"\\definecolor{currentfill}{rgb}{%f,%f,%f}\"\n                     % tuple(rgbFace[:3]))\n            _writeln(self.fh, r\"\\pgfsetfillcolor{currentfill}\")\n        if has_fill and fillopacity != 1.0:\n            _writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % fillopacity)\n\n        # linewidth and color\n        lw = gc.get_linewidth() * mpl_pt_to_in * latex_in_to_pt\n        stroke_rgba = gc.get_rgb()\n        _writeln(self.fh, r\"\\pgfsetlinewidth{%fpt}\" % lw)\n        _writeln(self.fh,\n                 r\"\\definecolor{currentstroke}{rgb}{%f,%f,%f}\"\n                 % stroke_rgba[:3])\n        _writeln(self.fh, r\"\\pgfsetstrokecolor{currentstroke}\")\n        if strokeopacity != 1.0:\n            _writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % strokeopacity)\n\n        # line style\n        dash_offset, dash_list = gc.get_dashes()\n        if dash_list is None:\n            _writeln(self.fh, r\"\\pgfsetdash{}{0pt}\")\n        else:\n            _writeln(self.fh,\n                     r\"\\pgfsetdash{%s}{%fpt}\"\n                     % (\"\".join(r\"{%fpt}\" % dash for dash in dash_list),\n                        dash_offset))\n\n    def _print_pgf_path(self, gc, path, transform, rgbFace=None):\n        f = 1. / self.dpi\n        # check for clip box / ignore clip for filled paths\n        bbox = gc.get_clip_rectangle() if gc else None\n        maxcoord = 16383 / 72.27 * self.dpi  # Max dimensions in LaTeX.\n        if bbox and (rgbFace is None):\n            p1, p2 = bbox.get_points()\n            clip = (max(p1[0], -maxcoord), max(p1[1], -maxcoord),\n                    min(p2[0], maxcoord), min(p2[1], maxcoord))\n        else:\n            clip = (-maxcoord, -maxcoord, maxcoord, maxcoord)\n        # build path\n        for points, code in path.iter_segments(transform, clip=clip):\n            if code == Path.MOVETO:\n                x, y = tuple(points)\n                _writeln(self.fh,\n                         r\"\\pgfpathmoveto{\\pgfqpoint{%fin}{%fin}}\" %\n                         (f * x, f * y))\n            elif code == Path.CLOSEPOLY:\n                _writeln(self.fh, r\"\\pgfpathclose\")\n            elif code == Path.LINETO:\n                x, y = tuple(points)\n                _writeln(self.fh,\n                         r\"\\pgfpathlineto{\\pgfqpoint{%fin}{%fin}}\" %\n                         (f * x, f * y))\n            elif code == Path.CURVE3:\n                cx, cy, px, py = tuple(points)\n                coords = cx * f, cy * f, px * f, py * f\n                _writeln(self.fh,\n                         r\"\\pgfpathquadraticcurveto\"\n                         r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}\"\n                         % coords)\n            elif code == Path.CURVE4:\n                c1x, c1y, c2x, c2y, px, py = tuple(points)\n                coords = c1x * f, c1y * f, c2x * f, c2y * f, px * f, py * f\n                _writeln(self.fh,\n                         r\"\\pgfpathcurveto\"\n                         r\"{\\pgfqpoint{%fin}{%fin}}\"\n                         r\"{\\pgfqpoint{%fin}{%fin}}\"\n                         r\"{\\pgfqpoint{%fin}{%fin}}\"\n                         % coords)\n\n        # apply pgf decorators\n        sketch_params = gc.get_sketch_params() if gc else None\n        if sketch_params is not None:\n            # Only \"length\" directly maps to \"segment length\" in PGF's API.\n            # PGF uses \"amplitude\" to pass the combined deviation in both x-\n            # and y-direction, while matplotlib only varies the length of the\n            # wiggle along the line (\"randomness\" and \"length\" parameters)\n            # and has a separate \"scale\" argument for the amplitude.\n            # -> Use \"randomness\" as PRNG seed to allow the user to force the\n            # same shape on multiple sketched lines\n            scale, length, randomness = sketch_params\n            if scale is not None:\n                # make matplotlib and PGF rendering visually similar\n                length *= 0.5\n                scale *= 2\n                # PGF guarantees that repeated loading is a no-op\n                _writeln(self.fh, r\"\\usepgfmodule{decorations}\")\n                _writeln(self.fh, r\"\\usepgflibrary{decorations.pathmorphing}\")\n                _writeln(self.fh, r\"\\pgfkeys{/pgf/decoration/.cd, \"\n                         f\"segment length = {(length * f):f}in, \"\n                         f\"amplitude = {(scale * f):f}in}}\")\n                _writeln(self.fh, f\"\\\\pgfmathsetseed{{{int(randomness)}}}\")\n                _writeln(self.fh, r\"\\pgfdecoratecurrentpath{random steps}\")\n\n    def _pgf_path_draw(self, stroke=True, fill=False):\n        actions = []\n        if stroke:\n            actions.append(\"stroke\")\n        if fill:\n            actions.append(\"fill\")\n        _writeln(self.fh, r\"\\pgfusepath{%s}\" % \",\".join(actions))\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if not os.path.exists(getattr(self.fh, \"name\", \"\")):\n            raise ValueError(\n                \"streamed pgf-code does not support raster graphics, consider \"\n                \"using the pgf-to-pdf option\")\n\n        # save the images to png files\n        path = pathlib.Path(self.fh.name)\n        fname_img = \"%s-img%d.png\" % (path.stem, self.image_counter)\n        Image.fromarray(im[::-1]).save(path.parent / fname_img)\n        self.image_counter += 1\n\n        # reference the image in the pgf picture\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n        self._print_pgf_clip(gc)\n        f = 1. / self.dpi  # from display coords to inch\n        if transform is None:\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x * f, y * f))\n            w, h = w * f, h * f\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformcm{%f}{%f}{%f}{%f}{%fin}{%fin}\" %\n                     (tr1 * f, tr2 * f, tr3 * f, tr4 * f,\n                      (tr5 + x) * f, (tr6 + y) * f))\n            w = h = 1  # scale is already included in the transform\n        interp = str(transform is None).lower()  # interpolation in PDF reader\n        _writeln(self.fh,\n                 r\"\\pgftext[left,bottom]\"\n                 r\"{%s[interpolate=%s,width=%fin,height=%fin]{%s}}\" %\n                 (_get_image_inclusion_command(),\n                  interp, w, h, fname_img))\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath=\"TeX\", mtext=None):\n        # docstring inherited\n        self.draw_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # prepare string for tex\n        s = _escape_and_apply_props(s, prop)\n\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        alpha = gc.get_alpha()\n        if alpha != 1.0:\n            _writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % alpha)\n            _writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % alpha)\n        rgb = tuple(gc.get_rgb())[:3]\n        _writeln(self.fh, r\"\\definecolor{textcolor}{rgb}{%f,%f,%f}\" % rgb)\n        _writeln(self.fh, r\"\\pgfsetstrokecolor{textcolor}\")\n        _writeln(self.fh, r\"\\pgfsetfillcolor{textcolor}\")\n        s = r\"\\color{textcolor}\" + s\n\n        dpi = self.figure.dpi\n        text_args = []\n        if mtext and (\n                (angle == 0 or\n                 mtext.get_rotation_mode() == \"anchor\") and\n                mtext.get_verticalalignment() != \"center_baseline\"):\n            # if text anchoring can be supported, get the original coordinates\n            # and add alignment information\n            pos = mtext.get_unitless_position()\n            x, y = mtext.get_transform().transform(pos)\n            halign = {\"left\": \"left\", \"right\": \"right\", \"center\": \"\"}\n            valign = {\"top\": \"top\", \"bottom\": \"bottom\",\n                      \"baseline\": \"base\", \"center\": \"\"}\n            text_args.extend([\n                f\"x={x/dpi:f}in\",\n                f\"y={y/dpi:f}in\",\n                halign[mtext.get_horizontalalignment()],\n                valign[mtext.get_verticalalignment()],\n            ])\n        else:\n            # if not, use the text layout provided by Matplotlib.\n            text_args.append(f\"x={x/dpi:f}in, y={y/dpi:f}in, left, base\")\n\n        if angle != 0:\n            text_args.append(\"rotate=%f\" % angle)\n\n        _writeln(self.fh, r\"\\pgftext[%s]{%s}\" % (\",\".join(text_args), s))\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        # get text metrics in units of latex pt, convert to display units\n        w, h, d = (LatexManager._get_cached_or_new()\n                   .get_width_height_descent(s, prop))\n        # TODO: this should be latex_pt_to_in instead of mpl_pt_to_in\n        # but having a little bit more space around the text looks better,\n        # plus the bounding box reported by LaTeX is VERY narrow\n        f = mpl_pt_to_in * self.dpi\n        return w * f, h * f, d * f\n\n    def flipy(self):\n        # docstring inherited\n        return False\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return (self.figure.get_figwidth() * self.dpi,\n                self.figure.get_figheight() * self.dpi)\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * mpl_pt_to_in * self.dpi",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "fh",
          "types": null
        },
        {
          "name": "figure",
          "types": null
        },
        {
          "name": "image_counter",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_pgf.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    NO_ESCAPE = _api.deprecated(\"3.6\", obj_type=\"\")(\n        property(lambda self: _NO_ESCAPE))\n    re_mathsep = _api.deprecated(\"3.6\", obj_type=\"\")(\n        property(lambda self: _split_math.__self__))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS",
      "name": "FigureCanvasPS",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/_print_ps",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/_print_figure",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/_print_figure_tex",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasPS(FigureCanvasBase):\n    fixed_dpi = 72\n    filetypes = {'ps': 'Postscript',\n                 'eps': 'Encapsulated Postscript'}\n\n    def get_default_filetype(self):\n        return 'ps'\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def _print_ps(\n            self, fmt, outfile, *args,\n            metadata=None, papertype=None, orientation='portrait',\n            **kwargs):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            filename = pathlib.Path(outfile).name\n            dsc_comments[\"Title\"] = \\\n                filename.encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"Matplotlib v{mpl.__version__}, https://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.utcfromtimestamp(\n                int(source_date_epoch)).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        _api.check_in_list(['auto', *papersize], papertype=papertype)\n\n        orientation = _api.check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype, **kwargs)\n\n    def _print_figure(\n            self, fmt, outfile, *,\n            dpi, dsc_comments, orientation, papertype,\n            bbox_inches_restore=None):\n        \"\"\"\n        Render the figure to a filesystem path or a file-like object.\n\n        Parameters are as for `.print_figure`, except that *dsc_comments* is a\n        all string containing Document Structuring Convention comments,\n        generated from the *metadata* parameter to `.print_figure`.\n        \"\"\"\n        is_eps = fmt == 'eps'\n        if not (isinstance(outfile, (str, os.PathLike))\n                or is_writable_file_like(outfile)):\n            raise ValueError(\"outfile must be a path or a file-like object\")\n\n        # find the appropriate papertype\n        width, height = self.figure.get_size_inches()\n        if papertype == 'auto':\n            papertype = _get_papertype(\n                *orientation.swap_if_landscape((width, height)))\n        paper_width, paper_height = orientation.swap_if_landscape(\n            papersize[papertype])\n\n        if mpl.rcParams['ps.usedistiller']:\n            # distillers improperly clip eps files if pagesize is too small\n            if width > paper_width or height > paper_height:\n                papertype = _get_papertype(\n                    *orientation.swap_if_landscape((width, height)))\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    papersize[papertype])\n\n        # center the figure on the paper\n        xo = 72 * 0.5 * (paper_width - width)\n        yo = 72 * 0.5 * (paper_height - height)\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        rotation = 0\n        if orientation is _Orientation.landscape:\n            llx, lly, urx, ury = lly, llx, ury, urx\n            xo, yo = 72 * paper_height - yo, xo\n            rotation = 90\n        bbox = (llx, lly, urx, ury)\n\n        self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi, ps_renderer,\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(f\"%!PS-Adobe-3.0\\n\"\n                      f\"%%DocumentPaperSizes: {papertype}\\n\"\n                      f\"%%Pages: 1\\n\",\n                      end=\"\", file=fh)\n            print(f\"{dsc_comments}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"{get_bbox_header(bbox)[0]}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                Ndict += len(ps_renderer._character_tracker.used)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            print(\"\\n\".join(psDefs), file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                for font_path, chars \\\n                        in ps_renderer._character_tracker.used.items():\n                    if not chars:\n                        continue\n                    fonttype = mpl.rcParams['ps.fonttype']\n                    # Can't use more than 255 chars from a single Type 3 font.\n                    if len(chars) > 255:\n                        fonttype = 42\n                    fh.flush()\n                    if fonttype == 3:\n                        fh.write(_font_to_ps_type3(font_path, chars))\n                    else:  # Type 42 only.\n                        _font_to_ps_type42(font_path, chars, fh)\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(\"%s clipbox\" % _nums_to_str(width*72, height*72, 0, 0),\n                  file=fh)\n\n            # write the figure\n            print(self._pswriter.getvalue(), file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()\n\n        if mpl.rcParams['ps.usedistiller']:\n            # We are going to use an external program to process the output.\n            # Write to a temporary file.\n            with TemporaryDirectory() as tmpdir:\n                tmpfile = os.path.join(tmpdir, \"tmp.ps\")\n                with open(tmpfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)\n                if mpl.rcParams['ps.usedistiller'] == 'ghostscript':\n                    _try_distill(gs_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                    _try_distill(xpdf_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                _move_path_to_path_or_stream(tmpfile, outfile)\n\n        else:  # Write directly to outfile.\n            with cbook.open_file_cm(outfile, \"w\", encoding=\"latin-1\") as file:\n                if not file_requires_unicode(file):\n                    file = codecs.getwriter(\"latin-1\")(file)\n                print_figure_impl(file)\n\n    def _print_figure_tex(\n            self, fmt, outfile, *,\n            dpi, dsc_comments, orientation, papertype,\n            bbox_inches_restore=None):\n        \"\"\"\n        If :rc:`text.usetex` is True, a temporary pair of tex/eps files\n        are created to allow tex to manage the text layout via the PSFrags\n        package. These files are processed to yield the final ps or eps file.\n\n        The rest of the behavior is as for `._print_figure`.\n        \"\"\"\n        is_eps = fmt == 'eps'\n\n        width, height = self.figure.get_size_inches()\n        xo = 0\n        yo = 0\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        bbox = (llx, lly, urx, ury)\n\n        self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(self.figure,\n                                     width, height, dpi, ps_renderer,\n                                     bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        # write to a temp file, we'll move it to outfile when done\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir, \"tmp.ps\")\n            tmppath.write_text(\n                f\"\"\"\\\n%!PS-Adobe-3.0 EPSF-3.0\n{dsc_comments}\n{get_bbox_header(bbox)[0]}\n%%EndComments\n%%BeginProlog\n/mpldict {len(psDefs)} dict def\nmpldict begin\n{\"\".join(psDefs)}\nend\n%%EndProlog\nmpldict begin\n{_nums_to_str(xo, yo)} translate\n{_nums_to_str(width*72, height*72)} 0 0 clipbox\n{self._pswriter.getvalue()}\nend\nshowpage\n\"\"\",\n                encoding=\"latin-1\")\n\n            if orientation is _Orientation.landscape:  # now, ready to rotate\n                width, height = height, width\n                bbox = (lly, llx, ury, urx)\n\n            # set the paper size to the figure size if is_eps. The\n            # resulting ps file has the given size with correct bounding\n            # box so that there is no need to call 'pstoeps'\n            if is_eps:\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    self.figure.get_size_inches())\n            else:\n                if papertype == 'auto':\n                    papertype = _get_papertype(width, height)\n                paper_width, paper_height = papersize[papertype]\n\n            psfrag_rotated = _convert_psfrags(\n                tmppath, ps_renderer.psfrag, paper_width, paper_height,\n                orientation.name)\n\n            if (mpl.rcParams['ps.usedistiller'] == 'ghostscript'\n                    or mpl.rcParams['text.usetex']):\n                _try_distill(gs_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n            elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                _try_distill(xpdf_distill,\n                             tmppath, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n            _move_path_to_path_or_stream(tmppath, outfile)\n\n    print_ps = functools.partialmethod(_print_ps, \"ps\")\n    print_eps = functools.partialmethod(_print_ps, \"eps\")\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()",
      "instance_attributes": [
        {
          "name": "_pswriter",
          "types": {
            "kind": "NamedType",
            "name": "StringIO"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper",
      "name": "PsBackendHelper",
      "qname": "lib.matplotlib.backends.backend_ps.PsBackendHelper",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper/__init__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class PsBackendHelper:\n    def __init__(self):\n        self._cached = {}",
      "instance_attributes": [
        {
          "name": "_cached",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS",
      "name": "RendererPS",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS",
      "decorators": [],
      "superclasses": [
        "_backend_pdf_ps.RendererPDFPSBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_is_transparent",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_linejoin_cmd",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_linecap_cmd",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/get_image_magnification",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_convert_path",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_get_clip_cmd",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_draw_ps"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.",
      "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.",
      "code": "class RendererPS(_backend_pdf_ps.RendererPDFPSBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles.\n    \"\"\"\n\n    _afm_font_dir = cbook._get_data_path(\"fonts/afm\")\n    _use_afm_rc_name = \"ps.useafm\"\n\n    def __init__(self, width, height, pswriter, imagedpi=72):\n        # Although postscript itself is dpi independent, we need to inform the\n        # image code about a requested dpi to generate high resolution images\n        # and them scale them before embedding them.\n        super().__init__(width, height)\n        self._pswriter = pswriter\n        if mpl.rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi / 72\n        self._clip_paths = {}\n        self._path_collection_id = 0\n\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n        self._logwarn_once = functools.lru_cache(None)(_log.warning)\n\n    def _is_transparent(self, rgb_or_rgba):\n        if rgb_or_rgba is None:\n            return True  # Consistent with rgbFace semantics.\n        elif len(rgb_or_rgba) == 4:\n            if rgb_or_rgba[3] == 0:\n                return True\n            if rgb_or_rgba[3] != 1:\n                self._logwarn_once(\n                    \"The PostScript backend does not support transparency; \"\n                    \"partially transparent artists will be rendered opaque.\")\n            return False\n        else:  # len() == 3.\n            return False\n\n    def set_color(self, r, g, b, store=True):\n        if (r, g, b) != self.color:\n            self._pswriter.write(f\"{r:1.3f} setgray\\n\"\n                                 if r == g == b else\n                                 f\"{r:1.3f} {g:1.3f} {b:1.3f} setrgbcolor\\n\")\n            if store:\n                self.color = (r, g, b)\n\n    def set_linewidth(self, linewidth, store=True):\n        linewidth = float(linewidth)\n        if linewidth != self.linewidth:\n            self._pswriter.write(\"%1.3f setlinewidth\\n\" % linewidth)\n            if store:\n                self.linewidth = linewidth\n\n    @staticmethod\n    def _linejoin_cmd(linejoin):\n        # Support for directly passing integer values is for backcompat.\n        linejoin = {'miter': 0, 'round': 1, 'bevel': 2, 0: 0, 1: 1, 2: 2}[\n            linejoin]\n        return f\"{linejoin:d} setlinejoin\\n\"\n\n    def set_linejoin(self, linejoin, store=True):\n        if linejoin != self.linejoin:\n            self._pswriter.write(self._linejoin_cmd(linejoin))\n            if store:\n                self.linejoin = linejoin\n\n    @staticmethod\n    def _linecap_cmd(linecap):\n        # Support for directly passing integer values is for backcompat.\n        linecap = {'butt': 0, 'round': 1, 'projecting': 2, 0: 0, 1: 1, 2: 2}[\n            linecap]\n        return f\"{linecap:d} setlinecap\\n\"\n\n    def set_linecap(self, linecap, store=True):\n        if linecap != self.linecap:\n            self._pswriter.write(self._linecap_cmd(linecap))\n            if store:\n                self.linecap = linecap\n\n    def set_linedash(self, offset, seq, store=True):\n        if self.linedash is not None:\n            oldo, oldseq = self.linedash\n            if np.array_equal(seq, oldseq) and oldo == offset:\n                return\n\n        self._pswriter.write(f\"[{_nums_to_str(*seq)}]\"\n                             f\" {_nums_to_str(offset)} setdash\\n\"\n                             if seq is not None and len(seq) else\n                             \"[] 0 setdash\\n\")\n        if store:\n            self.linedash = (offset, seq)\n\n    def set_font(self, fontname, fontsize, store=True):\n        if (fontname, fontsize) != (self.fontname, self.fontsize):\n            self._pswriter.write(f\"/{fontname} {fontsize:1.3f} selectfont\\n\")\n            if store:\n                self.fontname = fontname\n                self.fontsize = fontsize\n\n    def create_hatch(self, hatch):\n        sidelen = 72\n        if hatch in self._hatches:\n            return self._hatches[hatch]\n        name = 'H%d' % len(self._hatches)\n        linewidth = mpl.rcParams['hatch.linewidth']\n        pageheight = self.height * 72\n        self._pswriter.write(f\"\"\"\\\n  << /PatternType 1\n     /PaintType 2\n     /TilingType 2\n     /BBox[0 0 {sidelen:d} {sidelen:d}]\n     /XStep {sidelen:d}\n     /YStep {sidelen:d}\n\n     /PaintProc {{\n        pop\n        {linewidth:g} setlinewidth\n{self._convert_path(\n    Path.hatch(hatch), Affine2D().scale(sidelen), simplify=False)}\n        gsave\n        fill\n        grestore\n        stroke\n     }} bind\n   >>\n   matrix\n   0 {pageheight:g} translate\n   makepattern\n   /{name} exch def\n\"\"\")\n        self._hatches[hatch] = name\n        return name\n\n    def get_image_magnification(self):\n        \"\"\"\n        Get the factor by which to magnify images passed to draw_image.\n        Allows a backend to have images at a different resolution to other\n        artists.\n        \"\"\"\n        return self.image_magnification\n\n    def _convert_path(self, path, transform, clip=False, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0, self.height * 72.0)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, None,\n            6, [b\"m\", b\"l\", b\"\", b\"c\", b\"cl\"], True).decode(\"ascii\")\n\n    def _get_clip_cmd(self, gc):\n        clip = []\n        rect = gc.get_clip_rectangle()\n        if rect is not None:\n            clip.append(\"%s clipbox\\n\" % _nums_to_str(*rect.size, *rect.p0))\n        path, trf = gc.get_clip_path()\n        if path is not None:\n            key = (path, id(trf))\n            custom_clip_cmd = self._clip_paths.get(key)\n            if custom_clip_cmd is None:\n                custom_clip_cmd = \"c%d\" % len(self._clip_paths)\n                self._pswriter.write(f\"\"\"\\\n/{custom_clip_cmd} {{\n{self._convert_path(path, trf, simplify=False)}\nclip\nnewpath\n}} bind def\n\"\"\")\n                self._clip_paths[key] = custom_clip_cmd\n            clip.append(f\"{custom_clip_cmd}\\n\")\n        return \"\".join(clip)\n\n    @_log_if_debug_on\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n[{matrix}] concat\n{xscale:g} {yscale:g} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataString readhexstring pop\n}} bind {imagecmd}\n{hexdata}\ngrestore\n\"\"\")\n\n    @_log_if_debug_on\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        clip = rgbFace is None and gc.get_hatch_path() is None\n        simplify = path.should_simplify and clip\n        ps = self._convert_path(path, transform, clip=clip, simplify=simplify)\n        self._draw_ps(ps, gc, rgbFace)\n\n    @_log_if_debug_on\n    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        ps_color = (\n            None\n            if self._is_transparent(rgbFace)\n            else '%1.3f setgray' % rgbFace[0]\n            if rgbFace[0] == rgbFace[1] == rgbFace[2]\n            else '%1.3f %1.3f %1.3f setrgbcolor' % rgbFace[:3])\n\n        # construct the generic marker command:\n\n        # don't want the translate to be global\n        ps_cmd = ['/o {', 'gsave', 'newpath', 'translate']\n\n        lw = gc.get_linewidth()\n        alpha = (gc.get_alpha()\n                 if gc.get_forced_alpha() or len(gc.get_rgb()) == 3\n                 else gc.get_rgb()[3])\n        stroke = lw > 0 and alpha > 0\n        if stroke:\n            ps_cmd.append('%.1f setlinewidth' % lw)\n            ps_cmd.append(self._linejoin_cmd(gc.get_joinstyle()))\n            ps_cmd.append(self._linecap_cmd(gc.get_capstyle()))\n\n        ps_cmd.append(self._convert_path(marker_path, marker_trans,\n                                         simplify=False))\n\n        if rgbFace:\n            if stroke:\n                ps_cmd.append('gsave')\n            if ps_color:\n                ps_cmd.extend([ps_color, 'fill'])\n            if stroke:\n                ps_cmd.append('grestore')\n\n        if stroke:\n            ps_cmd.append('stroke')\n        ps_cmd.extend(['grestore', '} bind def'])\n\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.width*72, self.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ps_cmd.append(\"%g %g o\" % (x, y))\n\n        ps = '\\n'.join(ps_cmd)\n        self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False)\n\n    @_log_if_debug_on\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #     (len_path + 2) * uses_per_path\n        # cost of definition+use is\n        #     (len_path + 3) + 3 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 3 * uses_per_path + 3 < (len_path + 2) * uses_per_path\n        if not should_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = 'p%d_%d' % (self._path_collection_id, i)\n            path_bytes = self._convert_path(path, transform, simplify=False)\n            self._pswriter.write(f\"\"\"\\\n/{name} {{\nnewpath\ntranslate\n{path_bytes}\n}} bind def\n\"\"\")\n            path_codes.append(name)\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            ps = \"%g %g %s\" % (xo, yo, path_id)\n            self._draw_ps(ps, gc0, rgbFace)\n\n        self._path_collection_id += 1\n\n    @_log_if_debug_on\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if not hasattr(self, \"psfrag\"):\n            self._logwarn_once(\n                \"The PS backend determines usetex status solely based on \"\n                \"rcParams['text.usetex'] and does not support having \"\n                \"usetex=True only for some elements; this element will thus \"\n                \"be rendered as if usetex=False.\")\n            self.draw_text(gc, x, y, s, prop, angle, False, mtext)\n            return\n\n        w, h, bl = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        fontsize = prop.get_size_in_points()\n        thetext = 'psmarker%d' % self.textcnt\n        color = '%1.3f,%1.3f,%1.3f' % gc.get_rgb()[:3]\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(\n                       mpl.rcParams['font.family'][0], r'{\\rmfamily %s}')\n        s = fontcmd % s\n        tex = r'\\color[rgb]{%s} %s' % (color, s)\n\n        # Stick to the bottom alignment.\n        pos = _nums_to_str(x, y-bl)\n        self.psfrag.append(\n            r'\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                thetext, angle, fontsize, fontsize*1.25, tex))\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{pos} moveto\n({thetext})\nshow\ngrestore\n\"\"\")\n        self.textcnt += 1\n\n    @_log_if_debug_on\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if ismath == 'TeX':\n            return self.draw_tex(gc, x, y, s, prop, angle)\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        if mpl.rcParams['ps.useafm']:\n            font = self._get_font_afm(prop)\n            scale = 0.001 * prop.get_size_in_points()\n            stream = []\n            thisx = 0\n            last_name = None  # kerns returns 0 for None.\n            xs_names = []\n            for c in s:\n                name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char('?')\n                kern = font.get_kern_dist_from_name(last_name, name)\n                last_name = name\n                thisx += kern * scale\n                xs_names.append((thisx, name))\n                thisx += width * scale\n            ps_name = (font.postscript_name\n                       .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n            stream.append((ps_name, xs_names))\n\n        else:\n            font = self._get_font_ttf(prop)\n            self._character_tracker.track(font, s)\n            stream = []\n            prev_font = curr_stream = None\n            for item in _text_helpers.layout(s, font):\n                ps_name = (item.ft_object.postscript_name\n                           .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n                if item.ft_object is not prev_font:\n                    if curr_stream:\n                        stream.append(curr_stream)\n                    prev_font = item.ft_object\n                    curr_stream = [ps_name, []]\n                curr_stream[1].append(\n                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                )\n            # append the last entry\n            stream.append(curr_stream)\n\n        self.set_color(*gc.get_rgb())\n\n        for ps_name, xs_names in stream:\n            self.set_font(ps_name, prop.get_size_in_points(), False)\n            thetext = \"\\n\".join(f\"{x:g} 0 m /{name:s} glyphshow\"\n                                for x, name in xs_names)\n            self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n{angle:g} rotate\n{thetext}\ngrestore\n\"\"\")\n\n    @_log_if_debug_on\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw the math text using matplotlib.mathtext.\"\"\"\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n        self.set_color(*gc.get_rgb())\n        self._pswriter.write(\n            f\"gsave\\n\"\n            f\"{x:g} {y:g} translate\\n\"\n            f\"{angle:g} rotate\\n\")\n        lastfont = None\n        for font, fontsize, num, ox, oy in glyphs:\n            self._character_tracker.track_glyph(font, num)\n            if (font.postscript_name, fontsize) != lastfont:\n                lastfont = font.postscript_name, fontsize\n                self._pswriter.write(\n                    f\"/{font.postscript_name} {fontsize} selectfont\\n\")\n            glyph_name = (\n                font.get_name_char(chr(num)) if isinstance(font, AFM) else\n                font.get_glyph_name(font.get_char_index(num)))\n            self._pswriter.write(\n                f\"{ox:g} {oy:g} moveto\\n\"\n                f\"/{glyph_name} glyphshow\\n\")\n        for ox, oy, w, h in rects:\n            self._pswriter.write(f\"{ox} {oy} {w} {h} rectfill\\n\")\n        self._pswriter.write(\"grestore\\n\")\n\n    @_log_if_debug_on\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)\n\n    @_log_if_debug_on\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] == 4\n\n        shape = points.shape\n        flat_points = points.reshape((shape[0] * shape[1], 2))\n        flat_points = trans.transform(flat_points)\n        flat_colors = colors.reshape((shape[0] * shape[1], 4))\n        points_min = np.min(flat_points, axis=0) - (1 << 12)\n        points_max = np.max(flat_points, axis=0) + (1 << 12)\n        factor = np.ceil((2 ** 32 - 1) / (points_max - points_min))\n\n        xmin, ymin = points_min\n        xmax, ymax = points_max\n\n        data = np.empty(\n            shape[0] * shape[1],\n            dtype=[('flags', 'u1'), ('points', '2>u4'), ('colors', '3u1')])\n        data['flags'] = 0\n        data['points'] = (flat_points - points_min) * factor\n        data['colors'] = flat_colors[:, :3] * 255.0\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n<< /ShadingType 4\n   /ColorSpace [/DeviceRGB]\n   /BitsPerCoordinate 32\n   /BitsPerComponent 8\n   /BitsPerFlag 8\n   /AntiAlias true\n   /Decode [ {xmin:g} {xmax:g} {ymin:g} {ymax:g} 0 1 0 1 0 1 ]\n   /DataSource <\n{hexdata}\n>\n>>\nshfill\ngrestore\n\"\"\")\n\n    def _draw_ps(self, ps, gc, rgbFace, *, fill=True, stroke=True):\n        \"\"\"\n        Emit the PostScript snippet *ps* with all the attributes from *gc*\n        applied.  *ps* must consist of PostScript commands to construct a path.\n\n        The *fill* and/or *stroke* kwargs can be set to False if the *ps*\n        string already includes filling and/or stroking, in which case\n        `_draw_ps` is just supplying properties and clipping.\n        \"\"\"\n        write = self._pswriter.write\n        mightstroke = (gc.get_linewidth() > 0\n                       and not self._is_transparent(gc.get_rgb()))\n        if not mightstroke:\n            stroke = False\n        if self._is_transparent(rgbFace):\n            fill = False\n        hatch = gc.get_hatch()\n\n        if mightstroke:\n            self.set_linewidth(gc.get_linewidth())\n            self.set_linejoin(gc.get_joinstyle())\n            self.set_linecap(gc.get_capstyle())\n            self.set_linedash(*gc.get_dashes())\n        if mightstroke or hatch:\n            self.set_color(*gc.get_rgb()[:3])\n        write('gsave\\n')\n\n        write(self._get_clip_cmd(gc))\n\n        write(ps.strip())\n        write(\"\\n\")\n\n        if fill:\n            if stroke or hatch:\n                write(\"gsave\\n\")\n            self.set_color(*rgbFace[:3], store=False)\n            write(\"fill\\n\")\n            if stroke or hatch:\n                write(\"grestore\\n\")\n\n        if hatch:\n            hatch_name = self.create_hatch(hatch)\n            write(\"gsave\\n\")\n            write(\"%f %f %f \" % gc.get_hatch_color()[:3])\n            write(\"%s setpattern fill grestore\\n\" % hatch_name)\n\n        if stroke:\n            write(\"stroke\\n\")\n\n        write(\"grestore\\n\")",
      "instance_attributes": [
        {
          "name": "_pswriter",
          "types": null
        },
        {
          "name": "textcnt",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "psfrag",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "imagedpi",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "color",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "linewidth",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "linejoin",
          "types": null
        },
        {
          "name": "linecap",
          "types": null
        },
        {
          "name": "linedash",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "fontname",
          "types": null
        },
        {
          "name": "fontsize",
          "types": null
        },
        {
          "name": "_hatches",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "image_magnification",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "_clip_paths",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_path_collection_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_character_tracker",
          "types": null
        },
        {
          "name": "_logwarn_once",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt",
      "name": "ConfigureSubplotsQt",
      "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.ConfigureSubplotsBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConfigureSubplotsQt(backend_tools.ConfigureSubplotsBase):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._subplot_dialog = None\n\n    def trigger(self, *args):\n        NavigationToolbar2QT.configure_subplots(self)",
      "instance_attributes": [
        {
          "name": "_subplot_dialog",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT",
      "name": "FigureCanvasQT",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase",
        "QtWidgets.QWidget"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/_update_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/_update_screen",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/showEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseEventCoords",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/enterEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/leaveEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mousePressEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseDoubleClickEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseMoveEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseReleaseEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/wheelEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyPressEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyReleaseEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/resizeEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/sizeHint",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/minumumSizeHint",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/_get_key",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/flush_events",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/start_event_loop",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/stop_event_loop",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/blit",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/_draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/drawRectangle"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasQT(FigureCanvasBase, QtWidgets.QWidget):\n    required_interactive_framework = \"qt\"\n    _timer_cls = TimerQT\n    manager_class = _api.classproperty(lambda cls: FigureManagerQT)\n\n    buttond = {\n        getattr(_enum(\"QtCore.Qt.MouseButton\"), k): v for k, v in [\n            (\"LeftButton\", MouseButton.LEFT),\n            (\"RightButton\", MouseButton.RIGHT),\n            (\"MiddleButton\", MouseButton.MIDDLE),\n            (\"XButton1\", MouseButton.BACK),\n            (\"XButton2\", MouseButton.FORWARD),\n        ]\n    }\n\n    def __init__(self, figure=None):\n        _create_qApp()\n        super().__init__(figure=figure)\n\n        self._draw_pending = False\n        self._is_drawing = False\n        self._draw_rect_callback = lambda painter: None\n        self._in_resize_event = False\n\n        self.setAttribute(\n            _enum(\"QtCore.Qt.WidgetAttribute\").WA_OpaquePaintEvent)\n        self.setMouseTracking(True)\n        self.resize(*self.get_width_height())\n\n        palette = QtGui.QPalette(QtGui.QColor(\"white\"))\n        self.setPalette(palette)\n\n    def _update_pixel_ratio(self):\n        if self._set_device_pixel_ratio(_devicePixelRatioF(self)):\n            # The easiest way to resize the canvas is to emit a resizeEvent\n            # since we implement all the logic for resizing the canvas for\n            # that event.\n            event = QtGui.QResizeEvent(self.size(), self.size())\n            self.resizeEvent(event)\n\n    def _update_screen(self, screen):\n        # Handler for changes to a window's attached screen.\n        self._update_pixel_ratio()\n        if screen is not None:\n            screen.physicalDotsPerInchChanged.connect(self._update_pixel_ratio)\n            screen.logicalDotsPerInchChanged.connect(self._update_pixel_ratio)\n\n    def showEvent(self, event):\n        # Set up correct pixel ratio, and connect to any signal changes for it,\n        # once the window is shown (and thus has these attributes).\n        window = self.window().windowHandle()\n        window.screenChanged.connect(self._update_screen)\n        self._update_screen(window.screen())\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        self.setCursor(_api.check_getitem(cursord, cursor=cursor))\n\n    def mouseEventCoords(self, pos=None):\n        \"\"\"\n        Calculate mouse coordinates in physical pixels.\n\n        Qt uses logical pixels, but the figure is scaled to physical\n        pixels for rendering.  Transform to physical pixels so that\n        all of the down-stream transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        if pos is None:\n            pos = self.mapFromGlobal(QtGui.QCursor.pos())\n        elif hasattr(pos, \"position\"):  # qt6 QtGui.QEvent\n            pos = pos.position()\n        elif hasattr(pos, \"pos\"):  # qt5 QtCore.QEvent\n            pos = pos.pos()\n        # (otherwise, it's already a QPoint)\n        x = pos.x()\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height / self.device_pixel_ratio - pos.y()\n        return x * self.device_pixel_ratio, y * self.device_pixel_ratio\n\n    def enterEvent(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self.mouseEventCoords(event),\n                      guiEvent=event)._process()\n\n    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        LocationEvent(\"figure_leave_event\", self,\n                      *self.mouseEventCoords(),\n                      guiEvent=event)._process()\n\n    def mousePressEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       guiEvent=event)._process()\n\n    def mouseDoubleClickEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       guiEvent=event)._process()\n\n    def mouseMoveEvent(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   guiEvent=event)._process()\n\n    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       guiEvent=event)._process()\n\n    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is sometimes not\n        # provided (`isNull()`) and is unreliable on X11 (\"xcb\").\n        if (event.pixelDelta().isNull()\n                or QtWidgets.QApplication.instance().platformName() == \"xcb\"):\n            steps = event.angleDelta().y() / 120\n        else:\n            steps = event.pixelDelta().y()\n        if steps:\n            MouseEvent(\"scroll_event\", self,\n                       *self.mouseEventCoords(event), step=steps,\n                       guiEvent=event)._process()\n\n    def keyPressEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            KeyEvent(\"key_press_event\", self,\n                     key, *self.mouseEventCoords(),\n                     guiEvent=event)._process()\n\n    def keyReleaseEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            KeyEvent(\"key_release_event\", self,\n                     key, *self.mouseEventCoords(),\n                     guiEvent=event)._process()\n\n    def resizeEvent(self, event):\n        if self._in_resize_event:  # Prevent PyQt6 recursion\n            return\n        self._in_resize_event = True\n        try:\n            w = event.size().width() * self.device_pixel_ratio\n            h = event.size().height() * self.device_pixel_ratio\n            dpival = self.figure.dpi\n            winch = w / dpival\n            hinch = h / dpival\n            self.figure.set_size_inches(winch, hinch, forward=False)\n            # pass back into Qt to let it finish\n            QtWidgets.QWidget.resizeEvent(self, event)\n            # emit our resize events\n            ResizeEvent(\"resize_event\", self)._process()\n            self.draw_idle()\n        finally:\n            self._in_resize_event = False\n\n    def sizeHint(self):\n        w, h = self.get_width_height()\n        return QtCore.QSize(w, h)\n\n    def minumumSizeHint(self):\n        return QtCore.QSize(10, 10)\n\n    def _get_key(self, event):\n        event_key = event.key()\n        event_mods = _to_int(event.modifiers())  # actually a bitmask\n\n        # get names of the pressed modifier keys\n        # 'control' is named 'control' when a standalone key, but 'ctrl' when a\n        # modifier\n        # bit twiddling to pick out modifier keys from event_mods bitmask,\n        # if event_key is a MODIFIER, it should not be duplicated in mods\n        mods = [SPECIAL_KEYS[key].replace('control', 'ctrl')\n                for mod, key in _MODIFIER_KEYS\n                if event_key != key and event_mods & mod]\n        try:\n            # for certain keys (enter, left, backspace, etc) use a word for the\n            # key, rather than Unicode\n            key = SPECIAL_KEYS[event_key]\n        except KeyError:\n            # Unicode defines code points up to 0x10ffff (sys.maxunicode)\n            # QT will use Key_Codes larger than that for keyboard keys that are\n            # are not Unicode characters (like multimedia keys)\n            # skip these\n            # if you really want them, you should add them to SPECIAL_KEYS\n            if event_key > sys.maxunicode:\n                return None\n\n            key = chr(event_key)\n            # qt delivers capitalized letters.  fix capitalization\n            # note that capslock is ignored\n            if 'shift' in mods:\n                mods.remove('shift')\n            else:\n                key = key.lower()\n\n        return '+'.join(mods + [key])\n\n    def flush_events(self):\n        # docstring inherited\n        QtWidgets.QApplication.instance().processEvents()\n\n    def start_event_loop(self, timeout=0):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\") and self._event_loop.isRunning():\n            raise RuntimeError(\"Event loop already running\")\n        self._event_loop = event_loop = QtCore.QEventLoop()\n        if timeout > 0:\n            _ = QtCore.QTimer.singleShot(int(timeout * 1000), event_loop.quit)\n\n        with _maybe_allow_interrupt(event_loop):\n            qt_compat._exec(event_loop)\n\n    def stop_event_loop(self, event=None):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\"):\n            self._event_loop.quit()\n\n    def draw(self):\n        \"\"\"Render the figure, and queue a request for a Qt draw.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()\n\n    def draw_idle(self):\n        \"\"\"Queue redraw of the Agg buffer and request Qt paintEvent.\"\"\"\n        # The Agg draw needs to be handled by the same thread Matplotlib\n        # modifies the scene graph from. Post Agg draw request to the\n        # current event loop in order to ensure thread affinity and to\n        # accumulate multiple draw requests from event handling.\n        # TODO: queued signal connection might be safer than singleShot\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            QtCore.QTimer.singleShot(0, self._draw_idle)\n\n    def blit(self, bbox=None):\n        # docstring inherited\n        if bbox is None and self.figure:\n            bbox = self.figure.bbox  # Blit the entire canvas if bbox is None.\n        # repaint uses logical pixels, not physical pixels like the renderer.\n        l, b, w, h = [int(pt / self.device_pixel_ratio) for pt in bbox.bounds]\n        t = b + h\n        self.repaint(l, self.rect().height() - t, w, h)\n\n    def _draw_idle(self):\n        with self._idle_draw_cntx():\n            if not self._draw_pending:\n                return\n            self._draw_pending = False\n            if self.height() < 0 or self.width() < 0:\n                return\n            try:\n                self.draw()\n            except Exception:\n                # Uncaught exceptions are fatal for PyQt5, so catch them.\n                traceback.print_exc()\n\n    def drawRectangle(self, rect):\n        # Draw the zoom rectangle to the QPainter.  _draw_rect_callback needs\n        # to be called at the end of paintEvent.\n        if rect is not None:\n            x0, y0, w, h = [int(pt / self.device_pixel_ratio) for pt in rect]\n            x1 = x0 + w\n            y1 = y0 + h\n            def _draw_rect_callback(painter):\n                pen = QtGui.QPen(\n                    QtGui.QColor(\"black\"),\n                    1 / self.device_pixel_ratio\n                )\n\n                pen.setDashPattern([3, 3])\n                for color, offset in [\n                        (QtGui.QColor(\"black\"), 0),\n                        (QtGui.QColor(\"white\"), 3),\n                ]:\n                    pen.setDashOffset(offset)\n                    pen.setColor(color)\n                    painter.setPen(pen)\n                    # Draw the lines from x0, y0 towards x1, y1 so that the\n                    # dashes don't \"jump\" when moving the zoom box.\n                    painter.drawLine(x0, y0, x0, y1)\n                    painter.drawLine(x0, y0, x1, y0)\n                    painter.drawLine(x0, y1, x1, y1)\n                    painter.drawLine(x1, y0, x1, y1)\n        else:\n            def _draw_rect_callback(painter):\n                return\n        self._draw_rect_callback = _draw_rect_callback\n        self.update()",
      "instance_attributes": [
        {
          "name": "_draw_pending",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_is_drawing",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_draw_rect_callback",
          "types": {
            "kind": "NamedType",
            "name": "Callable"
          }
        },
        {
          "name": "_in_resize_event",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_event_loop",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT",
      "name": "FigureManagerQT",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/full_screen_toggle",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/_widgetclosed",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/show",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/destroy",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/get_window_title",
        "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/set_window_title"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Attributes\n----------\ncanvas : `FigureCanvas`\n    The FigureCanvas instance\nnum : int or str\n    The Figure number\ntoolbar : qt.QToolBar\n    The qt.QToolBar\nwindow : qt.QMainWindow\n    The qt.QMainWindow",
      "code": "class FigureManagerQT(FigureManagerBase):\n    \"\"\"\n    Attributes\n    ----------\n    canvas : `FigureCanvas`\n        The FigureCanvas instance\n    num : int or str\n        The Figure number\n    toolbar : qt.QToolBar\n        The qt.QToolBar\n    window : qt.QMainWindow\n        The qt.QMainWindow\n    \"\"\"\n\n    def __init__(self, canvas, num):\n        self.window = MainWindow()\n        super().__init__(canvas, num)\n        self.window.closing.connect(\n            # The lambda prevents the event from being immediately gc'd.\n            lambda: CloseEvent(\"close_event\", self.canvas)._process())\n        self.window.closing.connect(self._widgetclosed)\n\n        if sys.platform != \"darwin\":\n            image = str(cbook._get_data_path('images/matplotlib.svg'))\n            icon = QtGui.QIcon(image)\n            self.window.setWindowIcon(icon)\n\n        self.window._destroying = False\n\n        if self.toolbar:\n            self.window.addToolBar(self.toolbar)\n            tbs_height = self.toolbar.sizeHint().height()\n        else:\n            tbs_height = 0\n\n        # resize the main window so it will display the canvas with the\n        # requested size:\n        cs = canvas.sizeHint()\n        cs_height = cs.height()\n        height = cs_height + tbs_height\n        self.window.resize(cs.width(), height)\n\n        self.window.setCentralWidget(self.canvas)\n\n        if mpl.is_interactive():\n            self.window.show()\n            self.canvas.draw_idle()\n\n        # Give the keyboard focus to the figure instead of the manager:\n        # StrongFocus accepts both tab and click to focus and will enable the\n        # canvas to process event without clicking.\n        # https://doc.qt.io/qt-5/qt.html#FocusPolicy-enum\n        self.canvas.setFocusPolicy(_enum(\"QtCore.Qt.FocusPolicy\").StrongFocus)\n        self.canvas.setFocus()\n\n        self.window.raise_()\n\n    def full_screen_toggle(self):\n        if self.window.isFullScreen():\n            self.window.showNormal()\n        else:\n            self.window.showFullScreen()\n\n    def _widgetclosed(self):\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        try:\n            Gcf.destroy(self)\n        except AttributeError:\n            pass\n            # It seems that when the python session is killed,\n            # Gcf can get destroyed before the Gcf.destroy\n            # line is run, leading to a useless AttributeError.\n\n    def resize(self, width, height):\n        # The Qt methods return sizes in 'virtual' pixels so we do need to\n        # rescale from physical to logical pixels.\n        width = int(width / self.canvas.device_pixel_ratio)\n        height = int(height / self.canvas.device_pixel_ratio)\n        extra_width = self.window.width() - self.canvas.width()\n        extra_height = self.window.height() - self.canvas.height()\n        self.canvas.resize(width, height)\n        self.window.resize(width + extra_width, height + extra_height)\n\n    def show(self):\n        self.window.show()\n        if mpl.rcParams['figure.raise_window']:\n            self.window.activateWindow()\n            self.window.raise_()\n\n    def destroy(self, *args):\n        # check for qApp first, as PySide deletes it in its atexit handler\n        if QtWidgets.QApplication.instance() is None:\n            return\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        if self.toolbar:\n            self.toolbar.destroy()\n        self.window.close()\n\n    def get_window_title(self):\n        return self.window.windowTitle()\n\n    def set_window_title(self, title):\n        self.window.setWindowTitle(title)",
      "instance_attributes": [
        {
          "name": "window",
          "types": {
            "kind": "NamedType",
            "name": "MainWindow"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt",
      "name": "HelpQt",
      "qname": "lib.matplotlib.backends.backend_qt.HelpQt",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpQt(backend_tools.ToolHelpBase):\n    def trigger(self, *args):\n        QtWidgets.QMessageBox.information(None, \"Help\", self._get_help_html())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow",
      "name": "MainWindow",
      "qname": "lib.matplotlib.backends.backend_qt.MainWindow",
      "decorators": [],
      "superclasses": [
        "QtWidgets.QMainWindow"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow/closeEvent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class MainWindow(QtWidgets.QMainWindow):\n    closing = QtCore.Signal()\n\n    def closeEvent(self, event):\n        self.closing.emit()\n        super().closeEvent(event)",
      "instance_attributes": [
        {
          "name": "_destroying",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT",
      "name": "NavigationToolbar2QT",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2",
        "QtWidgets.QToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/_icon",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/edit_parameters",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/_update_buttons_checked",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/pan",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/zoom",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_message",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/configure_subplots",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):\n    message = QtCore.Signal(str)\n\n    toolitems = [*NavigationToolbar2.toolitems]\n    toolitems.insert(\n        # Add 'customize' action after 'subplots'\n        [name for name, *_ in toolitems].index(\"Subplots\") + 1,\n        (\"Customize\", \"Edit axis, curve and image parameters\",\n         \"qt4_editor_options\", \"edit_parameters\"))\n\n    def __init__(self, canvas, parent=None, coordinates=True):\n        \"\"\"coordinates: should we show the coordinates on the right?\"\"\"\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(QtCore.Qt.ToolBarArea(\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").TopToolBarArea) |\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").BottomToolBarArea)))\n\n        self.coordinates = coordinates\n        self._actions = {}  # mapping of toolitem method names to QActions.\n        self._subplot_dialog = None\n\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.addSeparator()\n            else:\n                a = self.addAction(self._icon(image_file + '.png'),\n                                   text, getattr(self, callback))\n                self._actions[callback] = a\n                if callback in ['zoom', 'pan']:\n                    a.setCheckable(True)\n                if tooltip_text is not None:\n                    a.setToolTip(tooltip_text)\n\n        # Add the (x, y) location widget at the right side of the toolbar\n        # The stretch factor is 1 which means any resizing of the toolbar\n        # will resize this label instead of the buttons.\n        if self.coordinates:\n            self.locLabel = QtWidgets.QLabel(\"\", self)\n            self.locLabel.setAlignment(QtCore.Qt.AlignmentFlag(\n                _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignRight) |\n                _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignVCenter)))\n            self.locLabel.setSizePolicy(QtWidgets.QSizePolicy(\n                _enum(\"QtWidgets.QSizePolicy.Policy\").Expanding,\n                _enum(\"QtWidgets.QSizePolicy.Policy\").Ignored,\n            ))\n            labelAction = self.addWidget(self.locLabel)\n            labelAction.setVisible(True)\n\n        NavigationToolbar2.__init__(self, canvas)\n\n    def _icon(self, name):\n        \"\"\"\n        Construct a `.QIcon` from an image file *name*, including the extension\n        and relative to Matplotlib's \"images\" data directory.\n        \"\"\"\n        # use a high-resolution icon with suffix '_large' if available\n        # note: user-provided icons may not have '_large' versions\n        path_regular = cbook._get_data_path('images', name)\n        path_large = path_regular.with_name(\n            path_regular.name.replace('.png', '_large.png'))\n        filename = str(path_large if path_large.exists() else path_regular)\n\n        pm = QtGui.QPixmap(filename)\n        _setDevicePixelRatio(pm, _devicePixelRatioF(self))\n        if self.palette().color(self.backgroundRole()).value() < 128:\n            icon_color = self.palette().color(self.foregroundRole())\n            mask = pm.createMaskFromColor(\n                QtGui.QColor('black'),\n                _enum(\"QtCore.Qt.MaskMode\").MaskOutColor)\n            pm.fill(icon_color)\n            pm.setMask(mask)\n        return QtGui.QIcon(pm)\n\n    def edit_parameters(self):\n        axes = self.canvas.figure.get_axes()\n        if not axes:\n            QtWidgets.QMessageBox.warning(\n                self.canvas.parent(), \"Error\", \"There are no axes to edit.\")\n            return\n        elif len(axes) == 1:\n            ax, = axes\n        else:\n            titles = [\n                ax.get_label() or\n                ax.get_title() or\n                ax.get_title(\"left\") or\n                ax.get_title(\"right\") or\n                \" - \".join(filter(None, [ax.get_xlabel(), ax.get_ylabel()])) or\n                f\"<anonymous {type(ax).__name__}>\"\n                for ax in axes]\n            duplicate_titles = [\n                title for title in titles if titles.count(title) > 1]\n            for i, ax in enumerate(axes):\n                if titles[i] in duplicate_titles:\n                    titles[i] += f\" (id: {id(ax):#x})\"  # Deduplicate titles.\n            item, ok = QtWidgets.QInputDialog.getItem(\n                self.canvas.parent(),\n                'Customize', 'Select axes:', titles, 0, False)\n            if not ok:\n                return\n            ax = axes[titles.index(item)]\n        figureoptions.figure_edit(ax, self)\n\n    def _update_buttons_checked(self):\n        # sync button checkstates to match active mode\n        if 'pan' in self._actions:\n            self._actions['pan'].setChecked(self.mode.name == 'PAN')\n        if 'zoom' in self._actions:\n            self._actions['zoom'].setChecked(self.mode.name == 'ZOOM')\n\n    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()\n\n    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()\n\n    def set_message(self, s):\n        self.message.emit(s)\n        if self.coordinates:\n            self.locLabel.setText(s)\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas.drawRectangle(rect)\n\n    def remove_rubberband(self):\n        self.canvas.drawRectangle(None)\n\n    def configure_subplots(self):\n        if self._subplot_dialog is None:\n            self._subplot_dialog = SubplotToolQt(\n                self.canvas.figure, self.canvas.parent())\n            self.canvas.mpl_connect(\n                \"close_event\", lambda e: self._subplot_dialog.reject())\n        self._subplot_dialog.update_from_current_subplotpars()\n        self._subplot_dialog.show()\n        return self._subplot_dialog\n\n    def save_figure(self, *args):\n        filetypes = self.canvas.get_supported_filetypes_grouped()\n        sorted_filetypes = sorted(filetypes.items())\n        default_filetype = self.canvas.get_default_filetype()\n\n        startpath = os.path.expanduser(mpl.rcParams['savefig.directory'])\n        start = os.path.join(startpath, self.canvas.get_default_filename())\n        filters = []\n        selectedFilter = None\n        for name, exts in sorted_filetypes:\n            exts_list = \" \".join(['*.%s' % ext for ext in exts])\n            filter = '%s (%s)' % (name, exts_list)\n            if default_filetype in exts:\n                selectedFilter = filter\n            filters.append(filter)\n        filters = ';;'.join(filters)\n\n        fname, filter = qt_compat._getSaveFileName(\n            self.canvas.parent(), \"Choose a filename to save to\", start,\n            filters, selectedFilter)\n        if fname:\n            # Save dir for next time, unless empty str (i.e., use cwd).\n            if startpath != \"\":\n                mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n            try:\n                self.canvas.figure.savefig(fname)\n            except Exception as e:\n                QtWidgets.QMessageBox.critical(\n                    self, \"Error saving file\", str(e),\n                    _enum(\"QtWidgets.QMessageBox.StandardButton\").Ok,\n                    _enum(\"QtWidgets.QMessageBox.StandardButton\").NoButton)\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'back' in self._actions:\n            self._actions['back'].setEnabled(can_backward)\n        if 'forward' in self._actions:\n            self._actions['forward'].setEnabled(can_forward)",
      "instance_attributes": [
        {
          "name": "coordinates",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_actions",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_subplot_dialog",
          "types": {
            "kind": "NamedType",
            "name": "SubplotToolQt"
          }
        },
        {
          "name": "locLabel",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt",
      "name": "RubberbandQt",
      "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.RubberbandBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/remove_rubberband"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RubberbandQt(backend_tools.RubberbandBase):\n    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2QT.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)\n\n    def remove_rubberband(self):\n        NavigationToolbar2QT.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt",
      "name": "SaveFigureQt",
      "qname": "lib.matplotlib.backends.backend_qt.SaveFigureQt",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureQt(backend_tools.SaveFigureBase):\n    def trigger(self, *args):\n        NavigationToolbar2QT.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt",
      "name": "SetCursorQt",
      "qname": "lib.matplotlib.backends.backend_qt.SetCursorQt",
      "decorators": [
        "_api.deprecated('3.5', alternative='ToolSetCursor')"
      ],
      "superclasses": [
        "backend_tools.SetCursorBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt/set_cursor"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SetCursorQt(backend_tools.SetCursorBase):\n    def set_cursor(self, cursor):\n        NavigationToolbar2QT.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt",
      "name": "SubplotToolQt",
      "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt",
      "decorators": [],
      "superclasses": [
        "QtWidgets.QDialog"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/update_from_current_subplotpars",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/_export_values",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/_on_value_changed",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/_tight_layout",
        "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/_reset"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SubplotToolQt(QtWidgets.QDialog):\n    def __init__(self, targetfig, parent):\n        super().__init__()\n        self.setWindowIcon(QtGui.QIcon(\n            str(cbook._get_data_path(\"images/matplotlib.png\"))))\n        self.setObjectName(\"SubplotTool\")\n        self._spinboxes = {}\n        main_layout = QtWidgets.QHBoxLayout()\n        self.setLayout(main_layout)\n        for group, spinboxes, buttons in [\n                (\"Borders\",\n                 [\"top\", \"bottom\", \"left\", \"right\"],\n                 [(\"Export values\", self._export_values)]),\n                (\"Spacings\",\n                 [\"hspace\", \"wspace\"],\n                 [(\"Tight layout\", self._tight_layout),\n                  (\"Reset\", self._reset),\n                  (\"Close\", self.close)])]:\n            layout = QtWidgets.QVBoxLayout()\n            main_layout.addLayout(layout)\n            box = QtWidgets.QGroupBox(group)\n            layout.addWidget(box)\n            inner = QtWidgets.QFormLayout(box)\n            for name in spinboxes:\n                self._spinboxes[name] = spinbox = QtWidgets.QDoubleSpinBox()\n                spinbox.setRange(0, 1)\n                spinbox.setDecimals(3)\n                spinbox.setSingleStep(0.005)\n                spinbox.setKeyboardTracking(False)\n                spinbox.valueChanged.connect(self._on_value_changed)\n                inner.addRow(name, spinbox)\n            layout.addStretch(1)\n            for name, method in buttons:\n                button = QtWidgets.QPushButton(name)\n                # Don't trigger on <enter>, which is used to input values.\n                button.setAutoDefault(False)\n                button.clicked.connect(method)\n                layout.addWidget(button)\n                if name == \"Close\":\n                    button.setFocus()\n        self._figure = targetfig\n        self._defaults = {}\n        self._export_values_dialog = None\n        self.update_from_current_subplotpars()\n\n    def update_from_current_subplotpars(self):\n        self._defaults = {spinbox: getattr(self._figure.subplotpars, name)\n                          for name, spinbox in self._spinboxes.items()}\n        self._reset()  # Set spinbox current values without triggering signals.\n\n    def _export_values(self):\n        # Explicitly round to 3 decimals (which is also the spinbox precision)\n        # to avoid numbers of the form 0.100...001.\n        self._export_values_dialog = QtWidgets.QDialog()\n        layout = QtWidgets.QVBoxLayout()\n        self._export_values_dialog.setLayout(layout)\n        text = QtWidgets.QPlainTextEdit()\n        text.setReadOnly(True)\n        layout.addWidget(text)\n        text.setPlainText(\n            \",\\n\".join(f\"{attr}={spinbox.value():.3}\"\n                       for attr, spinbox in self._spinboxes.items()))\n        # Adjust the height of the text widget to fit the whole text, plus\n        # some padding.\n        size = text.maximumSize()\n        size.setHeight(\n            QtGui.QFontMetrics(text.document().defaultFont())\n            .size(0, text.toPlainText()).height() + 20)\n        text.setMaximumSize(size)\n        self._export_values_dialog.show()\n\n    def _on_value_changed(self):\n        spinboxes = self._spinboxes\n        # Set all mins and maxes, so that this can also be used in _reset().\n        for lower, higher in [(\"bottom\", \"top\"), (\"left\", \"right\")]:\n            spinboxes[higher].setMinimum(spinboxes[lower].value() + .001)\n            spinboxes[lower].setMaximum(spinboxes[higher].value() - .001)\n        self._figure.subplots_adjust(\n            **{attr: spinbox.value() for attr, spinbox in spinboxes.items()})\n        self._figure.canvas.draw_idle()\n\n    def _tight_layout(self):\n        self._figure.tight_layout()\n        for attr, spinbox in self._spinboxes.items():\n            spinbox.blockSignals(True)\n            spinbox.setValue(vars(self._figure.subplotpars)[attr])\n            spinbox.blockSignals(False)\n        self._figure.canvas.draw_idle()\n\n    def _reset(self):\n        for spinbox, value in self._defaults.items():\n            spinbox.setRange(0, 1)\n            spinbox.blockSignals(True)\n            spinbox.setValue(value)\n            spinbox.blockSignals(False)\n        self._on_value_changed()",
      "instance_attributes": [
        {
          "name": "_spinboxes",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_figure",
          "types": null
        },
        {
          "name": "_defaults",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_export_values_dialog",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT",
      "name": "TimerQT",
      "qname": "lib.matplotlib.backends.backend_qt.TimerQT",
      "decorators": [],
      "superclasses": [
        "TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__del__",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/_timer_set_single_shot",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/_timer_set_interval",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/_timer_stop"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using QTimer events.",
      "docstring": "Subclass of `.TimerBase` using QTimer events.",
      "code": "class TimerQT(TimerBase):\n    \"\"\"Subclass of `.TimerBase` using QTimer events.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # Create a new timer and connect the timeout() signal to the\n        # _on_timer method.\n        self._timer = QtCore.QTimer()\n        self._timer.timeout.connect(self._on_timer)\n        super().__init__(*args, **kwargs)\n\n    def __del__(self):\n        # The check for deletedness is needed to avoid an error at animation\n        # shutdown with PySide2.\n        if not _isdeleted(self._timer):\n            self._timer_stop()\n\n    def _timer_set_single_shot(self):\n        self._timer.setSingleShot(self._single)\n\n    def _timer_set_interval(self):\n        self._timer.setInterval(self._interval)\n\n    def _timer_start(self):\n        self._timer.start()\n\n    def _timer_stop(self):\n        self._timer.stop()",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT",
      "name": "ToolCopyToClipboardQT",
      "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT",
      "decorators": [
        "backend_tools._register_tool_class(FigureCanvasQT)"
      ],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardQT(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        pixmap = self.canvas.grab()\n        QtWidgets.QApplication.instance().clipboard().setPixmap(pixmap)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt",
      "name": "ToolbarQt",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "QtWidgets.QToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/_add_to_group",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarQt(ToolContainerBase, QtWidgets.QToolBar):\n    def __init__(self, toolmanager, parent=None):\n        ToolContainerBase.__init__(self, toolmanager)\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(QtCore.Qt.ToolBarArea(\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").TopToolBarArea) |\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").BottomToolBarArea)))\n        message_label = QtWidgets.QLabel(\"\")\n        message_label.setAlignment(QtCore.Qt.AlignmentFlag(\n            _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignRight) |\n            _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignVCenter)))\n        message_label.setSizePolicy(QtWidgets.QSizePolicy(\n            _enum(\"QtWidgets.QSizePolicy.Policy\").Expanding,\n            _enum(\"QtWidgets.QSizePolicy.Policy\").Ignored,\n        ))\n        self._message_action = self.addWidget(message_label)\n        self._toolitems = {}\n        self._groups = {}\n\n    def add_toolitem(\n            self, name, group, position, image_file, description, toggle):\n\n        button = QtWidgets.QToolButton(self)\n        if image_file:\n            button.setIcon(NavigationToolbar2QT._icon(self, image_file))\n        button.setText(name)\n        if description:\n            button.setToolTip(description)\n\n        def handler():\n            self.trigger_tool(name)\n        if toggle:\n            button.setCheckable(True)\n            button.toggled.connect(handler)\n        else:\n            button.clicked.connect(handler)\n\n        self._toolitems.setdefault(name, [])\n        self._add_to_group(group, name, button, position)\n        self._toolitems[name].append((button, handler))\n\n    def _add_to_group(self, group, name, button, position):\n        gr = self._groups.get(group, [])\n        if not gr:\n            sep = self.insertSeparator(self._message_action)\n            gr.append(sep)\n        before = gr[position]\n        widget = self.insertWidget(before, button)\n        gr.insert(position, widget)\n        self._groups[group] = gr\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for button, handler in self._toolitems[name]:\n            button.toggled.disconnect(handler)\n            button.setChecked(toggled)\n            button.toggled.connect(handler)\n\n    def remove_toolitem(self, name):\n        for button, handler in self._toolitems[name]:\n            button.setParent(None)\n        del self._toolitems[name]\n\n    def set_message(self, s):\n        self.widgetForAction(self._message_action).setText(s)",
      "instance_attributes": [
        {
          "name": "_message_action",
          "types": null
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_qt.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    qApp = _api.deprecated(\n        \"3.6\", alternative=\"QtWidgets.QApplication.instance()\")(\n            property(lambda self: QtWidgets.QApplication.instance()))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg",
      "name": "FigureCanvasQTAgg",
      "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "FigureCanvasQT"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/paintEvent",
        "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasQTAgg(FigureCanvasAgg, FigureCanvasQT):\n\n    def paintEvent(self, event):\n        \"\"\"\n        Copy the image from the Agg canvas to the qt.drawable.\n\n        In Qt, all drawing should be done inside of here when a widget is\n        shown onscreen.\n        \"\"\"\n        self._draw_idle()  # Only does something if a draw is pending.\n\n        # If the canvas does not have a renderer, then give up and wait for\n        # FigureCanvasAgg.draw(self) to be called.\n        if not hasattr(self, 'renderer'):\n            return\n\n        painter = QtGui.QPainter(self)\n        try:\n            # See documentation of QRect: bottom() and right() are off\n            # by 1, so use left() + width() and top() + height().\n            rect = event.rect()\n            # scale rect dimensions using the screen dpi ratio to get\n            # correct values for the Figure coordinates (rather than\n            # QT5's coords)\n            width = rect.width() * self.device_pixel_ratio\n            height = rect.height() * self.device_pixel_ratio\n            left, top = self.mouseEventCoords(rect.topLeft())\n            # shift the \"top\" by the height of the image to get the\n            # correct corner for our coordinate system\n            bottom = top - height\n            # same with the right side of the image\n            right = left + width\n            # create a buffer using the image bounding box\n            bbox = Bbox([[left, bottom], [right, top]])\n            reg = self.copy_from_bbox(bbox)\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                memoryview(reg))\n\n            # clear the widget canvas\n            painter.eraseRect(rect)\n\n            if QT_API == \"PyQt6\":\n                from PyQt6 import sip\n                ptr = int(sip.voidptr(buf))\n            else:\n                ptr = buf\n            qimage = QtGui.QImage(\n                ptr, buf.shape[1], buf.shape[0],\n                _enum(\"QtGui.QImage.Format\").Format_ARGB32_Premultiplied)\n            _setDevicePixelRatio(qimage, self.device_pixel_ratio)\n            # set origin using original QT coordinates\n            origin = QtCore.QPoint(rect.left(), rect.top())\n            painter.drawImage(origin, qimage)\n            # Adjust the buf reference count to work around a memory\n            # leak bug in QImage under PySide.\n            if QT_API in ('PySide', 'PySide2'):\n                if QtCore.__version_info__ < (5, 12):\n                    ctypes.c_long.from_address(id(buf)).value = 1\n\n            self._draw_rect_callback(painter)\n        finally:\n            painter.end()\n\n    def print_figure(self, *args, **kwargs):\n        super().print_figure(*args, **kwargs)\n        self.draw()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo",
      "name": "FigureCanvasQTCairo",
      "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "FigureCanvasQT"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/draw",
        "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/paintEvent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasQTCairo(FigureCanvasCairo, FigureCanvasQT):\n    def draw(self):\n        if hasattr(self._renderer.gc, \"ctx\"):\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        super().draw()\n\n    def paintEvent(self, event):\n        width = int(self.device_pixel_ratio * self.width())\n        height = int(self.device_pixel_ratio * self.height())\n        if (width, height) != self._renderer.get_canvas_width_height():\n            surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n            self._renderer.set_context(cairo.Context(surface))\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        buf = self._renderer.gc.ctx.get_target().get_data()\n        if QT_API == \"PyQt6\":\n            from PyQt6 import sip\n            ptr = int(sip.voidptr(buf))\n        else:\n            ptr = buf\n        qimage = QtGui.QImage(\n            ptr, width, height,\n            _enum(\"QtGui.QImage.Format\").Format_ARGB32_Premultiplied)\n        # Adjust the buf reference count to work around a memory leak bug in\n        # QImage under PySide.\n        if QT_API in ('PySide', 'PySide2'):\n            if QtCore.__version_info__ < (5, 12):\n                ctypes.c_long.from_address(id(buf)).value = 1\n        _setDevicePixelRatio(qimage, self.device_pixel_ratio)\n        painter = QtGui.QPainter(self)\n        painter.eraseRect(event.rect())\n        painter.drawImage(0, 0, qimage)\n        self._draw_rect_callback(painter)\n        painter.end()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG",
      "name": "FigureCanvasSVG",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg",
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz",
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasSVG(FigureCanvasBase):\n    filetypes = {'svg': 'Scalable Vector Graphics',\n                 'svgz': 'Scalable Vector Graphics'}\n\n    fixed_dpi = 72\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_svg(self, filename, *args, bbox_inches_restore=None,\n                  metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n\n        metadata : dict[str, Any], optional\n            Metadata in the SVG file defined as key-value pairs of strings,\n            datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n            'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n            The standard keys and their value types are:\n\n            * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n              ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n              ``'Title'``, and ``'Type'``.\n            * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n              ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n            * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n              non-*str*, then it will be formatted as ISO 8601.\n\n            Values have been predefined for ``'Creator'``, ``'Date'``,\n            ``'Format'``, and ``'Type'``. They can be removed by setting them\n            to `None`.\n\n            Information is encoded as `Dublin Core Metadata`__.\n\n            .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n            __ DC_\n        \"\"\"\n        with cbook.open_file_cm(filename, \"w\", encoding=\"utf-8\") as fh:\n            if not cbook.file_requires_unicode(fh):\n                fh = codecs.getwriter('utf-8')(fh)\n            dpi = self.figure.dpi\n            self.figure.dpi = 72\n            width, height = self.figure.get_size_inches()\n            w, h = width * 72, height * 72\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererSVG(w, h, fh, image_dpi=dpi, metadata=metadata),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_svgz(self, filename, *args, **kwargs):\n        with cbook.open_file_cm(filename, \"wb\") as fh, \\\n                gzip.GzipFile(mode='w', fileobj=fh) as gzipwriter:\n            return self.print_svg(gzipwriter, **kwargs)\n\n    def get_default_filetype(self):\n        return 'svg'\n\n    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG",
      "name": "RendererSVG",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/finalize",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_metadata",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_default_style",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_make_id",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_make_flip_transform",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_hatch",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_hatches",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_style_dict",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_style",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_clip_attrs",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_clips",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_image_nocomposite",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_convert_path",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_scale_image",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_image_magnification",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_update_glyph_map_defs",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_adjust_char_id",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_draw_text_as_path",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_draw_text_as_text",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/flipy",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererSVG(RendererBase):\n    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72,\n                 *, metadata=None):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        if basename is None:\n            basename = getattr(svgwriter, \"name\", \"\")\n            if not isinstance(basename, str):\n                basename = \"\"\n        self.basename = basename\n\n        self._groupd = {}\n        self._image_counter = itertools.count()\n        self._clipd = {}\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = {}\n        self._has_gouraud = False\n        self._n_gradients = 0\n\n        super().__init__()\n        self._glyph_map = dict()\n        str_height = _short_float_fmt(height)\n        str_width = _short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width='%spt' % str_width,\n            height='%spt' % str_height,\n            viewBox='0 0 %s %s' % (str_width, str_height),\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()\n\n    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()\n\n    def _write_metadata(self, metadata):\n        # Add metadata following the Dublin Core Metadata Initiative, and the\n        # Creative Commons Rights Expression Language. This is mainly for\n        # compatibility with Inkscape.\n        if metadata is None:\n            metadata = {}\n        metadata = {\n            'Format': 'image/svg+xml',\n            'Type': 'http://purl.org/dc/dcmitype/StillImage',\n            'Creator':\n                f'Matplotlib v{mpl.__version__}, https://matplotlib.org/',\n            **metadata\n        }\n        writer = self.writer\n\n        if 'Title' in metadata:\n            title = metadata['Title']\n            _check_is_str(title, 'Title')\n            writer.element('title', text=title)\n\n        # Special handling.\n        date = metadata.get('Date', None)\n        if date is not None:\n            if isinstance(date, str):\n                dates = [date]\n            elif isinstance(date, (datetime.datetime, datetime.date)):\n                dates = [date.isoformat()]\n            elif np.iterable(date):\n                dates = []\n                for d in date:\n                    if isinstance(d, str):\n                        dates.append(d)\n                    elif isinstance(d, (datetime.datetime, datetime.date)):\n                        dates.append(d.isoformat())\n                    else:\n                        raise TypeError(\n                            f'Invalid type for Date metadata. '\n                            f'Expected iterable of str, date, or datetime, '\n                            f'not {type(d)}.')\n            else:\n                raise TypeError(f'Invalid type for Date metadata. '\n                                f'Expected str, date, datetime, or iterable '\n                                f'of the same, not {type(date)}.')\n            metadata['Date'] = '/'.join(dates)\n        elif 'Date' not in metadata:\n            # Do not add `Date` if the user explicitly set `Date` to `None`\n            # Get source date from SOURCE_DATE_EPOCH, if set.\n            # See https://reproducible-builds.org/specs/source-date-epoch/\n            date = os.getenv(\"SOURCE_DATE_EPOCH\")\n            if date:\n                date = datetime.datetime.utcfromtimestamp(int(date))\n                metadata['Date'] = date.replace(tzinfo=UTC).isoformat()\n            else:\n                metadata['Date'] = datetime.datetime.today().isoformat()\n\n        mid = None\n        def ensure_metadata(mid):\n            if mid is not None:\n                return mid\n            mid = writer.start('metadata')\n            writer.start('rdf:RDF', attrib={\n                'xmlns:dc': \"http://purl.org/dc/elements/1.1/\",\n                'xmlns:cc': \"http://creativecommons.org/ns#\",\n                'xmlns:rdf': \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n            })\n            writer.start('cc:Work')\n            return mid\n\n        uri = metadata.pop('Type', None)\n        if uri is not None:\n            mid = ensure_metadata(mid)\n            writer.element('dc:type', attrib={'rdf:resource': uri})\n\n        # Single value only.\n        for key in ['Title', 'Coverage', 'Date', 'Description', 'Format',\n                    'Identifier', 'Language', 'Relation', 'Source']:\n            info = metadata.pop(key, None)\n            if info is not None:\n                mid = ensure_metadata(mid)\n                _check_is_str(info, key)\n                writer.element(f'dc:{key.lower()}', text=info)\n\n        # Multiple Agent values.\n        for key in ['Creator', 'Contributor', 'Publisher', 'Rights']:\n            agents = metadata.pop(key, None)\n            if agents is None:\n                continue\n\n            if isinstance(agents, str):\n                agents = [agents]\n\n            _check_is_iterable_of_str(agents, key)\n            # Now we know that we have an iterable of str\n            mid = ensure_metadata(mid)\n            writer.start(f'dc:{key.lower()}')\n            for agent in agents:\n                writer.start('cc:Agent')\n                writer.element('dc:title', text=agent)\n                writer.end('cc:Agent')\n            writer.end(f'dc:{key.lower()}')\n\n        # Multiple values.\n        keywords = metadata.pop('Keywords', None)\n        if keywords is not None:\n            if isinstance(keywords, str):\n                keywords = [keywords]\n            _check_is_iterable_of_str(keywords, 'Keywords')\n            # Now we know that we have an iterable of str\n            mid = ensure_metadata(mid)\n            writer.start('dc:subject')\n            writer.start('rdf:Bag')\n            for keyword in keywords:\n                writer.element('rdf:li', text=keyword)\n            writer.end('rdf:Bag')\n            writer.end('dc:subject')\n\n        if mid is not None:\n            writer.close(mid)\n\n        if metadata:\n            raise ValueError('Unknown metadata key(s) passed to SVG writer: ' +\n                             ','.join(metadata))\n\n    def _write_default_style(self):\n        writer = self.writer\n        default_style = _generate_css({\n            'stroke-linejoin': 'round',\n            'stroke-linecap': 'butt'})\n        writer.start('defs')\n        writer.element('style', type='text/css', text='*{%s}' % default_style)\n        writer.end('defs')\n\n    def _make_id(self, type, content):\n        salt = mpl.rcParams['svg.hashsalt']\n        if salt is None:\n            salt = str(uuid.uuid4())\n        m = hashlib.sha256()\n        m.update(salt.encode('utf8'))\n        m.update(str(content).encode('utf8'))\n        return '%s%s' % (type, m.hexdigest()[:10])\n\n    def _make_flip_transform(self, transform):\n        return transform + Affine2D().scale(1, -1).translate(0, self.height)\n\n    def _get_hatch(self, gc, rgbFace):\n        \"\"\"\n        Create a new hatch pattern\n        \"\"\"\n        if rgbFace is not None:\n            rgbFace = tuple(rgbFace)\n        edge = gc.get_hatch_color()\n        if edge is not None:\n            edge = tuple(edge)\n        dictkey = (gc.get_hatch(), rgbFace, edge)\n        oid = self._hatchd.get(dictkey)\n        if oid is None:\n            oid = self._make_id('h', dictkey)\n            self._hatchd[dictkey] = ((gc.get_hatch_path(), rgbFace, edge), oid)\n        else:\n            _, oid = oid\n        return oid\n\n    def _write_hatches(self):\n        if not len(self._hatchd):\n            return\n        HATCH_SIZE = 72\n        writer = self.writer\n        writer.start('defs')\n        for (path, face, stroke), oid in self._hatchd.values():\n            writer.start(\n                'pattern',\n                id=oid,\n                patternUnits=\"userSpaceOnUse\",\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE),\n                height=str(HATCH_SIZE))\n            path_data = self._convert_path(\n                path,\n                Affine2D()\n                .scale(HATCH_SIZE).scale(1.0, -1.0).translate(0, HATCH_SIZE),\n                simplify=False)\n            if face is None:\n                fill = 'none'\n            else:\n                fill = rgb2hex(face)\n            writer.element(\n                'rect',\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE+1),\n                height=str(HATCH_SIZE+1),\n                fill=fill)\n            hatch_style = {\n                    'fill': rgb2hex(stroke),\n                    'stroke': rgb2hex(stroke),\n                    'stroke-width': str(mpl.rcParams['hatch.linewidth']),\n                    'stroke-linecap': 'butt',\n                    'stroke-linejoin': 'miter'\n                    }\n            if stroke[3] < 1:\n                hatch_style['stroke-opacity'] = str(stroke[3])\n            writer.element(\n                'path',\n                d=path_data,\n                style=_generate_css(hatch_style)\n                )\n            writer.end('pattern')\n        writer.end('defs')\n\n    def _get_style_dict(self, gc, rgbFace):\n        \"\"\"Generate a style string from the GraphicsContext and rgbFace.\"\"\"\n        attrib = {}\n\n        forced_alpha = gc.get_forced_alpha()\n\n        if gc.get_hatch() is not None:\n            attrib['fill'] = \"url(#%s)\" % self._get_hatch(gc, rgbFace)\n            if (rgbFace is not None and len(rgbFace) == 4 and rgbFace[3] != 1.0\n                    and not forced_alpha):\n                attrib['fill-opacity'] = _short_float_fmt(rgbFace[3])\n        else:\n            if rgbFace is None:\n                attrib['fill'] = 'none'\n            else:\n                if tuple(rgbFace[:3]) != (0, 0, 0):\n                    attrib['fill'] = rgb2hex(rgbFace)\n                if (len(rgbFace) == 4 and rgbFace[3] != 1.0\n                        and not forced_alpha):\n                    attrib['fill-opacity'] = _short_float_fmt(rgbFace[3])\n\n        if forced_alpha and gc.get_alpha() != 1.0:\n            attrib['opacity'] = _short_float_fmt(gc.get_alpha())\n\n        offset, seq = gc.get_dashes()\n        if seq is not None:\n            attrib['stroke-dasharray'] = ','.join(\n                _short_float_fmt(val) for val in seq)\n            attrib['stroke-dashoffset'] = _short_float_fmt(float(offset))\n\n        linewidth = gc.get_linewidth()\n        if linewidth:\n            rgb = gc.get_rgb()\n            attrib['stroke'] = rgb2hex(rgb)\n            if not forced_alpha and rgb[3] != 1.0:\n                attrib['stroke-opacity'] = _short_float_fmt(rgb[3])\n            if linewidth != 1.0:\n                attrib['stroke-width'] = _short_float_fmt(linewidth)\n            if gc.get_joinstyle() != 'round':\n                attrib['stroke-linejoin'] = gc.get_joinstyle()\n            if gc.get_capstyle() != 'butt':\n                attrib['stroke-linecap'] = _capstyle_d[gc.get_capstyle()]\n\n        return attrib\n\n    def _get_style(self, gc, rgbFace):\n        return _generate_css(self._get_style_dict(gc, rgbFace))\n\n    def _get_clip_attrs(self, gc):\n        cliprect = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            clippath_trans = self._make_flip_transform(clippath_trans)\n            dictkey = (id(clippath), str(clippath_trans))\n        elif cliprect is not None:\n            x, y, w, h = cliprect.bounds\n            y = self.height-(y+h)\n            dictkey = (x, y, w, h)\n        else:\n            return {}\n        clip = self._clipd.get(dictkey)\n        if clip is None:\n            oid = self._make_id('p', dictkey)\n            if clippath is not None:\n                self._clipd[dictkey] = ((clippath, clippath_trans), oid)\n            else:\n                self._clipd[dictkey] = (dictkey, oid)\n        else:\n            clip, oid = clip\n        return {'clip-path': f'url(#{oid})'}\n\n    def _write_clips(self):\n        if not len(self._clipd):\n            return\n        writer = self.writer\n        writer.start('defs')\n        for clip, oid in self._clipd.values():\n            writer.start('clipPath', id=oid)\n            if len(clip) == 2:\n                clippath, clippath_trans = clip\n                path_data = self._convert_path(\n                    clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(y),\n                    width=_short_float_fmt(w),\n                    height=_short_float_fmt(h))\n            writer.end('clipPath')\n        writer.end('defs')\n\n    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=\"%s_%d\" % (s, self._groupd[s]))\n\n    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def _convert_path(self, path, transform=None, clip=None, simplify=None,\n                      sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width, self.height)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, sketch, 6,\n            [b'M', b'L', b'Q', b'C', b'z'], False).decode('ascii')\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify,\n            sketch=gc.get_sketch_params())\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, **self._get_clip_attrs(gc),\n                            style=self._get_style(gc, rgbFace))\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, _generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = _generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        writer.start('g', **self._get_clip_attrs(gc))\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': '#%s' % oid}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = _short_float_fmt(x)\n                attrib['y'] = _short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        writer.end('g')\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #    (len_path + 5) * uses_per_path\n        # cost of definition+use is\n        #    (len_path + 3) + 9 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 9 * uses_per_path + 3 < (len_path + 5) * uses_per_path\n        if not should_do_optimization:\n            return super().draw_path_collection(\n                gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C%x_%x_%s' % (\n                self._path_collection_id, i, self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            clip_attrs = self._get_clip_attrs(gc0)\n            if clip_attrs:\n                writer.start('g', **clip_attrs)\n            attrib = {\n                'xlink:href': '#%s' % path_id,\n                'x': _short_float_fmt(xo),\n                'y': _short_float_fmt(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clip_attrs:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        # docstring inherited\n\n        # This uses a method described here:\n        #\n        #   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html\n        #\n        # that uses three overlapping linear gradients to simulate a\n        # Gouraud triangle.  Each gradient goes from fully opaque in\n        # one corner to fully transparent along the opposite edge.\n        # The line between the stop points is perpendicular to the\n        # opposite edge.  Underlying these three gradients is a solid\n        # triangle whose color is the average of all three points.\n\n        writer = self.writer\n        if not self._has_gouraud:\n            self._has_gouraud = True\n            writer.start(\n                'filter',\n                id='colorAdd')\n            writer.element(\n                'feComposite',\n                attrib={'in': 'SourceGraphic'},\n                in2='BackgroundImage',\n                operator='arithmetic',\n                k2=\"1\", k3=\"1\")\n            writer.end('filter')\n            # feColorMatrix filter to correct opacity\n            writer.start(\n                'filter',\n                id='colorMat')\n            writer.element(\n                'feColorMatrix',\n                attrib={'type': 'matrix'},\n                values='1 0 0 0 0 \\n0 1 0 0 0 \\n0 0 1 0 0' +\n                       ' \\n1 1 1 1 0 \\n0 0 0 0 1 ')\n            writer.end('filter')\n\n        avg_color = np.average(colors, axis=0)\n        if avg_color[-1] == 0:\n            # Skip fully-transparent triangles\n            return\n\n        trans_and_flip = self._make_flip_transform(trans)\n        tpoints = trans_and_flip.transform(points)\n\n        writer.start('defs')\n        for i in range(3):\n            x1, y1 = tpoints[i]\n            x2, y2 = tpoints[(i + 1) % 3]\n            x3, y3 = tpoints[(i + 2) % 3]\n            rgba_color = colors[i]\n\n            if x2 == x3:\n                xb = x2\n                yb = y1\n            elif y2 == y3:\n                xb = x1\n                yb = y2\n            else:\n                m1 = (y2 - y3) / (x2 - x3)\n                b1 = y2 - (m1 * x2)\n                m2 = -(1.0 / m1)\n                b2 = y1 - (m2 * x1)\n                xb = (-b1 + b2) / (m1 - m2)\n                yb = m2 * xb + b2\n\n            writer.start(\n                'linearGradient',\n                id=\"GR%x_%d\" % (self._n_gradients, i),\n                gradientUnits=\"userSpaceOnUse\",\n                x1=_short_float_fmt(x1), y1=_short_float_fmt(y1),\n                x2=_short_float_fmt(xb), y2=_short_float_fmt(yb))\n            writer.element(\n                'stop',\n                offset='1',\n                style=_generate_css({\n                    'stop-color': rgb2hex(avg_color),\n                    'stop-opacity': _short_float_fmt(rgba_color[-1])}))\n            writer.element(\n                'stop',\n                offset='0',\n                style=_generate_css({'stop-color': rgb2hex(rgba_color),\n                                    'stop-opacity': \"0\"}))\n\n            writer.end('linearGradient')\n\n        writer.end('defs')\n\n        # triangle formation using \"path\"\n        dpath = \"M \" + _short_float_fmt(x1)+',' + _short_float_fmt(y1)\n        dpath += \" L \" + _short_float_fmt(x2) + ',' + _short_float_fmt(y2)\n        dpath += \" \" + _short_float_fmt(x3) + ',' + _short_float_fmt(y3) + \" Z\"\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': rgb2hex(avg_color),\n                    'fill-opacity': '1',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.start(\n                'g',\n                attrib={'stroke': \"none\",\n                        'stroke-width': \"0\",\n                        'shape-rendering': \"crispEdges\",\n                        'filter': \"url(#colorMat)\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_0)' % self._n_gradients,\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_1)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_2)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.end('g')\n\n        self._n_gradients += 1\n\n    def draw_gouraud_triangles(self, gc, triangles_array, colors_array,\n                               transform):\n        self.writer.start('g', **self._get_clip_attrs(gc))\n        transform = transform.frozen()\n        for tri, col in zip(triangles_array, colors_array):\n            self.draw_gouraud_triangle(gc, tri, col, transform)\n        self.writer.end('g')\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True\n\n    def get_image_magnification(self):\n        return self.image_dpi / 72.0\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n\n        if w == 0 or h == 0:\n            return\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Can't apply clip-path directly to the image because the image has\n            # a transformation, which would also be applied to the clip-path.\n            self.writer.start('g', **clip_attrs)\n\n        url = gc.get_url()\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n\n        attrib = {}\n        oid = gc.get_gid()\n        if mpl.rcParams['svg.image_inline']:\n            buf = BytesIO()\n            Image.fromarray(im).save(buf, format=\"png\")\n            oid = oid or self._make_id('image', buf.getvalue())\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(buf.getvalue()).decode('ascii'))\n        else:\n            if self.basename is None:\n                raise ValueError(\"Cannot save image data to filesystem when \"\n                                 \"writing SVG to an in-memory buffer\")\n            filename = '{}.image{}.png'.format(\n                self.basename, next(self._image_counter))\n            _log.info('Writing image file for inclusion: %s', filename)\n            Image.fromarray(im).save(filename)\n            oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n        attrib['id'] = oid\n\n        if transform is None:\n            w = 72.0 * w / self.image_dpi\n            h = 72.0 * h / self.image_dpi\n\n            self.writer.element(\n                'image',\n                transform=_generate_transform([\n                    ('scale', (1, -1)), ('translate', (0, -h))]),\n                x=_short_float_fmt(x),\n                y=_short_float_fmt(-(self.height - y - h)),\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n        else:\n            alpha = gc.get_alpha()\n            if alpha != 1.0:\n                attrib['opacity'] = _short_float_fmt(alpha)\n\n            flipped = (\n                Affine2D().scale(1.0 / w, 1.0 / h) +\n                transform +\n                Affine2D()\n                .translate(x, y)\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n            attrib['transform'] = _generate_transform(\n                [('matrix', flipped.frozen())])\n            attrib['style'] = (\n                'image-rendering:crisp-edges;'\n                'image-rendering:pixelated')\n            self.writer.element(\n                'image',\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clip_attrs:\n            self.writer.end('g')\n\n    def _update_glyph_map_defs(self, glyph_map_new):\n        \"\"\"\n        Emit definitions for not-yet-defined glyphs, and record them as having\n        been defined.\n        \"\"\"\n        writer = self.writer\n        if glyph_map_new:\n            writer.start('defs')\n            for char_id, (vertices, codes) in glyph_map_new.items():\n                char_id = self._adjust_char_id(char_id)\n                # x64 to go back to FreeType's internal (integral) units.\n                path_data = self._convert_path(\n                    Path(vertices * 64, codes), simplify=False)\n                writer.element(\n                    'path', id=char_id, d=path_data,\n                    transform=_generate_transform([('scale', (1 / 64,))]))\n            writer.end('defs')\n            self._glyph_map.update(glyph_map_new)\n\n    def _adjust_char_id(self, char_id):\n        return char_id.replace(\"%20\", \"_\")\n\n    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        \"\"\"\n        Draw the text by converting them to paths using the textpath module.\n\n        Parameters\n        ----------\n        s : str\n            text to be converted\n        prop : `matplotlib.font_manager.FontProperties`\n            font property\n        ismath : bool\n            If True, use mathtext parser. If \"TeX\", use *usetex* mode.\n        \"\"\"\n        writer = self.writer\n\n        writer.comment(s)\n\n        glyph_map = self._glyph_map\n\n        text2path = self._text2path\n        color = rgb2hex(gc.get_rgb())\n        fontsize = prop.get_size_in_points()\n\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = _short_float_fmt(alpha)\n        font_scale = fontsize / text2path.FONT_SCALE\n        attrib = {\n            'style': _generate_css(style),\n            'transform': _generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))]),\n        }\n        writer.start('g', attrib=attrib)\n\n        if not ismath:\n            font = text2path._get_font(prop)\n            _glyphs = text2path.get_glyphs_with_font(\n                font, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for glyph_id, xposition, yposition, scale in glyph_info:\n                attrib = {'xlink:href': '#%s' % glyph_id}\n                if xposition != 0.0:\n                    attrib['x'] = _short_float_fmt(xposition)\n                if yposition != 0.0:\n                    attrib['y'] = _short_float_fmt(yposition)\n                writer.element('use', attrib=attrib)\n\n        else:\n            if ismath == \"TeX\":\n                _glyphs = text2path.get_glyphs_tex(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            else:\n                _glyphs = text2path.get_glyphs_mathtext(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for char_id, xposition, yposition, scale in glyph_info:\n                char_id = self._adjust_char_id(char_id)\n                writer.element(\n                    'use',\n                    transform=_generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': '#%s' % char_id})\n\n            for verts, codes in rects:\n                path = Path(verts, codes)\n                path_data = self._convert_path(path, simplify=False)\n                writer.element('path', d=path_data)\n\n        writer.end('g')\n\n    def _draw_text_as_text(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        writer = self.writer\n\n        color = rgb2hex(gc.get_rgb())\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = _short_float_fmt(alpha)\n\n        if not ismath:\n            attrib = {}\n\n            font_parts = []\n            if prop.get_style() != 'normal':\n                font_parts.append(prop.get_style())\n            if prop.get_variant() != 'normal':\n                font_parts.append(prop.get_variant())\n            weight = fm.weight_dict[prop.get_weight()]\n            if weight != 400:\n                font_parts.append(f'{weight}')\n            font_parts.extend([\n                f'{_short_float_fmt(prop.get_size())}px',\n                # ensure quoting\n                f'{\", \".join(repr(f) for f in prop.get_family())}',\n            ])\n            style['font'] = ' '.join(font_parts)\n            if prop.get_stretch() != 'normal':\n                style['font-stretch'] = prop.get_stretch()\n            attrib['style'] = _generate_css(style)\n\n            if mtext and (angle == 0 or mtext.get_rotation_mode() == \"anchor\"):\n                # If text anchoring can be supported, get the original\n                # coordinates and add alignment information.\n\n                # Get anchor coordinates.\n                transform = mtext.get_transform()\n                ax, ay = transform.transform(mtext.get_unitless_position())\n                ay = self.height - ay\n\n                # Don't do vertical anchor alignment. Most applications do not\n                # support 'alignment-baseline' yet. Apply the vertical layout\n                # to the anchor point manually for now.\n                angle_rad = np.deg2rad(angle)\n                dir_vert = np.array([np.sin(angle_rad), np.cos(angle_rad)])\n                v_offset = np.dot(dir_vert, [(x - ax), (y - ay)])\n                ax = ax + v_offset * dir_vert[0]\n                ay = ay + v_offset * dir_vert[1]\n\n                ha_mpl_to_svg = {'left': 'start', 'right': 'end',\n                                 'center': 'middle'}\n                style['text-anchor'] = ha_mpl_to_svg[mtext.get_ha()]\n\n                attrib['x'] = _short_float_fmt(ax)\n                attrib['y'] = _short_float_fmt(ay)\n                attrib['style'] = _generate_css(style)\n                attrib['transform'] = _generate_transform([\n                    (\"rotate\", (-angle, ax, ay))])\n\n            else:\n                attrib['transform'] = _generate_transform([\n                    ('translate', (x, y)),\n                    ('rotate', (-angle,))])\n\n            writer.element('text', s, attrib=attrib)\n\n        else:\n            writer.comment(s)\n\n            width, height, descent, glyphs, rects = \\\n                self._text2path.mathtext_parser.parse(s, 72, prop)\n\n            # Apply attributes to 'g', not 'text', because we likely have some\n            # rectangles as well with the same style and transformation.\n            writer.start('g',\n                         style=_generate_css(style),\n                         transform=_generate_transform([\n                             ('translate', (x, y)),\n                             ('rotate', (-angle,))]),\n                         )\n\n            writer.start('text')\n\n            # Sort the characters by font, and output one tspan for each.\n            spans = {}\n            for font, fontsize, thetext, new_x, new_y in glyphs:\n                entry = fm.ttfFontProperty(font)\n                font_parts = []\n                if entry.style != 'normal':\n                    font_parts.append(entry.style)\n                if entry.variant != 'normal':\n                    font_parts.append(entry.variant)\n                if entry.weight != 400:\n                    font_parts.append(f'{entry.weight}')\n                font_parts.extend([\n                    f'{_short_float_fmt(fontsize)}px',\n                    f'{entry.name!r}',  # ensure quoting\n                ])\n                style = {'font': ' '.join(font_parts)}\n                if entry.stretch != 'normal':\n                    style['font-stretch'] = entry.stretch\n                style = _generate_css(style)\n                if thetext == 32:\n                    thetext = 0xa0  # non-breaking space\n                spans.setdefault(style, []).append((new_x, -new_y, thetext))\n\n            for style, chars in spans.items():\n                chars.sort()\n\n                if len({y for x, y, t in chars}) == 1:  # Are all y's the same?\n                    ys = str(chars[0][1])\n                else:\n                    ys = ' '.join(str(c[1]) for c in chars)\n\n                attrib = {\n                    'style': style,\n                    'x': ' '.join(_short_float_fmt(c[0]) for c in chars),\n                    'y': ys\n                    }\n\n                writer.element(\n                    'tspan',\n                    ''.join(chr(c[2]) for c in chars),\n                    attrib=attrib)\n\n            writer.end('text')\n\n            for x, y, width, height in rects:\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(-y-1),\n                    width=_short_float_fmt(width),\n                    height=_short_float_fmt(height)\n                    )\n\n            writer.end('g')\n\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath=\"TeX\")\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Cannot apply clip-path directly to the text, because\n            # it has a transformation\n            self.writer.start('g', **clip_attrs)\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n\n        if mpl.rcParams['svg.fonttype'] == 'path':\n            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n        else:\n            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n        if clip_attrs:\n            self.writer.end('g')\n\n    def flipy(self):\n        # docstring inherited\n        return True\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)",
      "instance_attributes": [
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "writer",
          "types": {
            "kind": "NamedType",
            "name": "XMLWriter"
          }
        },
        {
          "name": "image_dpi",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "basename",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_groupd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_image_counter",
          "types": {
            "kind": "NamedType",
            "name": "count"
          }
        },
        {
          "name": "_clipd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_markers",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_path_collection_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_hatchd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_has_gouraud",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_n_gradients",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_glyph_map",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_start_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter",
      "name": "XMLWriter",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__flush",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/flush"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Parameters\n----------\nfile : writable text file-like object",
      "code": "class XMLWriter:\n    \"\"\"\n    Parameters\n    ----------\n    file : writable text file-like object\n    \"\"\"\n\n    def __init__(self, file):\n        self.__write = file.write\n        if hasattr(file, \"flush\"):\n            self.flush = file.flush\n        self.__open = 0  # true if start tag is open\n        self.__tags = []\n        self.__data = []\n        self.__indentation = \" \" * 64\n\n    def __flush(self, indent=True):\n        # flush internal buffers\n        if self.__open:\n            if indent:\n                self.__write(\">\\n\")\n            else:\n                self.__write(\">\")\n            self.__open = 0\n        if self.__data:\n            data = ''.join(self.__data)\n            self.__write(_escape_cdata(data))\n            self.__data = []\n\n    def start(self, tag, attrib={}, **extra):\n        \"\"\"\n        Open a new element.  Attributes can be given as keyword\n        arguments, or as a string/string dictionary. The method returns\n        an opaque identifier that can be passed to the :meth:`close`\n        method, to close all open elements up to and including this one.\n\n        Parameters\n        ----------\n        tag\n            Element tag.\n        attrib\n            Attribute dictionary.  Alternatively, attributes can be given as\n            keyword arguments.\n\n        Returns\n        -------\n        An element identifier.\n        \"\"\"\n        self.__flush()\n        tag = _escape_cdata(tag)\n        self.__data = []\n        self.__tags.append(tag)\n        self.__write(self.__indentation[:len(self.__tags) - 1])\n        self.__write(\"<%s\" % tag)\n        for k, v in {**attrib, **extra}.items():\n            if v:\n                k = _escape_cdata(k)\n                v = _quote_escape_attrib(v)\n                self.__write(' %s=%s' % (k, v))\n        self.__open = 1\n        return len(self.__tags) - 1\n\n    def comment(self, comment):\n        \"\"\"\n        Add a comment to the output stream.\n\n        Parameters\n        ----------\n        comment : str\n            Comment text.\n        \"\"\"\n        self.__flush()\n        self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"<!-- %s -->\\n\" % _escape_comment(comment))\n\n    def data(self, text):\n        \"\"\"\n        Add character data to the output stream.\n\n        Parameters\n        ----------\n        text : str\n            Character data.\n        \"\"\"\n        self.__data.append(text)\n\n    def end(self, tag=None, indent=True):\n        \"\"\"\n        Close the current element (opened by the most recent call to\n        :meth:`start`).\n\n        Parameters\n        ----------\n        tag\n            Element tag.  If given, the tag must match the start tag.  If\n            omitted, the current element is closed.\n        \"\"\"\n        if tag:\n            assert self.__tags, \"unbalanced end(%s)\" % tag\n            assert _escape_cdata(tag) == self.__tags[-1], \\\n                \"expected end(%s), got %s\" % (self.__tags[-1], tag)\n        else:\n            assert self.__tags, \"unbalanced end()\"\n        tag = self.__tags.pop()\n        if self.__data:\n            self.__flush(indent)\n        elif self.__open:\n            self.__open = 0\n            self.__write(\"/>\\n\")\n            return\n        if indent:\n            self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"</%s>\\n\" % tag)\n\n    def close(self, id):\n        \"\"\"\n        Close open elements, up to (and including) the element identified\n        by the given identifier.\n\n        Parameters\n        ----------\n        id\n            Element identifier, as returned by the :meth:`start` method.\n        \"\"\"\n        while len(self.__tags) > id:\n            self.end()\n\n    def element(self, tag, text=None, attrib={}, **extra):\n        \"\"\"\n        Add an entire element.  This is the same as calling :meth:`start`,\n        :meth:`data`, and :meth:`end` in sequence. The *text* argument can be\n        omitted.\n        \"\"\"\n        self.start(tag, attrib, **extra)\n        if text:\n            self.data(text)\n        self.end(indent=False)\n\n    def flush(self):\n        \"\"\"Flush the output stream.\"\"\"\n        pass  # replaced by the constructor",
      "instance_attributes": [
        {
          "name": "__write",
          "types": null
        },
        {
          "name": "flush",
          "types": null
        },
        {
          "name": "__open",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "__tags",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "__data",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "__indentation",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate",
      "name": "FigureCanvasTemplate",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/draw",
        "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo",
        "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/get_default_filetype"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc.\n\nNote: GUI templates will want to connect events for button presses,\nmouse movements and key presses to functions that call the base\nclass methods button_press_event, button_release_event,\nmotion_notify_event, key_press_event, and key_release_event.  See the\nimplementations of the interactive backends for examples.",
      "docstring": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc.\n\nNote: GUI templates will want to connect events for button presses,\nmouse movements and key presses to functions that call the base\nclass methods button_press_event, button_release_event,\nmotion_notify_event, key_press_event, and key_release_event.  See the\nimplementations of the interactive backends for examples.\n\nAttributes\n----------\nfigure : `matplotlib.figure.Figure`\n    A high-level Figure instance",
      "code": "class FigureCanvasTemplate(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc.\n\n    Note: GUI templates will want to connect events for button presses,\n    mouse movements and key presses to functions that call the base\n    class methods button_press_event, button_release_event,\n    motion_notify_event, key_press_event, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    # The instantiated manager class.  For further customization,\n    # ``FigureManager.create_with_canvas`` can also be overridden; see the\n    # wx-based backends for an example.\n    manager_class = FigureManagerTemplate\n\n    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file type is not in the base set of filetypes,\n    # you should add it to the class-scope filetypes dictionary as follows:\n    filetypes = {**FigureCanvasBase.filetypes, 'foo': 'My magic Foo format'}\n\n    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_foo(self, filename, *args, **kwargs):\n        \"\"\"\n        Write out format foo.\n\n        This method is normally called via `.Figure.savefig` and\n        `.FigureCanvasBase.print_figure`, which take care of setting the figure\n        facecolor, edgecolor, and dpi to the desired output values, and will\n        restore them to the original values.  Therefore, `print_foo` does not\n        need to handle these settings.\n        \"\"\"\n        self.draw()\n\n    def get_default_filetype(self):\n        return 'foo'",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureManagerTemplate",
      "name": "FigureManagerTemplate",
      "qname": "lib.matplotlib.backends.backend_template.FigureManagerTemplate",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.",
      "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.",
      "code": "class FigureManagerTemplate(FigureManagerBase):\n    \"\"\"\n    Helper class for pyplot mode, wraps everything up into a neat bundle.\n\n    For non-interactive backends, the base class is sufficient.\n    \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/GraphicsContextTemplate",
      "name": "GraphicsContextTemplate",
      "qname": "lib.matplotlib.backends.backend_template.GraphicsContextTemplate",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The graphics context provides the color, line styles, etc.  See the cairo\nand postscript backends for examples of mapping the graphics context\nattributes (cap styles, join styles, line widths, colors) to a particular\nbackend.  In cairo this is done by wrapping a cairo.Context object and\nforwarding the appropriate calls to it using a dictionary mapping styles\nto gdk constants.  In Postscript, all the work is done by the renderer,\nmapping line styles to postscript calls.\n\nIf it's more appropriate to do the mapping at the renderer level (as in\nthe postscript backend), you don't need to override any of the GC methods.\nIf it's more appropriate to wrap an instance (as in the cairo backend) and\ndo the mapping here, you'll need to override several of the setter\nmethods.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\nappropriate for your backend.",
      "docstring": "The graphics context provides the color, line styles, etc.  See the cairo\nand postscript backends for examples of mapping the graphics context\nattributes (cap styles, join styles, line widths, colors) to a particular\nbackend.  In cairo this is done by wrapping a cairo.Context object and\nforwarding the appropriate calls to it using a dictionary mapping styles\nto gdk constants.  In Postscript, all the work is done by the renderer,\nmapping line styles to postscript calls.\n\nIf it's more appropriate to do the mapping at the renderer level (as in\nthe postscript backend), you don't need to override any of the GC methods.\nIf it's more appropriate to wrap an instance (as in the cairo backend) and\ndo the mapping here, you'll need to override several of the setter\nmethods.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\nappropriate for your backend.",
      "code": "class GraphicsContextTemplate(GraphicsContextBase):\n    \"\"\"\n    The graphics context provides the color, line styles, etc.  See the cairo\n    and postscript backends for examples of mapping the graphics context\n    attributes (cap styles, join styles, line widths, colors) to a particular\n    backend.  In cairo this is done by wrapping a cairo.Context object and\n    forwarding the appropriate calls to it using a dictionary mapping styles\n    to gdk constants.  In Postscript, all the work is done by the renderer,\n    mapping line styles to postscript calls.\n\n    If it's more appropriate to do the mapping at the renderer level (as in\n    the postscript backend), you don't need to override any of the GC methods.\n    If it's more appropriate to wrap an instance (as in the cairo backend) and\n    do the mapping here, you'll need to override several of the setter\n    methods.\n\n    The base GraphicsContext stores colors as a RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\n    appropriate for your backend.\n    \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate",
      "name": "RendererTemplate",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/flipy",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `.backend_bases.RendererBase` for\ndocumentation of the methods.",
      "docstring": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `.backend_bases.RendererBase` for\ndocumentation of the methods.",
      "code": "class RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `.backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offset_trans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                        coordinates, offsets, offsetTrans, facecolors,\n#                        antialiased, edgecolors):\n#         pass\n\n    def draw_image(self, gc, x, y, im):\n        pass\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        pass\n\n    def flipy(self):\n        # docstring inherited\n        return True\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return 100, 100\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        return 1, 1, 1\n\n    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextTemplate()\n\n    def points_to_pixels(self, points):\n        # if backend doesn't have dpi, e.g., postscript or svg\n        return points",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg",
      "name": "FigureCanvasTkAgg",
      "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "FigureCanvasTk"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/draw",
        "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasTkAgg(FigureCanvasAgg, FigureCanvasTk):\n    def draw(self):\n        super().draw()\n        self.blit()\n\n    def blit(self, bbox=None):\n        _backend_tk.blit(self._tkphoto, self.renderer.buffer_rgba(),\n                         (0, 1, 2, 3), bbox=bbox)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo",
      "name": "FigureCanvasTkCairo",
      "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "FigureCanvasTk"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasTkCairo(FigureCanvasCairo, FigureCanvasTk):\n    def draw(self):\n        width = int(self.figure.bbox.width)\n        height = int(self.figure.bbox.height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_context(cairo.Context(surface))\n        self._renderer.dpi = self.figure.dpi\n        self.figure.draw(self._renderer)\n        buf = np.reshape(surface.get_data(), (height, width, 4))\n        _backend_tk.blit(\n            self._tkphoto, buf,\n            (2, 1, 0, 3) if sys.byteorder == \"little\" else (1, 2, 3, 0))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/FigureCanvasWebAgg",
      "name": "FigureCanvasWebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg.FigureCanvasWebAgg",
      "decorators": [],
      "superclasses": [
        "core.FigureCanvasWebAggCore"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasWebAgg(core.FigureCanvasWebAggCore):\n    manager_class = FigureManagerWebAgg",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/FigureManagerWebAgg",
      "name": "FigureManagerWebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg.FigureManagerWebAgg",
      "decorators": [],
      "superclasses": [
        "core.FigureManagerWebAgg"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerWebAgg(core.FigureManagerWebAgg):\n    _toolbar2_class = core.NavigationToolbar2WebAgg",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread",
      "name": "ServerThread",
      "qname": "lib.matplotlib.backends.backend_webagg.ServerThread",
      "decorators": [],
      "superclasses": [
        "threading.Thread"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread/run"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ServerThread(threading.Thread):\n    def run(self):\n        tornado.ioloop.IOLoop.instance().start()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication",
      "name": "WebAggApplication",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication",
      "decorators": [],
      "superclasses": [
        "tornado.web.Application"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize",
        "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/start"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class WebAggApplication(tornado.web.Application):\n    initialized = False\n    started = False\n\n    class FavIcon(tornado.web.RequestHandler):\n        def get(self):\n            self.set_header('Content-Type', 'image/png')\n            self.write(Path(mpl.get_data_path(),\n                            'images/matplotlib.png').read_bytes())\n\n    class SingleFigurePage(tornado.web.RequestHandler):\n        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)\n\n        def get(self, fignum):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"single_figure.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                fig_id=fignum,\n                toolitems=core.NavigationToolbar2WebAgg.toolitems,\n                canvas=manager.canvas)\n\n    class AllFiguresPage(tornado.web.RequestHandler):\n        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)\n\n        def get(self):\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"all_figures.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                figures=sorted(Gcf.figs.items()),\n                toolitems=core.NavigationToolbar2WebAgg.toolitems)\n\n    class MplJs(tornado.web.RequestHandler):\n        def get(self):\n            self.set_header('Content-Type', 'application/javascript')\n\n            js_content = core.FigureManagerWebAgg.get_javascript()\n\n            self.write(js_content)\n\n    class Download(tornado.web.RequestHandler):\n        def get(self, fignum, fmt):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n            self.set_header(\n                'Content-Type', mimetypes.types_map.get(fmt, 'binary'))\n            buff = BytesIO()\n            manager.canvas.figure.savefig(buff, format=fmt)\n            self.write(buff.getvalue())\n\n    class WebSocket(tornado.websocket.WebSocketHandler):\n        supports_binary = True\n\n        def open(self, fignum):\n            self.fignum = int(fignum)\n            self.manager = Gcf.get_fig_manager(self.fignum)\n            self.manager.add_web_socket(self)\n            if hasattr(self, 'set_nodelay'):\n                self.set_nodelay(True)\n\n        def on_close(self):\n            self.manager.remove_web_socket(self)\n\n        def on_message(self, message):\n            message = json.loads(message)\n            # The 'supports_binary' message is on a client-by-client\n            # basis.  The others affect the (shared) canvas as a\n            # whole.\n            if message['type'] == 'supports_binary':\n                self.supports_binary = message['value']\n            else:\n                manager = Gcf.get_fig_manager(self.fignum)\n                # It is possible for a figure to be closed,\n                # but a stale figure UI is still sending messages\n                # from the browser.\n                if manager is not None:\n                    manager.handle_json(message)\n\n        def send_json(self, content):\n            self.write_message(json.dumps(content))\n\n        def send_binary(self, blob):\n            if self.supports_binary:\n                self.write_message(blob, binary=True)\n            else:\n                data_uri = \"data:image/png;base64,{0}\".format(\n                    blob.encode('base64').replace('\\n', ''))\n                self.write_message(data_uri)\n\n    def __init__(self, url_prefix=''):\n        if url_prefix:\n            assert url_prefix[0] == '/' and url_prefix[-1] != '/', \\\n                'url_prefix must start with a \"/\" and not end with one.'\n\n        super().__init__(\n            [\n                # Static files for the CSS and JS\n                (url_prefix + r'/_static/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': core.FigureManagerWebAgg.get_static_file_path()}),\n\n                # Static images for the toolbar\n                (url_prefix + r'/_images/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': Path(mpl.get_data_path(), 'images')}),\n\n                # A Matplotlib favicon\n                (url_prefix + r'/favicon.ico', self.FavIcon),\n\n                # The page that contains all of the pieces\n                (url_prefix + r'/([0-9]+)', self.SingleFigurePage,\n                 {'url_prefix': url_prefix}),\n\n                # The page that contains all of the figures\n                (url_prefix + r'/?', self.AllFiguresPage,\n                 {'url_prefix': url_prefix}),\n\n                (url_prefix + r'/js/mpl.js', self.MplJs),\n\n                # Sends images and events to the browser, and receives\n                # events from the browser\n                (url_prefix + r'/([0-9]+)/ws', self.WebSocket),\n\n                # Handles the downloading (i.e., saving) of static images\n                (url_prefix + r'/([0-9]+)/download.([a-z0-9.]+)',\n                 self.Download),\n            ],\n            template_path=core.FigureManagerWebAgg.get_static_file_path())\n\n    @classmethod\n    def initialize(cls, url_prefix='', port=None, address=None):\n        if cls.initialized:\n            return\n\n        # Create the class instance\n        app = cls(url_prefix=url_prefix)\n\n        cls.url_prefix = url_prefix\n\n        # This port selection algorithm is borrowed, more or less\n        # verbatim, from IPython.\n        def random_ports(port, n):\n            \"\"\"\n            Generate a list of n random ports near the given port.\n\n            The first 5 ports will be sequential, and the remaining n-5 will be\n            randomly selected in the range [port-2*n, port+2*n].\n            \"\"\"\n            for i in range(min(5, n)):\n                yield port + i\n            for i in range(n - 5):\n                yield port + random.randint(-2 * n, 2 * n)\n\n        if address is None:\n            cls.address = mpl.rcParams['webagg.address']\n        else:\n            cls.address = address\n        cls.port = mpl.rcParams['webagg.port']\n        for port in random_ports(cls.port,\n                                 mpl.rcParams['webagg.port_retries']):\n            try:\n                app.listen(port, cls.address)\n            except socket.error as e:\n                if e.errno != errno.EADDRINUSE:\n                    raise\n            else:\n                cls.port = port\n                break\n        else:\n            raise SystemExit(\n                \"The webagg server could not be started because an available \"\n                \"port could not be found\")\n\n        cls.initialized = True\n\n    @classmethod\n    def start(cls):\n        if cls.started:\n            return\n\n        \"\"\"\n        IOLoop.running() was removed as of Tornado 2.4; see for example\n        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY\n        Thus there is no correct way to check if the loop has already been\n        launched. We may end up with two concurrently running loops in that\n        unlucky case with all the expected consequences.\n        \"\"\"\n        ioloop = tornado.ioloop.IOLoop.instance()\n\n        def shutdown():\n            ioloop.stop()\n            print(\"Server is stopped\")\n            sys.stdout.flush()\n            cls.started = False\n\n        @contextmanager\n        def catch_sigint():\n            old_handler = signal.signal(\n                signal.SIGINT,\n                lambda sig, frame: ioloop.add_callback_from_signal(shutdown))\n            try:\n                yield\n            finally:\n                signal.signal(signal.SIGINT, old_handler)\n\n        # Set the flag to True *before* blocking on ioloop.start()\n        cls.started = True\n\n        print(\"Press Ctrl+C to stop WebAgg server\")\n        sys.stdout.flush()\n        with catch_sigint():\n            ioloop.start()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore",
      "name": "FigureCanvasWebAggCore",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore",
      "decorators": [],
      "superclasses": [
        "backend_agg.FigureCanvasAgg"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/show",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/blit",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_diff_image",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/_handle_mouse",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/_handle_key",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_device_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/_handle_set_device_pixel_ratio",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasWebAggCore(backend_agg.FigureCanvasAgg):\n    manager_class = _api.classproperty(lambda cls: FigureManagerWebAgg)\n    _timer_cls = TimerAsyncio\n    # Webagg and friends having the right methods, but still\n    # having bugs in practice.  Do not advertise that it works until\n    # we can debug this.\n    supports_blit = False\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Set to True when the renderer contains data that is newer\n        # than the PNG buffer.\n        self._png_is_old = True\n        # Set to True by the `refresh` message so that the next frame\n        # sent to the clients will be a full frame.\n        self._force_full = True\n        # The last buffer, for diff mode.\n        self._last_buff = np.empty((0, 0))\n        # Store the current image mode so that at any point, clients can\n        # request the information. This should be changed by calling\n        # self.set_image_mode(mode) so that the notification can be given\n        # to the connected clients.\n        self._current_image_mode = 'full'\n        # Track mouse events to fill in the x, y position of key events.\n        self._last_mouse_xy = (None, None)\n\n    def show(self):\n        # show the figure window\n        from matplotlib.pyplot import show\n        show()\n\n    def draw(self):\n        self._png_is_old = True\n        try:\n            super().draw()\n        finally:\n            self.manager.refresh_all()  # Swap the frames.\n\n    def blit(self, bbox=None):\n        self._png_is_old = True\n        self.manager.refresh_all()\n\n    def draw_idle(self):\n        self.send_event(\"draw\")\n\n    def set_cursor(self, cursor):\n        # docstring inherited\n        cursor = _api.check_getitem({\n            backend_tools.Cursors.HAND: 'pointer',\n            backend_tools.Cursors.POINTER: 'default',\n            backend_tools.Cursors.SELECT_REGION: 'crosshair',\n            backend_tools.Cursors.MOVE: 'move',\n            backend_tools.Cursors.WAIT: 'wait',\n            backend_tools.Cursors.RESIZE_HORIZONTAL: 'ew-resize',\n            backend_tools.Cursors.RESIZE_VERTICAL: 'ns-resize',\n        }, cursor=cursor)\n        self.send_event('cursor', cursor=cursor)\n\n    def set_image_mode(self, mode):\n        \"\"\"\n        Set the image mode for any subsequent images which will be sent\n        to the clients. The modes may currently be either 'full' or 'diff'.\n\n        Note: diff images may not contain transparency, therefore upon\n        draw this mode may be changed if the resulting image has any\n        transparent component.\n        \"\"\"\n        _api.check_in_list(['full', 'diff'], mode=mode)\n        if self._current_image_mode != mode:\n            self._current_image_mode = mode\n            self.handle_send_image_mode(None)\n\n    def get_diff_image(self):\n        if self._png_is_old:\n            renderer = self.get_renderer()\n\n            pixels = np.asarray(renderer.buffer_rgba())\n            # The buffer is created as type uint32 so that entire\n            # pixels can be compared in one numpy call, rather than\n            # needing to compare each plane separately.\n            buff = pixels.view(np.uint32).squeeze(2)\n\n            if (self._force_full\n                    # If the buffer has changed size we need to do a full draw.\n                    or buff.shape != self._last_buff.shape\n                    # If any pixels have transparency, we need to force a full\n                    # draw as we cannot overlay new on top of old.\n                    or (pixels[:, :, 3] != 255).any()):\n                self.set_image_mode('full')\n                output = buff\n            else:\n                self.set_image_mode('diff')\n                diff = buff != self._last_buff\n                output = np.where(diff, buff, 0)\n\n            # Store the current buffer so we can compute the next diff.\n            self._last_buff = buff.copy()\n            self._force_full = False\n            self._png_is_old = False\n\n            data = output.view(dtype=np.uint8).reshape((*output.shape, 4))\n            with BytesIO() as png:\n                Image.fromarray(data).save(png, format=\"png\")\n                return png.getvalue()\n\n    def handle_event(self, event):\n        e_type = event['type']\n        handler = getattr(self, 'handle_{0}'.format(e_type),\n                          self.handle_unknown_event)\n        return handler(event)\n\n    def handle_unknown_event(self, event):\n        _log.warning('Unhandled message type {0}. {1}'.format(\n                     event['type'], event))\n\n    def handle_ack(self, event):\n        # Network latency tends to decrease if traffic is flowing\n        # in both directions.  Therefore, the browser sends back\n        # an \"ack\" message after each image frame is received.\n        # This could also be used as a simple sanity check in the\n        # future, but for now the performance increase is enough\n        # to justify it, even if the server does nothing with it.\n        pass\n\n    def handle_draw(self, event):\n        self.draw()\n\n    def _handle_mouse(self, event):\n        x = event['x']\n        y = event['y']\n        y = self.get_renderer().height - y\n        self._last_mouse_xy = x, y\n        # JavaScript button numbers and Matplotlib button numbers are off by 1.\n        button = event['button'] + 1\n\n        e_type = event['type']\n        guiEvent = event.get('guiEvent')\n        if e_type in ['button_press', 'button_release']:\n            MouseEvent(e_type + '_event', self, x, y, button,\n                       guiEvent=guiEvent)._process()\n        elif e_type == 'dblclick':\n            MouseEvent('button_press_event', self, x, y, button, dblclick=True,\n                       guiEvent=guiEvent)._process()\n        elif e_type == 'scroll':\n            MouseEvent('scroll_event', self, x, y, step=event['step'],\n                       guiEvent=guiEvent)._process()\n        elif e_type == 'motion_notify':\n            MouseEvent(e_type + '_event', self, x, y,\n                       guiEvent=guiEvent)._process()\n        elif e_type in ['figure_enter', 'figure_leave']:\n            LocationEvent(e_type + '_event', self, x, y,\n                          guiEvent=guiEvent)._process()\n    handle_button_press = handle_button_release = handle_dblclick = \\\n        handle_figure_enter = handle_figure_leave = handle_motion_notify = \\\n        handle_scroll = _handle_mouse\n\n    def _handle_key(self, event):\n        KeyEvent(event['type'] + '_event', self,\n                 _handle_key(event['key']), *self._last_mouse_xy,\n                 guiEvent=event.get('guiEvent'))._process()\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def handle_refresh(self, event):\n        figure_label = self.figure.get_label()\n        if not figure_label:\n            figure_label = \"Figure {0}\".format(self.manager.num)\n        self.send_event('figure_label', label=figure_label)\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()\n\n    def handle_resize(self, event):\n        x = int(event.get('width', 800)) * self.device_pixel_ratio\n        y = int(event.get('height', 800)) * self.device_pixel_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        ResizeEvent('resize_event', self)._process()\n        self.draw_idle()\n\n    def handle_send_image_mode(self, event):\n        # The client requests notification of what the current image mode is.\n        self.send_event('image_mode', mode=self._current_image_mode)\n\n    def handle_set_device_pixel_ratio(self, event):\n        self._handle_set_device_pixel_ratio(event.get('device_pixel_ratio', 1))\n\n    def handle_set_dpi_ratio(self, event):\n        # This handler is for backwards-compatibility with older ipympl.\n        self._handle_set_device_pixel_ratio(event.get('dpi_ratio', 1))\n\n    def _handle_set_device_pixel_ratio(self, device_pixel_ratio):\n        if self._set_device_pixel_ratio(device_pixel_ratio):\n            self._force_full = True\n            self.draw_idle()\n\n    def send_event(self, event_type, **kwargs):\n        if self.manager:\n            self.manager._send_event(event_type, **kwargs)",
      "instance_attributes": [
        {
          "name": "_png_is_old",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_force_full",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_last_buff",
          "types": {
            "kind": "NamedType",
            "name": "ndarray"
          }
        },
        {
          "name": "_current_image_mode",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_last_mouse_xy",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg",
      "name": "FigureManagerWebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg",
      "decorators": [],
      "superclasses": [
        "backend_bases.FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/show",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/refresh_all",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_static_file_path",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/_send_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerWebAgg(backend_bases.FigureManagerBase):\n    # This must be None to not break ipympl\n    _toolbar2_class = None\n    ToolbarCls = NavigationToolbar2WebAgg\n\n    def __init__(self, canvas, num):\n        self.web_sockets = set()\n        super().__init__(canvas, num)\n\n    def show(self):\n        pass\n\n    def resize(self, w, h, forward=True):\n        self._send_event(\n            'resize',\n            size=(w / self.canvas.device_pixel_ratio,\n                  h / self.canvas.device_pixel_ratio),\n            forward=forward)\n\n    def set_window_title(self, title):\n        self._send_event('figure_label', label=title)\n\n    # The following methods are specific to FigureManagerWebAgg\n\n    def add_web_socket(self, web_socket):\n        assert hasattr(web_socket, 'send_binary')\n        assert hasattr(web_socket, 'send_json')\n        self.web_sockets.add(web_socket)\n        self.resize(*self.canvas.figure.bbox.size)\n        self._send_event('refresh')\n\n    def remove_web_socket(self, web_socket):\n        self.web_sockets.remove(web_socket)\n\n    def handle_json(self, content):\n        self.canvas.handle_event(content)\n\n    def refresh_all(self):\n        if self.web_sockets:\n            diff = self.canvas.get_diff_image()\n            if diff is not None:\n                for s in self.web_sockets:\n                    s.send_binary(diff)\n\n    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = StringIO()\n        else:\n            output = stream\n\n        output.write((Path(__file__).parent / \"web_backend/js/mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n\n        toolitems = []\n        for name, tooltip, image, method in cls.ToolbarCls.toolitems:\n            if name is None:\n                toolitems.append(['', '', '', ''])\n            else:\n                toolitems.append([name, tooltip, image, method])\n        output.write(\"mpl.toolbar_items = {0};\\n\\n\".format(\n            json.dumps(toolitems)))\n\n        extensions = []\n        for filetype, ext in sorted(FigureCanvasWebAggCore.\n                                    get_supported_filetypes_grouped().\n                                    items()):\n            extensions.append(ext[0])\n        output.write(\"mpl.extensions = {0};\\n\\n\".format(\n            json.dumps(extensions)))\n\n        output.write(\"mpl.default_extension = {0};\".format(\n            json.dumps(FigureCanvasWebAggCore.get_default_filetype())))\n\n        if stream is None:\n            return output.getvalue()\n\n    @classmethod\n    def get_static_file_path(cls):\n        return os.path.join(os.path.dirname(__file__), 'web_backend')\n\n    def _send_event(self, event_type, **kwargs):\n        payload = {'type': event_type, **kwargs}\n        for s in self.web_sockets:\n            s.send_json(payload)",
      "instance_attributes": [
        {
          "name": "web_sockets",
          "types": {
            "kind": "NamedType",
            "name": "set"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg",
      "name": "NavigationToolbar2WebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg",
      "decorators": [],
      "superclasses": [
        "backend_bases.NavigationToolbar2"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/pan",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/zoom",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2WebAgg(backend_bases.NavigationToolbar2):\n\n    # Use the standard toolbar items + download button\n    toolitems = [\n        (text, tooltip_text, image_file, name_of_method)\n        for text, tooltip_text, image_file, name_of_method\n        in (*backend_bases.NavigationToolbar2.toolitems,\n            ('Download', 'Download plot', 'filesave', 'download'))\n        if name_of_method in _ALLOWED_TOOL_ITEMS\n    ]\n\n    cursor = _api.deprecate_privatize_attribute(\"3.5\")\n\n    def __init__(self, canvas):\n        self.message = ''\n        self._cursor = None  # Remove with deprecation.\n        super().__init__(canvas)\n\n    def set_message(self, message):\n        if message != self.message:\n            self.canvas.send_event(\"message\", message=message)\n        self.message = message\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.send_event(\"rubberband\", x0=x0, y0=y0, x1=x1, y1=y1)\n\n    def remove_rubberband(self):\n        self.canvas.send_event(\"rubberband\", x0=-1, y0=-1, x1=-1, y1=-1)\n\n    def save_figure(self, *args):\n        \"\"\"Save the current figure\"\"\"\n        self.canvas.send_event('save')\n\n    def pan(self):\n        super().pan()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)\n\n    def zoom(self):\n        super().zoom()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        self.canvas.send_event('history_buttons',\n                               Back=can_backward, Forward=can_forward)",
      "instance_attributes": [
        {
          "name": "message",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_cursor",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio",
      "name": "TimerAsyncio",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio",
      "decorators": [],
      "superclasses": [
        "backend_bases.TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/_timer_stop",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/_timer_set_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class TimerAsyncio(backend_bases.TimerBase):\n    def __init__(self, *args, **kwargs):\n        self._task = None\n        super().__init__(*args, **kwargs)\n\n    async def _timer_task(self, interval):\n        while True:\n            try:\n                await asyncio.sleep(interval)\n                self._on_timer()\n\n                if self._single:\n                    break\n            except asyncio.CancelledError:\n                break\n\n    def _timer_start(self):\n        self._timer_stop()\n\n        self._task = asyncio.ensure_future(\n            self._timer_task(max(self.interval / 1_000., 1e-6))\n        )\n\n    def _timer_stop(self):\n        if self._task is not None:\n            self._task.cancel()\n        self._task = None\n\n    def _timer_set_interval(self):\n        # Only stop and restart it if the timer has already been started\n        if self._task is not None:\n            self._timer_stop()\n            self._timer_start()",
      "instance_attributes": [
        {
          "name": "_task",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado",
      "name": "TimerTornado",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado",
      "decorators": [],
      "superclasses": [
        "backend_bases.TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/_timer_stop",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/_timer_set_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class TimerTornado(backend_bases.TimerBase):\n    def __init__(self, *args, **kwargs):\n        self._timer = None\n        super().__init__(*args, **kwargs)\n\n    def _timer_start(self):\n        import tornado\n\n        self._timer_stop()\n        if self._single:\n            ioloop = tornado.ioloop.IOLoop.instance()\n            self._timer = ioloop.add_timeout(\n                datetime.timedelta(milliseconds=self.interval),\n                self._on_timer)\n        else:\n            self._timer = tornado.ioloop.PeriodicCallback(\n                self._on_timer,\n                max(self.interval, 1e-6))\n            self._timer.start()\n\n    def _timer_stop(self):\n        import tornado\n\n        if self._timer is None:\n            return\n        elif self._single:\n            ioloop = tornado.ioloop.IOLoop.instance()\n            ioloop.remove_timeout(self._timer)\n        else:\n            self._timer.stop()\n        self._timer = None\n\n    def _timer_set_interval(self):\n        # Only stop and restart it if the timer has already been started\n        if self._timer is not None:\n            self._timer_stop()\n            self._timer_start()",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": {
            "kind": "NamedType",
            "name": "PeriodicCallback"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx",
      "name": "ConfigureSubplotsWx",
      "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.ConfigureSubplotsBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConfigureSubplotsWx(backend_tools.ConfigureSubplotsBase):\n    def trigger(self, *args):\n        NavigationToolbar2Wx.configure_subplots(self)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx",
      "name": "FigureCanvasWx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx",
      "decorators": [],
      "superclasses": [
        "_FigureCanvasWxBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/_print_image"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasWx(_FigureCanvasWxBase):\n    # Rendering to a Wx canvas using the deprecated Wx renderer.\n\n    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using RendererWx instance renderer, or using a\n        previously defined renderer if none is specified.\n        \"\"\"\n        _log.debug(\"%s - draw()\", type(self))\n        self.renderer = RendererWx(self.bitmap, self.figure.dpi)\n        self.figure.draw(self.renderer)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)\n\n    def _print_image(self, filetype, filename):\n        bitmap = wx.Bitmap(math.ceil(self.figure.bbox.width),\n                           math.ceil(self.figure.bbox.height))\n        self.figure.draw(RendererWx(bitmap, self.figure.dpi))\n        saved_obj = (bitmap.ConvertToImage()\n                     if cbook.is_writable_file_like(filename)\n                     else bitmap)\n        if not saved_obj.SaveFile(filename, filetype):\n            raise RuntimeError(f'Could not save figure to {filename}')\n        # draw() is required here since bits of state about the last renderer\n        # are strewn about the artist draw methods.  Do not remove the draw\n        # without first verifying that these have been cleaned up.  The artist\n        # contains() methods will fail otherwise.\n        if self._isDrawn:\n            self.draw()\n        # The \"if self\" check avoids a \"wrapped C/C++ object has been deleted\"\n        # RuntimeError if doing things after window is closed.\n        if self:\n            self.Refresh()\n\n    print_bmp = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_BMP)\n    print_jpeg = print_jpg = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_JPEG)\n    print_pcx = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_PCX)\n    print_png = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_PNG)\n    print_tiff = print_tif = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_TIF)\n    print_xpm = functools.partialmethod(\n        _print_image, wx.BITMAP_TYPE_XPM)",
      "instance_attributes": [
        {
          "name": "renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererWx"
          }
        },
        {
          "name": "_isDrawn",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx",
      "name": "FigureFrameWx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx",
      "decorators": [],
      "superclasses": [
        "wx.Frame"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_figure_manager",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/_on_close"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureFrameWx(wx.Frame):\n    def __init__(self, num, fig, *, canvas_class=None):\n        # On non-Windows platform, explicitly set the position - fix\n        # positioning bug on some Linux platforms\n        if wx.Platform == '__WXMSW__':\n            pos = wx.DefaultPosition\n        else:\n            pos = wx.Point(20, 20)\n        super().__init__(parent=None, id=-1, pos=pos)\n        # Frame will be sized later by the Fit method\n        _log.debug(\"%s - __init__()\", type(self))\n        _set_frame_icon(self)\n\n        # The parameter will become required after the deprecation elapses.\n        if canvas_class is not None:\n            self.canvas = canvas_class(self, -1, fig)\n        else:\n            _api.warn_deprecated(\n                \"3.6\", message=\"The canvas_class parameter will become \"\n                \"required after the deprecation period starting in Matplotlib \"\n                \"%(since)s elapses.\")\n            self.canvas = self.get_canvas(fig)\n\n        # Auto-attaches itself to self.canvas.manager\n        manager = FigureManagerWx(self.canvas, num, self)\n\n        toolbar = self.canvas.manager.toolbar\n        if toolbar is not None:\n            self.SetToolBar(toolbar)\n\n        # On Windows, canvas sizing must occur after toolbar addition;\n        # otherwise the toolbar further resizes the canvas.\n        w, h = map(math.ceil, fig.bbox.size)\n        self.canvas.SetInitialSize(wx.Size(w, h))\n        self.canvas.SetMinSize((2, 2))\n        self.canvas.SetFocus()\n\n        self.Fit()\n\n        self.Bind(wx.EVT_CLOSE, self._on_close)\n\n    sizer = _api.deprecated(\"3.6\", alternative=\"frame.GetSizer()\")(\n        property(lambda self: self.GetSizer()))\n    figmgr = _api.deprecated(\"3.6\", alternative=\"frame.canvas.manager\")(\n        property(lambda self: self.canvas.manager))\n    num = _api.deprecated(\"3.6\", alternative=\"frame.canvas.manager.num\")(\n        property(lambda self: self.canvas.manager.num))\n    toolbar = _api.deprecated(\"3.6\", alternative=\"frame.GetToolBar()\")(\n        property(lambda self: self.GetToolBar()))\n    toolmanager = _api.deprecated(\n        \"3.6\", alternative=\"frame.canvas.manager.toolmanager\")(\n            property(lambda self: self.canvas.manager.toolmanager))\n\n    @_api.deprecated(\n        \"3.6\", alternative=\"the canvas_class constructor parameter\")\n    def get_canvas(self, fig):\n        return FigureCanvasWx(self, -1, fig)\n\n    @_api.deprecated(\"3.6\", alternative=\"frame.canvas.manager\")\n    def get_figure_manager(self):\n        _log.debug(\"%s - get_figure_manager()\", type(self))\n        return self.canvas.manager\n\n    def _on_close(self, event):\n        _log.debug(\"%s - on_close()\", type(self))\n        CloseEvent(\"close_event\", self.canvas)._process()\n        self.canvas.stop_event_loop()\n        # set FigureManagerWx.frame to None to prevent repeated attempts to\n        # close this frame from FigureManagerWx.destroy()\n        self.canvas.manager.frame = None\n        # remove figure manager from Gcf.figs\n        Gcf.destroy(self.canvas.manager)\n        try:  # See issue 2941338.\n            self.canvas.mpl_disconnect(self.canvas.toolbar._id_drag)\n        except AttributeError:  # If there's no toolbar.\n            pass\n        # Carry on with close event propagation, frame & children destruction\n        event.Skip()",
      "instance_attributes": [
        {
          "name": "canvas",
          "types": {
            "kind": "NamedType",
            "name": "FigureCanvasWx"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx",
      "name": "FigureManagerWx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/show",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/full_screen_toggle",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/get_window_title",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.",
      "docstring": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.\n\nAttributes\n----------\ncanvas : `FigureCanvas`\n    a FigureCanvasWx(wx.Panel) instance\nwindow : wxFrame\n    a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html",
      "code": "class FigureManagerWx(FigureManagerBase):\n    \"\"\"\n    Container/controller for the FigureCanvas and GUI frame.\n\n    It is instantiated by Gcf whenever a new figure is created.  Gcf is\n    responsible for managing multiple instances of FigureManagerWx.\n\n    Attributes\n    ----------\n    canvas : `FigureCanvas`\n        a FigureCanvasWx(wx.Panel) instance\n    window : wxFrame\n        a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html\n    \"\"\"\n\n    def __init__(self, canvas, num, frame):\n        _log.debug(\"%s - __init__()\", type(self))\n        self.frame = self.window = frame\n        super().__init__(canvas, num)\n\n    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        # docstring inherited\n        wxapp = wx.GetApp() or _create_wxapp()\n        frame = FigureFrameWx(num, figure, canvas_class=canvas_class)\n        manager = figure.canvas.manager\n        if mpl.is_interactive():\n            manager.frame.Show()\n            figure.canvas.draw_idle()\n        return manager\n\n    def show(self):\n        # docstring inherited\n        self.frame.Show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.frame.Raise()\n\n    def destroy(self, *args):\n        # docstring inherited\n        _log.debug(\"%s - destroy()\", type(self))\n        frame = self.frame\n        if frame:  # Else, may have been already deleted, e.g. when closing.\n            # As this can be called from non-GUI thread from plt.close use\n            # wx.CallAfter to ensure thread safety.\n            wx.CallAfter(frame.Close)\n\n    def full_screen_toggle(self):\n        # docstring inherited\n        self.frame.ShowFullScreen(not self.frame.IsFullScreen())\n\n    def get_window_title(self):\n        # docstring inherited\n        return self.window.GetTitle()\n\n    def set_window_title(self, title):\n        # docstring inherited\n        self.window.SetTitle(title)\n\n    def resize(self, width, height):\n        # docstring inherited\n        # Directly using SetClientSize doesn't handle the toolbar on Windows.\n        self.window.SetSize(self.window.ClientToWindowSize(wx.Size(\n            math.ceil(width), math.ceil(height))))",
      "instance_attributes": [
        {
          "name": "frame",
          "types": null
        },
        {
          "name": "window",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx",
      "name": "GraphicsContextWx",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/select",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/unselect",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The graphics context provides the color, line styles, etc.\n\nThis class stores a reference to a wxMemoryDC, and a\nwxGraphicsContext that draws to it.  Creating a wxGraphicsContext\nseems to be fairly heavy, so these objects are cached based on the\nbitmap object that is passed in.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\nsince wxPython colour management is rather simple, I have not chosen\nto implement a separate colour manager class.",
      "docstring": "The graphics context provides the color, line styles, etc.\n\nThis class stores a reference to a wxMemoryDC, and a\nwxGraphicsContext that draws to it.  Creating a wxGraphicsContext\nseems to be fairly heavy, so these objects are cached based on the\nbitmap object that is passed in.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\nsince wxPython colour management is rather simple, I have not chosen\nto implement a separate colour manager class.",
      "code": "class GraphicsContextWx(GraphicsContextBase):\n    \"\"\"\n    The graphics context provides the color, line styles, etc.\n\n    This class stores a reference to a wxMemoryDC, and a\n    wxGraphicsContext that draws to it.  Creating a wxGraphicsContext\n    seems to be fairly heavy, so these objects are cached based on the\n    bitmap object that is passed in.\n\n    The base GraphicsContext stores colors as a RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\n    since wxPython colour management is rather simple, I have not chosen\n    to implement a separate colour manager class.\n    \"\"\"\n    _capd = {'butt': wx.CAP_BUTT,\n             'projecting': wx.CAP_PROJECTING,\n             'round': wx.CAP_ROUND}\n\n    _joind = {'bevel': wx.JOIN_BEVEL,\n              'miter': wx.JOIN_MITER,\n              'round': wx.JOIN_ROUND}\n\n    _cache = weakref.WeakKeyDictionary()\n\n    def __init__(self, bitmap, renderer):\n        super().__init__()\n        # assert self.Ok(), \"wxMemoryDC not OK to use\"\n        _log.debug(\"%s - __init__(): %s\", type(self), bitmap)\n\n        dc, gfx_ctx = self._cache.get(bitmap, (None, None))\n        if dc is None:\n            dc = wx.MemoryDC(bitmap)\n            gfx_ctx = wx.GraphicsContext.Create(dc)\n            gfx_ctx._lastcliprect = None\n            self._cache[bitmap] = dc, gfx_ctx\n\n        self.bitmap = bitmap\n        self.dc = dc\n        self.gfx_ctx = gfx_ctx\n        self._pen = wx.Pen('BLACK', 1, wx.SOLID)\n        gfx_ctx.SetPen(self._pen)\n        self.renderer = renderer\n\n    def select(self):\n        \"\"\"Select the current bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(self.bitmap)\n            self.IsSelected = True\n\n    def unselect(self):\n        \"\"\"Select a Null bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(wx.NullBitmap)\n            self.IsSelected = False\n\n    def set_foreground(self, fg, isRGBA=None):\n        # docstring inherited\n        # Implementation note: wxPython has a separate concept of pen and\n        # brush - the brush fills any outline trace left by the pen.\n        # Here we set both to the same colour - if a figure is not to be\n        # filled, the renderer will set the brush to be transparent\n        # Same goes for text foreground...\n        _log.debug(\"%s - set_foreground()\", type(self))\n        self.select()\n        super().set_foreground(fg, isRGBA)\n\n        self._pen.SetColour(self.get_wxcolour(self.get_rgb()))\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def set_linewidth(self, w):\n        # docstring inherited\n        w = float(w)\n        _log.debug(\"%s - set_linewidth()\", type(self))\n        self.select()\n        if 0 < w < 1:\n            w = 1\n        super().set_linewidth(w)\n        lw = int(self.renderer.points_to_pixels(self._linewidth))\n        if lw == 0:\n            lw = 1\n        self._pen.SetWidth(lw)\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def set_capstyle(self, cs):\n        # docstring inherited\n        _log.debug(\"%s - set_capstyle()\", type(self))\n        self.select()\n        super().set_capstyle(cs)\n        self._pen.SetCap(GraphicsContextWx._capd[self._capstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def set_joinstyle(self, js):\n        # docstring inherited\n        _log.debug(\"%s - set_joinstyle()\", type(self))\n        self.select()\n        super().set_joinstyle(js)\n        self._pen.SetJoin(GraphicsContextWx._joind[self._joinstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def get_wxcolour(self, color):\n        \"\"\"Convert a RGB(A) color to a wx.Colour.\"\"\"\n        _log.debug(\"%s - get_wx_color()\", type(self))\n        return wx.Colour(*[int(255 * x) for x in color])",
      "instance_attributes": [
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "dc",
          "types": null
        },
        {
          "name": "gfx_ctx",
          "types": null
        },
        {
          "name": "_pen",
          "types": null
        },
        {
          "name": "renderer",
          "types": null
        },
        {
          "name": "IsSelected",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx",
      "name": "HelpWx",
      "qname": "lib.matplotlib.backends.backend_wx.HelpWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpWx(backend_tools.ToolHelpBase):\n    def trigger(self, *args):\n        _HelpDialog.show(self.figure.canvas.GetTopLevelParent(),\n                         self._get_help_entries())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx",
      "name": "NavigationToolbar2Wx",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2",
        "wx.ToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/_icon",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/_update_buttons_checked",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2Wx(NavigationToolbar2, wx.ToolBar):\n    def __init__(self, canvas, coordinates=True, *, style=wx.TB_BOTTOM):\n        wx.ToolBar.__init__(self, canvas.GetParent(), -1, style=style)\n\n        if 'wxMac' in wx.PlatformInfo:\n            self.SetToolBitmapSize((24, 24))\n        self.wx_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.AddSeparator()\n                continue\n            self.wx_ids[text] = (\n                self.AddTool(\n                    -1,\n                    bitmap=self._icon(f\"{image_file}.png\"),\n                    bmpDisabled=wx.NullBitmap,\n                    label=text, shortHelp=tooltip_text,\n                    kind=(wx.ITEM_CHECK if text in [\"Pan\", \"Zoom\"]\n                          else wx.ITEM_NORMAL))\n                .Id)\n            self.Bind(wx.EVT_TOOL, getattr(self, callback),\n                      id=self.wx_ids[text])\n\n        self._coordinates = coordinates\n        if self._coordinates:\n            self.AddStretchableSpace()\n            self._label_text = wx.StaticText(self, style=wx.ALIGN_RIGHT)\n            self.AddControl(self._label_text)\n\n        self.Realize()\n\n        NavigationToolbar2.__init__(self, canvas)\n\n    @staticmethod\n    def _icon(name):\n        \"\"\"\n        Construct a `wx.Bitmap` suitable for use as icon from an image file\n        *name*, including the extension and relative to Matplotlib's \"images\"\n        data directory.\n        \"\"\"\n        image = np.array(PIL.Image.open(cbook._get_data_path(\"images\", name)))\n        try:\n            dark = wx.SystemSettings.GetAppearance().IsDark()\n        except AttributeError:  # wxpython < 4.1\n            # copied from wx's IsUsingDarkBackground / GetLuminance.\n            bg = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)\n            fg = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n            # See wx.Colour.GetLuminance.\n            bg_lum = (.299 * bg.red + .587 * bg.green + .114 * bg.blue) / 255\n            fg_lum = (.299 * fg.red + .587 * fg.green + .114 * fg.blue) / 255\n            dark = fg_lum - bg_lum > .2\n        if dark:\n            fg = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n            black_mask = (image[..., :3] == 0).all(axis=-1)\n            image[black_mask, :3] = (fg.Red(), fg.Green(), fg.Blue())\n        return wx.Bitmap.FromBufferRGBA(\n            image.shape[1], image.shape[0], image.tobytes())\n\n    def _update_buttons_checked(self):\n        if \"Pan\" in self.wx_ids:\n            self.ToggleTool(self.wx_ids[\"Pan\"], self.mode.name == \"PAN\")\n        if \"Zoom\" in self.wx_ids:\n            self.ToggleTool(self.wx_ids[\"Zoom\"], self.mode.name == \"ZOOM\")\n\n    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()\n\n    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()\n\n    def save_figure(self, *args):\n        # Fetch the required filename and file type.\n        filetypes, exts, filter_index = self.canvas._get_imagesave_wildcards()\n        default_file = self.canvas.get_default_filename()\n        dialog = wx.FileDialog(\n            self.canvas.GetParent(), \"Save to file\",\n            mpl.rcParams[\"savefig.directory\"], default_file, filetypes,\n            wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)\n        dialog.SetFilterIndex(filter_index)\n        if dialog.ShowModal() == wx.ID_OK:\n            path = pathlib.Path(dialog.GetPath())\n            _log.debug('%s - Save file path: %s', type(self), path)\n            fmt = exts[dialog.GetFilterIndex()]\n            ext = path.suffix[1:]\n            if ext in self.canvas.get_supported_filetypes() and fmt != ext:\n                # looks like they forgot to set the image type drop\n                # down, going with the extension.\n                _log.warning('extension %s did not match the selected '\n                             'image type %s; going with %s',\n                             ext, fmt, ext)\n                fmt = ext\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams[\"savefig.directory\"]:\n                mpl.rcParams[\"savefig.directory\"] = str(path.parent)\n            try:\n                self.canvas.figure.savefig(str(path), format=fmt)\n            except Exception as e:\n                dialog = wx.MessageDialog(\n                    parent=self.canvas.GetParent(), message=str(e),\n                    caption='Matplotlib error')\n                dialog.ShowModal()\n                dialog.Destroy()\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        self.canvas._rubberband_rect = (x0, height - y0, x1, height - y1)\n        self.canvas.Refresh()\n\n    def remove_rubberband(self):\n        self.canvas._rubberband_rect = None\n        self.canvas.Refresh()\n\n    def set_message(self, s):\n        if self._coordinates:\n            self._label_text.SetLabel(s)\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'Back' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Back'], can_backward)\n        if 'Forward' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Forward'], can_forward)",
      "instance_attributes": [
        {
          "name": "wx_ids",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_coordinates",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_label_text",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx",
      "name": "RendererWx",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx",
      "decorators": [
        "_api.deprecated('2.0', name='wx', obj_type='backend', removal='the future', alternative='wxagg', addendum='See the Matplotlib usage FAQ for more info on backends.')"
      ],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/flipy",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/offset_text_height",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles. It acts as the\n'renderer' instance used by many classes in the hierarchy.",
      "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles. It acts as the\n'renderer' instance used by many classes in the hierarchy.",
      "code": "class RendererWx(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles. It acts as the\n    'renderer' instance used by many classes in the hierarchy.\n    \"\"\"\n    # In wxPython, drawing is performed on a wxDC instance, which will\n    # generally be mapped to the client area of the window displaying\n    # the plot. Under wxPython, the wxDC instance has a wx.Pen which\n    # describes the colour and weight of any lines drawn, and a wxBrush\n    # which describes the fill colour of any closed polygon.\n\n    # Font styles, families and weight.\n    fontweights = {\n        100: wx.FONTWEIGHT_LIGHT,\n        200: wx.FONTWEIGHT_LIGHT,\n        300: wx.FONTWEIGHT_LIGHT,\n        400: wx.FONTWEIGHT_NORMAL,\n        500: wx.FONTWEIGHT_NORMAL,\n        600: wx.FONTWEIGHT_NORMAL,\n        700: wx.FONTWEIGHT_BOLD,\n        800: wx.FONTWEIGHT_BOLD,\n        900: wx.FONTWEIGHT_BOLD,\n        'ultralight': wx.FONTWEIGHT_LIGHT,\n        'light': wx.FONTWEIGHT_LIGHT,\n        'normal': wx.FONTWEIGHT_NORMAL,\n        'medium': wx.FONTWEIGHT_NORMAL,\n        'semibold': wx.FONTWEIGHT_NORMAL,\n        'bold': wx.FONTWEIGHT_BOLD,\n        'heavy': wx.FONTWEIGHT_BOLD,\n        'ultrabold': wx.FONTWEIGHT_BOLD,\n        'black': wx.FONTWEIGHT_BOLD,\n    }\n    fontangles = {\n        'italic': wx.FONTSTYLE_ITALIC,\n        'normal': wx.FONTSTYLE_NORMAL,\n        'oblique': wx.FONTSTYLE_SLANT,\n    }\n\n    # wxPython allows for portable font styles, choosing them appropriately for\n    # the target platform. Map some standard font names to the portable styles.\n    # QUESTION: Is it wise to agree to standard fontnames across all backends?\n    fontnames = {\n        'Sans': wx.FONTFAMILY_SWISS,\n        'Roman': wx.FONTFAMILY_ROMAN,\n        'Script': wx.FONTFAMILY_SCRIPT,\n        'Decorative': wx.FONTFAMILY_DECORATIVE,\n        'Modern': wx.FONTFAMILY_MODERN,\n        'Courier': wx.FONTFAMILY_MODERN,\n        'courier': wx.FONTFAMILY_MODERN,\n    }\n\n    def __init__(self, bitmap, dpi):\n        \"\"\"Initialise a wxWindows renderer instance.\"\"\"\n        super().__init__()\n        _log.debug(\"%s - __init__()\", type(self))\n        self.width = bitmap.GetWidth()\n        self.height = bitmap.GetHeight()\n        self.bitmap = bitmap\n        self.fontd = {}\n        self.dpi = dpi\n        self.gc = None\n\n    def flipy(self):\n        # docstring inherited\n        return True\n\n    @_api.deprecated(\"3.6\")\n    def offset_text_height(self):\n        return True\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n\n        if self.gc is None:\n            gc = self.new_gc()\n        else:\n            gc = self.gc\n        gfx_ctx = gc.gfx_ctx\n        font = self.get_wx_font(s, prop)\n        gfx_ctx.SetFont(font, wx.BLACK)\n        w, h, descent, leading = gfx_ctx.GetFullTextExtent(s)\n\n        return w, h, descent\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def handle_clip_rectangle(self, gc):\n        new_bounds = gc.get_clip_rectangle()\n        if new_bounds is not None:\n            new_bounds = new_bounds.bounds\n        gfx_ctx = gc.gfx_ctx\n        if gfx_ctx._lastcliprect != new_bounds:\n            gfx_ctx._lastcliprect = new_bounds\n            if new_bounds is None:\n                gfx_ctx.ResetClip()\n            else:\n                gfx_ctx.Clip(new_bounds[0],\n                             self.height - new_bounds[1] - new_bounds[3],\n                             new_bounds[2], new_bounds[3])\n\n    @staticmethod\n    def convert_path(gfx_ctx, path, transform):\n        wxpath = gfx_ctx.CreatePath()\n        for points, code in path.iter_segments(transform):\n            if code == Path.MOVETO:\n                wxpath.MoveToPoint(*points)\n            elif code == Path.LINETO:\n                wxpath.AddLineToPoint(*points)\n            elif code == Path.CURVE3:\n                wxpath.AddQuadCurveToPoint(*points)\n            elif code == Path.CURVE4:\n                wxpath.AddCurveToPoint(*points)\n            elif code == Path.CLOSEPOLY:\n                wxpath.CloseSubpath()\n        return wxpath\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n        transform = transform + \\\n            Affine2D().scale(1.0, -1.0).translate(0.0, self.height)\n        wxpath = self.convert_path(gfx_ctx, path, transform)\n        if rgbFace is not None:\n            gfx_ctx.SetBrush(wx.Brush(gc.get_wxcolour(rgbFace)))\n            gfx_ctx.DrawPath(wxpath)\n        else:\n            gfx_ctx.StrokePath(wxpath)\n        gc.unselect()\n\n    def draw_image(self, gc, x, y, im):\n        bbox = gc.get_clip_rectangle()\n        if bbox is not None:\n            l, b, w, h = bbox.bounds\n        else:\n            l = 0\n            b = 0\n            w = self.width\n            h = self.height\n        rows, cols = im.shape[:2]\n        bitmap = wx.Bitmap.FromBufferRGBA(cols, rows, im.tobytes())\n        gc.select()\n        gc.gfx_ctx.DrawBitmap(bitmap, int(l), int(self.height - b),\n                              int(w), int(-h))\n        gc.unselect()\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n        _log.debug(\"%s - draw_text()\", type(self))\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n\n        font = self.get_wx_font(s, prop)\n        color = gc.get_wxcolour(gc.get_rgb())\n        gfx_ctx.SetFont(font, color)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath)\n        x = int(x)\n        y = int(y - h)\n\n        if angle == 0.0:\n            gfx_ctx.DrawText(s, x, y)\n        else:\n            rads = math.radians(angle)\n            xo = h * math.sin(rads)\n            yo = h * math.cos(rads)\n            gfx_ctx.DrawRotatedText(s, x - xo, y - yo, rads)\n\n        gc.unselect()\n\n    def new_gc(self):\n        # docstring inherited\n        _log.debug(\"%s - new_gc()\", type(self))\n        self.gc = GraphicsContextWx(self.bitmap, self)\n        self.gc.select()\n        self.gc.unselect()\n        return self.gc\n\n    def get_wx_font(self, s, prop):\n        \"\"\"Return a wx font.  Cache font instances for efficiency.\"\"\"\n        _log.debug(\"%s - get_wx_font()\", type(self))\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is not None:\n            return font\n        size = self.points_to_pixels(prop.get_size_in_points())\n        # Font colour is determined by the active wx.Pen\n        # TODO: It may be wise to cache font information\n        self.fontd[key] = font = wx.Font(  # Cache the font and gc.\n            pointSize=int(size + 0.5),\n            family=self.fontnames.get(prop.get_name(), wx.ROMAN),\n            style=self.fontangles[prop.get_style()],\n            weight=self.fontweights[prop.get_weight()])\n        return font\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0)",
      "instance_attributes": [
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "fontd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "gc",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextWx"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx",
      "name": "RubberbandWx",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.RubberbandBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RubberbandWx(backend_tools.RubberbandBase):\n    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2Wx.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)\n\n    def remove_rubberband(self):\n        NavigationToolbar2Wx.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx",
      "name": "SaveFigureWx",
      "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureWx(backend_tools.SaveFigureBase):\n    def trigger(self, *args):\n        NavigationToolbar2Wx.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx",
      "name": "SetCursorWx",
      "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx",
      "decorators": [
        "_api.deprecated('3.5', alternative='ToolSetCursor')"
      ],
      "superclasses": [
        "backend_tools.SetCursorBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SetCursorWx(backend_tools.SetCursorBase):\n    def set_cursor(self, cursor):\n        NavigationToolbar2Wx.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx",
      "name": "TimerWx",
      "qname": "lib.matplotlib.backends.backend_wx.TimerWx",
      "decorators": [],
      "superclasses": [
        "TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/_timer_stop",
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/_timer_set_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using wx.Timer events.",
      "docstring": "Subclass of `.TimerBase` using wx.Timer events.",
      "code": "class TimerWx(TimerBase):\n    \"\"\"Subclass of `.TimerBase` using wx.Timer events.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._timer = wx.Timer()\n        self._timer.Notify = self._on_timer\n        super().__init__(*args, **kwargs)\n\n    def _timer_start(self):\n        self._timer.Start(self._interval, self._single)\n\n    def _timer_stop(self):\n        self._timer.Stop()\n\n    def _timer_set_interval(self):\n        if self._timer.IsRunning():\n            self._timer_start()  # Restart with new interval.",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx",
      "name": "ToolCopyToClipboardWx",
      "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx",
      "decorators": [
        "backend_tools._register_tool_class(_FigureCanvasWxBase)"
      ],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardWx(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        if not self.canvas._isDrawn:\n            self.canvas.draw()\n        if not self.canvas.bitmap.IsOk() or not wx.TheClipboard.Open():\n            return\n        try:\n            wx.TheClipboard.SetData(wx.BitmapDataObject(self.canvas.bitmap))\n        finally:\n            wx.TheClipboard.Close()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx",
      "name": "ToolbarWx",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "wx.ToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/_get_tool_pos",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarWx(ToolContainerBase, wx.ToolBar):\n    def __init__(self, toolmanager, parent=None, style=wx.TB_BOTTOM):\n        if parent is None:\n            parent = toolmanager.canvas.GetParent()\n        ToolContainerBase.__init__(self, toolmanager)\n        wx.ToolBar.__init__(self, parent, -1, style=style)\n        self._space = self.AddStretchableSpace()\n        self._label_text = wx.StaticText(self, style=wx.ALIGN_RIGHT)\n        self.AddControl(self._label_text)\n        self._toolitems = {}\n        self._groups = {}  # Mapping of groups to the separator after them.\n\n    def _get_tool_pos(self, tool):\n        \"\"\"\n        Find the position (index) of a wx.ToolBarToolBase in a ToolBar.\n\n        ``ToolBar.GetToolPos`` is not useful because wx assigns the same Id to\n        all Separators and StretchableSpaces.\n        \"\"\"\n        pos, = [pos for pos in range(self.ToolsCount)\n                if self.GetToolByPos(pos) == tool]\n        return pos\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        # Find or create the separator that follows this group.\n        if group not in self._groups:\n            self._groups[group] = self.InsertSeparator(\n                self._get_tool_pos(self._space))\n        sep = self._groups[group]\n        # List all separators.\n        seps = [t for t in map(self.GetToolByPos, range(self.ToolsCount))\n                if t.IsSeparator() and not t.IsStretchableSpace()]\n        # Find where to insert the tool.\n        if position >= 0:\n            # Find the start of the group by looking for the separator\n            # preceding this one; then move forward from it.\n            start = (0 if sep == seps[0]\n                     else self._get_tool_pos(seps[seps.index(sep) - 1]) + 1)\n        else:\n            # Move backwards from this separator.\n            start = self._get_tool_pos(sep) + 1\n        idx = start + position\n        if image_file:\n            bmp = NavigationToolbar2Wx._icon(image_file)\n            kind = wx.ITEM_NORMAL if not toggle else wx.ITEM_CHECK\n            tool = self.InsertTool(idx, -1, name, bmp, wx.NullBitmap, kind,\n                                   description or \"\")\n        else:\n            size = (self.GetTextExtent(name)[0] + 10, -1)\n            if toggle:\n                control = wx.ToggleButton(self, -1, name, size=size)\n            else:\n                control = wx.Button(self, -1, name, size=size)\n            tool = self.InsertControl(idx, control, label=name)\n        self.Realize()\n\n        def handler(event):\n            self.trigger_tool(name)\n\n        if image_file:\n            self.Bind(wx.EVT_TOOL, handler, tool)\n        else:\n            control.Bind(wx.EVT_LEFT_DOWN, handler)\n\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tool, handler))\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for tool, handler in self._toolitems[name]:\n            if not tool.IsControl():\n                self.ToggleTool(tool.Id, toggled)\n            else:\n                tool.GetControl().SetValue(toggled)\n        self.Refresh()\n\n    def remove_toolitem(self, name):\n        for tool, handler in self._toolitems[name]:\n            self.DeleteTool(tool.Id)\n        del self._toolitems[name]\n\n    def set_message(self, s):\n        self._label_text.SetLabel(s)",
      "instance_attributes": [
        {
          "name": "_space",
          "types": null
        },
        {
          "name": "_label_text",
          "types": null
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_wx.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    cursord = _api.deprecated(\"3.5\", obj_type=\"\")(property(lambda self: {\n        cursors.MOVE: wx.CURSOR_HAND,\n        cursors.HAND: wx.CURSOR_HAND,\n        cursors.POINTER: wx.CURSOR_ARROW,\n        cursors.SELECT_REGION: wx.CURSOR_CROSS,\n        cursors.WAIT: wx.CURSOR_WAIT,\n        cursors.RESIZE_HORIZONTAL: wx.CURSOR_SIZEWE,\n        cursors.RESIZE_VERTICAL: wx.CURSOR_SIZENS,\n    }))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg",
      "name": "FigureCanvasWxAgg",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "_FigureCanvasWxBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw",
        "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually)\nlives inside a frame instantiated by a FigureManagerWx. The parent\nwindow probably implements a wxSizer to control the displayed\ncontrol size - but we give a hint as to our preferred minimum\nsize.",
      "docstring": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually)\nlives inside a frame instantiated by a FigureManagerWx. The parent\nwindow probably implements a wxSizer to control the displayed\ncontrol size - but we give a hint as to our preferred minimum\nsize.",
      "code": "class FigureCanvasWxAgg(FigureCanvasAgg, _FigureCanvasWxBase):\n    \"\"\"\n    The FigureCanvas contains the figure and does event handling.\n\n    In the wxPython backend, it is derived from wxPanel, and (usually)\n    lives inside a frame instantiated by a FigureManagerWx. The parent\n    window probably implements a wxSizer to control the displayed\n    control size - but we give a hint as to our preferred minimum\n    size.\n    \"\"\"\n\n    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using agg.\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n        self.bitmap = _rgba_to_wx_bitmap(self.get_renderer().buffer_rgba())\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)\n\n    def blit(self, bbox=None):\n        # docstring inherited\n        bitmap = _rgba_to_wx_bitmap(self.get_renderer().buffer_rgba())\n        if bbox is None:\n            self.bitmap = bitmap\n        else:\n            srcDC = wx.MemoryDC(bitmap)\n            destDC = wx.MemoryDC(self.bitmap)\n            x = int(bbox.x0)\n            y = int(self.bitmap.GetHeight() - bbox.y1)\n            destDC.Blit(x, y, int(bbox.width), int(bbox.height), srcDC, x, y)\n            destDC.SelectObject(wx.NullBitmap)\n            srcDC.SelectObject(wx.NullBitmap)\n        self.gui_repaint()",
      "instance_attributes": [
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "_isDrawn",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg",
      "name": "FigureFrameWxAgg",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg",
      "decorators": [
        "_api.deprecated('3.6', alternative='FigureFrameWx(..., canvas_class=FigureCanvasWxAgg)')"
      ],
      "superclasses": [
        "FigureFrameWx"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureFrameWxAgg(FigureFrameWx):\n    def get_canvas(self, fig):\n        return FigureCanvasWxAgg(self, -1, fig)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo",
      "name": "FigureCanvasWxCairo",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "_FigureCanvasWxBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually) lives\ninside a frame instantiated by a FigureManagerWx. The parent window\nprobably implements a wxSizer to control the displayed control size - but\nwe give a hint as to our preferred minimum size.",
      "docstring": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually) lives\ninside a frame instantiated by a FigureManagerWx. The parent window\nprobably implements a wxSizer to control the displayed control size - but\nwe give a hint as to our preferred minimum size.",
      "code": "class FigureCanvasWxCairo(FigureCanvasCairo, _FigureCanvasWxBase):\n    \"\"\"\n    The FigureCanvas contains the figure and does event handling.\n\n    In the wxPython backend, it is derived from wxPanel, and (usually) lives\n    inside a frame instantiated by a FigureManagerWx. The parent window\n    probably implements a wxSizer to control the displayed control size - but\n    we give a hint as to our preferred minimum size.\n    \"\"\"\n\n    def draw(self, drawDC=None):\n        size = self.figure.bbox.size.astype(int)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, *size)\n        self._renderer.set_context(cairo.Context(surface))\n        self._renderer.dpi = self.figure.dpi\n        self.figure.draw(self._renderer)\n        self.bitmap = wxcairo.BitmapFromImageSurface(surface)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)",
      "instance_attributes": [
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "_isDrawn",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo",
      "name": "FigureFrameWxCairo",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo",
      "decorators": [
        "_api.deprecated('3.6', alternative='FigureFrameWx(..., canvas_class=FigureCanvasWxCairo)')"
      ],
      "superclasses": [
        "FigureFrameWx"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureFrameWxCairo(FigureFrameWx):\n    def get_canvas(self, fig):\n        return FigureCanvasWxCairo(self, -1, fig)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.qt_compat/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.qt_compat.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    ETS = _api.deprecated(\"3.5\")(property(lambda self: dict(\n        pyqt5=(QT_API_PYQT5, 5), pyside2=(QT_API_PYSIDE2, 5))))\n    QT_RC_MAJOR_VERSION = _api.deprecated(\"3.5\")(property(\n        lambda self: int(QtCore.qVersion().split(\".\")[0])))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry",
      "name": "CallbackRegistry",
      "qname": "lib.matplotlib.cbook.CallbackRegistry",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__getstate__",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__setstate__",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/_connect_picklable",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/_remove_proxy",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/blocked"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Handle registering, processing, blocking, and disconnecting\nfor a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...    print('eat', x)\n    >>> def ondrink(x):\n    ...    print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456)   # nothing will be called\n\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)        # nothing will be called\n\n    >>> with callbacks.blocked(signal='drink'):\n    ...     callbacks.process('drink', 123)  # nothing will be called\n    >>> callbacks.process('drink', 123)\n    drink 123\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.",
      "docstring": "Handle registering, processing, blocking, and disconnecting\nfor a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...    print('eat', x)\n    >>> def ondrink(x):\n    ...    print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456)   # nothing will be called\n\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)        # nothing will be called\n\n    >>> with callbacks.blocked(signal='drink'):\n    ...     callbacks.process('drink', 123)  # nothing will be called\n    >>> callbacks.process('drink', 123)\n    drink 123\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.\n\nParameters\n----------\nexception_handler : callable, optional\n   If not None, *exception_handler* must be a function that takes an\n   `Exception` as single parameter.  It gets called with any `Exception`\n   raised by the callbacks during `CallbackRegistry.process`, and may\n   either re-raise the exception or handle it in another manner.\n\n   The default handler prints the exception (with `traceback.print_exc`) if\n   an interactive event loop is running; it re-raises the exception if no\n   interactive event loop is running.\n\nsignals : list, optional\n    If not None, *signals* is a list of signals that this registry handles:\n    attempting to `process` or to `connect` to a signal not in the list\n    throws a `ValueError`.  The default, None, does not restrict the\n    handled signals.",
      "code": "class CallbackRegistry:\n    \"\"\"\n    Handle registering, processing, blocking, and disconnecting\n    for a set of signals and callbacks:\n\n        >>> def oneat(x):\n        ...    print('eat', x)\n        >>> def ondrink(x):\n        ...    print('drink', x)\n\n        >>> from matplotlib.cbook import CallbackRegistry\n        >>> callbacks = CallbackRegistry()\n\n        >>> id_eat = callbacks.connect('eat', oneat)\n        >>> id_drink = callbacks.connect('drink', ondrink)\n\n        >>> callbacks.process('drink', 123)\n        drink 123\n        >>> callbacks.process('eat', 456)\n        eat 456\n        >>> callbacks.process('be merry', 456)   # nothing will be called\n\n        >>> callbacks.disconnect(id_eat)\n        >>> callbacks.process('eat', 456)        # nothing will be called\n\n        >>> with callbacks.blocked(signal='drink'):\n        ...     callbacks.process('drink', 123)  # nothing will be called\n        >>> callbacks.process('drink', 123)\n        drink 123\n\n    In practice, one should always disconnect all callbacks when they are\n    no longer needed to avoid dangling references (and thus memory leaks).\n    However, real code in Matplotlib rarely does so, and due to its design,\n    it is rather difficult to place this kind of code.  To get around this,\n    and prevent this class of memory leaks, we instead store weak references\n    to bound methods only, so when the destination object needs to die, the\n    CallbackRegistry won't keep it alive.\n\n    Parameters\n    ----------\n    exception_handler : callable, optional\n       If not None, *exception_handler* must be a function that takes an\n       `Exception` as single parameter.  It gets called with any `Exception`\n       raised by the callbacks during `CallbackRegistry.process`, and may\n       either re-raise the exception or handle it in another manner.\n\n       The default handler prints the exception (with `traceback.print_exc`) if\n       an interactive event loop is running; it re-raises the exception if no\n       interactive event loop is running.\n\n    signals : list, optional\n        If not None, *signals* is a list of signals that this registry handles:\n        attempting to `process` or to `connect` to a signal not in the list\n        throws a `ValueError`.  The default, None, does not restrict the\n        handled signals.\n    \"\"\"\n\n    # We maintain two mappings:\n    #   callbacks: signal -> {cid -> weakref-to-callback}\n    #   _func_cid_map: signal -> {weakref-to-callback -> cid}\n\n    def __init__(self, exception_handler=_exception_printer, *, signals=None):\n        self._signals = None if signals is None else list(signals)  # Copy it.\n        self.exception_handler = exception_handler\n        self.callbacks = {}\n        self._cid_gen = itertools.count()\n        self._func_cid_map = {}\n        # A hidden variable that marks cids that need to be pickled.\n        self._pickled_cids = set()\n\n    def __getstate__(self):\n        return {\n            **vars(self),\n            # In general, callbacks may not be pickled, so we just drop them,\n            # unless directed otherwise by self._pickled_cids.\n            \"callbacks\": {s: {cid: proxy() for cid, proxy in d.items()\n                              if cid in self._pickled_cids}\n                          for s, d in self.callbacks.items()},\n            # It is simpler to reconstruct this from callbacks in __setstate__.\n            \"_func_cid_map\": None,\n        }\n\n    def __setstate__(self, state):\n        vars(self).update(state)\n        self.callbacks = {\n            s: {cid: _weak_or_strong_ref(func, self._remove_proxy)\n                for cid, func in d.items()}\n            for s, d in self.callbacks.items()}\n        self._func_cid_map = {\n            s: {proxy: cid for cid, proxy in d.items()}\n            for s, d in self.callbacks.items()}\n\n    def connect(self, signal, func):\n        \"\"\"Register *func* to be called when signal *signal* is generated.\"\"\"\n        if signal == \"units finalize\":\n            _api.warn_deprecated(\n                \"3.5\", name=signal, obj_type=\"signal\", alternative=\"units\")\n        if self._signals is not None:\n            _api.check_in_list(self._signals, signal=signal)\n        self._func_cid_map.setdefault(signal, {})\n        proxy = _weak_or_strong_ref(func, self._remove_proxy)\n        if proxy in self._func_cid_map[signal]:\n            return self._func_cid_map[signal][proxy]\n        cid = next(self._cid_gen)\n        self._func_cid_map[signal][proxy] = cid\n        self.callbacks.setdefault(signal, {})\n        self.callbacks[signal][cid] = proxy\n        return cid\n\n    def _connect_picklable(self, signal, func):\n        \"\"\"\n        Like `.connect`, but the callback is kept when pickling/unpickling.\n\n        Currently internal-use only.\n        \"\"\"\n        cid = self.connect(signal, func)\n        self._pickled_cids.add(cid)\n        return cid\n\n    # Keep a reference to sys.is_finalizing, as sys may have been cleared out\n    # at that point.\n    def _remove_proxy(self, proxy, *, _is_finalizing=sys.is_finalizing):\n        if _is_finalizing():\n            # Weakrefs can't be properly torn down at that point anymore.\n            return\n        for signal, proxy_to_cid in list(self._func_cid_map.items()):\n            cid = proxy_to_cid.pop(proxy, None)\n            if cid is not None:\n                del self.callbacks[signal][cid]\n                self._pickled_cids.discard(cid)\n                break\n        else:\n            # Not found\n            return\n        # Clean up empty dicts\n        if len(self.callbacks[signal]) == 0:\n            del self.callbacks[signal]\n            del self._func_cid_map[signal]\n\n    def disconnect(self, cid):\n        \"\"\"\n        Disconnect the callback registered with callback id *cid*.\n\n        No error is raised if such a callback does not exist.\n        \"\"\"\n        self._pickled_cids.discard(cid)\n        # Clean up callbacks\n        for signal, cid_to_proxy in list(self.callbacks.items()):\n            proxy = cid_to_proxy.pop(cid, None)\n            if proxy is not None:\n                break\n        else:\n            # Not found\n            return\n\n        proxy_to_cid = self._func_cid_map[signal]\n        for current_proxy, current_cid in list(proxy_to_cid.items()):\n            if current_cid == cid:\n                assert proxy is current_proxy\n                del proxy_to_cid[current_proxy]\n        # Clean up empty dicts\n        if len(self.callbacks[signal]) == 0:\n            del self.callbacks[signal]\n            del self._func_cid_map[signal]\n\n    def process(self, s, *args, **kwargs):\n        \"\"\"\n        Process signal *s*.\n\n        All of the functions registered to receive callbacks on *s* will be\n        called with ``*args`` and ``**kwargs``.\n        \"\"\"\n        if self._signals is not None:\n            _api.check_in_list(self._signals, signal=s)\n        for cid, ref in list(self.callbacks.get(s, {}).items()):\n            func = ref()\n            if func is not None:\n                try:\n                    func(*args, **kwargs)\n                # this does not capture KeyboardInterrupt, SystemExit,\n                # and GeneratorExit\n                except Exception as exc:\n                    if self.exception_handler is not None:\n                        self.exception_handler(exc)\n                    else:\n                        raise\n\n    @contextlib.contextmanager\n    def blocked(self, *, signal=None):\n        \"\"\"\n        Block callback signals from being processed.\n\n        A context manager to temporarily block/disable callback signals\n        from being processed by the registered listeners.\n\n        Parameters\n        ----------\n        signal : str, optional\n            The callback signal to block. The default is to block all signals.\n        \"\"\"\n        orig = self.callbacks\n        try:\n            if signal is None:\n                # Empty out the callbacks\n                self.callbacks = {}\n            else:\n                # Only remove the specific signal\n                self.callbacks = {k: orig[k] for k in orig if k != signal}\n            yield\n        finally:\n            self.callbacks = orig",
      "instance_attributes": [
        {
          "name": "_signals",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "exception_handler",
          "types": {
            "kind": "NamedType",
            "name": "Callable"
          }
        },
        {
          "name": "callbacks",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_cid_gen",
          "types": {
            "kind": "NamedType",
            "name": "count"
          }
        },
        {
          "name": "_func_cid_map",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_pickled_cids",
          "types": {
            "kind": "NamedType",
            "name": "set"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper",
      "name": "Grouper",
      "qname": "lib.matplotlib.cbook.Grouper",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/Grouper/__init__",
        "matplotlib/lib.matplotlib.cbook/Grouper/__contains__",
        "matplotlib/lib.matplotlib.cbook/Grouper/clean",
        "matplotlib/lib.matplotlib.cbook/Grouper/join",
        "matplotlib/lib.matplotlib.cbook/Grouper/joined",
        "matplotlib/lib.matplotlib.cbook/Grouper/remove",
        "matplotlib/lib.matplotlib.cbook/Grouper/__iter__",
        "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.",
      "docstring": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.\n\nExamples\n--------\n>>> from matplotlib.cbook import Grouper\n>>> class Foo:\n...     def __init__(self, s):\n...         self.s = s\n...     def __repr__(self):\n...         return self.s\n...\n>>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n>>> grp = Grouper()\n>>> grp.join(a, b)\n>>> grp.join(b, c)\n>>> grp.join(d, e)\n>>> list(grp)\n[[a, b, c], [d, e]]\n>>> grp.joined(a, b)\nTrue\n>>> grp.joined(a, c)\nTrue\n>>> grp.joined(a, d)\nFalse",
      "code": "class Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> list(grp)\n    [[a, b, c], [d, e]]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]",
      "instance_attributes": [
        {
          "name": "_mapping",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/GrouperView",
      "name": "GrouperView",
      "qname": "lib.matplotlib.cbook.GrouperView",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/GrouperView/__init__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Immutable view over a `.Grouper`.",
      "docstring": "Immutable view over a `.Grouper`.",
      "code": "class GrouperView:\n    \"\"\"Immutable view over a `.Grouper`.\"\"\"\n\n    def __init__(self, grouper):\n        self._grouper = grouper\n\n    class _GrouperMethodForwarder:\n        def __init__(self, deprecated_kw=None):\n            self._deprecated_kw = deprecated_kw\n\n        def __set_name__(self, owner, name):\n            wrapped = getattr(Grouper, name)\n            forwarder = functools.wraps(wrapped)(\n                lambda self, *args, **kwargs: wrapped(\n                    self._grouper, *args, **kwargs))\n            if self._deprecated_kw:\n                forwarder = _api.deprecated(**self._deprecated_kw)(forwarder)\n            setattr(owner, name, forwarder)\n\n    __contains__ = _GrouperMethodForwarder()\n    __iter__ = _GrouperMethodForwarder()\n    joined = _GrouperMethodForwarder()\n    get_siblings = _GrouperMethodForwarder()\n    clean = _GrouperMethodForwarder(deprecated_kw=dict(since=\"3.6\"))\n    join = _GrouperMethodForwarder(deprecated_kw=dict(since=\"3.6\"))\n    remove = _GrouperMethodForwarder(deprecated_kw=dict(since=\"3.6\"))",
      "instance_attributes": [
        {
          "name": "_grouper",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack",
      "name": "Stack",
      "qname": "lib.matplotlib.cbook.Stack",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/Stack/__init__",
        "matplotlib/lib.matplotlib.cbook/Stack/__call__",
        "matplotlib/lib.matplotlib.cbook/Stack/__len__",
        "matplotlib/lib.matplotlib.cbook/Stack/__getitem__",
        "matplotlib/lib.matplotlib.cbook/Stack/forward",
        "matplotlib/lib.matplotlib.cbook/Stack/back",
        "matplotlib/lib.matplotlib.cbook/Stack/push",
        "matplotlib/lib.matplotlib.cbook/Stack/home",
        "matplotlib/lib.matplotlib.cbook/Stack/empty",
        "matplotlib/lib.matplotlib.cbook/Stack/clear",
        "matplotlib/lib.matplotlib.cbook/Stack/bubble",
        "matplotlib/lib.matplotlib.cbook/Stack/remove"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "docstring": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "code": "class Stack:\n    \"\"\"\n    Stack of elements with a movable cursor.\n\n    Mimics home/back/forward in a web browser.\n    \"\"\"\n\n    def __init__(self, default=None):\n        self.clear()\n        self._default = default\n\n    def __call__(self):\n        \"\"\"Return the current element, or None.\"\"\"\n        if not self._elements:\n            return self._default\n        else:\n            return self._elements[self._pos]\n\n    def __len__(self):\n        return len(self._elements)\n\n    def __getitem__(self, ind):\n        return self._elements[ind]\n\n    def forward(self):\n        \"\"\"Move the position forward and return the current element.\"\"\"\n        self._pos = min(self._pos + 1, len(self._elements) - 1)\n        return self()\n\n    def back(self):\n        \"\"\"Move the position back and return the current element.\"\"\"\n        if self._pos > 0:\n            self._pos -= 1\n        return self()\n\n    def push(self, o):\n        \"\"\"\n        Push *o* to the stack at current position.  Discard all later elements.\n\n        *o* is returned.\n        \"\"\"\n        self._elements = self._elements[:self._pos + 1] + [o]\n        self._pos = len(self._elements) - 1\n        return self()\n\n    def home(self):\n        \"\"\"\n        Push the first element onto the top of the stack.\n\n        The first element is returned.\n        \"\"\"\n        if not self._elements:\n            return\n        self.push(self._elements[0])\n        return self()\n\n    def empty(self):\n        \"\"\"Return whether the stack is empty.\"\"\"\n        return len(self._elements) == 0\n\n    def clear(self):\n        \"\"\"Empty the stack.\"\"\"\n        self._pos = -1\n        self._elements = []\n\n    def bubble(self, o):\n        \"\"\"\n        Raise all references of *o* to the top of the stack, and return it.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        top_elements = []\n        for elem in old_elements:\n            if elem == o:\n                top_elements.append(elem)\n            else:\n                self.push(elem)\n        for _ in top_elements:\n            self.push(o)\n        return o\n\n    def remove(self, o):\n        \"\"\"\n        Remove *o* from the stack.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        for elem in old_elements:\n            if elem != o:\n                self.push(elem)",
      "instance_attributes": [
        {
          "name": "_default",
          "types": null
        },
        {
          "name": "_pos",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.cbook.__getattr__",
      "decorators": [
        "_api.caching_module_getattr"
      ],
      "superclasses": [],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class __getattr__:\n    # module-level deprecations\n    MatplotlibDeprecationWarning = _api.deprecated(\n        \"3.6\", obj_type=\"\",\n        alternative=\"matplotlib.MatplotlibDeprecationWarning\")(\n        property(lambda self: _api.deprecation.MatplotlibDeprecationWarning))\n    mplDeprecation = _api.deprecated(\n        \"3.6\", obj_type=\"\",\n        alternative=\"matplotlib.MatplotlibDeprecationWarning\")(\n        property(lambda self: _api.deprecation.MatplotlibDeprecationWarning))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/maxdict",
      "name": "maxdict",
      "qname": "lib.matplotlib.cbook.maxdict",
      "decorators": [
        "_api.deprecated('3.6', alternative='functools.lru_cache')"
      ],
      "superclasses": [
        "dict"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/maxdict/__init__",
        "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A dictionary with a maximum size.",
      "docstring": "A dictionary with a maximum size.\n\nNotes\n-----\nThis doesn't override all the relevant methods to constrain the size,\njust ``__setitem__``, so use with caution.",
      "code": "class maxdict(dict):\n    \"\"\"\n    A dictionary with a maximum size.\n\n    Notes\n    -----\n    This doesn't override all the relevant methods to constrain the size,\n    just ``__setitem__``, so use with caution.\n    \"\"\"\n\n    def __init__(self, maxsize):\n        super().__init__()\n        self.maxsize = maxsize\n\n    def __setitem__(self, k, v):\n        super().__setitem__(k, v)\n        while len(self) >= self.maxsize:\n            del self[next(iter(self))]",
      "instance_attributes": [
        {
          "name": "maxsize",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/silent_list",
      "name": "silent_list",
      "qname": "lib.matplotlib.cbook.silent_list",
      "decorators": [],
      "superclasses": [
        "list"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/silent_list/__init__",
        "matplotlib/lib.matplotlib.cbook/silent_list/__repr__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>\n\nIf ``self.type`` is None, the type name is obtained from the first item in\nthe list (if any).",
      "docstring": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>\n\nIf ``self.type`` is None, the type name is obtained from the first item in\nthe list (if any).",
      "code": "class silent_list(list):\n    \"\"\"\n    A list with a short ``repr()``.\n\n    This is meant to be used for a homogeneous list of artists, so that they\n    don't cause long, meaningless output.\n\n    Instead of ::\n\n        [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n         <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n         <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\n    one will get ::\n\n        <a list of 3 Line2D objects>\n\n    If ``self.type`` is None, the type name is obtained from the first item in\n    the list (if any).\n    \"\"\"\n\n    def __init__(self, type, seq=None):\n        self.type = type\n        if seq is not None:\n            self.extend(seq)\n\n    def __repr__(self):\n        if self.type is not None or len(self) != 0:\n            tp = self.type if self.type is not None else type(self[0]).__name__\n            return f\"<a list of {len(self)} {tp} objects>\"\n        else:\n            return \"<an empty list>\"",
      "instance_attributes": [
        {
          "name": "type",
          "types": null
        }
      ]
    }
  ],
  "functions": [
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/buffer_rgba",
      "name": "buffer_rgba",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.buffer_rgba",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/buffer_rgba/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.buffer_rgba.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the image as a `memoryview` to the renderer's buffer.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "docstring": "Get the image as a `memoryview` to the renderer's buffer.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "code": "    def buffer_rgba(self):\n        \"\"\"\n        Get the image as a `memoryview` to the renderer's buffer.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.buffer_rgba()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox",
      "name": "copy_from_bbox",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.copy_from_bbox",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.copy_from_bbox.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.copy_from_bbox.bbox",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def copy_from_bbox(self, bbox):\n        renderer = self.get_renderer()\n        return renderer.copy_from_bbox(bbox)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        # docstring inherited\n        self.renderer = self.get_renderer()\n        self.renderer.clear()\n        # Acquire a lock on the shared font cache.\n        with RendererAgg.lock, \\\n             (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self.figure.draw(self.renderer)\n            # A GUI class may be need to update a window using this draw, so\n            # don't forget to call the superclass.\n            super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer",
      "name": "get_renderer",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer",
      "decorators": [
        "_api.delete_parameter('3.6', 'cleared', alternative='renderer.clear()')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer/cleared",
          "name": "cleared",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer.cleared",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.6\", \"cleared\", alternative=\"renderer.clear()\")\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (self._lastKey == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg",
      "name": "print_jpg",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_jpg(self, filename_or_obj, *args, pil_kwargs=None):\n        # savefig() has already applied savefig.facecolor; we now set it to\n        # white to make imsave() blend semi-transparent figures against an\n        # assumed white background.\n        with mpl.rc_context({\"savefig.facecolor\": \"white\"}):\n            self._print_pil(filename_or_obj, \"jpeg\", pil_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "The file to write to."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "Metadata in the PNG file as key-value pairs of bytes or latin-1\nencodable strings.\nAccording to the PNG specification, keys must be shorter than 79\nchars.\n\nThe `PNG specification`_ defines some common keywords that may be\nused as appropriate:\n\n- Title: Short (one line) title or caption for image.\n- Author: Name of image's creator.\n- Description: Description of image (possibly long).\n- Copyright: Copyright notice.\n- Creation Time: Time of original image creation\n  (usually RFC 1123 format).\n- Software: Software used to create the image.\n- Disclaimer: Legal disclaimer.\n- Warning: Warning of nature of content.\n- Source: Device used to create the image.\n- Comment: Miscellaneous comment;\n  conversion from other image format.\n\nOther keywords may be invented for other purposes.\n\nIf 'Software' is not given, an autogenerated value for Matplotlib\nwill be used.  This can be removed by setting it to *None*.\n\nFor more details see the `PNG specification`_.\n\n.. _PNG specification:                 https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords"
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "Keyword arguments passed to `PIL.Image.Image.save`.\n\nIf the 'pnginfo' key is present, it completely overrides\n*metadata*, including the default 'Software' key."
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write the figure to a PNG file.",
      "docstring": "Write the figure to a PNG file.\n\nParameters\n----------\nfilename_or_obj : str or path-like or file-like\n    The file to write to.\n\nmetadata : dict, optional\n    Metadata in the PNG file as key-value pairs of bytes or latin-1\n    encodable strings.\n    According to the PNG specification, keys must be shorter than 79\n    chars.\n\n    The `PNG specification`_ defines some common keywords that may be\n    used as appropriate:\n\n    - Title: Short (one line) title or caption for image.\n    - Author: Name of image's creator.\n    - Description: Description of image (possibly long).\n    - Copyright: Copyright notice.\n    - Creation Time: Time of original image creation\n      (usually RFC 1123 format).\n    - Software: Software used to create the image.\n    - Disclaimer: Legal disclaimer.\n    - Warning: Warning of nature of content.\n    - Source: Device used to create the image.\n    - Comment: Miscellaneous comment;\n      conversion from other image format.\n\n    Other keywords may be invented for other purposes.\n\n    If 'Software' is not given, an autogenerated value for Matplotlib\n    will be used.  This can be removed by setting it to *None*.\n\n    For more details see the `PNG specification`_.\n\n    .. _PNG specification:                 https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\npil_kwargs : dict, optional\n    Keyword arguments passed to `PIL.Image.Image.save`.\n\n    If the 'pnginfo' key is present, it completely overrides\n    *metadata*, including the default 'Software' key.",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_png(self, filename_or_obj, *args,\n                  metadata=None, pil_kwargs=None):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for Matplotlib\n            will be used.  This can be removed by setting it to *None*.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            Keyword arguments passed to `PIL.Image.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n        self._print_pil(filename_or_obj, \"png\", pil_kwargs, metadata)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw",
      "name": "print_raw",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_raw(self, filename_or_obj, *args):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        with cbook.open_file_cm(filename_or_obj, \"wb\") as fh:\n            fh.write(renderer.buffer_rgba())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif",
      "name": "print_tif",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_tif(self, filename_or_obj, *, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"tiff\", pil_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_to_buffer",
      "name": "print_to_buffer",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_to_buffer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_to_buffer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_to_buffer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        return (bytes(renderer.buffer_rgba()),\n                (int(renderer.width), int(renderer.height)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp",
      "name": "print_webp",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_webp",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_webp.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_webp.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_webp/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_webp.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_webp(self, filename_or_obj, *, pil_kwargs=None):\n        self._print_pil(filename_or_obj, \"webp\", pil_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region",
      "name": "restore_region",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/region",
          "name": "region",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.region",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/xy",
          "name": "xy",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.xy",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def restore_region(self, region, bbox=None, xy=None):\n        renderer = self.get_renderer()\n        return renderer.restore_region(region, bbox, xy)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_argb",
      "name": "tostring_argb",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_argb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_argb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_argb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the image as ARGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "docstring": "Get the image as ARGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "code": "    def tostring_argb(self):\n        \"\"\"\n        Get the image as ARGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_argb()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_rgb",
      "name": "tostring_rgb",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_rgb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_rgb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_rgb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the image as RGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "docstring": "Get the image as RGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "code": "    def tostring_rgb(self):\n        \"\"\"\n        Get the image as RGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_rgb()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__getstate__",
      "name": "__getstate__",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__getstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__getstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__getstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles",
      "docstring": "",
      "code": "    def __init__(self, width, height, dpi):\n        super().__init__()\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('Agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__",
      "name": "__setstate__",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__setstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__setstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__/state",
          "name": "state",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__setstate__.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/buffer_rgba",
      "name": "buffer_rgba",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.buffer_rgba",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/buffer_rgba/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.buffer_rgba.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def buffer_rgba(self):\n        return memoryview(self._renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/clear",
      "name": "clear",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def clear(self):\n        self._renderer.clear()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext",
      "name": "draw_mathtext",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw mathtext using :mod:`matplotlib.mathtext`.",
      "docstring": "Draw mathtext using :mod:`matplotlib.mathtext`.",
      "code": "    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw mathtext using :mod:`matplotlib.mathtext`.\"\"\"\n        ox, oy, width, height, descent, font_image = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        xd = descent * sin(radians(angle))\n        yd = descent * cos(radians(angle))\n        x = round(x + ox + xd)\n        y = round(y - oy + yd)\n        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        nmax = mpl.rcParams['agg.path.chunksize']  # here at least for testing\n        npts = path.vertices.shape[0]\n\n        if (npts > nmax > 100 and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts / nmax)\n            chsize = int(np.ceil(npts / nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1, :]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO  # move to end of last chunk\n                p = Path(v, c)\n                p.simplify_threshold = path.simplify_threshold\n                try:\n                    self._renderer.draw_path(gc, p, transform, rgbFace)\n                except OverflowError:\n                    msg = (\n                        \"Exceeded cell block limit in Agg.\\n\\n\"\n                        \"Please reduce the value of \"\n                        f\"rcParams['agg.path.chunksize'] (currently {nmax}) \"\n                        \"or increase the path simplification threshold\"\n                        \"(rcParams['path.simplify_threshold'] = \"\n                        f\"{mpl.rcParams['path.simplify_threshold']:.2f} by \"\n                        \"default and path.simplify_threshold = \"\n                        f\"{path.simplify_threshold:.2f} on the input).\"\n                    )\n                    raise OverflowError(msg) from None\n        else:\n            try:\n                self._renderer.draw_path(gc, path, transform, rgbFace)\n            except OverflowError:\n                cant_chunk = ''\n                if rgbFace is not None:\n                    cant_chunk += \"- can not split filled path\\n\"\n                if gc.get_hatch() is not None:\n                    cant_chunk += \"- can not split hatched path\\n\"\n                if not path.should_simplify:\n                    cant_chunk += \"- path.should_simplify is False\\n\"\n                if len(cant_chunk):\n                    msg = (\n                        \"Exceeded cell block limit in Agg, however for the \"\n                        \"following reasons:\\n\\n\"\n                        f\"{cant_chunk}\\n\"\n                        \"we can not automatically split up this path to draw.\"\n                        \"\\n\\nPlease manually simplify your path.\"\n                    )\n\n                else:\n                    inc_threshold = (\n                        \"or increase the path simplification threshold\"\n                        \"(rcParams['path.simplify_threshold'] = \"\n                        f\"{mpl.rcParams['path.simplify_threshold']} \"\n                        \"by default and path.simplify_threshold \"\n                        f\"= {path.simplify_threshold} \"\n                        \"on the input).\"\n                        )\n                    if nmax > 100:\n                        msg = (\n                            \"Exceeded cell block limit in Agg.  Please reduce \"\n                            \"the value of rcParams['agg.path.chunksize'] \"\n                            f\"(currently {nmax}) {inc_threshold}\"\n                        )\n                    else:\n                        msg = (\n                            \"Exceeded cell block limit in Agg.  Please set \"\n                            \"the value of rcParams['agg.path.chunksize'], \"\n                            f\"(currently {nmax}) to be greater than 100 \"\n                            + inc_threshold\n                        )\n\n                raise OverflowError(msg) from None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        # todo, handle props, angle, origins\n        size = prop.get_size_in_points()\n\n        texmanager = self.get_texmanager()\n\n        Z = texmanager.get_grey(s, size, self.dpi)\n        Z = np.array(Z * 255.0, np.uint8)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xd)\n        y = round(y + yd)\n        self._renderer.draw_text_image(Z, x, y, angle, gc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n        font = self._prepare_font(prop)\n        # We pass '0' for angle here, since it will be rotated (in raster\n        # space) in the following call to draw_text_image).\n        font.set_text(s, 0, flags=get_hinting_flag())\n        font.draw_glyphs_to_bitmap(\n            antialiased=mpl.rcParams['text.antialiased'])\n        d = font.get_descent() / 64.0\n        # The descent needs to be adjusted for the angle.\n        xo, yo = font.get_bitmap_offset()\n        xo /= 64.0\n        yo /= 64.0\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xo + xd)\n        y = round(y + yo + yd)\n        self._renderer.draw_text_image(font, x, y + 1, angle, gc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        _api.check_in_list([\"TeX\", True, False], ismath=ismath)\n        if ismath == \"TeX\":\n            # todo: handle props\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(\n                s, fontsize, renderer=self)\n            return w, h, d\n\n        if ismath:\n            ox, oy, width, height, descent, font_image = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        font = self._prepare_font(prop)\n        font.set_text(s, 0.0, flags=get_hinting_flag())\n        w, h = font.get_width_height()  # width and height of unrotated string\n        d = font.get_descent()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d /= 64.0\n        return w, h, d"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_image_nocomposite",
      "name": "option_image_nocomposite",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_image_nocomposite/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_image_nocomposite(self):\n        # docstring inherited\n\n        # It is generally faster to composite each image directly to\n        # the Figure, and there's no file size benefit to compositing\n        # with the Agg backend\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_scale_image",
      "name": "option_scale_image",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_scale_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_scale_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_scale_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_scale_image(self):\n        # docstring inherited\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * self.dpi / 72"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region",
      "name": "restore_region",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/region",
          "name": "region",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.region",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/xy",
          "name": "xy",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.xy",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Restore the saved region. If bbox (instance of BboxBase, or\nits extents) is given, only the region specified by the bbox\nwill be restored. *xy* (a pair of floats) optionally\nspecifies the new position (the LLC of the original region,\nnot the LLC of the bbox) where the region will be restored.\n\n>>> region = renderer.copy_from_bbox()\n>>> x1, y1, x2, y2 = region.get_extents()\n>>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n...                         xy=(x1-dx, y1))",
      "docstring": "Restore the saved region. If bbox (instance of BboxBase, or\nits extents) is given, only the region specified by the bbox\nwill be restored. *xy* (a pair of floats) optionally\nspecifies the new position (the LLC of the original region,\nnot the LLC of the bbox) where the region will be restored.\n\n>>> region = renderer.copy_from_bbox()\n>>> x1, y1, x2, y2 = region.get_extents()\n>>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n...                         xy=(x1-dx, y1))",
      "code": "    def restore_region(self, region, bbox=None, xy=None):\n        \"\"\"\n        Restore the saved region. If bbox (instance of BboxBase, or\n        its extents) is given, only the region specified by the bbox\n        will be restored. *xy* (a pair of floats) optionally\n        specifies the new position (the LLC of the original region,\n        not the LLC of the bbox) where the region will be restored.\n\n        >>> region = renderer.copy_from_bbox()\n        >>> x1, y1, x2, y2 = region.get_extents()\n        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n        ...                         xy=(x1-dx, y1))\n\n        \"\"\"\n        if bbox is not None or xy is not None:\n            if bbox is None:\n                x1, y1, x2, y2 = region.get_extents()\n            elif isinstance(bbox, BboxBase):\n                x1, y1, x2, y2 = bbox.extents\n            else:\n                x1, y1, x2, y2 = bbox\n\n            if xy is None:\n                ox, oy = x1, y1\n            else:\n                ox, oy = xy\n\n            # The incoming data is float, but the _renderer type-checking wants\n            # to see integers.\n            self._renderer.restore_region(region, int(x1), int(y1),\n                                          int(x2), int(y2), int(ox), int(oy))\n\n        else:\n            self._renderer.restore_region(region)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/start_filter",
      "name": "start_filter",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.start_filter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/start_filter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.start_filter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Start filtering. It simply create a new canvas (the old one is saved).",
      "docstring": "Start filtering. It simply create a new canvas (the old one is saved).",
      "code": "    def start_filter(self):\n        \"\"\"\n        Start filtering. It simply create a new canvas (the old one is saved).\n        \"\"\"\n        self._filter_renderers.append(self._renderer)\n        self._renderer = _RendererAgg(int(self.width), int(self.height),\n                                      self.dpi)\n        self._update_methods()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter",
      "name": "stop_filter",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter/post_processing",
          "name": "post_processing",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter.post_processing",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save the plot in the current canvas as a image and apply\nthe *post_processing* function.\n\n   def post_processing(image, dpi):\n     # ny, nx, depth = image.shape\n     # image (numpy array) has RGBA channels and has a depth of 4.\n     ...\n     # create a new_image (numpy array of 4 channels, size can be\n     # different). The resulting image may have offsets from\n     # lower-left corner of the original image\n     return new_image, offset_x, offset_y\n\nThe saved renderer is restored and the returned image from\npost_processing is plotted (using draw_image) on it.",
      "docstring": "Save the plot in the current canvas as a image and apply\nthe *post_processing* function.\n\n   def post_processing(image, dpi):\n     # ny, nx, depth = image.shape\n     # image (numpy array) has RGBA channels and has a depth of 4.\n     ...\n     # create a new_image (numpy array of 4 channels, size can be\n     # different). The resulting image may have offsets from\n     # lower-left corner of the original image\n     return new_image, offset_x, offset_y\n\nThe saved renderer is restored and the returned image from\npost_processing is plotted (using draw_image) on it.",
      "code": "    def stop_filter(self, post_processing):\n        \"\"\"\n        Save the plot in the current canvas as a image and apply\n        the *post_processing* function.\n\n           def post_processing(image, dpi):\n             # ny, nx, depth = image.shape\n             # image (numpy array) has RGBA channels and has a depth of 4.\n             ...\n             # create a new_image (numpy array of 4 channels, size can be\n             # different). The resulting image may have offsets from\n             # lower-left corner of the original image\n             return new_image, offset_x, offset_y\n\n        The saved renderer is restored and the returned image from\n        post_processing is plotted (using draw_image) on it.\n        \"\"\"\n        orig_img = np.asarray(self.buffer_rgba())\n        slice_y, slice_x = cbook._get_nonzero_slices(orig_img[..., 3])\n        cropped_img = orig_img[slice_y, slice_x]\n\n        self._renderer = self._filter_renderers.pop()\n        self._update_methods()\n\n        if cropped_img.size:\n            img, ox, oy = post_processing(cropped_img / 255, self.dpi)\n            gc = self.new_gc()\n            if img.dtype.kind == 'f':\n                img = np.asarray(img * 255., np.uint8)\n            self._renderer.draw_image(\n                gc, slice_x.start + ox, int(self.height) - slice_y.stop + oy,\n                img[::-1])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_argb",
      "name": "tostring_argb",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_argb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_argb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_argb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def tostring_argb(self):\n        return np.asarray(self._renderer).take([3, 0, 1, 2], axis=2).tobytes()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgb",
      "name": "tostring_rgb",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def tostring_rgb(self):\n        return np.asarray(self._renderer).take([0, 1, 2], axis=2).tobytes()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/get_hinting_flag",
      "name": "get_hinting_flag",
      "qname": "lib.matplotlib.backends.backend_agg.get_hinting_flag",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_hinting_flag():\n    mapping = {\n        'default': LOAD_DEFAULT,\n        'no_autohint': LOAD_NO_AUTOHINT,\n        'force_autohint': LOAD_FORCE_AUTOHINT,\n        'no_hinting': LOAD_NO_HINTING,\n        True: LOAD_FORCE_AUTOHINT,\n        False: LOAD_NO_HINTING,\n        'either': LOAD_DEFAULT,\n        'native': LOAD_NO_AUTOHINT,\n        'auto': LOAD_FORCE_AUTOHINT,\n        'none': LOAD_NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox",
      "name": "copy_from_bbox",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.copy_from_bbox",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.copy_from_bbox.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.copy_from_bbox.bbox",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def copy_from_bbox(self, bbox):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"copy_from_bbox only works when rendering to an ImageSurface\")\n        sw = surface.get_width()\n        sh = surface.get_height()\n        x0 = math.ceil(bbox.x0)\n        x1 = math.floor(bbox.x1)\n        y0 = math.ceil(sh - bbox.y1)\n        y1 = math.floor(sh - bbox.y0)\n        if not (0 <= x0 and x1 <= sw and bbox.x0 <= bbox.x1\n                and 0 <= y0 and y1 <= sh and bbox.y0 <= bbox.y1):\n            raise ValueError(\"Invalid bbox\")\n        sls = slice(y0, y0 + max(y1 - y0, 0)), slice(x0, x0 + max(x1 - x0, 0))\n        data = (np.frombuffer(surface.get_data(), np.uint32)\n                .reshape((sh, sw))[sls].copy())\n        return _CairoRegion(sls, data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/get_renderer",
      "name": "get_renderer",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.get_renderer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/get_renderer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.get_renderer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_renderer(self):\n        return self._renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_png",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_png.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_png(self, fobj):\n        self._get_printed_image_surface().write_to_png(fobj)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba",
      "name": "print_rgba",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_rgba",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_rgba.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_rgba.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_rgba(self, fobj):\n        width, height = self.get_width_height()\n        buf = self._get_printed_image_surface().get_data()\n        fobj.write(cbook._premultiplied_argb32_to_unmultiplied_rgba8888(\n            np.asarray(buf).reshape((width, height, 4))))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region",
      "name": "restore_region",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.restore_region",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.restore_region.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region/region",
          "name": "region",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.restore_region.region",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def restore_region(self, region):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"restore_region only works when rendering to an ImageSurface\")\n        surface.flush()\n        sw = surface.get_width()\n        sh = surface.get_height()\n        sly, slx = region._slices\n        (np.frombuffer(surface.get_data(), np.uint32)\n         .reshape((sh, sw))[sly, slx]) = region._data\n        surface.mark_dirty_rectangle(\n            slx.start, sly.start, slx.stop - slx.start, sly.stop - sly.start)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.__init__.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, renderer):\n        super().__init__()\n        self.renderer = renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/get_rgb",
      "name": "get_rgb",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.get_rgb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/get_rgb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.get_rgb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_rgb(self):\n        return self.ctx.get_source().get_rgba()[:3]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/restore",
      "name": "restore",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.restore",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/restore/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.restore.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def restore(self):\n        self.ctx.restore()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha",
      "name": "set_alpha",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_alpha",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_alpha.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_alpha.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_alpha(self, alpha):\n        super().set_alpha(alpha)\n        _alpha = self.get_alpha()\n        rgb = self._rgb\n        if self.get_forced_alpha():\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], _alpha)\n        else:\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], rgb[3])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_antialiased",
      "name": "set_antialiased",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_antialiased",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_antialiased/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_antialiased.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_antialiased/b",
          "name": "b",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_antialiased.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_antialiased(self, b):\n        self.ctx.set_antialias(\n            cairo.ANTIALIAS_DEFAULT if b else cairo.ANTIALIAS_NONE)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle",
      "name": "set_capstyle",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_capstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_capstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle/cs",
          "name": "cs",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_capstyle.cs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_capstyle(self, cs):\n        self.ctx.set_line_cap(_api.check_getitem(self._capd, capstyle=cs))\n        self._capstyle = cs"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path",
      "name": "set_clip_path",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_clip_path(self, path):\n        if not path:\n            return\n        tpath, affine = path.get_transformed_path_and_affine()\n        ctx = self.ctx\n        ctx.new_path()\n        affine = (affine\n                  + Affine2D().scale(1, -1).translate(0, self.renderer.height))\n        _append_path(ctx, tpath, affine)\n        ctx.clip()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle",
      "name": "set_clip_rectangle",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_rectangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_rectangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle/rectangle",
          "name": "rectangle",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_rectangle.rectangle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_clip_rectangle(self, rectangle):\n        if not rectangle:\n            return\n        x, y, w, h = np.round(rectangle.bounds)\n        ctx = self.ctx\n        ctx.new_path()\n        ctx.rectangle(x, self.renderer.height - h - y, w, h)\n        ctx.clip()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes",
      "name": "set_dashes",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes/offset",
          "name": "offset",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes.offset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes/dashes",
          "name": "dashes",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes.dashes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_dashes(self, offset, dashes):\n        self._dashes = offset, dashes\n        if dashes is None:\n            self.ctx.set_dash([], 0)  # switch dashes off\n        else:\n            self.ctx.set_dash(\n                list(self.renderer.points_to_pixels(np.asarray(dashes))),\n                offset)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground",
      "name": "set_foreground",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground/fg",
          "name": "fg",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground.fg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground/isRGBA",
          "name": "isRGBA",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground.isRGBA",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_foreground(self, fg, isRGBA=None):\n        super().set_foreground(fg, isRGBA)\n        if len(self._rgb) == 3:\n            self.ctx.set_source_rgb(*self._rgb)\n        else:\n            self.ctx.set_source_rgba(*self._rgb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle",
      "name": "set_joinstyle",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_joinstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_joinstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle/js",
          "name": "js",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_joinstyle.js",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_joinstyle(self, js):\n        self.ctx.set_line_join(_api.check_getitem(self._joind, joinstyle=js))\n        self._joinstyle = js"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth",
      "name": "set_linewidth",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_linewidth",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_linewidth.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth/w",
          "name": "w",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_linewidth.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linewidth(self, w):\n        self._linewidth = float(w)\n        self.ctx.set_line_width(self.renderer.points_to_pixels(w))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, dpi):\n        self.dpi = dpi\n        self.gc = GraphicsContextCairo(renderer=self)\n        self.width = None\n        self.height = None\n        self.text_ctx = cairo.Context(\n           cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1))\n        super().__init__()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im):\n        im = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(im[::-1])\n        surface = cairo.ImageSurface.create_for_data(\n            im.ravel().data, cairo.FORMAT_ARGB32,\n            im.shape[1], im.shape[0], im.shape[1] * 4)\n        ctx = gc.ctx\n        y = self.height - y - im.shape[0]\n\n        ctx.save()\n        ctx.set_source_surface(surface, float(x), float(y))\n        ctx.paint()\n        ctx.restore()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(self, gc, marker_path, marker_trans, path, transform,\n                     rgbFace=None):\n        # docstring inherited\n\n        ctx = gc.ctx\n        ctx.new_path()\n        # Create the path for the marker; it needs to be flipped here already!\n        _append_path(ctx, marker_path, marker_trans + Affine2D().scale(1, -1))\n        marker_path = ctx.copy_path_flat()\n\n        # Figure out whether the path has a fill\n        x1, y1, x2, y2 = ctx.fill_extents()\n        if x1 == 0 and y1 == 0 and x2 == 0 and y2 == 0:\n            filled = False\n            # No fill, just unset this (so we don't try to fill it later on)\n            rgbFace = None\n        else:\n            filled = True\n\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n\n        ctx.new_path()\n        for i, (vertices, codes) in enumerate(\n                path.iter_segments(transform, simplify=False)):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ctx.save()\n\n                # Translate and apply path\n                ctx.translate(x, y)\n                ctx.append_path(marker_path)\n\n                ctx.restore()\n\n                # Slower code path if there is a fill; we need to draw\n                # the fill and stroke for each marker at the same time.\n                # Also flush out the drawing every once in a while to\n                # prevent the paths from getting way too long.\n                if filled or i % 1000 == 0:\n                    self._fill_and_stroke(\n                        ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n        # Fast path, if there is no fill, draw everything in one step\n        if not filled:\n            self._fill_and_stroke(\n                ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        ctx = gc.ctx\n        # Clip the path to the actual rendering extents if it isn't filled.\n        clip = (ctx.clip_extents()\n                if rgbFace is None and gc.get_hatch() is None\n                else None)\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n        ctx.new_path()\n        _append_path(ctx, path, transform, clip)\n        self._fill_and_stroke(\n            ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # Note: (x, y) are device/display coords, not user-coords, unlike other\n        # draw_* methods\n        if ismath:\n            self._draw_mathtext(gc, x, y, s, prop, angle)\n\n        else:\n            ctx = gc.ctx\n            ctx.new_path()\n            ctx.move_to(x, y)\n\n            ctx.save()\n            ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n            ctx.set_font_size(self.points_to_pixels(prop.get_size_in_points()))\n            opts = cairo.FontOptions()\n            opts.set_antialias(\n                cairo.ANTIALIAS_DEFAULT if mpl.rcParams[\"text.antialiased\"]\n                else cairo.ANTIALIAS_NONE)\n            ctx.set_font_options(opts)\n            if angle:\n                ctx.rotate(np.deg2rad(-angle))\n            ctx.show_text(s)\n            ctx.restore()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath == 'TeX':\n            return super().get_text_width_height_descent(s, prop, ismath)\n\n        if ismath:\n            width, height, descent, *_ = \\\n                self._text2path.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        ctx = self.text_ctx\n        # problem - scale remembers last setting and font can become\n        # enormous causing program to crash\n        # save/restore prevents the problem\n        ctx.save()\n        ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n        ctx.set_font_size(self.points_to_pixels(prop.get_size_in_points()))\n\n        y_bearing, w, h = ctx.text_extents(s)[1:4]\n        ctx.restore()\n\n        return w, h, h + y_bearing"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        self.gc.ctx.save()\n        self.gc._alpha = 1\n        self.gc._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        return self.gc"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points / 72 * self.dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_context",
      "name": "set_context",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_context",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_context/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_context.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_context/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_context.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_context(self, ctx):\n        surface = ctx.get_target()\n        if hasattr(surface, \"get_width\") and hasattr(surface, \"get_height\"):\n            size = surface.get_width(), surface.get_height()\n        elif hasattr(surface, \"get_extents\"):  # GTK4 RecordingSurface.\n            ext = surface.get_extents()\n            size = ext.width, ext.height\n        else:  # vector surfaces.\n            ctx.save()\n            ctx.reset_clip()\n            rect, *rest = ctx.copy_clip_rectangle_list()\n            if rest:\n                raise TypeError(\"Cannot infer surface size\")\n            size = rect.width, rect.height\n            ctx.restore()\n        self.gc.ctx = ctx\n        self.width, self.height = size"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface",
      "name": "set_ctx_from_surface",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_ctx_from_surface",
      "decorators": [
        "_api.deprecated('3.6', alternative='set_context')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_ctx_from_surface.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface/surface",
          "name": "surface",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_ctx_from_surface.surface",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\", alternative=\"set_context\")\n    def set_ctx_from_surface(self, surface):\n        self.gc.ctx = cairo.Context(surface)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height",
      "name": "set_width_height",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    def set_width_height(self, width, height):\n        self.width = width\n        self.height = height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.__init__.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('screen-changed',       self._update_device_pixel_ratio)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_can_focus(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event",
      "name": "button_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_press_event(self, widget, event):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event",
      "name": "button_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_release_event(self, widget, event):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords(event), event.button,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event",
      "name": "configure_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def configure_event(self, widget, event):\n        if widget.get_property(\"window\") is None:\n            return\n        w = event.width * self.device_pixel_ratio\n        h = event.height * self.device_pixel_ratio\n        if w < 3 or h < 3:\n            return  # empty fig\n        # resize the figure (in inches)\n        dpi = self.figure.dpi\n        self.figure.set_size_inches(w / dpi, h / dpi, forward=False)\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self):\n        CloseEvent(\"close_event\", self)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event",
      "name": "enter_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_notify_event(self, widget, event):\n        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n                      guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/flush_events",
      "name": "flush_events",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.flush_events",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/flush_events/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.flush_events.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flush_events(self):\n        # docstring inherited\n        context = GLib.MainContext.default()\n        while context.pending():\n            context.iteration(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event",
      "name": "key_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_press_event(self, widget, event):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event",
      "name": "key_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_release_event(self, widget, event):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(event), *self._mpl_coords(),\n                 guiEvent=event)._process()\n        return True  # stop event propagation"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event",
      "name": "leave_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_notify_event(self, widget, event):\n        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n                      guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event",
      "name": "motion_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def motion_notify_event(self, widget, event):\n        MouseEvent(\"motion_notify_event\", self, *self._mpl_coords(event),\n                   guiEvent=event)._process()\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK3Agg or GTK3Cairo\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event",
      "name": "scroll_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def scroll_event(self, widget, event):\n        step = 1 if event.direction == Gdk.ScrollDirection.UP else -1\n        MouseEvent(\"scroll_event\", self, *self._mpl_coords(event), step=step,\n                   guiEvent=event)._process()\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        # docstring inherited\n        window = self.get_property(\"window\")\n        if window is not None:\n            window.set_cursor(_mpl_to_gtk_cursor(cursor))\n            context = GLib.MainContext.default()\n            context.iteration(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate",
      "name": "size_allocate",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate/allocation",
          "name": "allocation",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate.allocation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width * self.device_pixel_ratio / dpival\n        hinch = allocation.height * self.device_pixel_ratio / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        if Gtk.check_version(3, 20, 0) is None:\n            self._show_shortcuts_window()\n        else:\n            self._show_shortcuts_dialog()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__",
      "decorators": [
        "_api.delete_parameter('3.6', 'window')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__/window",
          "name": "window",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__.window",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.6\", \"window\")\n    def __init__(self, canvas, window=None):\n        self._win = window\n        GObject.GObject.__init__(self)\n\n        self.set_style(Gtk.ToolbarStyle.ICONS)\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.insert(Gtk.SeparatorToolItem(), -1)\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            self._gtk_ids[text] = button = (\n                Gtk.ToggleToolButton() if callback in ['zoom', 'pan'] else\n                Gtk.ToolButton())\n            button.set_label(text)\n            button.set_icon_widget(image)\n            # Save the handler id, so that we can block it as needed.\n            button._signal_handler = button.connect(\n                'clicked', getattr(self, callback))\n            button.set_tooltip_text(tooltip_text)\n            self.insert(button, -1)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        toolitem.set_expand(True)  # Push real message to the right.\n        toolitem.add(label)\n\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        self.message = Gtk.Label()\n        self.message.set_justify(Gtk.Justification.RIGHT)\n        toolitem.add(self.message)\n\n        self.show_all()\n\n        _NavigationToolbar2GTK.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        dialog = Gtk.FileChooserDialog(\n            title=\"Save the figure\",\n            parent=self.canvas.get_toplevel(),\n            action=Gtk.FileChooserAction.SAVE,\n            buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,\n                     Gtk.STOCK_SAVE,   Gtk.ResponseType.OK),\n        )\n        for name, fmts \\\n                in self.canvas.get_supported_filetypes_grouped().items():\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(f'*.{fmt}')\n            dialog.add_filter(ff)\n            if self.canvas.get_default_filetype() in fmts:\n                dialog.set_filter(ff)\n\n        @functools.partial(dialog.connect, \"notify::filter\")\n        def on_notify_filter(*args):\n            name = dialog.get_filter().get_name()\n            fmt = self.canvas.get_supported_filetypes_grouped()[name][0]\n            dialog.set_current_name(\n                str(Path(dialog.get_current_name()).with_suffix(f'.{fmt}')))\n\n        dialog.set_current_folder(mpl.rcParams[\"savefig.directory\"])\n        dialog.set_current_name(self.canvas.get_default_filename())\n        dialog.set_do_overwrite_confirmation(True)\n\n        response = dialog.run()\n        fname = dialog.get_filename()\n        ff = dialog.get_filter()  # Doesn't autoadjust to filename :/\n        fmt = self.canvas.get_supported_filetypes_grouped()[ff.get_name()][0]\n        dialog.destroy()\n        if response != Gtk.ResponseType.OK:\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n        try:\n            self.canvas.figure.savefig(fname, format=fmt)\n        except Exception as e:\n            dialog = Gtk.MessageDialog(\n                parent=self.canvas.get_toplevel(), message_format=str(e),\n                type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK)\n            dialog.run()\n            dialog.destroy()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK3.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        NavigationToolbar2GTK3.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        window = self.canvas.get_window()\n        x, y, width, height = window.get_geometry()\n        pb = Gdk.pixbuf_get_from_window(window, x, y, width, height)\n        clipboard.set_image(pb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.pack_end(self._message, False, False, 0)\n        self.show_all()\n        self._groups = {}\n        self._toolitems = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleToolButton()\n        else:\n            button = Gtk.ToolButton()\n        button.set_label(name)\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            button.set_icon_widget(image)\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        button.show_all()\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event(f'{name} not in toolbar', self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self._message.set_label(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/error_msg_gtk",
      "name": "error_msg_gtk",
      "qname": "lib.matplotlib.backends.backend_gtk3.error_msg_gtk",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/error_msg_gtk/msg",
          "name": "msg",
          "qname": "lib.matplotlib.backends.backend_gtk3.error_msg_gtk.msg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/error_msg_gtk/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_gtk3.error_msg_gtk.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef error_msg_gtk(msg, parent=None):\n    if parent is not None:  # find the toplevel Gtk.Window\n        parent = parent.get_toplevel()\n        if not parent.is_toplevel():\n            parent = None\n    if not isinstance(msg, str):\n        msg = ','.join(map(str, msg))\n    dialog = Gtk.MessageDialog(\n        parent=parent, type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK,\n        message_format=msg)\n    dialog.run()\n    dialog.destroy()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._bbox_queue = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # If bbox is None, blit the entire canvas to gtk. Otherwise\n        # blit only the area defined by the bbox.\n        if bbox is None:\n            bbox = self.figure.bbox\n\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        x = int(bbox.x0 / scale)\n        y = allocation.height - int(bbox.y1 / scale)\n        width = (int(bbox.x1) - int(bbox.x0)) // scale\n        height = (int(bbox.y1) - int(bbox.y0)) // scale\n\n        self._bbox_queue.append(bbox)\n        self.queue_draw_area(x, y, width, height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n        w = allocation.width * scale\n        h = allocation.height * scale\n\n        if not len(self._bbox_queue):\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            bbox_queue = [transforms.Bbox([[0, 0], [w, h]])]\n        else:\n            bbox_queue = self._bbox_queue\n\n        for bbox in bbox_queue:\n            x = int(bbox.x0)\n            y = h - int(bbox.y1)\n            width = int(bbox.x1) - int(bbox.x0)\n            height = int(bbox.y1) - int(bbox.y0)\n\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                np.asarray(self.copy_from_bbox(bbox)))\n            image = cairo.ImageSurface.create_for_data(\n                buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n            image.set_device_scale(scale, scale)\n            ctx.set_source_surface(image, x / scale, y / scale)\n            ctx.paint()\n\n        if len(self._bbox_queue):\n            self._bbox_queue = []\n\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            scale = self.device_pixel_ratio\n            # Scale physical drawing to logical size.\n            ctx.scale(1 / scale, 1 / scale)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.__init__.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure=None):\n        super().__init__(figure=figure)\n\n        self.set_hexpand(True)\n        self.set_vexpand(True)\n\n        self._idle_draw_id = 0\n        self._rubberband_rect = None\n\n        self.set_draw_func(self._draw_func)\n        self.connect('resize', self.resize_event)\n        self.connect('notify::scale-factor', self._update_device_pixel_ratio)\n\n        click = Gtk.GestureClick()\n        click.set_button(0)  # All buttons.\n        click.connect('pressed', self.button_press_event)\n        click.connect('released', self.button_release_event)\n        self.add_controller(click)\n\n        key = Gtk.EventControllerKey()\n        key.connect('key-pressed', self.key_press_event)\n        key.connect('key-released', self.key_release_event)\n        self.add_controller(key)\n\n        motion = Gtk.EventControllerMotion()\n        motion.connect('motion', self.motion_notify_event)\n        motion.connect('enter', self.enter_notify_event)\n        motion.connect('leave', self.leave_notify_event)\n        self.add_controller(motion)\n\n        scroll = Gtk.EventControllerScroll.new(\n            Gtk.EventControllerScrollFlags.VERTICAL)\n        scroll.connect('scroll', self.scroll_event)\n        self.add_controller(scroll)\n\n        self.set_focusable(True)\n\n        css = Gtk.CssProvider()\n        css.load_from_data(b\".matplotlib-canvas { background-color: white; }\")\n        style_ctx = self.get_style_context()\n        style_ctx.add_provider(css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)\n        style_ctx.add_class(\"matplotlib-canvas\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event",
      "name": "button_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/n_press",
          "name": "n_press",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.n_press",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_press_event/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_press_event.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_press_event(self, controller, n_press, x, y):\n        MouseEvent(\"button_press_event\", self,\n                   *self._mpl_coords((x, y)), controller.get_current_button()\n                   )._process()\n        self.grab_focus()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event",
      "name": "button_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/n_press",
          "name": "n_press",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.n_press",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/button_release_event/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.button_release_event.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_release_event(self, controller, n_press, x, y):\n        MouseEvent(\"button_release_event\", self,\n                   *self._mpl_coords((x, y)), controller.get_current_button()\n                   )._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self):\n        self.close_event()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event",
      "name": "enter_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/enter_notify_event/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.enter_notify_event.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_notify_event(self, controller, x, y):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self._mpl_coords((x, y)))._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/flush_events",
      "name": "flush_events",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.flush_events",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/flush_events/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.flush_events.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flush_events(self):\n        # docstring inherited\n        context = GLib.MainContext.default()\n        while context.pending():\n            context.iteration(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event",
      "name": "key_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/keyval",
          "name": "keyval",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.keyval",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/keycode",
          "name": "keycode",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.keycode",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_press_event/state",
          "name": "state",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_press_event.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_press_event(self, controller, keyval, keycode, state):\n        KeyEvent(\"key_press_event\", self,\n                 self._get_key(keyval, keycode, state), *self._mpl_coords()\n                 )._process()\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event",
      "name": "key_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/keyval",
          "name": "keyval",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.keyval",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/keycode",
          "name": "keycode",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.keycode",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/key_release_event/state",
          "name": "state",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.key_release_event.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_release_event(self, controller, keyval, keycode, state):\n        KeyEvent(\"key_release_event\", self,\n                 self._get_key(keyval, keycode, state), *self._mpl_coords()\n                 )._process()\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/leave_notify_event",
      "name": "leave_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.leave_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/leave_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.leave_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/leave_notify_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.leave_notify_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_notify_event(self, controller):\n        LocationEvent(\"figure_leave_event\", self,\n                      *self._mpl_coords())._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event",
      "name": "motion_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/motion_notify_event/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.motion_notify_event.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def motion_notify_event(self, controller, x, y):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self._mpl_coords((x, y)))._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK4Agg or GTK4Cairo\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event",
      "name": "resize_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event/area",
          "name": "area",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event.area",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/resize_event/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.resize_event.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize_event(self, area, width, height):\n        self._update_device_pixel_ratio()\n        dpi = self.figure.dpi\n        winch = width * self.device_pixel_ratio / dpi\n        hinch = height * self.device_pixel_ratio / dpi\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event",
      "name": "scroll_event",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event/controller",
          "name": "controller",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event.controller",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event/dx",
          "name": "dx",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event.dx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/scroll_event/dy",
          "name": "dy",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.scroll_event.dy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def scroll_event(self, controller, dx, dy):\n        MouseEvent(\"scroll_event\", self,\n                   *self._mpl_coords(), step=dy)._process()\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/FigureCanvasGTK4/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_gtk4.FigureCanvasGTK4.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        # docstring inherited\n        self.set_cursor_from_name(_backend_gtk.mpl_to_gtk_cursor_name(cursor))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk4.HelpGTK4.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.HelpGTK4.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/HelpGTK4/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk4.HelpGTK4.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        section = Gtk.ShortcutsSection()\n\n        for name, tool in sorted(self.toolmanager.tools.items()):\n            if not tool.description:\n                continue\n\n            # Putting everything in a separate group allows GTK to\n            # automatically split them into separate columns/pages, which is\n            # useful because we have lots of shortcuts, some with many keys\n            # that are very wide.\n            group = Gtk.ShortcutsGroup()\n            section.append(group)\n            # A hack to remove the title since we have no group naming.\n            child = group.get_first_child()\n            while child is not None:\n                child.set_visible(False)\n                child = child.get_next_sibling()\n\n            shortcut = Gtk.ShortcutsShortcut(\n                accelerator=' '.join(\n                    self._normalize_shortcut(key)\n                    for key in self.toolmanager.get_tool_keymap(name)\n                    if self._is_valid_shortcut(key)),\n                title=tool.name,\n                subtitle=tool.description)\n            group.append(shortcut)\n\n        window = Gtk.ShortcutsWindow(\n            title='Help',\n            modal=True,\n            transient_for=self._figure.canvas.get_root())\n        window.set_child(section)\n\n        window.show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.__init__",
      "decorators": [
        "_api.delete_parameter('3.6', 'window')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/__init__/window",
          "name": "window",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.__init__.window",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.6\", \"window\")\n    def __init__(self, canvas, window=None):\n        self._win = window\n        Gtk.Box.__init__(self)\n\n        self.add_css_class('toolbar')\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.append(Gtk.Separator())\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))))\n            self._gtk_ids[text] = button = (\n                Gtk.ToggleButton() if callback in ['zoom', 'pan'] else\n                Gtk.Button())\n            button.set_child(image)\n            button.add_css_class('flat')\n            button.add_css_class('image-button')\n            # Save the handler id, so that we can block it as needed.\n            button._signal_handler = button.connect(\n                'clicked', getattr(self, callback))\n            button.set_tooltip_text(tooltip_text)\n            self.append(button)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self.message = Gtk.Label()\n        self.message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self.message)\n\n        _NavigationToolbar2GTK.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/NavigationToolbar2GTK4/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk4.NavigationToolbar2GTK4.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        dialog = Gtk.FileChooserNative(\n            title='Save the figure',\n            transient_for=self.canvas.get_root(),\n            action=Gtk.FileChooserAction.SAVE,\n            modal=True)\n        self._save_dialog = dialog  # Must keep a reference.\n\n        ff = Gtk.FileFilter()\n        ff.set_name('All files')\n        ff.add_pattern('*')\n        dialog.add_filter(ff)\n        dialog.set_filter(ff)\n\n        formats = []\n        default_format = None\n        for i, (name, fmts) in enumerate(\n                self.canvas.get_supported_filetypes_grouped().items()):\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(f'*.{fmt}')\n            dialog.add_filter(ff)\n            formats.append(name)\n            if self.canvas.get_default_filetype() in fmts:\n                default_format = i\n        # Setting the choice doesn't always work, so make sure the default\n        # format is first.\n        formats = [formats[default_format], *formats[:default_format],\n                   *formats[default_format+1:]]\n        dialog.add_choice('format', 'File format', formats, formats)\n        dialog.set_choice('format', formats[default_format])\n\n        dialog.set_current_folder(Gio.File.new_for_path(\n            os.path.expanduser(mpl.rcParams['savefig.directory'])))\n        dialog.set_current_name(self.canvas.get_default_filename())\n\n        @functools.partial(dialog.connect, 'response')\n        def on_response(dialog, response):\n            file = dialog.get_file()\n            fmt = dialog.get_choice('format')\n            fmt = self.canvas.get_supported_filetypes_grouped()[fmt][0]\n            dialog.destroy()\n            self._save_dialog = None\n            if response != Gtk.ResponseType.ACCEPT:\n                return\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams['savefig.directory']:\n                parent = file.get_parent()\n                mpl.rcParams['savefig.directory'] = parent.get_path()\n            try:\n                self.canvas.figure.savefig(file.get_path(), format=fmt)\n            except Exception as e:\n                msg = Gtk.MessageDialog(\n                    transient_for=self.canvas.get_root(),\n                    message_type=Gtk.MessageType.ERROR,\n                    buttons=Gtk.ButtonsType.OK, modal=True,\n                    text=str(e))\n                msg.show()\n\n        dialog.show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/SaveFigureGTK4/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk4.SaveFigureGTK4.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        NavigationToolbar2GTK4.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolCopyToClipboardGTK4/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolCopyToClipboardGTK4.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        with io.BytesIO() as f:\n            self.canvas.print_rgba(f)\n            w, h = self.canvas.get_width_height()\n            pb = GdkPixbuf.Pixbuf.new_from_data(f.getbuffer(),\n                                                GdkPixbuf.Colorspace.RGB, True,\n                                                8, w, h, w*4)\n        clipboard = self.canvas.get_clipboard()\n        clipboard.set(pb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n\n        # Tool items are created later, but must appear before the message.\n        self._tool_box = Gtk.Box()\n        self.append(self._tool_box)\n        self._groups = {}\n        self._toolitems = {}\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        label.set_hexpand(True)  # Push real message to the right.\n        self.append(label)\n\n        self._message = Gtk.Label()\n        self._message.set_justify(Gtk.Justification.RIGHT)\n        self.append(self._message)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            button = Gtk.ToggleButton()\n        else:\n            button = Gtk.Button()\n        button.set_label(name)\n        button.add_css_class('flat')\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file))\n            button.set_child(image)\n            button.add_css_class('image-button')\n\n        if position is None:\n            position = -1\n\n        self._add_button(button, group, position)\n        signal = button.connect('clicked', self._call_tool, name)\n        button.set_tooltip_text(description)\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((button, signal))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event(f'{name} not in toolbar', self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self._message.set_label(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4/ToolbarGTK4/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_gtk4.ToolbarGTK4.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4agg/FigureCanvasGTK4Agg/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk4agg.FigureCanvasGTK4Agg.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        scale = self.device_pixel_ratio\n        allocation = self.get_allocation()\n\n        Gtk.render_background(\n            self.get_style_context(), ctx,\n            allocation.x, allocation.y,\n            allocation.width, allocation.height)\n\n        buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n            np.asarray(self.get_renderer().buffer_rgba()))\n        height, width, _ = buf.shape\n        image = cairo.ImageSurface.create_for_data(\n            buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n        image.set_device_scale(scale, scale)\n        ctx.set_source_surface(image, 0, 0)\n        ctx.paint()\n\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk4cairo/FigureCanvasGTK4Cairo/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk4cairo.FigureCanvasGTK4Cairo.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            scale = self.device_pixel_ratio\n            # Scale physical drawing to logical size.\n            ctx.scale(1 / scale, 1 / scale)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._draw_pending = False\n        self._is_drawing = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # docstring inherited\n        super().blit(bbox)\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure and update the macosx canvas.",
      "docstring": "Render the figure and update the macosx canvas.",
      "code": "    def draw(self):\n        \"\"\"Render the figure and update the macosx canvas.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        # docstring inherited\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            # Add a singleshot timer to the eventloop that will call back\n            # into the Python method _draw_idle to take care of the draw\n            self._single_shot_timer(self._draw_idle)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, width, height):\n        # Size from macOS is logical pixels, dpi is physical.\n        scale = self.figure.dpi / self.device_pixel_ratio\n        width /= scale\n        height /= scale\n        self.figure.set_size_inches(width, height, forward=False)\n        ResizeEvent(\"resize_event\", self)._process()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        self._shown = False\n        _macosx.FigureManager.__init__(self, canvas)\n        icon_path = str(cbook._get_data_path('images/matplotlib.pdf'))\n        _macosx.FigureManager.set_icon(icon_path)\n        FigureManagerBase.__init__(self, canvas, num)\n        if self.toolbar is not None:\n            self.toolbar.update()\n        if mpl.is_interactive():\n            self.show()\n            self.canvas.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.close",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    def close(self):\n        return self._close_button_pressed()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        if not self._shown:\n            self._show()\n            self._shown = True\n        if mpl.rcParams[\"figure.raise_window\"]:\n            self._raise()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas):\n        data_path = cbook._get_data_path('images')\n        _, tooltips, image_names, _ = zip(*NavigationToolbar2.toolitems)\n        _macosx.NavigationToolbar2.__init__(\n            self, canvas,\n            tuple(str(data_path / image_name) + \".pdf\"\n                  for image_name in image_names if image_name is not None),\n            tuple(tooltip for tooltip in tooltips if tooltip is not None))\n        NavigationToolbar2.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.set_rubberband(int(x0), int(y0), int(x1), int(y1))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/prepare_configure_subplots",
      "name": "prepare_configure_subplots",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.prepare_configure_subplots",
      "decorators": [
        "_api.deprecated('3.6', alternative='configure_subplots()')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/prepare_configure_subplots/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.prepare_configure_subplots.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\", alternative='configure_subplots()')\n    def prepare_configure_subplots(self):\n        toolfig = Figure(figsize=(6, 3))\n        canvas = FigureCanvasMac(toolfig)\n        toolfig.subplots_adjust(top=0.9)\n        # Need to keep a reference to the tool.\n        _tool = SubplotTool(self.canvas.figure, toolfig)\n        return canvas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas.remove_rubberband()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        directory = os.path.expanduser(mpl.rcParams['savefig.directory'])\n        filename = _macosx.choose_save_file('Save the figure',\n                                            directory,\n                                            self.canvas.get_default_filename())\n        if filename is None:  # Cancel\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(filename)\n        self.canvas.figure.savefig(filename)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__getattr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__getattr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__/attr",
          "name": "attr",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__getattr__.attr",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getattr__(self, attr):\n        # Proxy everything that hasn't been overridden to the base\n        # renderer. Things that *are* overridden can call methods\n        # on self._renderer directly, but must not cache/store\n        # methods (because things like RendererAgg change their\n        # methods on the fly in order to optimise proxying down\n        # to the underlying C implementation).\n        return getattr(self._renderer, attr)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/vector_renderer",
          "name": "vector_renderer",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.vector_renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/raster_renderer_class",
          "name": "raster_renderer_class",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.raster_renderer_class",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/bbox_inches_restore",
          "name": "bbox_inches_restore",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.bbox_inches_restore",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper class to implement a renderer that switches between\nvector and raster drawing.  An example may be a PDF writer, where\nmost things are drawn with PDF vector commands, but some very\ncomplex objects, such as quad meshes, are rasterised and then\noutput as images.",
      "docstring": "Parameters\n----------\nfigure : `matplotlib.figure.Figure`\n    The figure instance.\nwidth : scalar\n    The width of the canvas in logical units\nheight : scalar\n    The height of the canvas in logical units\ndpi : float\n    The dpi of the canvas\nvector_renderer : `matplotlib.backend_bases.RendererBase`\n    An instance of a subclass of\n    `~matplotlib.backend_bases.RendererBase` that will be used for the\n    vector drawing.\nraster_renderer_class : `matplotlib.backend_bases.RendererBase`\n    The renderer class to use for the raster drawing.  If not provided,\n    this will use the Agg backend (which is currently the only viable\n    option anyway.)",
      "code": "    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        Parameters\n        ----------\n        figure : `matplotlib.figure.Figure`\n            The figure instance.\n        width : scalar\n            The width of the canvas in logical units\n        height : scalar\n            The height of the canvas in logical units\n        dpi : float\n            The dpi of the canvas\n        vector_renderer : `matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n        raster_renderer_class : `matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.dpi\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/start_rasterizing",
      "name": "start_rasterizing",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.start_rasterizing",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/start_rasterizing/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.start_rasterizing.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Enter \"raster\" mode.  All subsequent drawing commands (until\n`stop_rasterizing` is called) will be drawn with the raster backend.",
      "docstring": "Enter \"raster\" mode.  All subsequent drawing commands (until\n`stop_rasterizing` is called) will be drawn with the raster backend.",
      "code": "    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        `stop_rasterizing` is called) will be drawn with the raster backend.\n        \"\"\"\n        # change the dpi of the figure temporarily.\n        self.figure.dpi = self.dpi\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore)\n            self._bbox_inches_restore = r\n\n        self._raster_renderer = self._raster_renderer_class(\n            self._width*self.dpi, self._height*self.dpi, self.dpi)\n        self._renderer = self._raster_renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/stop_rasterizing",
      "name": "stop_rasterizing",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.stop_rasterizing",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/stop_rasterizing/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.stop_rasterizing.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Exit \"raster\" mode.  All of the drawing that was done since\nthe last `start_rasterizing` call will be copied to the\nvector backend by calling draw_image.",
      "docstring": "Exit \"raster\" mode.  All of the drawing that was done since\nthe last `start_rasterizing` call will be copied to the\nvector backend by calling draw_image.",
      "code": "    def stop_rasterizing(self):\n        \"\"\"\n        Exit \"raster\" mode.  All of the drawing that was done since\n        the last `start_rasterizing` call will be copied to the\n        vector backend by calling draw_image.\n        \"\"\"\n\n        self._renderer = self._vector_renderer\n\n        height = self._height * self.dpi\n        img = np.asarray(self._raster_renderer.buffer_rgba())\n        slice_y, slice_x = cbook._get_nonzero_slices(img[..., 3])\n        cropped_img = img[slice_y, slice_x]\n        if cropped_img.size:\n            gc = self._renderer.new_gc()\n            # TODO: If the mixedmode resolution differs from the figure's\n            #       dpi, the image must be scaled (dpi->_figdpi). Not all\n            #       backends support this.\n            self._renderer.draw_image(\n                gc,\n                slice_x.start * self._figdpi / self.dpi,\n                (height - slice_y.stop) * self._figdpi / self.dpi,\n                cropped_img[::-1])\n        self._raster_renderer = None\n\n        # restore the figure dpi.\n        self.figure.dpi = self._figdpi\n\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore,\n                                               self._figdpi)\n            self._bbox_inches_restore = r"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__/manager",
          "name": "manager",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.__init__.manager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Manages the Comm connection between IPython and the browser (client).\n\nComms are 2 way, with the CommSocket being able to publish a message\nvia the send_json method, and handle a message with on_message. On the\nJS side figure.send_message and figure.ws.onmessage do the sending and\nreceiving respectively.",
      "docstring": "",
      "code": "    def __init__(self, manager):\n        self.supports_binary = None\n        self.manager = manager\n        self.uuid = str(uuid.uuid4())\n        # Publish an output area with a unique ID. The javascript can then\n        # hook into this area.\n        display(HTML(\"<div id=%r></div>\" % self.uuid))\n        try:\n            self.comm = Comm('matplotlib', data={'id': self.uuid})\n        except AttributeError as err:\n            raise RuntimeError('Unable to create an IPython notebook Comm '\n                               'instance. Are you in the IPython '\n                               'notebook?') from err\n        self.comm.on_msg(self.on_message)\n\n        manager = self.manager\n        self._ext_close = False\n\n        def _on_close(close_message):\n            self._ext_close = True\n            manager.remove_comm(close_message['content']['comm_id'])\n            manager.clearup_closed()\n\n        self.comm.on_close(_on_close)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/is_open",
      "name": "is_open",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.is_open",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/is_open/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.is_open.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_open(self):\n        return not (self._ext_close or self.comm._closed)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_close",
      "name": "on_close",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_close(self):\n        # When the socket is closed, deregister the websocket with\n        # the FigureManager.\n        if self.is_open():\n            try:\n                self.comm.close()\n            except KeyError:\n                # apparently already cleaned it up?\n                pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message",
      "name": "on_message",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_message(self, message):\n        # The 'supports_binary' message is relevant to the\n        # websocket itself.  The other messages get passed along\n        # to matplotlib as-is.\n\n        # Every message has a \"type\" and a \"figure_id\".\n        message = json.loads(message['content']['data'])\n        if message['type'] == 'closing':\n            self.on_close()\n            self.manager.clearup_closed()\n        elif message['type'] == 'supports_binary':\n            self.supports_binary = message['value']\n        else:\n            self.manager.handle_json(message)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary",
      "name": "send_binary",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_binary",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_binary.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary/blob",
          "name": "blob",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_binary.blob",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def send_binary(self, blob):\n        if self.supports_binary:\n            self.comm.send({'blob': 'image/png'}, buffers=[blob])\n        else:\n            # The comm is ASCII, so we send the image in base64 encoded data\n            # URL form.\n            data = b64encode(blob).decode('ascii')\n            data_uri = \"data:image/png;base64,{0}\".format(data)\n            self.comm.send({'data': data_uri})"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json",
      "name": "send_json",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_json",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json/content",
          "name": "content",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_json.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def send_json(self, content):\n        self.comm.send({'data': json.dumps(content)})"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        self._shown = False\n        super().__init__(canvas, num)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/clearup_closed",
      "name": "clearup_closed",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.clearup_closed",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/clearup_closed/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.clearup_closed.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Clear up any closed Comms.",
      "docstring": "Clear up any closed Comms.",
      "code": "    def clearup_closed(self):\n        \"\"\"Clear up any closed Comms.\"\"\"\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.is_open()}\n\n        if len(self.web_sockets) == 0:\n            self.canvas.close_event()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/connected@getter",
      "name": "connected",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.connected",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/connected@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.connected.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def connected(self):\n        return bool(self.web_sockets)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas",
      "name": "create_with_canvas",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas/canvas_class",
          "name": "canvas_class",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas.canvas_class",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/create_with_canvas/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.create_with_canvas.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        canvas = canvas_class(figure)\n        manager = cls(canvas, num)\n        if is_interactive():\n            manager.show()\n            canvas.draw_idle()\n\n        def destroy(event):\n            canvas.mpl_disconnect(cid)\n            Gcf.destroy(manager)\n\n        cid = canvas.mpl_connect('close_event', destroy)\n        return manager"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self):\n        self._send_event('close')\n        # need to copy comms as callbacks will modify this list\n        for comm in list(self.web_sockets):\n            comm.on_close()\n        self.clearup_closed()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/display_js",
      "name": "display_js",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.display_js",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/display_js/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.display_js.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def display_js(self):\n        # XXX How to do this just once? It has to deal with multiple\n        # browser instances using the same kernel (require.js - but the\n        # file isn't static?).\n        display(Javascript(FigureManagerNbAgg.get_javascript()))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript",
      "name": "get_javascript",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.get_javascript",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.get_javascript.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript/stream",
          "name": "stream",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.get_javascript.stream",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = io.StringIO()\n        else:\n            output = stream\n        super().get_javascript(stream=output)\n        output.write((pathlib.Path(__file__).parent\n                      / \"web_backend/js/nbagg_mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n        if stream is None:\n            return output.getvalue()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm",
      "name": "remove_comm",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.remove_comm",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.remove_comm.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm/comm_id",
          "name": "comm_id",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.remove_comm.comm_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_comm(self, comm_id):\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.comm.comm_id != comm_id}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/reshow",
      "name": "reshow",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.reshow",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/reshow/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.reshow.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A special method to re-show the figure in the notebook.",
      "docstring": "A special method to re-show the figure in the notebook.",
      "code": "    def reshow(self):\n        \"\"\"\n        A special method to re-show the figure in the notebook.\n\n        \"\"\"\n        self._shown = False\n        self.show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        if not self._shown:\n            self.display_js()\n            self._create_comm()\n        else:\n            self.canvas.draw_idle()\n        self._shown = True\n        # plt.figure adds an event which makes the figure in focus the active\n        # one. Disable this behaviour, as it results in figures being put as\n        # the active figure after they have been shown, even in non-interactive\n        # mode.\n        if hasattr(self, '_cidgcf'):\n            self.canvas.mpl_disconnect(self._cidgcf)\n        if not is_interactive():\n            from matplotlib._pylab_helpers import Gcf\n            Gcf.figs.pop(self.num, None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/connection_info",
      "name": "connection_info",
      "qname": "lib.matplotlib.backends.backend_nbagg.connection_info",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a string showing the figure and connection status for the backend.\n\nThis is intended as a diagnostic tool, and not for general use.",
      "docstring": "Return a string showing the figure and connection status for the backend.\n\nThis is intended as a diagnostic tool, and not for general use.",
      "code": "def connection_info():\n    \"\"\"\n    Return a string showing the figure and connection status for the backend.\n\n    This is intended as a diagnostic tool, and not for general use.\n    \"\"\"\n    result = [\n        '{fig} - {socket}'.format(\n            fig=(manager.canvas.figure.get_label()\n                 or \"Figure {}\".format(manager.num)),\n            socket=manager.web_sockets)\n        for manager in Gcf.get_all_fig_managers()\n    ]\n    if not is_interactive():\n        result.append(f'Figures pending show: {len(Gcf.figs)}')\n    return '\\n'.join(result)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'pdf'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf",
      "name": "print_pdf",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/bbox_inches_restore",
          "name": "bbox_inches_restore",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.bbox_inches_restore",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_pdf(self, filename, *,\n                  bbox_inches_restore=None, metadata=None):\n\n        dpi = self.figure.dpi\n        self.figure.dpi = 72  # there are 72 pdf points to an inch\n        width, height = self.figure.get_size_inches()\n        if isinstance(filename, PdfPages):\n            file = filename._file\n        else:\n            file = PdfFile(filename, metadata=metadata)\n        try:\n            file.newPage(width, height)\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererPdf(file, dpi, height, width),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n            if not isinstance(filename, PdfPages):\n                file.finalize()\n        finally:\n            if isinstance(filename, PdfPages):  # finish off this page\n                file.endStream()\n            else:            # we opened the file above; now finish it off\n                file.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, file):\n        super().__init__()\n        self._fillcolor = (0.0, 0.0, 0.0)\n        self._effective_alphas = (1.0, 1.0)\n        self.file = file\n        self.parent = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        d = dict(self.__dict__)\n        del d['file']\n        del d['parent']\n        return repr(d)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd",
      "name": "alpha_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/forced",
          "name": "forced",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.forced",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/effective_alphas",
          "name": "effective_alphas",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.effective_alphas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def alpha_cmd(self, alpha, forced, effective_alphas):\n        name = self.file.alphaState(effective_alphas)\n        return [name, Op.setgstate]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd",
      "name": "capstyle_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd.style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def capstyle_cmd(self, style):\n        return [self.capstyles[style], Op.setlinecap]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd",
      "name": "clip_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd/cliprect",
          "name": "cliprect",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd.cliprect",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd/clippath",
          "name": "clippath",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd.clippath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set clip rectangle. Calls `.pop()` and `.push()`.",
      "docstring": "Set clip rectangle. Calls `.pop()` and `.push()`.",
      "code": "    def clip_cmd(self, cliprect, clippath):\n        \"\"\"Set clip rectangle. Calls `.pop()` and `.push()`.\"\"\"\n        cmds = []\n        # Pop graphics state until we hit the right one or the stack is empty\n        while ((self._cliprect, self._clippath) != (cliprect, clippath)\n                and self.parent is not None):\n            cmds.extend(self.pop())\n        # Unless we hit the right one, set the clip polygon\n        if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n                self.parent is None):\n            cmds.extend(self.push())\n            if self._cliprect != cliprect:\n                cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n            if self._clippath != clippath:\n                path, affine = clippath.get_transformed_path_and_affine()\n                cmds.extend(\n                    PdfFile.pathOperations(path, affine, simplify=False) +\n                    [Op.clip, Op.endpath])\n        return cmds"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties",
      "name": "copy_properties",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy properties of other into self.",
      "docstring": "Copy properties of other into self.",
      "code": "    def copy_properties(self, other):\n        \"\"\"\n        Copy properties of other into self.\n        \"\"\"\n        super().copy_properties(other)\n        fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n        effective_alphas = getattr(other, '_effective_alphas',\n                                   self._effective_alphas)\n        self._fillcolor = fillcolor\n        self._effective_alphas = effective_alphas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd",
      "name": "dash_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd/dashes",
          "name": "dashes",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd.dashes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def dash_cmd(self, dashes):\n        offset, dash = dashes\n        if dash is None:\n            dash = []\n            offset = 0\n        return [list(dash), offset, Op.setdash]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta",
      "name": "delta",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy properties of other into self and return PDF commands\nneeded to transform self into other.",
      "docstring": "Copy properties of other into self and return PDF commands\nneeded to transform self into other.",
      "code": "    def delta(self, other):\n        \"\"\"\n        Copy properties of other into self and return PDF commands\n        needed to transform self into other.\n        \"\"\"\n        cmds = []\n        fill_performed = False\n        for params, cmd in self.commands:\n            different = False\n            for p in params:\n                ours = getattr(self, p)\n                theirs = getattr(other, p)\n                try:\n                    if ours is None or theirs is None:\n                        different = ours is not theirs\n                    else:\n                        different = bool(ours != theirs)\n                except ValueError:\n                    ours = np.asarray(ours)\n                    theirs = np.asarray(theirs)\n                    different = (ours.shape != theirs.shape or\n                                 np.any(ours != theirs))\n                if different:\n                    break\n\n            # Need to update hatching if we also updated fillcolor\n            if params == ('_hatch', '_hatch_color') and fill_performed:\n                different = True\n\n            if different:\n                if params == ('_fillcolor',):\n                    fill_performed = True\n                theirs = [getattr(other, p) for p in params]\n                cmds.extend(cmd(self, *theirs))\n                for p in params:\n                    setattr(self, p, getattr(other, p))\n        return cmds"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill",
      "name": "fill",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Predicate: does the path need to be filled?\n\nAn optional argument can be used to specify an alternative\n_fillcolor, as needed by RendererPdf.draw_markers.",
      "docstring": "Predicate: does the path need to be filled?\n\nAn optional argument can be used to specify an alternative\n_fillcolor, as needed by RendererPdf.draw_markers.",
      "code": "    def fill(self, *args):\n        \"\"\"\n        Predicate: does the path need to be filled?\n\n        An optional argument can be used to specify an alternative\n        _fillcolor, as needed by RendererPdf.draw_markers.\n        \"\"\"\n        if len(args):\n            _fillcolor = args[0]\n        else:\n            _fillcolor = self._fillcolor\n        return (self._hatch or\n                (_fillcolor is not None and\n                 (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd",
      "name": "fillcolor_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd/rgb",
          "name": "rgb",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd.rgb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def fillcolor_cmd(self, rgb):\n        if rgb is None or mpl.rcParams['pdf.inheritcolor']:\n            return []\n        elif rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_nonstroke]\n        else:\n            return [*rgb[:3], Op.setrgb_nonstroke]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Make sure every pushed graphics state is popped.",
      "docstring": "Make sure every pushed graphics state is popped.",
      "code": "    def finalize(self):\n        \"\"\"\n        Make sure every pushed graphics state is popped.\n        \"\"\"\n        cmds = []\n        while self.parent is not None:\n            cmds.extend(self.pop())\n        return cmds"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd",
      "name": "hatch_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd/hatch",
          "name": "hatch",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd.hatch",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd/hatch_color",
          "name": "hatch_color",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd.hatch_color",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def hatch_cmd(self, hatch, hatch_color):\n        if not hatch:\n            if self._fillcolor is not None:\n                return self.fillcolor_cmd(self._fillcolor)\n            else:\n                return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]\n        else:\n            hatch_style = (hatch_color, self._fillcolor, hatch)\n            name = self.file.hatchPattern(hatch_style)\n            return [Name('Pattern'), Op.setcolorspace_nonstroke,\n                    name, Op.setcolor_nonstroke]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd",
      "name": "joinstyle_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd.style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def joinstyle_cmd(self, style):\n        return [self.joinstyles[style], Op.setlinejoin]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd",
      "name": "linewidth_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def linewidth_cmd(self, width):\n        return [width, Op.setlinewidth]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/paint",
      "name": "paint",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.paint",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/paint/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.paint.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the appropriate pdf operator to cause the path to be\nstroked, filled, or both.",
      "docstring": "Return the appropriate pdf operator to cause the path to be\nstroked, filled, or both.",
      "code": "    def paint(self):\n        \"\"\"\n        Return the appropriate pdf operator to cause the path to be\n        stroked, filled, or both.\n        \"\"\"\n        return Op.paint_path(self.fill(), self.stroke())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/pop",
      "name": "pop",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/pop/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pop(self):\n        assert self.parent is not None\n        self.copy_properties(self.parent)\n        self.parent = self.parent.parent\n        return [Op.grestore]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/push",
      "name": "push",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/push/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def push(self):\n        parent = GraphicsContextPdf(self.file)\n        parent.copy_properties(self)\n        parent.parent = self.parent\n        self.parent = parent\n        return [Op.gsave]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd",
      "name": "rgb_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd/rgb",
          "name": "rgb",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd.rgb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def rgb_cmd(self, rgb):\n        if mpl.rcParams['pdf.inheritcolor']:\n            return []\n        if rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_stroke]\n        else:\n            return [*rgb[:3], Op.setrgb_stroke]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/stroke",
      "name": "stroke",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/stroke/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Predicate: does the path need to be stroked (its outline drawn)?\nThis tests for the various conditions that disable stroking\nthe path, in which case it would presumably be filled.",
      "docstring": "Predicate: does the path need to be stroked (its outline drawn)?\nThis tests for the various conditions that disable stroking\nthe path, in which case it would presumably be filled.",
      "code": "    def stroke(self):\n        \"\"\"\n        Predicate: does the path need to be stroked (its outline drawn)?\n        This tests for the various conditions that disable stroking\n        the path, in which case it would presumably be filled.\n        \"\"\"\n        # _linewidth > 0: in pdf a line of width 0 is drawn at minimum\n        #   possible device width, but e.g., agg doesn't draw at all\n        return (self._linewidth > 0 and self._alpha > 0 and\n                (len(self._rgb) <= 3 or self._rgb[3] != 0.0))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__",
      "name": "__eq__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other):\n        return isinstance(other, Name) and self.name == other.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__hash__",
      "name": "__hash__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__hash__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self):\n        return hash(self.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF name object.",
      "docstring": "",
      "code": "    def __init__(self, name):\n        if isinstance(name, Name):\n            self.name = name.name\n        else:\n            if isinstance(name, bytes):\n                name = name.decode('ascii')\n            self.name = name.translate(self._hexify).encode('ascii')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__",
      "name": "__lt__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__lt__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__lt__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__lt__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __lt__(self, other):\n        return isinstance(other, Name) and self.name < other.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return \"<Name %s>\" % self.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__str__",
      "name": "__str__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__str__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self):\n        return '/' + self.name.decode('ascii')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/hexify",
      "name": "hexify",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.hexify",
      "decorators": [
        "staticmethod",
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/hexify/match",
          "name": "match",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.hexify.match",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    @_api.deprecated(\"3.6\")\n    def hexify(match):\n        return '#%02x' % ord(match.group())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return b'/' + self.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path",
      "name": "paint_path",
      "qname": "lib.matplotlib.backends.backend_pdf.Op.paint_path",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_pdf.Op.paint_path.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path/fill",
          "name": "fill",
          "qname": "lib.matplotlib.backends.backend_pdf.Op.paint_path.fill",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Fill the path with the fill color."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/paint_path/stroke",
          "name": "stroke",
          "qname": "lib.matplotlib.backends.backend_pdf.Op.paint_path.stroke",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Stroke the outline of the path with the line color."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the PDF operator to paint a path.",
      "docstring": "Return the PDF operator to paint a path.\n\nParameters\n----------\nfill : bool\n    Fill the path with the fill color.\nstroke : bool\n    Stroke the outline of the path with the line color.",
      "code": "    @classmethod\n    def paint_path(cls, fill, stroke):\n        \"\"\"\n        Return the PDF operator to paint a path.\n\n        Parameters\n        ----------\n        fill : bool\n            Fill the path with the fill color.\n        stroke : bool\n            Stroke the outline of the path with the line color.\n        \"\"\"\n        if stroke:\n            if fill:\n                return cls.fill_stroke\n            else:\n                return cls.stroke\n        else:\n            if fill:\n                return cls.fill\n            else:\n                return cls.endpath"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Op.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Op/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Op.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return self.value"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__/op",
          "name": "op",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.__init__.op",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, op):\n        self.op = op"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return '<Operator %s>' % self.op"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return self.op"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF file object.",
      "docstring": "Parameters\n----------\nfilename : str or path-like or file-like\n    Output target; if a string, a file will be opened for writing.\n\nmetadata : dict from strings to strings and dates\n    Information dictionary object (see PDF reference section 10.2.1\n    'Document Information Dictionary'), e.g.:\n    ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n    The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n    'Creator', 'Producer', 'CreationDate', 'ModDate', and\n    'Trapped'. Values have been predefined for 'Creator', 'Producer'\n    and 'CreationDate'. They can be removed by setting them to `None`.",
      "code": "    def __init__(self, filename, metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n\n        metadata : dict from strings to strings and dates\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        super().__init__()\n\n        self._object_seq = itertools.count(1)  # consumed by reserveObject\n        self.xrefTable = [[0, 65535, 'the zero object']]\n        self.passed_in_file_object = False\n        self.original_file_like = None\n        self.tell_base = 0\n        fh, opened = cbook.to_filehandle(filename, \"wb\", return_opened=True)\n        if not opened:\n            try:\n                self.tell_base = filename.tell()\n            except IOError:\n                fh = BytesIO()\n                self.original_file_like = filename\n            else:\n                fh = filename\n                self.passed_in_file_object = True\n\n        self.fh = fh\n        self.currentstream = None  # stream object to write to, if any\n        fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n        # Output some eight-bit chars as a comment so various utilities\n        # recognize the file as binary by looking at the first few\n        # lines (see note in section 3.4.1 of the PDF reference).\n        fh.write(b\"%\\254\\334 \\253\\272\\n\")\n\n        self.rootObject = self.reserveObject('root')\n        self.pagesObject = self.reserveObject('pages')\n        self.pageList = []\n        self.fontObject = self.reserveObject('fonts')\n        self._extGStateObject = self.reserveObject('extended graphics states')\n        self.hatchObject = self.reserveObject('tiling patterns')\n        self.gouraudObject = self.reserveObject('Gouraud triangles')\n        self.XObjectObject = self.reserveObject('external objects')\n        self.resourceObject = self.reserveObject('resources')\n\n        root = {'Type': Name('Catalog'),\n                'Pages': self.pagesObject}\n        self.writeObject(self.rootObject, root)\n\n        self.infoDict = _create_pdf_info_dict('pdf', metadata or {})\n\n        self.fontNames = {}     # maps filenames to internal font names\n        self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))\n        self.dviFontInfo = {}   # maps dvi font names to embedding information\n        # differently encoded Type-1 fonts may share the same descriptor\n        self.type1Descriptors = {}\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n\n        self.alphaStates = {}   # maps alpha values to graphics state objects\n        self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))\n        self._soft_mask_states = {}\n        self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))\n        self._soft_mask_groups = []\n        self.hatchPatterns = {}\n        self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))\n        self.gouraudTriangles = []\n\n        self._images = {}\n        self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n\n        self.markers = {}\n        self.multi_byte_charprocs = {}\n\n        self.paths = []\n\n        # A list of annotations for each page. Each entry is a tuple of the\n        # overall Annots object reference that's inserted into the page object,\n        # followed by a list of the actual annotations.\n        self._annotations = []\n        # For annotations added before a page is created; mostly for the\n        # purpose of newTextnote.\n        self.pageAnnotations = []\n\n        # The PDF spec recommends to include every procset\n        procsets = [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]\n\n        # Write resource dictionary.\n        # Possibly TODO: more general ExtGState (graphics state dictionaries)\n        #                ColorSpace Pattern Shading Properties\n        resources = {'Font': self.fontObject,\n                     'XObject': self.XObjectObject,\n                     'ExtGState': self._extGStateObject,\n                     'Pattern': self.hatchObject,\n                     'Shading': self.gouraudObject,\n                     'ProcSet': procsets}\n        self.writeObject(self.resourceObject, resources)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles",
      "name": "addGouraudTriangles",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "np.ndarray",
            "default_value": "",
            "description": "Triangle vertices, shape (n, 3, 2)\nwhere n = number of triangles, 3 = vertices, 2 = x, y."
          },
          "type": {
            "kind": "NamedType",
            "name": "np.ndarray"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "np.ndarray",
            "default_value": "",
            "description": "Vertex colors, shape (n, 3, 1) or (n, 3, 4)\nas with points, but last dimension is either (gray,)\nor (r, g, b, alpha)."
          },
          "type": {
            "kind": "NamedType",
            "name": "np.ndarray"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a Gouraud triangle shading.",
      "docstring": "Add a Gouraud triangle shading.\n\nParameters\n----------\npoints : np.ndarray\n    Triangle vertices, shape (n, 3, 2)\n    where n = number of triangles, 3 = vertices, 2 = x, y.\ncolors : np.ndarray\n    Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n    as with points, but last dimension is either (gray,)\n    or (r, g, b, alpha).\n\nReturns\n-------\nName, Reference",
      "code": "    def addGouraudTriangles(self, points, colors):\n        \"\"\"\n        Add a Gouraud triangle shading.\n\n        Parameters\n        ----------\n        points : np.ndarray\n            Triangle vertices, shape (n, 3, 2)\n            where n = number of triangles, 3 = vertices, 2 = x, y.\n        colors : np.ndarray\n            Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n            as with points, but last dimension is either (gray,)\n            or (r, g, b, alpha).\n\n        Returns\n        -------\n        Name, Reference\n        \"\"\"\n        name = Name('GT%d' % len(self.gouraudTriangles))\n        ob = self.reserveObject(f'Gouraud triangle {name}')\n        self.gouraudTriangles.append((name, ob, points, colors))\n        return name, ob"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState",
      "name": "alphaState",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return name of an ExtGState that sets alpha to the given value.",
      "docstring": "Return name of an ExtGState that sets alpha to the given value.",
      "code": "    def alphaState(self, alpha):\n        \"\"\"Return name of an ExtGState that sets alpha to the given value.\"\"\"\n\n        state = self.alphaStates.get(alpha, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._alpha_state_seq)\n        self.alphaStates[alpha] = \\\n            (name, {'Type': Name('ExtGState'),\n                    'CA': alpha[0], 'ca': alpha[1]})\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream",
      "name": "beginStream",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/len",
          "name": "len",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.len",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.extra",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/png",
          "name": "png",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.png",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def beginStream(self, id, len, extra=None, png=None):\n        assert self.currentstream is None\n        self.currentstream = Stream(id, len, self, extra, png)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Flush all buffers and free all resources.",
      "docstring": "Flush all buffers and free all resources.",
      "code": "    def close(self):\n        \"\"\"Flush all buffers and free all resources.\"\"\"\n\n        self.endStream()\n        if self.passed_in_file_object:\n            self.fh.flush()\n        else:\n            if self.original_file_like is not None:\n                self.original_file_like.write(self.fh.getvalue())\n            self.fh.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor",
      "name": "createType1Descriptor",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor/t1font",
          "name": "t1font",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor.t1font",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor/fontfile",
          "name": "fontfile",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor.fontfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def createType1Descriptor(self, t1font, fontfile):\n        # Create and write the font descriptor and the font file\n        # of a Type-1 font\n        fontdescObject = self.reserveObject('font descriptor')\n        fontfileObject = self.reserveObject('font file')\n\n        italic_angle = t1font.prop['ItalicAngle']\n        fixed_pitch = t1font.prop['isFixedPitch']\n\n        flags = 0\n        # fixed width\n        if fixed_pitch:\n            flags |= 1 << 0\n        # TODO: serif\n        if 0:\n            flags |= 1 << 1\n        # TODO: symbolic (most TeX fonts are)\n        if 1:\n            flags |= 1 << 2\n        # non-symbolic\n        else:\n            flags |= 1 << 5\n        # italic\n        if italic_angle:\n            flags |= 1 << 6\n        # TODO: all caps\n        if 0:\n            flags |= 1 << 16\n        # TODO: small caps\n        if 0:\n            flags |= 1 << 17\n        # TODO: force bold\n        if 0:\n            flags |= 1 << 18\n\n        ft2font = get_font(fontfile)\n\n        descriptor = {\n            'Type':        Name('FontDescriptor'),\n            'FontName':    Name(t1font.prop['FontName']),\n            'Flags':       flags,\n            'FontBBox':    ft2font.bbox,\n            'ItalicAngle': italic_angle,\n            'Ascent':      ft2font.ascender,\n            'Descent':     ft2font.descender,\n            'CapHeight':   1000,  # TODO: find this out\n            'XHeight':     500,  # TODO: this one too\n            'FontFile':    fontfileObject,\n            'FontFamily':  t1font.prop['FamilyName'],\n            'StemV':       50,  # TODO\n            # (see also revision 3874; but not all TeX distros have AFM files!)\n            # 'FontWeight': a number where 400 = Regular, 700 = Bold\n            }\n\n        self.writeObject(fontdescObject, descriptor)\n\n        self.outputStream(fontfileObject, b\"\".join(t1font.parts[:2]),\n                          extra={'Length1': len(t1font.parts[0]),\n                                 'Length2': len(t1font.parts[1]),\n                                 'Length3': 0})\n\n        return fontdescObject"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName",
      "name": "dviFontName",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.dviFontName",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.dviFontName.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName/dvifont",
          "name": "dvifont",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.dviFontName.dvifont",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Given a dvi font object, return a name suitable for Op.selectfont.\nThis registers the font information in ``self.dviFontInfo`` if not yet\nregistered.",
      "docstring": "Given a dvi font object, return a name suitable for Op.selectfont.\nThis registers the font information in ``self.dviFontInfo`` if not yet\nregistered.",
      "code": "    def dviFontName(self, dvifont):\n        \"\"\"\n        Given a dvi font object, return a name suitable for Op.selectfont.\n        This registers the font information in ``self.dviFontInfo`` if not yet\n        registered.\n        \"\"\"\n\n        dvi_info = self.dviFontInfo.get(dvifont.texname)\n        if dvi_info is not None:\n            return dvi_info.pdfname\n\n        tex_font_map = dviread.PsfontsMap(dviread._find_tex_file('pdftex.map'))\n        psfont = tex_font_map[dvifont.texname]\n        if psfont.filename is None:\n            raise ValueError(\n                \"No usable font file found for {} (TeX: {}); \"\n                \"the font may lack a Type-1 version\"\n                .format(psfont.psname, dvifont.texname))\n\n        pdfname = next(self._internal_font_seq)\n        _log.debug('Assigning font %s = %s (dvi)', pdfname, dvifont.texname)\n        self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(\n            dvifont=dvifont,\n            pdfname=pdfname,\n            fontfile=psfont.filename,\n            basefont=psfont.psname,\n            encodingfile=psfont.encoding,\n            effects=psfont.effects)\n        return pdfname"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF",
      "name": "embedTTF",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF/characters",
          "name": "characters",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF.characters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Embed the TTF font from the named file into the document.",
      "docstring": "Embed the TTF font from the named file into the document.",
      "code": "    def embedTTF(self, filename, characters):\n        \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n\n        font = get_font(filename)\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"\"\"Convert font coordinates to PDF glyph coordinates.\"\"\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Best(?) to round away from zero for bounding boxes and the like.\n            if value < 0:\n                return math.floor(value)\n            else:\n                return math.ceil(value)\n\n        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array.\n            rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict = {'Type': Name('XObject'),\n                                    'Subtype': Name('Form'),\n                                    'BBox': bbox}\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.outputStream(charprocObject, stream, extra=charprocDict)\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_glyph_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject\n\n        def embedTTFType42(font, characters, descriptor):\n            \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n            fontdescObject = self.reserveObject('font descriptor')\n            cidFontDictObject = self.reserveObject('CID font dictionary')\n            type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n            cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n            fontfileObject = self.reserveObject('font file stream')\n            wObject = self.reserveObject('Type 0 widths')\n            toUnicodeMapObject = self.reserveObject('ToUnicode map')\n\n            subset_str = \"\".join(chr(c) for c in characters)\n            _log.debug(\"SUBSET %s characters: %s\", filename, subset_str)\n            fontdata = _backend_pdf_ps.get_glyphs_subset(filename, subset_str)\n            _log.debug(\n                \"SUBSET %s %d -> %d\", filename,\n                os.stat(filename).st_size, fontdata.getbuffer().nbytes\n            )\n\n            # We need this ref for XObjects\n            full_font = font\n\n            # reload the font object from the subset\n            # (all the necessary data could probably be obtained directly\n            # using fontLib.ttLib)\n            font = FT2Font(fontdata)\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            self.outputStream(\n                fontfileObject, fontdata.getvalue(),\n                extra={'Length1': fontdata.getbuffer().nbytes})\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\0'] * 65536\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph = font.load_char(ccode,\n                                       flags=LOAD_NO_SCALE | LOAD_NO_HINTING)\n                widths.append((ccode, cvt(glyph.horiAdvance)))\n                if ccode < 65536:\n                    cid_to_gid_map[ccode] = chr(gind)\n                max_ccode = max(ccode, max_ccode)\n            widths.sort()\n            cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n\n            last_ccode = -2\n            w = []\n            max_width = 0\n            unicode_groups = []\n            for ccode, width in widths:\n                if ccode != last_ccode + 1:\n                    w.append(ccode)\n                    w.append([width])\n                    unicode_groups.append([ccode, ccode])\n                else:\n                    w[-1].append(width)\n                    unicode_groups[-1][1] = ccode\n                max_width = max(max_width, width)\n                last_ccode = ccode\n\n            unicode_bfrange = []\n            for start, end in unicode_groups:\n                # Ensure the CID map contains only chars from BMP\n                if start > 65535:\n                    continue\n                end = min(65535, end)\n\n                unicode_bfrange.append(\n                    b\"<%04x> <%04x> [%s]\" %\n                    (start, end,\n                     b\" \".join(b\"<%04x>\" % x for x in range(start, end+1))))\n            unicode_cmap = (self._identityToUnicodeCMap %\n                            (len(unicode_groups), b\"\\n\".join(unicode_bfrange)))\n\n            # Add XObjects for unsupported chars\n            glyph_ids = []\n            for ccode in characters:\n                if not _font_supports_glyph(fonttype, ccode):\n                    gind = full_font.get_char_index(ccode)\n                    glyph_ids.append(gind)\n\n            bbox = [cvt(x, nearest=False) for x in full_font.bbox]\n            rawcharprocs = _get_pdf_charprocs(filename, glyph_ids)\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Type': Name('XObject'),\n                                'Subtype': Name('Form'),\n                                'BBox': bbox}\n                # Each glyph includes bounding box information,\n                # but xpdf and ghostscript can't handle it in a\n                # Form XObject (they segfault!!!), so we remove it\n                # from the stream here.  It's not needed anyway,\n                # since the Form XObject includes it in its BBox\n                # value.\n                stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.outputStream(charprocObject, stream, extra=charprocDict)\n\n                name = self._get_xobject_glyph_name(filename, charname)\n                self.multi_byte_charprocs[name] = charprocObject\n\n            # CIDToGIDMap stream\n            cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n            self.outputStream(cidToGidMapObject, cid_to_gid_map)\n\n            # ToUnicode CMap\n            self.outputStream(toUnicodeMapObject, unicode_cmap)\n\n            descriptor['MaxWidth'] = max_width\n\n            # Write everything out\n            self.writeObject(cidFontDictObject, cidFontDict)\n            self.writeObject(type0FontDictObject, type0FontDict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(wObject, w)\n\n            return type0FontDictObject\n\n        # Beginning of main embedTTF function...\n\n        ps_name = self._get_subsetted_psname(\n            font.postscript_name,\n            font.get_charmap()\n        )\n        ps_name = ps_name.encode('ascii', 'replace')\n        ps_name = Name(ps_name)\n        pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n        post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n        ff = font.face_flags\n        sf = font.style_flags\n\n        flags = 0\n        symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n        if ff & FIXED_WIDTH:\n            flags |= 1 << 0\n        if 0:  # TODO: serif\n            flags |= 1 << 1\n        if symbolic:\n            flags |= 1 << 2\n        else:\n            flags |= 1 << 5\n        if sf & ITALIC:\n            flags |= 1 << 6\n        if 0:  # TODO: all caps\n            flags |= 1 << 16\n        if 0:  # TODO: small caps\n            flags |= 1 << 17\n        if 0:  # TODO: force bold\n            flags |= 1 << 18\n\n        descriptor = {\n            'Type': Name('FontDescriptor'),\n            'FontName': ps_name,\n            'Flags': flags,\n            'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n            'Ascent': cvt(font.ascender, nearest=False),\n            'Descent': cvt(font.descender, nearest=False),\n            'CapHeight': cvt(pclt['capHeight'], nearest=False),\n            'XHeight': cvt(pclt['xHeight']),\n            'ItalicAngle': post['italicAngle'][1],  # ???\n            'StemV': 0  # ???\n            }\n\n        if fonttype == 3:\n            return embedTTFType3(font, characters, descriptor)\n        elif fonttype == 42:\n            return embedTTFType42(font, characters, descriptor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/endStream",
      "name": "endStream",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.endStream",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/endStream/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.endStream.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def endStream(self):\n        if self.currentstream is not None:\n            self.currentstream.end()\n            self.currentstream = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the various deferred objects and the pdf end matter.",
      "docstring": "Write out the various deferred objects and the pdf end matter.",
      "code": "    def finalize(self):\n        \"\"\"Write out the various deferred objects and the pdf end matter.\"\"\"\n\n        self.endStream()\n        self._write_annotations()\n        self.writeFonts()\n        self.writeExtGSTates()\n        self._write_soft_mask_groups()\n        self.writeHatches()\n        self.writeGouraudTriangles()\n        xobjects = {\n            name: ob for image, name, ob in self._images.values()}\n        for tup in self.markers.values():\n            xobjects[tup[0]] = tup[1]\n        for name, value in self.multi_byte_charprocs.items():\n            xobjects[name] = value\n        for name, path, trans, ob, join, cap, padding, filled, stroked \\\n                in self.paths:\n            xobjects[name] = ob\n        self.writeObject(self.XObjectObject, xobjects)\n        self.writeImages()\n        self.writeMarkers()\n        self.writePathCollectionTemplates()\n        self.writeObject(self.pagesObject,\n                         {'Type': Name('Pages'),\n                          'Kids': self.pageList,\n                          'Count': len(self.pageList)})\n        self.writeInfoDict()\n\n        # Finalize the file\n        self.writeXref()\n        self.writeTrailer()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName",
      "name": "fontName",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName/fontprop",
          "name": "fontprop",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName.fontprop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Select a font based on fontprop and return a name suitable for\nOp.selectfont. If fontprop is a string, it will be interpreted\nas the filename of the font.",
      "docstring": "Select a font based on fontprop and return a name suitable for\nOp.selectfont. If fontprop is a string, it will be interpreted\nas the filename of the font.",
      "code": "    def fontName(self, fontprop):\n        \"\"\"\n        Select a font based on fontprop and return a name suitable for\n        Op.selectfont. If fontprop is a string, it will be interpreted\n        as the filename of the font.\n        \"\"\"\n\n        if isinstance(fontprop, str):\n            filenames = [fontprop]\n        elif mpl.rcParams['pdf.use14corefonts']:\n            filenames = _fontManager._find_fonts_by_props(\n                fontprop, fontext='afm', directory=RendererPdf._afm_font_dir\n            )\n        else:\n            filenames = _fontManager._find_fonts_by_props(fontprop)\n        first_Fx = None\n        for fname in filenames:\n            Fx = self.fontNames.get(fname)\n            if not first_Fx:\n                first_Fx = Fx\n            if Fx is None:\n                Fx = next(self._internal_font_seq)\n                self.fontNames[fname] = Fx\n                _log.debug('Assigning font %s = %r', Fx, fname)\n                if not first_Fx:\n                    first_Fx = Fx\n\n        # find_fontsprop's first value always adheres to\n        # findfont's value, so technically no behaviour change\n        return first_Fx"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern",
      "name": "hatchPattern",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.hatchPattern",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.hatchPattern.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern/hatch_style",
          "name": "hatch_style",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.hatchPattern.hatch_style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def hatchPattern(self, hatch_style):\n        # The colors may come in as numpy arrays, which aren't hashable\n        if hatch_style is not None:\n            edge, face, hatch = hatch_style\n            if edge is not None:\n                edge = tuple(edge)\n            if face is not None:\n                face = tuple(face)\n            hatch_style = (edge, face, hatch)\n\n        pattern = self.hatchPatterns.get(hatch_style, None)\n        if pattern is not None:\n            return pattern\n\n        name = next(self._hatch_pattern_seq)\n        self.hatchPatterns[hatch_style] = name\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject",
      "name": "imageObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject/image",
          "name": "image",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject.image",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return name of an image XObject representing the given image.",
      "docstring": "Return name of an image XObject representing the given image.",
      "code": "    def imageObject(self, image):\n        \"\"\"Return name of an image XObject representing the given image.\"\"\"\n\n        entry = self._images.get(id(image), None)\n        if entry is not None:\n            return entry[1]\n\n        name = next(self._image_seq)\n        ob = self.reserveObject(f'image {name}')\n        self._images[id(image)] = (image, name, ob)\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject",
      "name": "markerObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/fill",
          "name": "fill",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.fill",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/stroke",
          "name": "stroke",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.stroke",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/lw",
          "name": "lw",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.lw",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/joinstyle",
          "name": "joinstyle",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.joinstyle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/capstyle",
          "name": "capstyle",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.capstyle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return name of a marker XObject representing the given path.",
      "docstring": "Return name of a marker XObject representing the given path.",
      "code": "    def markerObject(self, path, trans, fill, stroke, lw, joinstyle,\n                     capstyle):\n        \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n        # self.markers used by markerObject, writeMarkers, close:\n        # mapping from (path operations, fill?, stroke?) to\n        #   [name, object reference, bounding box, linewidth]\n        # This enables different draw_markers calls to share the XObject\n        # if the gc is sufficiently similar: colors etc can vary, but\n        # the choices of whether to fill and whether to stroke cannot.\n        # We need a bounding box enclosing all of the XObject path,\n        # but since line width may vary, we store the maximum of all\n        # occurring line widths in self.markers.\n        # close() is somewhat tightly coupled in that it expects the\n        # first two components of each value in self.markers to be the\n        # name and object reference.\n        pathops = self.pathOperations(path, trans, simplify=False)\n        key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)\n        result = self.markers.get(key)\n        if result is None:\n            name = Name('M%d' % len(self.markers))\n            ob = self.reserveObject('marker %d' % len(self.markers))\n            bbox = path.get_extents(trans)\n            self.markers[key] = [name, ob, bbox, lw]\n        else:\n            if result[-1] < lw:\n                result[-1] = lw\n            name = result[0]\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage",
      "name": "newPage",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def newPage(self, width, height):\n        self.endStream()\n\n        self.width, self.height = width, height\n        contentObject = self.reserveObject('page contents')\n        annotsObject = self.reserveObject('annotations')\n        thePage = {'Type': Name('Page'),\n                   'Parent': self.pagesObject,\n                   'Resources': self.resourceObject,\n                   'MediaBox': [0, 0, 72 * width, 72 * height],\n                   'Contents': contentObject,\n                   'Annots': annotsObject,\n                   }\n        pageObject = self.reserveObject('page')\n        self.writeObject(pageObject, thePage)\n        self.pageList.append(pageObject)\n        self._annotations.append((annotsObject, self.pageAnnotations))\n\n        self.beginStream(contentObject.id,\n                         self.reserveObject('length of content stream'))\n        # Initialize the pdf graphics state to match the default Matplotlib\n        # graphics context (colorspace and joinstyle).\n        self.output(Name('DeviceRGB'), Op.setcolorspace_stroke)\n        self.output(Name('DeviceRGB'), Op.setcolorspace_nonstroke)\n        self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n\n        # Clear the list of annotations for the next page\n        self.pageAnnotations = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote",
      "name": "newTextnote",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote/positionRect",
          "name": "positionRect",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote.positionRect",
          "default_value": "[-100, -100, 0, 0]",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def newTextnote(self, text, positionRect=[-100, -100, 0, 0]):\n        # Create a new annotation of type text\n        theNote = {'Type': Name('Annot'),\n                   'Subtype': Name('Text'),\n                   'Contents': text,\n                   'Rect': positionRect,\n                   }\n        self.pageAnnotations.append(theNote)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output",
      "name": "output",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.output",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.output.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.output.data",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def output(self, *data):\n        self.write(_fill([pdfRepr(x) for x in data]))\n        self.write(b'\\n')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream",
      "name": "outputStream",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream/ref",
          "name": "ref",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream.ref",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/outputStream/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.outputStream.extra",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def outputStream(self, ref, data, *, extra=None):\n        self.beginStream(ref.id, None, extra)\n        self.currentstream.write(data)\n        self.endStream()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject",
      "name": "pathCollectionObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/padding",
          "name": "padding",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.padding",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/filled",
          "name": "filled",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.filled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/stroked",
          "name": "stroked",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.stroked",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):\n        name = Name('P%d' % len(self.paths))\n        ob = self.reserveObject('path %d' % len(self.paths))\n        self.paths.append(\n            (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),\n             padding, filled, stroked))\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations",
      "name": "pathOperations",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/clip",
          "name": "clip",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.clip",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/simplify",
          "name": "simplify",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.simplify",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/sketch",
          "name": "sketch",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.sketch",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def pathOperations(path, transform, clip=None, simplify=None, sketch=None):\n        return [Verbatim(_path.convert_to_string(\n            path, transform, clip, simplify, sketch,\n            6,\n            [Op.moveto.value, Op.lineto.value, b'', Op.curveto.value,\n             Op.closepath.value],\n            True))]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref",
      "name": "recordXref",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def recordXref(self, id):\n        self.xrefTable[id][0] = self.fh.tell() - self.tell_base"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject",
      "name": "reserveObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject.name",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Reserve an ID for an indirect object.\n\nThe name is used for debugging in case we forget to print out\nthe object with writeObject.",
      "docstring": "Reserve an ID for an indirect object.\n\nThe name is used for debugging in case we forget to print out\nthe object with writeObject.",
      "code": "    def reserveObject(self, name=''):\n        \"\"\"\n        Reserve an ID for an indirect object.\n\n        The name is used for debugging in case we forget to print out\n        the object with writeObject.\n        \"\"\"\n        id = next(self._object_seq)\n        self.xrefTable.append([None, 0, name])\n        return Reference(id)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write",
      "name": "write",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.write",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.write.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.write.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def write(self, data):\n        if self.currentstream is None:\n            self.fh.write(data)\n        else:\n            self.currentstream.write(data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeExtGSTates",
      "name": "writeExtGSTates",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeExtGSTates/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeExtGSTates(self):\n        self.writeObject(\n            self._extGStateObject,\n            dict([\n                *self.alphaStates.values(),\n                *self._soft_mask_states.values()\n            ])\n        )"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeFonts",
      "name": "writeFonts",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeFonts",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeFonts/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeFonts.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeFonts(self):\n        fonts = {}\n        for dviname, info in sorted(self.dviFontInfo.items()):\n            Fx = info.pdfname\n            _log.debug('Embedding Type-1 font %s from dvi.', dviname)\n            fonts[Fx] = self._embedTeXFont(info)\n        for filename in sorted(self.fontNames):\n            Fx = self.fontNames[filename]\n            _log.debug('Embedding font %s.', filename)\n            if filename.endswith('.afm'):\n                # from pdf.use14corefonts\n                _log.debug('Writing AFM font.')\n                fonts[Fx] = self._write_afm_font(filename)\n            else:\n                # a normal TrueType font\n                _log.debug('Writing TrueType font.')\n                chars = self._character_tracker.used.get(filename)\n                if chars:\n                    fonts[Fx] = self.embedTTF(filename, chars)\n        self.writeObject(self.fontObject, fonts)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeGouraudTriangles",
      "name": "writeGouraudTriangles",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeGouraudTriangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeGouraudTriangles(self):\n        gouraudDict = dict()\n        for name, ob, points, colors in self.gouraudTriangles:\n            gouraudDict[name] = ob\n            shape = points.shape\n            flat_points = points.reshape((shape[0] * shape[1], 2))\n            colordim = colors.shape[2]\n            assert colordim in (1, 4)\n            flat_colors = colors.reshape((shape[0] * shape[1], colordim))\n            if colordim == 4:\n                # strip the alpha channel\n                colordim = 3\n            points_min = np.min(flat_points, axis=0) - (1 << 8)\n            points_max = np.max(flat_points, axis=0) + (1 << 8)\n            factor = 0xffffffff / (points_max - points_min)\n\n            self.beginStream(\n                ob.id, None,\n                {'ShadingType': 4,\n                 'BitsPerCoordinate': 32,\n                 'BitsPerComponent': 8,\n                 'BitsPerFlag': 8,\n                 'ColorSpace': Name(\n                     'DeviceRGB' if colordim == 3 else 'DeviceGray'\n                 ),\n                 'AntiAlias': False,\n                 'Decode': ([points_min[0], points_max[0],\n                             points_min[1], points_max[1]]\n                            + [0, 1] * colordim),\n                 })\n\n            streamarr = np.empty(\n                (shape[0] * shape[1],),\n                dtype=[('flags', 'u1'),\n                       ('points', '>u4', (2,)),\n                       ('colors', 'u1', (colordim,))])\n            streamarr['flags'] = 0\n            streamarr['points'] = (flat_points - points_min) * factor\n            streamarr['colors'] = flat_colors[:, :colordim] * 255.0\n\n            self.write(streamarr.tobytes())\n            self.endStream()\n        self.writeObject(self.gouraudObject, gouraudDict)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeHatches",
      "name": "writeHatches",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeHatches/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self.hatchPatterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n\n            stroke_rgb, fill_rgb, hatch = hatch_style\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_stroke)\n            if fill_rgb is not None:\n                self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n                            Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n\n            self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)\n\n            self.output(*self.pathOperations(\n                Path.hatch(hatch),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.fill_stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeImages",
      "name": "writeImages",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeImages/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeImages(self):\n        for img, name, ob in self._images.values():\n            data, adata = self._unpack(img)\n            if adata is not None:\n                smaskObject = self.reserveObject(\"smask\")\n                self._writeImg(adata, smaskObject.id)\n            else:\n                smaskObject = None\n            self._writeImg(data, ob.id, smaskObject)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeInfoDict",
      "name": "writeInfoDict",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeInfoDict/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the info dictionary, checking it for good form",
      "docstring": "Write out the info dictionary, checking it for good form",
      "code": "    def writeInfoDict(self):\n        \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n\n        self.infoObject = self.reserveObject('info')\n        self.writeObject(self.infoObject, self.infoDict)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeMarkers",
      "name": "writeMarkers",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeMarkers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeMarkers(self):\n        for ((pathops, fill, stroke, joinstyle, capstyle),\n             (name, ob, bbox, lw)) in self.markers.items():\n            # bbox wraps the exact limits of the control points, so half a line\n            # will appear outside it. If the join style is miter and the line\n            # is not parallel to the edge, then the line will extend even\n            # further. From the PDF specification, Section 8.4.3.5, the miter\n            # limit is miterLength / lineWidth and from Table 52, the default\n            # is 10. With half the miter length outside, that works out to the\n            # following padding:\n            bbox = bbox.padded(lw * 5)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': list(bbox.extents)})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(fill, stroke))\n            self.endStream()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject",
      "name": "writeObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject/object",
          "name": "object",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject.object",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject/contents",
          "name": "contents",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject.contents",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeObject(self, object, contents):\n        self.recordXref(object.id)\n        object.write(contents, self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath",
      "name": "writePath",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/clip",
          "name": "clip",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.clip",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/sketch",
          "name": "sketch",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.sketch",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writePath(self, path, transform, clip=False, sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72, self.height * 72)\n            simplify = path.should_simplify\n        else:\n            clip = None\n            simplify = False\n        cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n                                   sketch=sketch)\n        self.output(*cmds)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePathCollectionTemplates",
      "name": "writePathCollectionTemplates",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePathCollectionTemplates/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writePathCollectionTemplates(self):\n        for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n             stroked) in self.paths:\n            pathops = self.pathOperations(path, trans, simplify=False)\n            bbox = path.get_extents(trans)\n            if not np.all(np.isfinite(bbox.extents)):\n                extents = [0, 0, 0, 0]\n            else:\n                bbox = bbox.padded(padding)\n                extents = list(bbox.extents)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': extents})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(filled, stroked))\n            self.endStream()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeTrailer",
      "name": "writeTrailer",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeTrailer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the PDF trailer.",
      "docstring": "Write out the PDF trailer.",
      "code": "    def writeTrailer(self):\n        \"\"\"Write out the PDF trailer.\"\"\"\n\n        self.write(b\"trailer\\n\")\n        self.write(pdfRepr(\n            {'Size': len(self.xrefTable),\n             'Root': self.rootObject,\n             'Info': self.infoObject}))\n        # Could add 'ID'\n        self.write(b\"\\nstartxref\\n%d\\n%%%%EOF\\n\" % self.startxref)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeXref",
      "name": "writeXref",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeXref/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the xref table.",
      "docstring": "Write out the xref table.",
      "code": "    def writeXref(self):\n        \"\"\"Write out the xref table.\"\"\"\n        self.startxref = self.fh.tell() - self.tell_base\n        self.write(b\"xref\\n0 %d\\n\" % len(self.xrefTable))\n        for i, (offset, generation, name) in enumerate(self.xrefTable):\n            if offset is None:\n                raise AssertionError(\n                    'No offset for object %d (%s)' % (i, name))\n            else:\n                key = b\"f\" if name == 'the zero object' else b\"n\"\n                text = b\"%010d %05d %b \\n\" % (offset, generation, key)\n                self.write(text)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__enter__",
      "name": "__enter__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__enter__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter__(self):\n        return self"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__",
      "name": "__exit__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/exc_type",
          "name": "exc_type",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.exc_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/exc_val",
          "name": "exc_val",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.exc_val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/exc_tb",
          "name": "exc_tb",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.exc_tb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/keep_empty",
          "name": "keep_empty",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.keep_empty",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file.",
      "docstring": "Create a new PdfPages object.\n\nParameters\n----------\nfilename : str or path-like or file-like\n    Plots using `PdfPages.savefig` will be written to a file at this\n    location. The file is opened at once and any older file with the\n    same name is overwritten.\n\nkeep_empty : bool, optional\n    If set to False, then empty pdf files will be deleted automatically\n    when closed.\n\nmetadata : dict, optional\n    Information dictionary object (see PDF reference section 10.2.1\n    'Document Information Dictionary'), e.g.:\n    ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n    The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n    'Creator', 'Producer', 'CreationDate', 'ModDate', and\n    'Trapped'. Values have been predefined for 'Creator', 'Producer'\n    and 'CreationDate'. They can be removed by setting them to `None`.",
      "code": "    def __init__(self, filename, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. The file is opened at once and any older file with the\n            same name is overwritten.\n\n        keep_empty : bool, optional\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        self._file = PdfFile(filename, metadata=metadata)\n        self.keep_empty = keep_empty"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note",
      "name": "attach_note",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note/positionRect",
          "name": "positionRect",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note.positionRect",
          "default_value": "[-100, -100, 0, 0]",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a new text note to the page to be saved next. The optional\npositionRect specifies the position of the new note on the\npage. It is outside the page per default to make sure it is\ninvisible on printouts.",
      "docstring": "Add a new text note to the page to be saved next. The optional\npositionRect specifies the position of the new note on the\npage. It is outside the page per default to make sure it is\ninvisible on printouts.",
      "code": "    def attach_note(self, text, positionRect=[-100, -100, 0, 0]):\n        \"\"\"\n        Add a new text note to the page to be saved next. The optional\n        positionRect specifies the position of the new note on the\n        page. It is outside the page per default to make sure it is\n        invisible on printouts.\n        \"\"\"\n        self._file.newTextnote(text, positionRect)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finalize this object, making the underlying file a complete\nPDF file.",
      "docstring": "Finalize this object, making the underlying file a complete\nPDF file.",
      "code": "    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        self._file.finalize()\n        self._file.close()\n        if (self.get_pagecount() == 0 and not self.keep_empty and\n                not self._file.passed_in_file_object):\n            os.remove(self._file.fh.name)\n        self._file = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/get_pagecount",
      "name": "get_pagecount",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/get_pagecount/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the current number of pages in the multipage pdf file.",
      "docstring": "Return the current number of pages in the multipage pdf file.",
      "code": "    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return len(self._file.pageList)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/infodict",
      "name": "infodict",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.infodict",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/infodict/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.infodict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a modifiable information dictionary object\n(see PDF reference section 10.2.1 'Document Information\nDictionary').",
      "docstring": "Return a modifiable information dictionary object\n(see PDF reference section 10.2.1 'Document Information\nDictionary').",
      "code": "    def infodict(self):\n        \"\"\"\n        Return a modifiable information dictionary object\n        (see PDF reference section 10.2.1 'Document Information\n        Dictionary').\n        \"\"\"\n        return self._file.infoDict"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig",
      "name": "savefig",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Figure` or int",
            "default_value": "the active figure",
            "description": "The figure, or index of the figure, that is saved to the file."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`.Figure`"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.",
      "docstring": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.\n\nParameters\n----------\nfigure : `.Figure` or int, default: the active figure\n    The figure, or index of the figure, that is saved to the file.",
      "code": "    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, default: the active figure\n            The figure, or index of the figure, that is saved to the file.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n        # Force use of pdf backend, as PdfPages is tightly coupled with it.\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPdf(figure)\n            figure.savefig(self, format=\"pdf\", **kwargs)\n        finally:\n            figure.canvas = orig_canvas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.__init__.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF reference object.\n\nUse PdfFile.reserveObject() to create References.",
      "docstring": "",
      "code": "    def __init__(self, id):\n        self.id = id"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return \"<Reference %d>\" % self.id"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return b\"%d 0 R\" % self.id"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write",
      "name": "write",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.write",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.write.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write/contents",
          "name": "contents",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.write.contents",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.write.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def write(self, contents, file):\n        write = file.write\n        write(b\"%d 0 obj\\n\" % self.id)\n        write(pdfRepr(contents))\n        write(b\"\\nendobj\\n\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/image_dpi",
          "name": "image_dpi",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.image_dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, file, image_dpi, height, width):\n        super().__init__(width, height)\n        self.file = file\n        self.gc = self.new_gc()\n        self.image_dpi = image_dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc",
      "name": "check_gc",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc/fillcolor",
          "name": "fillcolor",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc.fillcolor",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc.get_rgb() is None:\n            # It should not matter what color here since linewidth should be\n            # 0 unless affected by global settings in rcParams, hence setting\n            # zero alpha just in case.\n            gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle",
      "name": "draw_gouraud_triangle",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles",
      "name": "draw_gouraud_triangles",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        if len(points) == 0:\n            return\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] in (1, 4)\n\n        shape = points.shape\n        points = points.reshape((shape[0] * shape[1], 2))\n        tpoints = trans.transform(points)\n        tpoints = tpoints.reshape(shape)\n        name, _ = self.file.addGouraudTriangles(tpoints, colors)\n        output = self.file.output\n\n        if colors.shape[2] == 1:\n            # grayscale\n            gc.set_alpha(1.0)\n            self.check_gc(gc)\n            output(name, Op.shading)\n            return\n\n        alpha = colors[0, 0, 3]\n        if np.allclose(alpha, colors[:, :, 3]):\n            # single alpha value\n            gc.set_alpha(alpha)\n            self.check_gc(gc)\n            output(name, Op.shading)\n        else:\n            # varying alpha: use a soft mask\n            alpha = colors[:, :, 3][:, :, None]\n            _, smask_ob = self.file.addGouraudTriangles(tpoints, alpha)\n            gstate = self.file._soft_mask_state(smask_ob)\n            output(Op.gsave, gstate, Op.setgstate,\n                   name, Op.shading,\n                   Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if transform is None:\n            # If there's no transform, alpha has already been applied\n            gc.set_alpha(1.0)\n\n        self.check_gc(gc)\n\n        w = 72.0 * w / self.image_dpi\n        h = 72.0 * h / self.image_dpi\n\n        imob = self.file.imageObject(im)\n\n        if transform is None:\n            self.file.output(Op.gsave,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n\n            self.file.output(Op.gsave,\n                             1, 0, 0, 1, x, y, Op.concat_matrix,\n                             tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        # Same logic as in draw_path_collection\n        len_marker_path = len(marker_path)\n        uses = len(path)\n        if len_marker_path * uses < len_marker_path + uses + 5:\n            RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n                                      path, trans, rgbFace)\n            return\n\n        self.check_gc(gc, rgbFace)\n        fill = gc.fill(rgbFace)\n        stroke = gc.stroke()\n\n        output = self.file.output\n        marker = self.file.markerObject(\n            marker_path, marker_trans, fill, stroke, self.gc._linewidth,\n            gc.get_joinstyle(), gc.get_capstyle())\n\n        output(Op.gsave)\n        lastx, lasty = 0, 0\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.file.width*72, self.file.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                if not (0 <= x <= self.file.width * 72\n                        and 0 <= y <= self.file.height * 72):\n                    continue\n                dx, dy = x - lastx, y - lasty\n                output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n                       marker, Op.use_xobject)\n                lastx, lasty = x, y\n        output(Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext",
      "name": "draw_mathtext",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        # TODO: fix positioning and encoding\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width, height, angle))\n\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        # Set up a global transformation matrix for the whole math expression\n        a = math.radians(angle)\n        self.file.output(Op.gsave)\n        self.file.output(math.cos(a), math.sin(a),\n                         -math.sin(a), math.cos(a),\n                         x, y, Op.concat_matrix)\n\n        self.check_gc(gc, gc._rgb)\n        prev_font = None, None\n        oldx, oldy = 0, 0\n        unsupported_chars = []\n\n        self.file.output(Op.begin_text)\n        for font, fontsize, num, ox, oy in glyphs:\n            self.file._character_tracker.track_glyph(font, num)\n            fontname = font.fname\n            if not _font_supports_glyph(fonttype, num):\n                # Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in\n                # Type 42) must be emitted separately (below).\n                unsupported_chars.append((font, fontsize, ox, oy, num))\n            else:\n                self._setup_textpos(ox, oy, 0, oldx, oldy)\n                oldx, oldy = ox, oy\n                if (fontname, fontsize) != prev_font:\n                    self.file.output(self.file.fontName(fontname), fontsize,\n                                     Op.selectfont)\n                    prev_font = fontname, fontsize\n                self.file.output(self.encode_string(chr(num), fonttype),\n                                 Op.show)\n        self.file.output(Op.end_text)\n\n        for font, fontsize, ox, oy, num in unsupported_chars:\n            self._draw_xobject_glyph(\n                font, fontsize, font.get_char_index(num), ox, oy)\n\n        # Draw any horizontal lines in the math layout\n        for ox, oy, width, height in rects:\n            self.file.output(Op.gsave, ox, oy, width, height,\n                             Op.rectangle, Op.fill, Op.grestore)\n\n        # Pop off the global transformation\n        self.file.output(Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        self.check_gc(gc, rgbFace)\n        self.file.writePath(\n            path, transform,\n            rgbFace is None and gc.get_hatch_path() is None,\n            gc.get_sketch_params())\n        self.file.output(self.gc.paint())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/offset_trans",
          "name": "offset_trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.offset_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # We can only reuse the objects if the presence of fill and\n        # stroke (and the amount of alpha for each) is the same for\n        # all of them\n        can_do_optimization = True\n        facecolors = np.asarray(facecolors)\n        edgecolors = np.asarray(edgecolors)\n\n        if not len(facecolors):\n            filled = False\n            can_do_optimization = not gc.get_hatch()\n        else:\n            if np.all(facecolors[:, 3] == facecolors[0, 3]):\n                filled = facecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        if not len(edgecolors):\n            stroked = False\n        else:\n            if np.all(np.asarray(linewidths) == 0.0):\n                stroked = False\n            elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):\n                stroked = edgecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is len_path * uses_per_path\n        # cost of XObject is len_path + 5 for the definition,\n        #    uses_per_path for the uses\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + uses_per_path + 5 < len_path * uses_per_path\n\n        if (not can_do_optimization) or (not should_do_optimization):\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        padding = np.max(linewidths)\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = self.file.pathCollectionObject(\n                gc, path, transform, padding, filled, stroked)\n            path_codes.append(name)\n\n        output = self.file.output\n        output(*self.gc.push())\n        lastx, lasty = 0, 0\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n\n            self.check_gc(gc0, rgbFace)\n            dx, dy = xo - lastx, yo - lasty\n            output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,\n                   Op.use_xobject)\n            lastx, lasty = xo, yo\n        output(*self.gc.pop())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        texmanager = self.get_texmanager()\n        fontsize = prop.get_size_in_points()\n        dvifile = texmanager.make_dvi(s, fontsize)\n        with dviread.Dvi(dvifile, 72) as dvi:\n            page, = dvi\n\n        if gc.get_url() is not None:\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, page.width, page.height, angle))\n\n        # Gather font information and do some setup for combining\n        # characters into strings. The variable seq will contain a\n        # sequence of font and text entries. A font entry is a list\n        # ['font', name, size] where name is a Name object for the\n        # font. A text entry is ['text', x, y, glyphs, x+w] where x\n        # and y are the starting coordinates, w is the width, and\n        # glyphs is a list; in this phase it will always contain just\n        # one one-character string, but later it may have longer\n        # strings interspersed with kern amounts.\n        oldfont, seq = None, []\n        for x1, y1, dvifont, glyph, width in page.text:\n            if dvifont != oldfont:\n                pdfname = self.file.dviFontName(dvifont)\n                seq += [['font', pdfname, dvifont.size]]\n                oldfont = dvifont\n            seq += [['text', x1, y1, [bytes([glyph])], x1+width]]\n\n        # Find consecutive text strings with constant y coordinate and\n        # combine into a sequence of strings and kerns, or just one\n        # string (if any kerns would be less than 0.1 points).\n        i, curx, fontsize = 0, 0, None\n        while i < len(seq)-1:\n            elt, nxt = seq[i:i+2]\n            if elt[0] == 'font':\n                fontsize = elt[2]\n            elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:\n                offset = elt[4] - nxt[1]\n                if abs(offset) < 0.1:\n                    elt[3][-1] += nxt[3][0]\n                    elt[4] += nxt[4]-nxt[1]\n                else:\n                    elt[3] += [offset*1000.0/fontsize, nxt[3][0]]\n                    elt[4] = nxt[4]\n                del seq[i+1]\n                continue\n            i += 1\n\n        # Create a transform to map the dvi contents to the canvas.\n        mytrans = Affine2D().rotate_deg(angle).translate(x, y)\n\n        # Output the text.\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        curx, cury, oldx, oldy = 0, 0, 0, 0\n        for elt in seq:\n            if elt[0] == 'font':\n                self.file.output(elt[1], elt[2], Op.selectfont)\n            elif elt[0] == 'text':\n                curx, cury = mytrans.transform((elt[1], elt[2]))\n                self._setup_textpos(curx, cury, angle, oldx, oldy)\n                oldx, oldy = curx, cury\n                if len(elt[3]) == 1:\n                    self.file.output(elt[3][0], Op.show)\n                else:\n                    self.file.output(elt[3], Op.showkern)\n            else:\n                assert False\n        self.file.output(Op.end_text)\n\n        # Then output the boxes (e.g., variable-length lines of square\n        # roots).\n        boxgc = self.new_gc()\n        boxgc.copy_properties(gc)\n        boxgc.set_linewidth(0)\n        pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.CLOSEPOLY]\n        for x1, y1, h, w in page.boxes:\n            path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],\n                         [0, 0]], pathops)\n            self.draw_path(boxgc, path, mytrans, gc._rgb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # TODO: combine consecutive texts into one BT/ET delimited section\n\n        self.check_gc(gc, gc._rgb)\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        fontsize = prop.get_size_in_points()\n\n        if mpl.rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            fonttype = 1\n        else:\n            font = self._get_font_ttf(prop)\n            self.file._character_tracker.track(font, s)\n            fonttype = mpl.rcParams['pdf.fonttype']\n\n        if gc.get_url() is not None:\n            font.set_text(s)\n            width, height = font.get_width_height()\n            self.file._annotations[-1][1].append(_get_link_annotation(\n                gc, x, y, width / 64, height / 64, angle))\n\n        # If fonttype is neither 3 nor 42, emit the whole string at once\n        # without manual kerning.\n        if fonttype not in [3, 42]:\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            self._setup_textpos(x, y, angle)\n            self.file.output(self.encode_string(s, fonttype),\n                             Op.show, Op.end_text)\n\n        # A sequence of characters is broken into multiple chunks. The chunking\n        # serves two purposes:\n        #   - For Type 3 fonts, there is no way to access multibyte characters,\n        #     as they cannot have a CIDMap.  Therefore, in this case we break\n        #     the string into chunks, where each chunk contains either a string\n        #     of consecutive 1-byte characters or a single multibyte character.\n        #   - A sequence of 1-byte characters is split into chunks to allow for\n        #     kerning adjustments between consecutive chunks.\n        #\n        # Each chunk is emitted with a separate command: 1-byte characters use\n        # the regular text show command (TJ) with appropriate kerning between\n        # chunks, whereas multibyte characters use the XObject command (Do).\n        else:\n            # List of (ft_object, start_x, [prev_kern, char, char, ...]),\n            # w/o zero kerns.\n            singlebyte_chunks = []\n            # List of (ft_object, start_x, glyph_index).\n            multibyte_glyphs = []\n            prev_was_multibyte = True\n            prev_font = font\n            for item in _text_helpers.layout(\n                    s, font, kern_mode=KERNING_UNFITTED):\n                if _font_supports_glyph(fonttype, ord(item.char)):\n                    if prev_was_multibyte or item.ft_object != prev_font:\n                        singlebyte_chunks.append((item.ft_object, item.x, []))\n                        prev_font = item.ft_object\n                    if item.prev_kern:\n                        singlebyte_chunks[-1][2].append(item.prev_kern)\n                    singlebyte_chunks[-1][2].append(item.char)\n                    prev_was_multibyte = False\n                else:\n                    multibyte_glyphs.append(\n                        (item.ft_object, item.x, item.glyph_idx)\n                    )\n                    prev_was_multibyte = True\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = math.radians(angle)\n            self.file.output(math.cos(a), math.sin(a),\n                             -math.sin(a), math.cos(a),\n                             x, y, Op.concat_matrix)\n            # Emit all the 1-byte characters in a BT/ET group.\n\n            self.file.output(Op.begin_text)\n            prev_start_x = 0\n            for ft_object, start_x, kerns_or_chars in singlebyte_chunks:\n                ft_name = self.file.fontName(ft_object.fname)\n                self.file.output(ft_name, fontsize, Op.selectfont)\n                self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n                self.file.output(\n                    # See pdf spec \"Text space details\" for the 1000/fontsize\n                    # (aka. 1000/T_fs) factor.\n                    [-1000 * next(group) / fontsize if tp == float  # a kern\n                     else self.encode_string(\"\".join(group), fonttype)\n                     for tp, group in itertools.groupby(kerns_or_chars, type)],\n                    Op.showkern)\n                prev_start_x = start_x\n            self.file.output(Op.end_text)\n            # Then emit all the multibyte characters, one at a time.\n            for ft_object, start_x, glyph_idx in multibyte_glyphs:\n                self._draw_xobject_glyph(\n                    ft_object, fontsize, glyph_idx, start_x, 0\n                )\n            self.file.output(Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string",
      "name": "encode_string",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string/fonttype",
          "name": "fonttype",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string.fonttype",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def encode_string(self, s, fonttype):\n        if fonttype in (1, 3):\n            return s.encode('cp1252', 'replace')\n        return s.encode('utf-16be', 'replace')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def finalize(self):\n        self.file.output(*self.gc.finalize())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/get_image_magnification",
      "name": "get_image_magnification",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/get_image_magnification/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_image_magnification(self):\n        return self.image_dpi/72.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPdf(self.file)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/len",
          "name": "len",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.len",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.extra",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/png",
          "name": "png",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.png",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF stream object.\n\nThis has no pdfRepr method. Instead, call begin(), then output the\ncontents of the stream by calling write(), and finally call end().",
      "docstring": "Parameters\n----------\nid : int\n    Object id of the stream.\nlen : Reference or None\n    An unused Reference object for the length of the stream;\n    None means to use a memory buffer so the length can be inlined.\nfile : PdfFile\n    The underlying object to write the stream to.\nextra : dict from Name to anything, or None\n    Extra key-value pairs to include in the stream header.\npng : dict or None\n    If the data is already png encoded, the decode parameters.",
      "code": "    def __init__(self, id, len, file, extra=None, png=None):\n        \"\"\"\n        Parameters\n        ----------\n        id : int\n            Object id of the stream.\n        len : Reference or None\n            An unused Reference object for the length of the stream;\n            None means to use a memory buffer so the length can be inlined.\n        file : PdfFile\n            The underlying object to write the stream to.\n        extra : dict from Name to anything, or None\n            Extra key-value pairs to include in the stream header.\n        png : dict or None\n            If the data is already png encoded, the decode parameters.\n        \"\"\"\n        self.id = id            # object id\n        self.len = len          # id of length object\n        self.pdfFile = file\n        self.file = file.fh      # file to which the stream is written\n        self.compressobj = None  # compression object\n        if extra is None:\n            self.extra = dict()\n        else:\n            self.extra = extra.copy()\n        if png is not None:\n            self.extra.update({'Filter':      Name('FlateDecode'),\n                               'DecodeParms': png})\n\n        self.pdfFile.recordXref(self.id)\n        if mpl.rcParams['pdf.compression'] and not png:\n            self.compressobj = zlib.compressobj(\n                mpl.rcParams['pdf.compression'])\n        if self.len is None:\n            self.file = BytesIO()\n        else:\n            self._writeHeader()\n            self.pos = self.file.tell()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/end",
      "name": "end",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream.end",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/end/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.end.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finalize stream.",
      "docstring": "Finalize stream.",
      "code": "    def end(self):\n        \"\"\"Finalize stream.\"\"\"\n\n        self._flush()\n        if self.len is None:\n            contents = self.file.getvalue()\n            self.len = len(contents)\n            self.file = self.pdfFile.fh\n            self._writeHeader()\n            self.file.write(contents)\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n        else:\n            length = self.file.tell() - self.pos\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n            self.pdfFile.writeObject(self.len, length)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write",
      "name": "write",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream.write",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.write.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.write.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write some data on the stream.",
      "docstring": "Write some data on the stream.",
      "code": "    def write(self, data):\n        \"\"\"Write some data on the stream.\"\"\"\n\n        if self.compressobj is None:\n            self.file.write(data)\n        else:\n            compressed = self.compressobj.compress(data)\n            self.file.write(compressed)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.__init__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Store verbatim PDF command content for later inclusion in the stream.",
      "docstring": "",
      "code": "    def __init__(self, x):\n        self._x = x"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return self._x"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/fill",
      "name": "fill",
      "qname": "lib.matplotlib.backends.backend_pdf.fill",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _fill')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/fill/strings",
          "name": "strings",
          "qname": "lib.matplotlib.backends.backend_pdf.fill.strings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/fill/linelen",
          "name": "linelen",
          "qname": "lib.matplotlib.backends.backend_pdf.fill.linelen",
          "default_value": "75",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _fill\")\ndef fill(strings, linelen=75):\n    return _fill(strings, linelen=linelen)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/pdfRepr/obj",
          "name": "obj",
          "qname": "lib.matplotlib.backends.backend_pdf.pdfRepr.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Map Python objects to PDF syntax.",
      "docstring": "Map Python objects to PDF syntax.",
      "code": "def pdfRepr(obj):\n    \"\"\"Map Python objects to PDF syntax.\"\"\"\n\n    # Some objects defined later have their own pdfRepr method.\n    if hasattr(obj, 'pdfRepr'):\n        return obj.pdfRepr()\n\n    # Floats. PDF does not have exponential notation (1.0e-10) so we\n    # need to use %f with some precision.  Perhaps the precision\n    # should adapt to the magnitude of the number?\n    elif isinstance(obj, (float, np.floating)):\n        if not np.isfinite(obj):\n            raise ValueError(\"Can only output finite numbers in PDF\")\n        r = b\"%.10f\" % obj\n        return r.rstrip(b'0').rstrip(b'.')\n\n    # Booleans. Needs to be tested before integers since\n    # isinstance(True, int) is true.\n    elif isinstance(obj, bool):\n        return [b'false', b'true'][obj]\n\n    # Integers are written as such.\n    elif isinstance(obj, (int, np.integer)):\n        return b\"%d\" % obj\n\n    # Non-ASCII Unicode strings are encoded in UTF-16BE with byte-order mark.\n    elif isinstance(obj, str):\n        return pdfRepr(obj.encode('ascii') if obj.isascii()\n                       else codecs.BOM_UTF16_BE + obj.encode('UTF-16BE'))\n\n    # Strings are written in parentheses, with backslashes and parens\n    # escaped. Actually balanced parens are allowed, but it is\n    # simpler to escape them all. TODO: cut long strings into lines;\n    # I believe there is some maximum line length in PDF.\n    # Despite the extra decode/encode, translate is faster than regex.\n    elif isinstance(obj, bytes):\n        return (\n            b'(' +\n            obj.decode('latin-1').translate(_str_escapes).encode('latin-1')\n            + b')')\n\n    # Dictionaries. The keys must be PDF names, so if we find strings\n    # there, we make Name objects from them. The values may be\n    # anything, so the caller must ensure that PDF names are\n    # represented as Name objects.\n    elif isinstance(obj, dict):\n        return _fill([\n            b\"<<\",\n            *[Name(k).pdfRepr() + b\" \" + pdfRepr(v) for k, v in obj.items()],\n            b\">>\",\n        ])\n\n    # Lists.\n    elif isinstance(obj, (list, tuple)):\n        return _fill([b\"[\", *[pdfRepr(val) for val in obj], b\"]\"])\n\n    # The null keyword.\n    elif obj is None:\n        return b'null'\n\n    # A date.\n    elif isinstance(obj, datetime):\n        return pdfRepr(_datetime_to_pdf(obj))\n\n    # A bounding box\n    elif isinstance(obj, BboxBase):\n        return _fill([pdfRepr(val) for val in obj.bounds])\n\n    else:\n        raise TypeError(\"Don't know a PDF representation for {} objects\"\n                        .format(type(obj)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'pdf'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_renderer",
      "name": "get_renderer",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_renderer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_renderer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_renderer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_renderer(self):\n        return RendererPgf(self.figure, None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf",
      "name": "print_pdf",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/fname_or_fh",
          "name": "fname_or_fh",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.fname_or_fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use LaTeX to compile a pgf generated figure to pdf.",
      "docstring": "Use LaTeX to compile a pgf generated figure to pdf.",
      "code": "    def print_pdf(self, fname_or_fh, *, metadata=None, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf generated figure to pdf.\"\"\"\n        w, h = self.figure.get_size_inches()\n\n        info_dict = _create_pdf_info_dict('pgf', metadata or {})\n        pdfinfo = ','.join(\n            _metadata_to_str(k, v) for k, v in info_dict.items())\n\n        # print figure to pgf and compile it with latex\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            self.print_pgf(tmppath / \"figure.pgf\", **kwargs)\n            (tmppath / \"figure.tex\").write_text(\n                \"\\n\".join([\n                    r\"\\documentclass[12pt]{article}\",\n                    r\"\\usepackage[pdfinfo={%s}]{hyperref}\" % pdfinfo,\n                    r\"\\usepackage[papersize={%fin,%fin}, margin=0in]{geometry}\"\n                    % (w, h),\n                    r\"\\usepackage{pgf}\",\n                    _get_preamble(),\n                    r\"\\begin{document}\",\n                    r\"\\centering\",\n                    r\"\\input{figure.pgf}\",\n                    r\"\\end{document}\",\n                ]), encoding=\"utf-8\")\n            texcommand = mpl.rcParams[\"pgf.texsystem\"]\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 \"figure.tex\"], _log, cwd=tmpdir)\n            with (tmppath / \"figure.pdf\").open(\"rb\") as orig, \\\n                 cbook.open_file_cm(fname_or_fh, \"wb\") as dest:\n                shutil.copyfileobj(orig, dest)  # copy file contents to target"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf",
      "name": "print_pgf",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/fname_or_fh",
          "name": "fname_or_fh",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.fname_or_fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Output pgf macros for drawing the figure so it can be included and\nrendered in latex documents.",
      "docstring": "Output pgf macros for drawing the figure so it can be included and\nrendered in latex documents.",
      "code": "    def print_pgf(self, fname_or_fh, **kwargs):\n        \"\"\"\n        Output pgf macros for drawing the figure so it can be included and\n        rendered in latex documents.\n        \"\"\"\n        with cbook.open_file_cm(fname_or_fh, \"w\", encoding=\"utf-8\") as file:\n            if not cbook.file_requires_unicode(file):\n                file = codecs.getwriter(\"utf-8\")(file)\n            self._print_pgf_to_fh(file, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/fname_or_fh",
          "name": "fname_or_fh",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.fname_or_fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use LaTeX to compile a pgf figure to pdf and convert it to png.",
      "docstring": "Use LaTeX to compile a pgf figure to pdf and convert it to png.",
      "code": "    def print_png(self, fname_or_fh, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf figure to pdf and convert it to png.\"\"\"\n        converter = make_pdf_to_png_converter()\n        with TemporaryDirectory() as tmpdir:\n            tmppath = pathlib.Path(tmpdir)\n            pdf_path = tmppath / \"figure.pdf\"\n            png_path = tmppath / \"figure.png\"\n            self.print_pdf(pdf_path, **kwargs)\n            converter(pdf_path, png_path, dpi=self.figure.dpi)\n            with png_path.open(\"rb\") as orig, \\\n                 cbook.open_file_cm(fname_or_fh, \"wb\") as dest:\n                shutil.copyfileobj(orig, dest)  # copy file contents to target"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__/latex_output",
          "name": "latex_output",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__.latex_output",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, message, latex_output=\"\"):\n        super().__init__(message)\n        self.latex_output = latex_output"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__str__",
      "name": "__str__",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__str__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self):\n        s, = self.args\n        if self.latex_output:\n            s += \"\\n\" + self.latex_output\n        return s"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.",
      "docstring": "",
      "code": "    def __init__(self):\n        # create a tmp directory for running latex, register it for deletion\n        self._tmpdir = TemporaryDirectory()\n        self.tmpdir = self._tmpdir.name\n        self._finalize_tmpdir = weakref.finalize(self, self._tmpdir.cleanup)\n\n        # test the LaTeX setup to ensure a clean startup of the subprocess\n        try:\n            self._setup_latex_process(expect_reply=False)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{self.latex.args[0]!r} not found.  Install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX \"\n                f\"implementation.\") from err\n        except OSError as err:\n            raise RuntimeError(\n                f\"Error starting process {self.latex.args[0]!r}\") from err\n        stdout, stderr = self.latex.communicate(\"\\n\\\\makeatletter\\\\@@end\\n\")\n        if self.latex.returncode != 0:\n            raise LatexError(\n                f\"LaTeX errored (probably missing font or error in preamble) \"\n                f\"while processing the following input:\\n\"\n                f\"{self._build_latex_header()}\",\n                stdout)\n\n        self.latex = None  # Will be set up on first use.\n        # Per-instance cache.\n        self._get_box_metrics = functools.lru_cache()(self._get_box_metrics)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent",
      "name": "get_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the width, total height, and descent (in TeX points) for a text\ntypeset by the current LaTeX environment.",
      "docstring": "Get the width, total height, and descent (in TeX points) for a text\ntypeset by the current LaTeX environment.",
      "code": "    def get_width_height_descent(self, text, prop):\n        \"\"\"\n        Get the width, total height, and descent (in TeX points) for a text\n        typeset by the current LaTeX environment.\n        \"\"\"\n        return self._get_box_metrics(_escape_and_apply_props(text, prop))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__enter__",
      "name": "__enter__",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__enter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__enter__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__enter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter__(self):\n        return self"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__",
      "name": "__exit__",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/exc_type",
          "name": "exc_type",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.exc_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/exc_val",
          "name": "exc_val",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.exc_val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/exc_tb",
          "name": "exc_tb",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.exc_tb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/keep_empty",
          "name": "keep_empty",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.keep_empty",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file using the pgf backend",
      "docstring": "Create a new PdfPages object.\n\nParameters\n----------\nfilename : str or path-like\n    Plots using `PdfPages.savefig` will be written to a file at this\n    location. Any older file with the same name is overwritten.\n\nkeep_empty : bool, default: True\n    If set to False, then empty pdf files will be deleted automatically\n    when closed.\n\nmetadata : dict, optional\n    Information dictionary object (see PDF reference section 10.2.1\n    'Document Information Dictionary'), e.g.:\n    ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n    The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n    'Creator', 'Producer', 'CreationDate', 'ModDate', and\n    'Trapped'. Values have been predefined for 'Creator', 'Producer'\n    and 'CreationDate'. They can be removed by setting them to `None`.\n\n    Note that some versions of LaTeX engines may ignore the 'Producer'\n    key and set it to themselves.",
      "code": "    def __init__(self, filename, *, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. Any older file with the same name is overwritten.\n\n        keep_empty : bool, default: True\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n\n            Note that some versions of LaTeX engines may ignore the 'Producer'\n            key and set it to themselves.\n        \"\"\"\n        self._output_name = filename\n        self._n_figures = 0\n        self.keep_empty = keep_empty\n        self._metadata = (metadata or {}).copy()\n        self._info_dict = _create_pdf_info_dict('pgf', self._metadata)\n        self._file = BytesIO()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finalize this object, running LaTeX in a temporary directory\nand moving the final pdf file to *filename*.",
      "docstring": "Finalize this object, running LaTeX in a temporary directory\nand moving the final pdf file to *filename*.",
      "code": "    def close(self):\n        \"\"\"\n        Finalize this object, running LaTeX in a temporary directory\n        and moving the final pdf file to *filename*.\n        \"\"\"\n        self._file.write(rb'\\end{document}\\n')\n        if self._n_figures > 0:\n            self._run_latex()\n        elif self.keep_empty:\n            open(self._output_name, 'wb').close()\n        self._file.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/get_pagecount",
      "name": "get_pagecount",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.get_pagecount",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/get_pagecount/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.get_pagecount.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the current number of pages in the multipage pdf file.",
      "docstring": "Return the current number of pages in the multipage pdf file.",
      "code": "    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return self._n_figures"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig",
      "name": "savefig",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Figure` or int",
            "default_value": "the active figure",
            "description": "The figure, or index of the figure, that is saved to the file."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`.Figure`"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.",
      "docstring": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.\n\nParameters\n----------\nfigure : `.Figure` or int, default: the active figure\n    The figure, or index of the figure, that is saved to the file.",
      "code": "    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, default: the active figure\n            The figure, or index of the figure, that is saved to the file.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPgf(figure)\n\n            width, height = figure.get_size_inches()\n            if self._n_figures == 0:\n                self._write_header(width, height)\n            else:\n                # \\pdfpagewidth and \\pdfpageheight exist on pdftex, xetex, and\n                # luatex<0.85; they were renamed to \\pagewidth and \\pageheight\n                # on luatex>=0.85.\n                self._file.write(\n                    br'\\newpage'\n                    br'\\ifdefined\\pdfpagewidth\\pdfpagewidth'\n                    br'\\else\\pagewidth\\fi=%ain'\n                    br'\\ifdefined\\pdfpageheight\\pdfpageheight'\n                    br'\\else\\pageheight\\fi=%ain'\n                    b'%%\\n' % (width, height)\n                )\n\n            figure.savefig(self._file, format=\"pgf\", **kwargs)\n            self._n_figures += 1\n        finally:\n            figure.canvas = orig_canvas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/fh",
          "name": "fh",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Create a new PGF renderer that translates any drawing instruction\ninto text commands to be interpreted in a latex pgfpicture environment.\n\nAttributes\n----------\nfigure : `matplotlib.figure.Figure`\n    Matplotlib figure to initialize height, width and dpi from.\nfh : file-like\n    File handle for the output of the drawing commands.",
      "code": "    def __init__(self, figure, fh):\n        \"\"\"\n        Create a new PGF renderer that translates any drawing instruction\n        into text commands to be interpreted in a latex pgfpicture environment.\n\n        Attributes\n        ----------\n        figure : `matplotlib.figure.Figure`\n            Matplotlib figure to initialize height, width and dpi from.\n        fh : file-like\n            File handle for the output of the drawing commands.\n        \"\"\"\n\n        super().__init__()\n        self.dpi = figure.dpi\n        self.fh = fh\n        self.figure = figure\n        self.image_counter = 0"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if not os.path.exists(getattr(self.fh, \"name\", \"\")):\n            raise ValueError(\n                \"streamed pgf-code does not support raster graphics, consider \"\n                \"using the pgf-to-pdf option\")\n\n        # save the images to png files\n        path = pathlib.Path(self.fh.name)\n        fname_img = \"%s-img%d.png\" % (path.stem, self.image_counter)\n        Image.fromarray(im[::-1]).save(path.parent / fname_img)\n        self.image_counter += 1\n\n        # reference the image in the pgf picture\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n        self._print_pgf_clip(gc)\n        f = 1. / self.dpi  # from display coords to inch\n        if transform is None:\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x * f, y * f))\n            w, h = w * f, h * f\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformcm{%f}{%f}{%f}{%f}{%fin}{%fin}\" %\n                     (tr1 * f, tr2 * f, tr3 * f, tr4 * f,\n                      (tr5 + x) * f, (tr6 + y) * f))\n            w = h = 1  # scale is already included in the transform\n        interp = str(transform is None).lower()  # interpolation in PDF reader\n        _writeln(self.fh,\n                 r\"\\pgftext[left,bottom]\"\n                 r\"{%s[interpolate=%s,width=%fin,height=%fin]{%s}}\" %\n                 (_get_image_inclusion_command(),\n                  interp, w, h, fname_img))\n        _writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        # convert from display units to in\n        f = 1. / self.dpi\n\n        # set style and clip\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n\n        # build marker definition\n        bl, tr = marker_path.get_extents(marker_trans).get_points()\n        coords = bl[0] * f, bl[1] * f, tr[0] * f, tr[1] * f\n        _writeln(self.fh,\n                 r\"\\pgfsys@defobject{currentmarker}\"\n                 r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}{\" % coords)\n        self._print_pgf_path(None, marker_path, marker_trans)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        _writeln(self.fh, r\"}\")\n\n        maxcoord = 16383 / 72.27 * self.dpi  # Max dimensions in LaTeX.\n        clip = (-maxcoord, -maxcoord, maxcoord, maxcoord)\n\n        # draw marker for each vertex\n        for point, code in path.iter_segments(trans, simplify=False,\n                                              clip=clip):\n            x, y = point[0] * f, point[1] * f\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            _writeln(self.fh, r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x, y))\n            _writeln(self.fh, r\"\\pgfsys@useobject{currentmarker}{}\")\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n\n        _writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n        # draw the path\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n        self._print_pgf_path(gc, path, transform, rgbFace)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        _writeln(self.fh, r\"\\end{pgfscope}\")\n\n        # if present, draw pattern on top\n        if gc.get_hatch():\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            self._print_pgf_path_styles(gc, rgbFace)\n\n            # combine clip and path for clipping\n            self._print_pgf_clip(gc)\n            self._print_pgf_path(gc, path, transform, rgbFace)\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n            # build pattern definition\n            _writeln(self.fh,\n                     r\"\\pgfsys@defobject{currentpattern}\"\n                     r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}{\")\n            _writeln(self.fh, r\"\\begin{pgfscope}\")\n            _writeln(self.fh,\n                     r\"\\pgfpathrectangle\"\n                     r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}\")\n            _writeln(self.fh, r\"\\pgfusepath{clip}\")\n            scale = mpl.transforms.Affine2D().scale(self.dpi)\n            self._print_pgf_path(None, gc.get_hatch_path(), scale)\n            self._pgf_path_draw(stroke=True)\n            _writeln(self.fh, r\"\\end{pgfscope}\")\n            _writeln(self.fh, r\"}\")\n            # repeat pattern, filling the bounding rect of the path\n            f = 1. / self.dpi\n            (xmin, ymin), (xmax, ymax) = \\\n                path.get_extents(transform).get_points()\n            xmin, xmax = f * xmin, f * xmax\n            ymin, ymax = f * ymin, f * ymax\n            repx, repy = math.ceil(xmax - xmin), math.ceil(ymax - ymin)\n            _writeln(self.fh,\n                     r\"\\pgfsys@transformshift{%fin}{%fin}\" % (xmin, ymin))\n            for iy in range(repy):\n                for ix in range(repx):\n                    _writeln(self.fh, r\"\\pgfsys@useobject{currentpattern}{}\")\n                    _writeln(self.fh, r\"\\pgfsys@transformshift{1in}{0in}\")\n                _writeln(self.fh, r\"\\pgfsys@transformshift{-%din}{0in}\" % repx)\n                _writeln(self.fh, r\"\\pgfsys@transformshift{0in}{1in}\")\n\n            _writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.ismath",
          "default_value": "'TeX'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_tex(self, gc, x, y, s, prop, angle, ismath=\"TeX\", mtext=None):\n        # docstring inherited\n        self.draw_text(gc, x, y, s, prop, angle, ismath, mtext)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # prepare string for tex\n        s = _escape_and_apply_props(s, prop)\n\n        _writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        alpha = gc.get_alpha()\n        if alpha != 1.0:\n            _writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % alpha)\n            _writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % alpha)\n        rgb = tuple(gc.get_rgb())[:3]\n        _writeln(self.fh, r\"\\definecolor{textcolor}{rgb}{%f,%f,%f}\" % rgb)\n        _writeln(self.fh, r\"\\pgfsetstrokecolor{textcolor}\")\n        _writeln(self.fh, r\"\\pgfsetfillcolor{textcolor}\")\n        s = r\"\\color{textcolor}\" + s\n\n        dpi = self.figure.dpi\n        text_args = []\n        if mtext and (\n                (angle == 0 or\n                 mtext.get_rotation_mode() == \"anchor\") and\n                mtext.get_verticalalignment() != \"center_baseline\"):\n            # if text anchoring can be supported, get the original coordinates\n            # and add alignment information\n            pos = mtext.get_unitless_position()\n            x, y = mtext.get_transform().transform(pos)\n            halign = {\"left\": \"left\", \"right\": \"right\", \"center\": \"\"}\n            valign = {\"top\": \"top\", \"bottom\": \"bottom\",\n                      \"baseline\": \"base\", \"center\": \"\"}\n            text_args.extend([\n                f\"x={x/dpi:f}in\",\n                f\"y={y/dpi:f}in\",\n                halign[mtext.get_horizontalalignment()],\n                valign[mtext.get_verticalalignment()],\n            ])\n        else:\n            # if not, use the text layout provided by Matplotlib.\n            text_args.append(f\"x={x/dpi:f}in, y={y/dpi:f}in, left, base\")\n\n        if angle != 0:\n            text_args.append(\"rotate=%f\" % angle)\n\n        _writeln(self.fh, r\"\\pgftext[%s]{%s}\" % (\",\".join(text_args), s))\n        _writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return (self.figure.get_figwidth() * self.dpi,\n                self.figure.get_figheight() * self.dpi)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        # get text metrics in units of latex pt, convert to display units\n        w, h, d = (LatexManager._get_cached_or_new()\n                   .get_width_height_descent(s, prop))\n        # TODO: this should be latex_pt_to_in instead of mpl_pt_to_in\n        # but having a little bit more space around the text looks better,\n        # plus the bounding box reported by LaTeX is VERY narrow\n        f = mpl_pt_to_in * self.dpi\n        return w * f, h * f, d * f"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_image_nocomposite",
      "name": "option_image_nocomposite",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_image_nocomposite",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_image_nocomposite/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_image_nocomposite.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_scale_image",
      "name": "option_scale_image",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_scale_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_scale_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_scale_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_scale_image(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * mpl_pt_to_in * self.dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/common_texification",
      "name": "common_texification",
      "qname": "lib.matplotlib.backends.backend_pgf.common_texification",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/common_texification/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pgf.common_texification.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef common_texification(text):\n    return _tex_escape(text)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/get_fontspec",
      "name": "get_fontspec",
      "qname": "lib.matplotlib.backends.backend_pgf.get_fontspec",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Build fontspec preamble from rc.",
      "docstring": "Build fontspec preamble from rc.",
      "code": "@_api.deprecated(\"3.6\")\ndef get_fontspec():\n    \"\"\"Build fontspec preamble from rc.\"\"\"\n    with mpl.rc_context({\"pgf.preamble\": \"\"}):\n        return _get_preamble()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/get_preamble",
      "name": "get_preamble",
      "qname": "lib.matplotlib.backends.backend_pgf.get_preamble",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get LaTeX preamble from rc.",
      "docstring": "Get LaTeX preamble from rc.",
      "code": "@_api.deprecated(\"3.6\")\ndef get_preamble():\n    \"\"\"Get LaTeX preamble from rc.\"\"\"\n    return mpl.rcParams[\"pgf.preamble\"]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/make_pdf_to_png_converter",
      "name": "make_pdf_to_png_converter",
      "qname": "lib.matplotlib.backends.backend_pgf.make_pdf_to_png_converter",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a function that converts a pdf file to a png file.",
      "docstring": "Return a function that converts a pdf file to a png file.",
      "code": "def make_pdf_to_png_converter():\n    \"\"\"Return a function that converts a pdf file to a png file.\"\"\"\n    try:\n        mpl._get_executable_info(\"pdftocairo\")\n    except mpl.ExecutableNotFoundError:\n        pass\n    else:\n        return lambda pdffile, pngfile, dpi: subprocess.check_output(\n            [\"pdftocairo\", \"-singlefile\", \"-transp\", \"-png\", \"-r\", \"%d\" % dpi,\n             pdffile, os.path.splitext(pngfile)[0]],\n            stderr=subprocess.STDOUT)\n    try:\n        gs_info = mpl._get_executable_info(\"gs\")\n    except mpl.ExecutableNotFoundError:\n        pass\n    else:\n        return lambda pdffile, pngfile, dpi: subprocess.check_output(\n            [gs_info.executable,\n             '-dQUIET', '-dSAFER', '-dBATCH', '-dNOPAUSE', '-dNOPROMPT',\n             '-dUseCIEColor', '-dTextAlphaBits=4',\n             '-dGraphicsAlphaBits=4', '-dDOINTERPOLATE',\n             '-sDEVICE=pngalpha', '-sOutputFile=%s' % pngfile,\n             '-r%d' % dpi, pdffile],\n            stderr=subprocess.STDOUT)\n    raise RuntimeError(\"No suitable pdf to png renderer found.\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/writeln",
      "name": "writeln",
      "qname": "lib.matplotlib.backends.backend_pgf.writeln",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/writeln/fh",
          "name": "fh",
          "qname": "lib.matplotlib.backends.backend_pgf.writeln.fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/writeln/line",
          "name": "line",
          "qname": "lib.matplotlib.backends.backend_pgf.writeln.line",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef writeln(fh, line):\n    return _writeln(fh, line)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'ps'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_ps.PsBackendHelper.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.PsBackendHelper.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self):\n        self._cached = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/pswriter",
          "name": "pswriter",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.pswriter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/imagedpi",
          "name": "imagedpi",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.imagedpi",
          "default_value": "72",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.",
      "docstring": "",
      "code": "    def __init__(self, width, height, pswriter, imagedpi=72):\n        # Although postscript itself is dpi independent, we need to inform the\n        # image code about a requested dpi to generate high resolution images\n        # and them scale them before embedding them.\n        super().__init__(width, height)\n        self._pswriter = pswriter\n        if mpl.rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi / 72\n        self._clip_paths = {}\n        self._path_collection_id = 0\n\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n        self._logwarn_once = functools.lru_cache(None)(_log.warning)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch",
      "name": "create_hatch",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.create_hatch",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.create_hatch.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch/hatch",
          "name": "hatch",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.create_hatch.hatch",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def create_hatch(self, hatch):\n        sidelen = 72\n        if hatch in self._hatches:\n            return self._hatches[hatch]\n        name = 'H%d' % len(self._hatches)\n        linewidth = mpl.rcParams['hatch.linewidth']\n        pageheight = self.height * 72\n        self._pswriter.write(f\"\"\"\\\n  << /PatternType 1\n     /PaintType 2\n     /TilingType 2\n     /BBox[0 0 {sidelen:d} {sidelen:d}]\n     /XStep {sidelen:d}\n     /YStep {sidelen:d}\n\n     /PaintProc {{\n        pop\n        {linewidth:g} setlinewidth\n{self._convert_path(\n    Path.hatch(hatch), Affine2D().scale(sidelen), simplify=False)}\n        gsave\n        fill\n        grestore\n        stroke\n     }} bind\n   >>\n   matrix\n   0 {pageheight:g} translate\n   makepattern\n   /{name} exch def\n\"\"\")\n        self._hatches[hatch] = name\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle",
      "name": "draw_gouraud_triangle",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles",
      "name": "draw_gouraud_triangles",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] == 4\n\n        shape = points.shape\n        flat_points = points.reshape((shape[0] * shape[1], 2))\n        flat_points = trans.transform(flat_points)\n        flat_colors = colors.reshape((shape[0] * shape[1], 4))\n        points_min = np.min(flat_points, axis=0) - (1 << 12)\n        points_max = np.max(flat_points, axis=0) + (1 << 12)\n        factor = np.ceil((2 ** 32 - 1) / (points_max - points_min))\n\n        xmin, ymin = points_min\n        xmax, ymax = points_max\n\n        data = np.empty(\n            shape[0] * shape[1],\n            dtype=[('flags', 'u1'), ('points', '2>u4'), ('colors', '3u1')])\n        data['flags'] = 0\n        data['points'] = (flat_points - points_min) * factor\n        data['colors'] = flat_colors[:, :3] * 255.0\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n<< /ShadingType 4\n   /ColorSpace [/DeviceRGB]\n   /BitsPerCoordinate 32\n   /BitsPerComponent 8\n   /BitsPerFlag 8\n   /AntiAlias true\n   /Decode [ {xmin:g} {xmax:g} {ymin:g} {ymax:g} 0 1 0 1 0 1 ]\n   /DataSource <\n{hexdata}\n>\n>>\nshfill\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        hexdata = data.tobytes().hex(\"\\n\", -64)  # Linewrap to 128 chars.\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n[{matrix}] concat\n{xscale:g} {yscale:g} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataString readhexstring pop\n}} bind {imagecmd}\n{hexdata}\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        ps_color = (\n            None\n            if self._is_transparent(rgbFace)\n            else '%1.3f setgray' % rgbFace[0]\n            if rgbFace[0] == rgbFace[1] == rgbFace[2]\n            else '%1.3f %1.3f %1.3f setrgbcolor' % rgbFace[:3])\n\n        # construct the generic marker command:\n\n        # don't want the translate to be global\n        ps_cmd = ['/o {', 'gsave', 'newpath', 'translate']\n\n        lw = gc.get_linewidth()\n        alpha = (gc.get_alpha()\n                 if gc.get_forced_alpha() or len(gc.get_rgb()) == 3\n                 else gc.get_rgb()[3])\n        stroke = lw > 0 and alpha > 0\n        if stroke:\n            ps_cmd.append('%.1f setlinewidth' % lw)\n            ps_cmd.append(self._linejoin_cmd(gc.get_joinstyle()))\n            ps_cmd.append(self._linecap_cmd(gc.get_capstyle()))\n\n        ps_cmd.append(self._convert_path(marker_path, marker_trans,\n                                         simplify=False))\n\n        if rgbFace:\n            if stroke:\n                ps_cmd.append('gsave')\n            if ps_color:\n                ps_cmd.extend([ps_color, 'fill'])\n            if stroke:\n                ps_cmd.append('grestore')\n\n        if stroke:\n            ps_cmd.append('stroke')\n        ps_cmd.extend(['grestore', '} bind def'])\n\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.width*72, self.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ps_cmd.append(\"%g %g o\" % (x, y))\n\n        ps = '\\n'.join(ps_cmd)\n        self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext",
      "name": "draw_mathtext",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw the math text using matplotlib.mathtext.",
      "docstring": "Draw the math text using matplotlib.mathtext.",
      "code": "    @_log_if_debug_on\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw the math text using matplotlib.mathtext.\"\"\"\n        width, height, descent, glyphs, rects = \\\n            self._text2path.mathtext_parser.parse(s, 72, prop)\n        self.set_color(*gc.get_rgb())\n        self._pswriter.write(\n            f\"gsave\\n\"\n            f\"{x:g} {y:g} translate\\n\"\n            f\"{angle:g} rotate\\n\")\n        lastfont = None\n        for font, fontsize, num, ox, oy in glyphs:\n            self._character_tracker.track_glyph(font, num)\n            if (font.postscript_name, fontsize) != lastfont:\n                lastfont = font.postscript_name, fontsize\n                self._pswriter.write(\n                    f\"/{font.postscript_name} {fontsize} selectfont\\n\")\n            glyph_name = (\n                font.get_name_char(chr(num)) if isinstance(font, AFM) else\n                font.get_glyph_name(font.get_char_index(num)))\n            self._pswriter.write(\n                f\"{ox:g} {oy:g} moveto\\n\"\n                f\"/{glyph_name} glyphshow\\n\")\n        for ox, oy, w, h in rects:\n            self._pswriter.write(f\"{ox} {oy} {w} {h} rectfill\\n\")\n        self._pswriter.write(\"grestore\\n\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        clip = rgbFace is None and gc.get_hatch_path() is None\n        simplify = path.should_simplify and clip\n        ps = self._convert_path(path, transform, clip=clip, simplify=simplify)\n        self._draw_ps(ps, gc, rgbFace)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/offset_trans",
          "name": "offset_trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.offset_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #     (len_path + 2) * uses_per_path\n        # cost of definition+use is\n        #     (len_path + 3) + 3 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 3 * uses_per_path + 3 < (len_path + 2) * uses_per_path\n        if not should_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = 'p%d_%d' % (self._path_collection_id, i)\n            path_bytes = self._convert_path(path, transform, simplify=False)\n            self._pswriter.write(f\"\"\"\\\n/{name} {{\nnewpath\ntranslate\n{path_bytes}\n}} bind def\n\"\"\")\n            path_codes.append(name)\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            ps = \"%g %g %s\" % (xo, yo, path_id)\n            self._draw_ps(ps, gc0, rgbFace)\n\n        self._path_collection_id += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if not hasattr(self, \"psfrag\"):\n            self._logwarn_once(\n                \"The PS backend determines usetex status solely based on \"\n                \"rcParams['text.usetex'] and does not support having \"\n                \"usetex=True only for some elements; this element will thus \"\n                \"be rendered as if usetex=False.\")\n            self.draw_text(gc, x, y, s, prop, angle, False, mtext)\n            return\n\n        w, h, bl = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        fontsize = prop.get_size_in_points()\n        thetext = 'psmarker%d' % self.textcnt\n        color = '%1.3f,%1.3f,%1.3f' % gc.get_rgb()[:3]\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(\n                       mpl.rcParams['font.family'][0], r'{\\rmfamily %s}')\n        s = fontcmd % s\n        tex = r'\\color[rgb]{%s} %s' % (color, s)\n\n        # Stick to the bottom alignment.\n        pos = _nums_to_str(x, y-bl)\n        self.psfrag.append(\n            r'\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                thetext, angle, fontsize, fontsize*1.25, tex))\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{pos} moveto\n({thetext})\nshow\ngrestore\n\"\"\")\n        self.textcnt += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text",
      "decorators": [
        "_log_if_debug_on"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_log_if_debug_on\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if self._is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if ismath == 'TeX':\n            return self.draw_tex(gc, x, y, s, prop, angle)\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        if mpl.rcParams['ps.useafm']:\n            font = self._get_font_afm(prop)\n            scale = 0.001 * prop.get_size_in_points()\n            stream = []\n            thisx = 0\n            last_name = None  # kerns returns 0 for None.\n            xs_names = []\n            for c in s:\n                name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char('?')\n                kern = font.get_kern_dist_from_name(last_name, name)\n                last_name = name\n                thisx += kern * scale\n                xs_names.append((thisx, name))\n                thisx += width * scale\n            ps_name = (font.postscript_name\n                       .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n            stream.append((ps_name, xs_names))\n\n        else:\n            font = self._get_font_ttf(prop)\n            self._character_tracker.track(font, s)\n            stream = []\n            prev_font = curr_stream = None\n            for item in _text_helpers.layout(s, font):\n                ps_name = (item.ft_object.postscript_name\n                           .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n                if item.ft_object is not prev_font:\n                    if curr_stream:\n                        stream.append(curr_stream)\n                    prev_font = item.ft_object\n                    curr_stream = [ps_name, []]\n                curr_stream[1].append(\n                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                )\n            # append the last entry\n            stream.append(curr_stream)\n\n        self.set_color(*gc.get_rgb())\n\n        for ps_name, xs_names in stream:\n            self.set_font(ps_name, prop.get_size_in_points(), False)\n            thetext = \"\\n\".join(f\"{x:g} 0 m /{name:s} glyphshow\"\n                                for x, name in xs_names)\n            self._pswriter.write(f\"\"\"\\\ngsave\n{self._get_clip_cmd(gc)}\n{x:g} {y:g} translate\n{angle:g} rotate\n{thetext}\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/get_image_magnification",
      "name": "get_image_magnification",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.get_image_magnification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/get_image_magnification/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.get_image_magnification.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the factor by which to magnify images passed to draw_image.\nAllows a backend to have images at a different resolution to other\nartists.",
      "docstring": "Get the factor by which to magnify images passed to draw_image.\nAllows a backend to have images at a different resolution to other\nartists.",
      "code": "    def get_image_magnification(self):\n        \"\"\"\n        Get the factor by which to magnify images passed to draw_image.\n        Allows a backend to have images at a different resolution to other\n        artists.\n        \"\"\"\n        return self.image_magnification"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color",
      "name": "set_color",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/r",
          "name": "r",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.r",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/g",
          "name": "g",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.g",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/b",
          "name": "b",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_color(self, r, g, b, store=True):\n        if (r, g, b) != self.color:\n            self._pswriter.write(f\"{r:1.3f} setgray\\n\"\n                                 if r == g == b else\n                                 f\"{r:1.3f} {g:1.3f} {b:1.3f} setrgbcolor\\n\")\n            if store:\n                self.color = (r, g, b)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font",
      "name": "set_font",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/fontname",
          "name": "fontname",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.fontname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/fontsize",
          "name": "fontsize",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.fontsize",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_font(self, fontname, fontsize, store=True):\n        if (fontname, fontsize) != (self.fontname, self.fontsize):\n            self._pswriter.write(f\"/{fontname} {fontsize:1.3f} selectfont\\n\")\n            if store:\n                self.fontname = fontname\n                self.fontsize = fontsize"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap",
      "name": "set_linecap",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap/linecap",
          "name": "linecap",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap.linecap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linecap(self, linecap, store=True):\n        if linecap != self.linecap:\n            self._pswriter.write(self._linecap_cmd(linecap))\n            if store:\n                self.linecap = linecap"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash",
      "name": "set_linedash",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/offset",
          "name": "offset",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.offset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/seq",
          "name": "seq",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.seq",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linedash(self, offset, seq, store=True):\n        if self.linedash is not None:\n            oldo, oldseq = self.linedash\n            if np.array_equal(seq, oldseq) and oldo == offset:\n                return\n\n        self._pswriter.write(f\"[{_nums_to_str(*seq)}]\"\n                             f\" {_nums_to_str(offset)} setdash\\n\"\n                             if seq is not None and len(seq) else\n                             \"[] 0 setdash\\n\")\n        if store:\n            self.linedash = (offset, seq)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin",
      "name": "set_linejoin",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin/linejoin",
          "name": "linejoin",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin.linejoin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linejoin(self, linejoin, store=True):\n        if linejoin != self.linejoin:\n            self._pswriter.write(self._linejoin_cmd(linejoin))\n            if store:\n                self.linejoin = linejoin"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth",
      "name": "set_linewidth",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth/linewidth",
          "name": "linewidth",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth.linewidth",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linewidth(self, linewidth, store=True):\n        linewidth = float(linewidth)\n        if linewidth != self.linewidth:\n            self._pswriter.write(\"%1.3f setlinewidth\\n\" % linewidth)\n            if store:\n                self.linewidth = linewidth"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags",
      "name": "convert_psfrags",
      "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/psfrags",
          "name": "psfrags",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.psfrags",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/font_preamble",
          "name": "font_preamble",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.font_preamble",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/custom_preamble",
          "name": "custom_preamble",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.custom_preamble",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/paper_width",
          "name": "paper_width",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.paper_width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/paper_height",
          "name": "paper_height",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.paper_height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/orientation",
          "name": "orientation",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.orientation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef convert_psfrags(tmpfile, psfrags, font_preamble, custom_preamble,\n                    paper_width, paper_height, orientation):\n    return _convert_psfrags(\n        pathlib.Path(tmpfile), psfrags, paper_width, paper_height, orientation)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/get_bbox_header",
      "name": "get_bbox_header",
      "qname": "lib.matplotlib.backends.backend_ps.get_bbox_header",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/get_bbox_header/lbrt",
          "name": "lbrt",
          "qname": "lib.matplotlib.backends.backend_ps.get_bbox_header.lbrt",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/get_bbox_header/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.get_bbox_header.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a postscript header string for the given bbox lbrt=(l, b, r, t).\nOptionally, return rotate command.",
      "docstring": "Return a postscript header string for the given bbox lbrt=(l, b, r, t).\nOptionally, return rotate command.",
      "code": "def get_bbox_header(lbrt, rotated=False):\n    \"\"\"\n    Return a postscript header string for the given bbox lbrt=(l, b, r, t).\n    Optionally, return rotate command.\n    \"\"\"\n\n    l, b, r, t = lbrt\n    if rotated:\n        rotate = \"%.2f %.2f translate\\n90 rotate\" % (l+r, 0)\n    else:\n        rotate = \"\"\n    bbox_info = '%%%%BoundingBox: %d %d %d %d' % (l, b, np.ceil(r), np.ceil(t))\n    hires_bbox_info = '%%%%HiResBoundingBox: %.6f %.6f %.6f %.6f' % (\n        l, b, r, t)\n\n    return '\\n'.join([bbox_info, hires_bbox_info]), rotate"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill",
      "name": "gs_distill",
      "qname": "lib.matplotlib.backends.backend_ps.gs_distill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/eps",
          "name": "eps",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.eps",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/ptype",
          "name": "ptype",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.ptype",
          "default_value": "'letter'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use ghostscript's pswrite or epswrite device to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. The output is low-level, converting text to outlines.",
      "docstring": "Use ghostscript's pswrite or epswrite device to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. The output is low-level, converting text to outlines.",
      "code": "def gs_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's pswrite or epswrite device to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. The output is low-level, converting text to outlines.\n    \"\"\"\n\n    if eps:\n        paper_option = \"-dEPSCrop\"\n    else:\n        paper_option = \"-sPAPERSIZE=%s\" % ptype\n\n    psfile = tmpfile + '.ps'\n    dpi = mpl.rcParams['ps.distiller.res']\n\n    cbook._check_and_log_subprocess(\n        [mpl._get_executable_info(\"gs\").executable,\n         \"-dBATCH\", \"-dNOPAUSE\", \"-r%d\" % dpi, \"-sDEVICE=ps2write\",\n         paper_option, \"-sOutputFile=%s\" % psfile, tmpfile],\n        _log)\n\n    os.remove(tmpfile)\n    shutil.move(psfile, tmpfile)\n\n    # While it is best if above steps preserve the original bounding\n    # box, there seem to be cases when it is not. For those cases,\n    # the original bbox can be restored during the pstoeps step.\n\n    if eps:\n        # For some versions of gs, above steps result in an ps file where the\n        # original bbox is no more correct. Do not adjust bbox for now.\n        pstoeps(tmpfile, bbox, rotated=rotated)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps",
      "name": "pstoeps",
      "qname": "lib.matplotlib.backends.backend_ps.pstoeps",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.pstoeps.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_ps.pstoeps.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.pstoeps.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert the postscript to encapsulated postscript.  The bbox of\nthe eps file will be replaced with the given *bbox* argument. If\nNone, original bbox will be used.",
      "docstring": "Convert the postscript to encapsulated postscript.  The bbox of\nthe eps file will be replaced with the given *bbox* argument. If\nNone, original bbox will be used.",
      "code": "def pstoeps(tmpfile, bbox=None, rotated=False):\n    \"\"\"\n    Convert the postscript to encapsulated postscript.  The bbox of\n    the eps file will be replaced with the given *bbox* argument. If\n    None, original bbox will be used.\n    \"\"\"\n\n    # if rotated==True, the output eps file need to be rotated\n    if bbox:\n        bbox_info, rotate = get_bbox_header(bbox, rotated=rotated)\n    else:\n        bbox_info, rotate = None, None\n\n    epsfile = tmpfile + '.eps'\n    with open(epsfile, 'wb') as epsh, open(tmpfile, 'rb') as tmph:\n        write = epsh.write\n        # Modify the header:\n        for line in tmph:\n            if line.startswith(b'%!PS'):\n                write(b\"%!PS-Adobe-3.0 EPSF-3.0\\n\")\n                if bbox:\n                    write(bbox_info.encode('ascii') + b'\\n')\n            elif line.startswith(b'%%EndComments'):\n                write(line)\n                write(b'%%BeginProlog\\n'\n                      b'save\\n'\n                      b'countdictstack\\n'\n                      b'mark\\n'\n                      b'newpath\\n'\n                      b'/showpage {} def\\n'\n                      b'/setpagedevice {pop} def\\n'\n                      b'%%EndProlog\\n'\n                      b'%%Page 1 1\\n')\n                if rotate:\n                    write(rotate.encode('ascii') + b'\\n')\n                break\n            elif bbox and line.startswith((b'%%Bound', b'%%HiResBound',\n                                           b'%%DocumentMedia', b'%%Pages')):\n                pass\n            else:\n                write(line)\n        # Now rewrite the rest of the file, and modify the trailer.\n        # This is done in a second loop such that the header of the embedded\n        # eps file is not modified.\n        for line in tmph:\n            if line.startswith(b'%%EOF'):\n                write(b'cleartomark\\n'\n                      b'countdictstack\\n'\n                      b'exch sub { end } repeat\\n'\n                      b'restore\\n'\n                      b'showpage\\n'\n                      b'%%EOF\\n')\n            elif line.startswith(b'%%PageBoundingBox'):\n                pass\n            else:\n                write(line)\n\n    os.remove(tmpfile)\n    shutil.move(epsfile, tmpfile)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/quote_ps_string",
      "name": "quote_ps_string",
      "qname": "lib.matplotlib.backends.backend_ps.quote_ps_string",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of this function')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/quote_ps_string/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.quote_ps_string.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Quote dangerous characters of S for use in a PostScript string constant.",
      "docstring": "Quote dangerous characters of S for use in a PostScript string constant.",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of this function\")\ndef quote_ps_string(s):\n    \"\"\"\n    Quote dangerous characters of S for use in a PostScript string constant.\n    \"\"\"\n    s = s.replace(b\"\\\\\", b\"\\\\\\\\\")\n    s = s.replace(b\"(\", b\"\\\\(\")\n    s = s.replace(b\")\", b\"\\\\)\")\n    s = s.replace(b\"'\", b\"\\\\251\")\n    s = s.replace(b\"`\", b\"\\\\301\")\n    s = re.sub(br\"[^ -~\\n]\", lambda x: br\"\\%03o\" % ord(x.group()), s)\n    return s.decode('ascii')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill",
      "name": "xpdf_distill",
      "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/eps",
          "name": "eps",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.eps",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/ptype",
          "name": "ptype",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.ptype",
          "default_value": "'letter'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. This distiller is preferred, generating high-level postscript\noutput that treats text as text.",
      "docstring": "Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. This distiller is preferred, generating high-level postscript\noutput that treats text as text.",
      "code": "def xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. This distiller is preferred, generating high-level postscript\n    output that treats text as text.\n    \"\"\"\n    mpl._get_executable_info(\"gs\")  # Effectively checks for ps2pdf.\n    mpl._get_executable_info(\"pdftops\")\n\n    with TemporaryDirectory() as tmpdir:\n        tmppdf = pathlib.Path(tmpdir, \"tmp.pdf\")\n        tmpps = pathlib.Path(tmpdir, \"tmp.ps\")\n        # Pass options as `-foo#bar` instead of `-foo=bar` to keep Windows\n        # happy (https://ghostscript.com/doc/9.56.1/Use.htm#MS_Windows).\n        cbook._check_and_log_subprocess(\n            [\"ps2pdf\",\n             \"-dAutoFilterColorImages#false\",\n             \"-dAutoFilterGrayImages#false\",\n             \"-sAutoRotatePages#None\",\n             \"-sGrayImageFilter#FlateEncode\",\n             \"-sColorImageFilter#FlateEncode\",\n             \"-dEPSCrop\" if eps else \"-sPAPERSIZE#%s\" % ptype,\n             tmpfile, tmppdf], _log)\n        cbook._check_and_log_subprocess(\n            [\"pdftops\", \"-paper\", \"match\", \"-level2\", tmppdf, tmpps], _log)\n        shutil.move(tmpps, tmpfile)\n    if eps:\n        pstoeps(tmpfile)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._subplot_dialog = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ConfigureSubplotsQt/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.ConfigureSubplotsQt.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2QT.configure_subplots(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.__init__.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure=None):\n        _create_qApp()\n        super().__init__(figure=figure)\n\n        self._draw_pending = False\n        self._is_drawing = False\n        self._draw_rect_callback = lambda painter: None\n        self._in_resize_event = False\n\n        self.setAttribute(\n            _enum(\"QtCore.Qt.WidgetAttribute\").WA_OpaquePaintEvent)\n        self.setMouseTracking(True)\n        self.resize(*self.get_width_height())\n\n        palette = QtGui.QPalette(QtGui.QColor(\"white\"))\n        self.setPalette(palette)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # docstring inherited\n        if bbox is None and self.figure:\n            bbox = self.figure.bbox  # Blit the entire canvas if bbox is None.\n        # repaint uses logical pixels, not physical pixels like the renderer.\n        l, b, w, h = [int(pt / self.device_pixel_ratio) for pt in bbox.bounds]\n        t = b + h\n        self.repaint(l, self.rect().height() - t, w, h)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure, and queue a request for a Qt draw.",
      "docstring": "Render the figure, and queue a request for a Qt draw.",
      "code": "    def draw(self):\n        \"\"\"Render the figure, and queue a request for a Qt draw.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/drawRectangle",
      "name": "drawRectangle",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.drawRectangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/drawRectangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.drawRectangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/drawRectangle/rect",
          "name": "rect",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.drawRectangle.rect",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def drawRectangle(self, rect):\n        # Draw the zoom rectangle to the QPainter.  _draw_rect_callback needs\n        # to be called at the end of paintEvent.\n        if rect is not None:\n            x0, y0, w, h = [int(pt / self.device_pixel_ratio) for pt in rect]\n            x1 = x0 + w\n            y1 = y0 + h\n            def _draw_rect_callback(painter):\n                pen = QtGui.QPen(\n                    QtGui.QColor(\"black\"),\n                    1 / self.device_pixel_ratio\n                )\n\n                pen.setDashPattern([3, 3])\n                for color, offset in [\n                        (QtGui.QColor(\"black\"), 0),\n                        (QtGui.QColor(\"white\"), 3),\n                ]:\n                    pen.setDashOffset(offset)\n                    pen.setColor(color)\n                    painter.setPen(pen)\n                    # Draw the lines from x0, y0 towards x1, y1 so that the\n                    # dashes don't \"jump\" when moving the zoom box.\n                    painter.drawLine(x0, y0, x0, y1)\n                    painter.drawLine(x0, y0, x1, y0)\n                    painter.drawLine(x0, y1, x1, y1)\n                    painter.drawLine(x1, y0, x1, y1)\n        else:\n            def _draw_rect_callback(painter):\n                return\n        self._draw_rect_callback = _draw_rect_callback\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Queue redraw of the Agg buffer and request Qt paintEvent.",
      "docstring": "Queue redraw of the Agg buffer and request Qt paintEvent.",
      "code": "    def draw_idle(self):\n        \"\"\"Queue redraw of the Agg buffer and request Qt paintEvent.\"\"\"\n        # The Agg draw needs to be handled by the same thread Matplotlib\n        # modifies the scene graph from. Post Agg draw request to the\n        # current event loop in order to ensure thread affinity and to\n        # accumulate multiple draw requests from event handling.\n        # TODO: queued signal connection might be safer than singleShot\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            QtCore.QTimer.singleShot(0, self._draw_idle)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/enterEvent",
      "name": "enterEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.enterEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/enterEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.enterEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/enterEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.enterEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enterEvent(self, event):\n        LocationEvent(\"figure_enter_event\", self,\n                      *self.mouseEventCoords(event),\n                      guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/flush_events",
      "name": "flush_events",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.flush_events",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/flush_events/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.flush_events.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flush_events(self):\n        # docstring inherited\n        QtWidgets.QApplication.instance().processEvents()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyPressEvent",
      "name": "keyPressEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyPressEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyPressEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyPressEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyPressEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyPressEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def keyPressEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            KeyEvent(\"key_press_event\", self,\n                     key, *self.mouseEventCoords(),\n                     guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyReleaseEvent",
      "name": "keyReleaseEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyReleaseEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyReleaseEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyReleaseEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/keyReleaseEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.keyReleaseEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def keyReleaseEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            KeyEvent(\"key_release_event\", self,\n                     key, *self.mouseEventCoords(),\n                     guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/leaveEvent",
      "name": "leaveEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.leaveEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/leaveEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.leaveEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/leaveEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.leaveEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        LocationEvent(\"figure_leave_event\", self,\n                      *self.mouseEventCoords(),\n                      guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/minumumSizeHint",
      "name": "minumumSizeHint",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.minumumSizeHint",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/minumumSizeHint/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.minumumSizeHint.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def minumumSizeHint(self):\n        return QtCore.QSize(10, 10)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseDoubleClickEvent",
      "name": "mouseDoubleClickEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseDoubleClickEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseDoubleClickEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseDoubleClickEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseDoubleClickEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseDoubleClickEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mouseDoubleClickEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button, dblclick=True,\n                       guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseEventCoords",
      "name": "mouseEventCoords",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseEventCoords",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseEventCoords/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseEventCoords.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseEventCoords/pos",
          "name": "pos",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseEventCoords.pos",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Calculate mouse coordinates in physical pixels.\n\nQt uses logical pixels, but the figure is scaled to physical\npixels for rendering.  Transform to physical pixels so that\nall of the down-stream transforms work as expected.\n\nAlso, the origin is different and needs to be corrected.",
      "docstring": "Calculate mouse coordinates in physical pixels.\n\nQt uses logical pixels, but the figure is scaled to physical\npixels for rendering.  Transform to physical pixels so that\nall of the down-stream transforms work as expected.\n\nAlso, the origin is different and needs to be corrected.",
      "code": "    def mouseEventCoords(self, pos=None):\n        \"\"\"\n        Calculate mouse coordinates in physical pixels.\n\n        Qt uses logical pixels, but the figure is scaled to physical\n        pixels for rendering.  Transform to physical pixels so that\n        all of the down-stream transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        if pos is None:\n            pos = self.mapFromGlobal(QtGui.QCursor.pos())\n        elif hasattr(pos, \"position\"):  # qt6 QtGui.QEvent\n            pos = pos.position()\n        elif hasattr(pos, \"pos\"):  # qt5 QtCore.QEvent\n            pos = pos.pos()\n        # (otherwise, it's already a QPoint)\n        x = pos.x()\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height / self.device_pixel_ratio - pos.y()\n        return x * self.device_pixel_ratio, y * self.device_pixel_ratio"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseMoveEvent",
      "name": "mouseMoveEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseMoveEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseMoveEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseMoveEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseMoveEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseMoveEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mouseMoveEvent(self, event):\n        MouseEvent(\"motion_notify_event\", self,\n                   *self.mouseEventCoords(event),\n                   guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mousePressEvent",
      "name": "mousePressEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mousePressEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mousePressEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mousePressEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mousePressEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mousePressEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mousePressEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_press_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseReleaseEvent",
      "name": "mouseReleaseEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseReleaseEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseReleaseEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseReleaseEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/mouseReleaseEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.mouseReleaseEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mouseReleaseEvent(self, event):\n        button = self.buttond.get(event.button())\n        if button is not None:\n            MouseEvent(\"button_release_event\", self,\n                       *self.mouseEventCoords(event), button,\n                       guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/resizeEvent",
      "name": "resizeEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.resizeEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/resizeEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.resizeEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/resizeEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.resizeEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resizeEvent(self, event):\n        if self._in_resize_event:  # Prevent PyQt6 recursion\n            return\n        self._in_resize_event = True\n        try:\n            w = event.size().width() * self.device_pixel_ratio\n            h = event.size().height() * self.device_pixel_ratio\n            dpival = self.figure.dpi\n            winch = w / dpival\n            hinch = h / dpival\n            self.figure.set_size_inches(winch, hinch, forward=False)\n            # pass back into Qt to let it finish\n            QtWidgets.QWidget.resizeEvent(self, event)\n            # emit our resize events\n            ResizeEvent(\"resize_event\", self)._process()\n            self.draw_idle()\n        finally:\n            self._in_resize_event = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        # docstring inherited\n        self.setCursor(_api.check_getitem(cursord, cursor=cursor))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/showEvent",
      "name": "showEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.showEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/showEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.showEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/showEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.showEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def showEvent(self, event):\n        # Set up correct pixel ratio, and connect to any signal changes for it,\n        # once the window is shown (and thus has these attributes).\n        window = self.window().windowHandle()\n        window.screenChanged.connect(self._update_screen)\n        self._update_screen(window.screen())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/sizeHint",
      "name": "sizeHint",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.sizeHint",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/sizeHint/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.sizeHint.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def sizeHint(self):\n        w, h = self.get_width_height()\n        return QtCore.QSize(w, h)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/start_event_loop",
      "name": "start_event_loop",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.start_event_loop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/start_event_loop/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.start_event_loop.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/start_event_loop/timeout",
          "name": "timeout",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.start_event_loop.timeout",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def start_event_loop(self, timeout=0):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\") and self._event_loop.isRunning():\n            raise RuntimeError(\"Event loop already running\")\n        self._event_loop = event_loop = QtCore.QEventLoop()\n        if timeout > 0:\n            _ = QtCore.QTimer.singleShot(int(timeout * 1000), event_loop.quit)\n\n        with _maybe_allow_interrupt(event_loop):\n            qt_compat._exec(event_loop)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/stop_event_loop",
      "name": "stop_event_loop",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.stop_event_loop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/stop_event_loop/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.stop_event_loop.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/stop_event_loop/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.stop_event_loop.event",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def stop_event_loop(self, event=None):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\"):\n            self._event_loop.quit()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/wheelEvent",
      "name": "wheelEvent",
      "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.wheelEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/wheelEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.wheelEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureCanvasQT/wheelEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.FigureCanvasQT.wheelEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def wheelEvent(self, event):\n        # from QWheelEvent::pixelDelta doc: pixelDelta is sometimes not\n        # provided (`isNull()`) and is unreliable on X11 (\"xcb\").\n        if (event.pixelDelta().isNull()\n                or QtWidgets.QApplication.instance().platformName() == \"xcb\"):\n            steps = event.angleDelta().y() / 120\n        else:\n            steps = event.pixelDelta().y()\n        if steps:\n            MouseEvent(\"scroll_event\", self,\n                       *self.mouseEventCoords(event), step=steps,\n                       guiEvent=event)._process()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        self.window = MainWindow()\n        super().__init__(canvas, num)\n        self.window.closing.connect(\n            # The lambda prevents the event from being immediately gc'd.\n            lambda: CloseEvent(\"close_event\", self.canvas)._process())\n        self.window.closing.connect(self._widgetclosed)\n\n        if sys.platform != \"darwin\":\n            image = str(cbook._get_data_path('images/matplotlib.svg'))\n            icon = QtGui.QIcon(image)\n            self.window.setWindowIcon(icon)\n\n        self.window._destroying = False\n\n        if self.toolbar:\n            self.window.addToolBar(self.toolbar)\n            tbs_height = self.toolbar.sizeHint().height()\n        else:\n            tbs_height = 0\n\n        # resize the main window so it will display the canvas with the\n        # requested size:\n        cs = canvas.sizeHint()\n        cs_height = cs.height()\n        height = cs_height + tbs_height\n        self.window.resize(cs.width(), height)\n\n        self.window.setCentralWidget(self.canvas)\n\n        if mpl.is_interactive():\n            self.window.show()\n            self.canvas.draw_idle()\n\n        # Give the keyboard focus to the figure instead of the manager:\n        # StrongFocus accepts both tab and click to focus and will enable the\n        # canvas to process event without clicking.\n        # https://doc.qt.io/qt-5/qt.html#FocusPolicy-enum\n        self.canvas.setFocusPolicy(_enum(\"QtCore.Qt.FocusPolicy\").StrongFocus)\n        self.canvas.setFocus()\n\n        self.window.raise_()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/destroy/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.destroy.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self, *args):\n        # check for qApp first, as PySide deletes it in its atexit handler\n        if QtWidgets.QApplication.instance() is None:\n            return\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        if self.toolbar:\n            self.toolbar.destroy()\n        self.window.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/full_screen_toggle",
      "name": "full_screen_toggle",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.full_screen_toggle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/full_screen_toggle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.full_screen_toggle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def full_screen_toggle(self):\n        if self.window.isFullScreen():\n            self.window.showNormal()\n        else:\n            self.window.showFullScreen()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/get_window_title",
      "name": "get_window_title",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.get_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/get_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.get_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_window_title(self):\n        return self.window.windowTitle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, width, height):\n        # The Qt methods return sizes in 'virtual' pixels so we do need to\n        # rescale from physical to logical pixels.\n        width = int(width / self.canvas.device_pixel_ratio)\n        height = int(height / self.canvas.device_pixel_ratio)\n        extra_width = self.window.width() - self.canvas.width()\n        extra_height = self.window.height() - self.canvas.height()\n        self.canvas.resize(width, height)\n        self.window.resize(width + extra_width, height + extra_height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        self.window.setWindowTitle(title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/FigureManagerQT/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.FigureManagerQT.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        self.window.show()\n        if mpl.rcParams['figure.raise_window']:\n            self.window.activateWindow()\n            self.window.raise_()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt.HelpQt.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.HelpQt.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/HelpQt/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.HelpQt.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        QtWidgets.QMessageBox.information(None, \"Help\", self._get_help_html())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow/closeEvent",
      "name": "closeEvent",
      "qname": "lib.matplotlib.backends.backend_qt.MainWindow.closeEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow/closeEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.MainWindow.closeEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/MainWindow/closeEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.MainWindow.closeEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def closeEvent(self, event):\n        self.closing.emit()\n        super().closeEvent(event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/__init__/coordinates",
          "name": "coordinates",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.__init__.coordinates",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "coordinates: should we show the coordinates on the right?",
      "code": "    def __init__(self, canvas, parent=None, coordinates=True):\n        \"\"\"coordinates: should we show the coordinates on the right?\"\"\"\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(QtCore.Qt.ToolBarArea(\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").TopToolBarArea) |\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").BottomToolBarArea)))\n\n        self.coordinates = coordinates\n        self._actions = {}  # mapping of toolitem method names to QActions.\n        self._subplot_dialog = None\n\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.addSeparator()\n            else:\n                a = self.addAction(self._icon(image_file + '.png'),\n                                   text, getattr(self, callback))\n                self._actions[callback] = a\n                if callback in ['zoom', 'pan']:\n                    a.setCheckable(True)\n                if tooltip_text is not None:\n                    a.setToolTip(tooltip_text)\n\n        # Add the (x, y) location widget at the right side of the toolbar\n        # The stretch factor is 1 which means any resizing of the toolbar\n        # will resize this label instead of the buttons.\n        if self.coordinates:\n            self.locLabel = QtWidgets.QLabel(\"\", self)\n            self.locLabel.setAlignment(QtCore.Qt.AlignmentFlag(\n                _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignRight) |\n                _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignVCenter)))\n            self.locLabel.setSizePolicy(QtWidgets.QSizePolicy(\n                _enum(\"QtWidgets.QSizePolicy.Policy\").Expanding,\n                _enum(\"QtWidgets.QSizePolicy.Policy\").Ignored,\n            ))\n            labelAction = self.addWidget(self.locLabel)\n            labelAction.setVisible(True)\n\n        NavigationToolbar2.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/configure_subplots",
      "name": "configure_subplots",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.configure_subplots",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/configure_subplots/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.configure_subplots.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def configure_subplots(self):\n        if self._subplot_dialog is None:\n            self._subplot_dialog = SubplotToolQt(\n                self.canvas.figure, self.canvas.parent())\n            self.canvas.mpl_connect(\n                \"close_event\", lambda e: self._subplot_dialog.reject())\n        self._subplot_dialog.update_from_current_subplotpars()\n        self._subplot_dialog.show()\n        return self._subplot_dialog"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas.drawRectangle(rect)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/edit_parameters",
      "name": "edit_parameters",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.edit_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/edit_parameters/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.edit_parameters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def edit_parameters(self):\n        axes = self.canvas.figure.get_axes()\n        if not axes:\n            QtWidgets.QMessageBox.warning(\n                self.canvas.parent(), \"Error\", \"There are no axes to edit.\")\n            return\n        elif len(axes) == 1:\n            ax, = axes\n        else:\n            titles = [\n                ax.get_label() or\n                ax.get_title() or\n                ax.get_title(\"left\") or\n                ax.get_title(\"right\") or\n                \" - \".join(filter(None, [ax.get_xlabel(), ax.get_ylabel()])) or\n                f\"<anonymous {type(ax).__name__}>\"\n                for ax in axes]\n            duplicate_titles = [\n                title for title in titles if titles.count(title) > 1]\n            for i, ax in enumerate(axes):\n                if titles[i] in duplicate_titles:\n                    titles[i] += f\" (id: {id(ax):#x})\"  # Deduplicate titles.\n            item, ok = QtWidgets.QInputDialog.getItem(\n                self.canvas.parent(),\n                'Customize', 'Select axes:', titles, 0, False)\n            if not ok:\n                return\n            ax = axes[titles.index(item)]\n        figureoptions.figure_edit(ax, self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/pan/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.pan.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas.drawRectangle(None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        filetypes = self.canvas.get_supported_filetypes_grouped()\n        sorted_filetypes = sorted(filetypes.items())\n        default_filetype = self.canvas.get_default_filetype()\n\n        startpath = os.path.expanduser(mpl.rcParams['savefig.directory'])\n        start = os.path.join(startpath, self.canvas.get_default_filename())\n        filters = []\n        selectedFilter = None\n        for name, exts in sorted_filetypes:\n            exts_list = \" \".join(['*.%s' % ext for ext in exts])\n            filter = '%s (%s)' % (name, exts_list)\n            if default_filetype in exts:\n                selectedFilter = filter\n            filters.append(filter)\n        filters = ';;'.join(filters)\n\n        fname, filter = qt_compat._getSaveFileName(\n            self.canvas.parent(), \"Choose a filename to save to\", start,\n            filters, selectedFilter)\n        if fname:\n            # Save dir for next time, unless empty str (i.e., use cwd).\n            if startpath != \"\":\n                mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n            try:\n                self.canvas.figure.savefig(fname)\n            except Exception as e:\n                QtWidgets.QMessageBox.critical(\n                    self, \"Error saving file\", str(e),\n                    _enum(\"QtWidgets.QMessageBox.StandardButton\").Ok,\n                    _enum(\"QtWidgets.QMessageBox.StandardButton\").NoButton)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'back' in self._actions:\n            self._actions['back'].setEnabled(can_backward)\n        if 'forward' in self._actions:\n            self._actions['forward'].setEnabled(can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self.message.emit(s)\n        if self.coordinates:\n            self.locLabel.setText(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/NavigationToolbar2QT/zoom/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.NavigationToolbar2QT.zoom.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2QT.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/RubberbandQt/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.RubberbandQt.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        NavigationToolbar2QT.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt.SaveFigureQt.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.SaveFigureQt.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SaveFigureQt/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.SaveFigureQt.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2QT.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_qt.SetCursorQt.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.SetCursorQt.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SetCursorQt/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_qt.SetCursorQt.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        NavigationToolbar2QT.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__/targetfig",
          "name": "targetfig",
          "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.__init__.targetfig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.__init__.parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, targetfig, parent):\n        super().__init__()\n        self.setWindowIcon(QtGui.QIcon(\n            str(cbook._get_data_path(\"images/matplotlib.png\"))))\n        self.setObjectName(\"SubplotTool\")\n        self._spinboxes = {}\n        main_layout = QtWidgets.QHBoxLayout()\n        self.setLayout(main_layout)\n        for group, spinboxes, buttons in [\n                (\"Borders\",\n                 [\"top\", \"bottom\", \"left\", \"right\"],\n                 [(\"Export values\", self._export_values)]),\n                (\"Spacings\",\n                 [\"hspace\", \"wspace\"],\n                 [(\"Tight layout\", self._tight_layout),\n                  (\"Reset\", self._reset),\n                  (\"Close\", self.close)])]:\n            layout = QtWidgets.QVBoxLayout()\n            main_layout.addLayout(layout)\n            box = QtWidgets.QGroupBox(group)\n            layout.addWidget(box)\n            inner = QtWidgets.QFormLayout(box)\n            for name in spinboxes:\n                self._spinboxes[name] = spinbox = QtWidgets.QDoubleSpinBox()\n                spinbox.setRange(0, 1)\n                spinbox.setDecimals(3)\n                spinbox.setSingleStep(0.005)\n                spinbox.setKeyboardTracking(False)\n                spinbox.valueChanged.connect(self._on_value_changed)\n                inner.addRow(name, spinbox)\n            layout.addStretch(1)\n            for name, method in buttons:\n                button = QtWidgets.QPushButton(name)\n                # Don't trigger on <enter>, which is used to input values.\n                button.setAutoDefault(False)\n                button.clicked.connect(method)\n                layout.addWidget(button)\n                if name == \"Close\":\n                    button.setFocus()\n        self._figure = targetfig\n        self._defaults = {}\n        self._export_values_dialog = None\n        self.update_from_current_subplotpars()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/update_from_current_subplotpars",
      "name": "update_from_current_subplotpars",
      "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.update_from_current_subplotpars",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/SubplotToolQt/update_from_current_subplotpars/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.SubplotToolQt.update_from_current_subplotpars.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def update_from_current_subplotpars(self):\n        self._defaults = {spinbox: getattr(self._figure.subplotpars, name)\n                          for name, spinbox in self._spinboxes.items()}\n        self._reset()  # Set spinbox current values without triggering signals."
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__del__",
      "name": "__del__",
      "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__del__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__del__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__del__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __del__(self):\n        # The check for deletedness is needed to avoid an error at animation\n        # shutdown with PySide2.\n        if not _isdeleted(self._timer):\n            self._timer_stop()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/TimerQT/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt.TimerQT.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using QTimer events.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        # Create a new timer and connect the timeout() signal to the\n        # _on_timer method.\n        self._timer = QtCore.QTimer()\n        self._timer.timeout.connect(self._on_timer)\n        super().__init__(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolCopyToClipboardQT/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt.ToolCopyToClipboardQT.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        pixmap = self.canvas.grab()\n        QtWidgets.QApplication.instance().clipboard().setPixmap(pixmap)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.__init__.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager, parent=None):\n        ToolContainerBase.__init__(self, toolmanager)\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(QtCore.Qt.ToolBarArea(\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").TopToolBarArea) |\n            _to_int(_enum(\"QtCore.Qt.ToolBarArea\").BottomToolBarArea)))\n        message_label = QtWidgets.QLabel(\"\")\n        message_label.setAlignment(QtCore.Qt.AlignmentFlag(\n            _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignRight) |\n            _to_int(_enum(\"QtCore.Qt.AlignmentFlag\").AlignVCenter)))\n        message_label.setSizePolicy(QtWidgets.QSizePolicy(\n            _enum(\"QtWidgets.QSizePolicy.Policy\").Expanding,\n            _enum(\"QtWidgets.QSizePolicy.Policy\").Ignored,\n        ))\n        self._message_action = self.addWidget(message_label)\n        self._toolitems = {}\n        self._groups = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(\n            self, name, group, position, image_file, description, toggle):\n\n        button = QtWidgets.QToolButton(self)\n        if image_file:\n            button.setIcon(NavigationToolbar2QT._icon(self, image_file))\n        button.setText(name)\n        if description:\n            button.setToolTip(description)\n\n        def handler():\n            self.trigger_tool(name)\n        if toggle:\n            button.setCheckable(True)\n            button.toggled.connect(handler)\n        else:\n            button.clicked.connect(handler)\n\n        self._toolitems.setdefault(name, [])\n        self._add_to_group(group, name, button, position)\n        self._toolitems[name].append((button, handler))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        for button, handler in self._toolitems[name]:\n            button.setParent(None)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self.widgetForAction(self._message_action).setText(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt/ToolbarQt/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_qt.ToolbarQt.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for button, handler in self._toolitems[name]:\n            button.toggled.disconnect(handler)\n            button.setChecked(toggled)\n            button.toggled.connect(handler)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_qt5.__getattr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/__getattr__/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt5.__getattr__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def __getattr__(name):\n    if name == 'qApp':\n        return _backend_qt.qApp\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/paintEvent",
      "name": "paintEvent",
      "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.paintEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/paintEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.paintEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/paintEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.paintEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy the image from the Agg canvas to the qt.drawable.\n\nIn Qt, all drawing should be done inside of here when a widget is\nshown onscreen.",
      "docstring": "Copy the image from the Agg canvas to the qt.drawable.\n\nIn Qt, all drawing should be done inside of here when a widget is\nshown onscreen.",
      "code": "    def paintEvent(self, event):\n        \"\"\"\n        Copy the image from the Agg canvas to the qt.drawable.\n\n        In Qt, all drawing should be done inside of here when a widget is\n        shown onscreen.\n        \"\"\"\n        self._draw_idle()  # Only does something if a draw is pending.\n\n        # If the canvas does not have a renderer, then give up and wait for\n        # FigureCanvasAgg.draw(self) to be called.\n        if not hasattr(self, 'renderer'):\n            return\n\n        painter = QtGui.QPainter(self)\n        try:\n            # See documentation of QRect: bottom() and right() are off\n            # by 1, so use left() + width() and top() + height().\n            rect = event.rect()\n            # scale rect dimensions using the screen dpi ratio to get\n            # correct values for the Figure coordinates (rather than\n            # QT5's coords)\n            width = rect.width() * self.device_pixel_ratio\n            height = rect.height() * self.device_pixel_ratio\n            left, top = self.mouseEventCoords(rect.topLeft())\n            # shift the \"top\" by the height of the image to get the\n            # correct corner for our coordinate system\n            bottom = top - height\n            # same with the right side of the image\n            right = left + width\n            # create a buffer using the image bounding box\n            bbox = Bbox([[left, bottom], [right, top]])\n            reg = self.copy_from_bbox(bbox)\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                memoryview(reg))\n\n            # clear the widget canvas\n            painter.eraseRect(rect)\n\n            if QT_API == \"PyQt6\":\n                from PyQt6 import sip\n                ptr = int(sip.voidptr(buf))\n            else:\n                ptr = buf\n            qimage = QtGui.QImage(\n                ptr, buf.shape[1], buf.shape[0],\n                _enum(\"QtGui.QImage.Format\").Format_ARGB32_Premultiplied)\n            _setDevicePixelRatio(qimage, self.device_pixel_ratio)\n            # set origin using original QT coordinates\n            origin = QtCore.QPoint(rect.left(), rect.top())\n            painter.drawImage(origin, qimage)\n            # Adjust the buf reference count to work around a memory\n            # leak bug in QImage under PySide.\n            if QT_API in ('PySide', 'PySide2'):\n                if QtCore.__version_info__ < (5, 12):\n                    ctypes.c_long.from_address(id(buf)).value = 1\n\n            self._draw_rect_callback(painter)\n        finally:\n            painter.end()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure",
      "name": "print_figure",
      "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.print_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.print_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.print_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtagg/FigureCanvasQTAgg/print_figure/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qtagg.FigureCanvasQTAgg.print_figure.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_figure(self, *args, **kwargs):\n        super().print_figure(*args, **kwargs)\n        self.draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        if hasattr(self._renderer.gc, \"ctx\"):\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/paintEvent",
      "name": "paintEvent",
      "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.paintEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/paintEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.paintEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qtcairo/FigureCanvasQTCairo/paintEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qtcairo.FigureCanvasQTCairo.paintEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def paintEvent(self, event):\n        width = int(self.device_pixel_ratio * self.width())\n        height = int(self.device_pixel_ratio * self.height())\n        if (width, height) != self._renderer.get_canvas_width_height():\n            surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n            self._renderer.set_context(cairo.Context(surface))\n            self._renderer.dpi = self.figure.dpi\n            self.figure.draw(self._renderer)\n        buf = self._renderer.gc.ctx.get_target().get_data()\n        if QT_API == \"PyQt6\":\n            from PyQt6 import sip\n            ptr = int(sip.voidptr(buf))\n        else:\n            ptr = buf\n        qimage = QtGui.QImage(\n            ptr, width, height,\n            _enum(\"QtGui.QImage.Format\").Format_ARGB32_Premultiplied)\n        # Adjust the buf reference count to work around a memory leak bug in\n        # QImage under PySide.\n        if QT_API in ('PySide', 'PySide2'):\n            if QtCore.__version_info__ < (5, 12):\n                ctypes.c_long.from_address(id(buf)).value = 1\n        _setDevicePixelRatio(qimage, self.device_pixel_ratio)\n        painter = QtGui.QPainter(self)\n        painter.eraseRect(event.rect())\n        painter.drawImage(0, 0, qimage)\n        self._draw_rect_callback(painter)\n        painter.end()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self.figure.draw_without_rendering()\n        return super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'svg'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg",
      "name": "print_svg",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "Output target; if a string, a file will be opened for writing."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/bbox_inches_restore",
          "name": "bbox_inches_restore",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.bbox_inches_restore",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "dict[str, Any]",
            "default_value": "",
            "description": "Metadata in the SVG file defined as key-value pairs of strings,\ndatetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\nThe standard keys and their value types are:\n\n* *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n  ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n  ``'Title'``, and ``'Type'``.\n* *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n  ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n* *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n  non-*str*, then it will be formatted as ISO 8601.\n\nValues have been predefined for ``'Creator'``, ``'Date'``,\n``'Format'``, and ``'Type'``. They can be removed by setting them\nto `None`.\n\nInformation is encoded as `Dublin Core Metadata`__.\n\n.. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n__ DC_"
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "Any]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Parameters\n----------\nfilename : str or path-like or file-like\n    Output target; if a string, a file will be opened for writing.\n\nmetadata : dict[str, Any], optional\n    Metadata in the SVG file defined as key-value pairs of strings,\n    datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n    'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n    The standard keys and their value types are:\n\n    * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n      ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n      ``'Title'``, and ``'Type'``.\n    * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n      ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n    * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n      non-*str*, then it will be formatted as ISO 8601.\n\n    Values have been predefined for ``'Creator'``, ``'Date'``,\n    ``'Format'``, and ``'Type'``. They can be removed by setting them\n    to `None`.\n\n    Information is encoded as `Dublin Core Metadata`__.\n\n    .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n    __ DC_",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_svg(self, filename, *args, bbox_inches_restore=None,\n                  metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n\n        metadata : dict[str, Any], optional\n            Metadata in the SVG file defined as key-value pairs of strings,\n            datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n            'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n            The standard keys and their value types are:\n\n            * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n              ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n              ``'Title'``, and ``'Type'``.\n            * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n              ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n            * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n              non-*str*, then it will be formatted as ISO 8601.\n\n            Values have been predefined for ``'Creator'``, ``'Date'``,\n            ``'Format'``, and ``'Type'``. They can be removed by setting them\n            to `None`.\n\n            Information is encoded as `Dublin Core Metadata`__.\n\n            .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n            __ DC_\n        \"\"\"\n        with cbook.open_file_cm(filename, \"w\", encoding=\"utf-8\") as fh:\n            if not cbook.file_requires_unicode(fh):\n                fh = codecs.getwriter('utf-8')(fh)\n            dpi = self.figure.dpi\n            self.figure.dpi = 72\n            width, height = self.figure.get_size_inches()\n            w, h = width * 72, height * 72\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererSVG(w, h, fh, image_dpi=dpi, metadata=metadata),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz",
      "name": "print_svgz",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_svgz(self, filename, *args, **kwargs):\n        with cbook.open_file_cm(filename, \"wb\") as fh, \\\n                gzip.GzipFile(mode='w', fileobj=fh) as gzipwriter:\n            return self.print_svg(gzipwriter, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/svgwriter",
          "name": "svgwriter",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.svgwriter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/basename",
          "name": "basename",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.basename",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/image_dpi",
          "name": "image_dpi",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.image_dpi",
          "default_value": "72",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72,\n                 *, metadata=None):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        if basename is None:\n            basename = getattr(svgwriter, \"name\", \"\")\n            if not isinstance(basename, str):\n                basename = \"\"\n        self.basename = basename\n\n        self._groupd = {}\n        self._image_counter = itertools.count()\n        self._clipd = {}\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = {}\n        self._has_gouraud = False\n        self._n_gradients = 0\n\n        super().__init__()\n        self._glyph_map = dict()\n        str_height = _short_float_fmt(height)\n        str_width = _short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width='%spt' % str_width,\n            height='%spt' % str_height,\n            viewBox='0 0 %s %s' % (str_width, str_height),\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group",
      "name": "close_group",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.close_group",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.close_group.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.close_group.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle",
      "name": "draw_gouraud_triangle",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        # docstring inherited\n\n        # This uses a method described here:\n        #\n        #   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html\n        #\n        # that uses three overlapping linear gradients to simulate a\n        # Gouraud triangle.  Each gradient goes from fully opaque in\n        # one corner to fully transparent along the opposite edge.\n        # The line between the stop points is perpendicular to the\n        # opposite edge.  Underlying these three gradients is a solid\n        # triangle whose color is the average of all three points.\n\n        writer = self.writer\n        if not self._has_gouraud:\n            self._has_gouraud = True\n            writer.start(\n                'filter',\n                id='colorAdd')\n            writer.element(\n                'feComposite',\n                attrib={'in': 'SourceGraphic'},\n                in2='BackgroundImage',\n                operator='arithmetic',\n                k2=\"1\", k3=\"1\")\n            writer.end('filter')\n            # feColorMatrix filter to correct opacity\n            writer.start(\n                'filter',\n                id='colorMat')\n            writer.element(\n                'feColorMatrix',\n                attrib={'type': 'matrix'},\n                values='1 0 0 0 0 \\n0 1 0 0 0 \\n0 0 1 0 0' +\n                       ' \\n1 1 1 1 0 \\n0 0 0 0 1 ')\n            writer.end('filter')\n\n        avg_color = np.average(colors, axis=0)\n        if avg_color[-1] == 0:\n            # Skip fully-transparent triangles\n            return\n\n        trans_and_flip = self._make_flip_transform(trans)\n        tpoints = trans_and_flip.transform(points)\n\n        writer.start('defs')\n        for i in range(3):\n            x1, y1 = tpoints[i]\n            x2, y2 = tpoints[(i + 1) % 3]\n            x3, y3 = tpoints[(i + 2) % 3]\n            rgba_color = colors[i]\n\n            if x2 == x3:\n                xb = x2\n                yb = y1\n            elif y2 == y3:\n                xb = x1\n                yb = y2\n            else:\n                m1 = (y2 - y3) / (x2 - x3)\n                b1 = y2 - (m1 * x2)\n                m2 = -(1.0 / m1)\n                b2 = y1 - (m2 * x1)\n                xb = (-b1 + b2) / (m1 - m2)\n                yb = m2 * xb + b2\n\n            writer.start(\n                'linearGradient',\n                id=\"GR%x_%d\" % (self._n_gradients, i),\n                gradientUnits=\"userSpaceOnUse\",\n                x1=_short_float_fmt(x1), y1=_short_float_fmt(y1),\n                x2=_short_float_fmt(xb), y2=_short_float_fmt(yb))\n            writer.element(\n                'stop',\n                offset='1',\n                style=_generate_css({\n                    'stop-color': rgb2hex(avg_color),\n                    'stop-opacity': _short_float_fmt(rgba_color[-1])}))\n            writer.element(\n                'stop',\n                offset='0',\n                style=_generate_css({'stop-color': rgb2hex(rgba_color),\n                                    'stop-opacity': \"0\"}))\n\n            writer.end('linearGradient')\n\n        writer.end('defs')\n\n        # triangle formation using \"path\"\n        dpath = \"M \" + _short_float_fmt(x1)+',' + _short_float_fmt(y1)\n        dpath += \" L \" + _short_float_fmt(x2) + ',' + _short_float_fmt(y2)\n        dpath += \" \" + _short_float_fmt(x3) + ',' + _short_float_fmt(y3) + \" Z\"\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': rgb2hex(avg_color),\n                    'fill-opacity': '1',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.start(\n                'g',\n                attrib={'stroke': \"none\",\n                        'stroke-width': \"0\",\n                        'shape-rendering': \"crispEdges\",\n                        'filter': \"url(#colorMat)\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_0)' % self._n_gradients,\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_1)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_2)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.end('g')\n\n        self._n_gradients += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles",
      "name": "draw_gouraud_triangles",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/triangles_array",
          "name": "triangles_array",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.triangles_array",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/colors_array",
          "name": "colors_array",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.colors_array",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangles(self, gc, triangles_array, colors_array,\n                               transform):\n        self.writer.start('g', **self._get_clip_attrs(gc))\n        transform = transform.frozen()\n        for tri, col in zip(triangles_array, colors_array):\n            self.draw_gouraud_triangle(gc, tri, col, transform)\n        self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n\n        if w == 0 or h == 0:\n            return\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Can't apply clip-path directly to the image because the image has\n            # a transformation, which would also be applied to the clip-path.\n            self.writer.start('g', **clip_attrs)\n\n        url = gc.get_url()\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n\n        attrib = {}\n        oid = gc.get_gid()\n        if mpl.rcParams['svg.image_inline']:\n            buf = BytesIO()\n            Image.fromarray(im).save(buf, format=\"png\")\n            oid = oid or self._make_id('image', buf.getvalue())\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(buf.getvalue()).decode('ascii'))\n        else:\n            if self.basename is None:\n                raise ValueError(\"Cannot save image data to filesystem when \"\n                                 \"writing SVG to an in-memory buffer\")\n            filename = '{}.image{}.png'.format(\n                self.basename, next(self._image_counter))\n            _log.info('Writing image file for inclusion: %s', filename)\n            Image.fromarray(im).save(filename)\n            oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n        attrib['id'] = oid\n\n        if transform is None:\n            w = 72.0 * w / self.image_dpi\n            h = 72.0 * h / self.image_dpi\n\n            self.writer.element(\n                'image',\n                transform=_generate_transform([\n                    ('scale', (1, -1)), ('translate', (0, -h))]),\n                x=_short_float_fmt(x),\n                y=_short_float_fmt(-(self.height - y - h)),\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n        else:\n            alpha = gc.get_alpha()\n            if alpha != 1.0:\n                attrib['opacity'] = _short_float_fmt(alpha)\n\n            flipped = (\n                Affine2D().scale(1.0 / w, 1.0 / h) +\n                transform +\n                Affine2D()\n                .translate(x, y)\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n            attrib['transform'] = _generate_transform(\n                [('matrix', flipped.frozen())])\n            attrib['style'] = (\n                'image-rendering:crisp-edges;'\n                'image-rendering:pixelated')\n            self.writer.element(\n                'image',\n                width=_short_float_fmt(w), height=_short_float_fmt(h),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clip_attrs:\n            self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, _generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = _generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        writer.start('g', **self._get_clip_attrs(gc))\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': '#%s' % oid}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = _short_float_fmt(x)\n                attrib['y'] = _short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify,\n            sketch=gc.get_sketch_params())\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, **self._get_clip_attrs(gc),\n                            style=self._get_style(gc, rgbFace))\n        if gc.get_url() is not None:\n            self.writer.end('a')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/offset_trans",
          "name": "offset_trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.offset_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offset_trans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #    (len_path + 5) * uses_per_path\n        # cost of definition+use is\n        #    (len_path + 3) + 9 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 9 * uses_per_path + 3 < (len_path + 5) * uses_per_path\n        if not should_do_optimization:\n            return super().draw_path_collection(\n                gc, master_transform, paths, all_transforms,\n                offsets, offset_trans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C%x_%x_%s' % (\n                self._path_collection_id, i, self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, path_codes, offsets, offset_trans,\n                facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            clip_attrs = self._get_clip_attrs(gc0)\n            if clip_attrs:\n                writer.start('g', **clip_attrs)\n            attrib = {\n                'xlink:href': '#%s' % path_id,\n                'x': _short_float_fmt(xo),\n                'y': _short_float_fmt(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clip_attrs:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):\n        # docstring inherited\n        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath=\"TeX\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        clip_attrs = self._get_clip_attrs(gc)\n        if clip_attrs:\n            # Cannot apply clip-path directly to the text, because\n            # it has a transformation\n            self.writer.start('g', **clip_attrs)\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n\n        if mpl.rcParams['svg.fonttype'] == 'path':\n            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n        else:\n            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n        if clip_attrs:\n            self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_image_magnification",
      "name": "get_image_magnification",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_image_magnification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_image_magnification/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_image_magnification.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_image_magnification(self):\n        return self.image_dpi / 72.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group",
      "name": "open_group",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group/gid",
          "name": "gid",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group.gid",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=\"%s_%d\" % (s, self._groupd[s]))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_image_nocomposite",
      "name": "option_image_nocomposite",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_image_nocomposite",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_image_nocomposite/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_image_nocomposite.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_scale_image",
      "name": "option_scale_image",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_scale_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_scale_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_scale_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_scale_image(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "writable text file-like object",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "writable text file-like object"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, file):\n        self.__write = file.write\n        if hasattr(file, \"flush\"):\n            self.flush = file.flush\n        self.__open = 0  # true if start tag is open\n        self.__tags = []\n        self.__data = []\n        self.__indentation = \" \" * 64"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.close.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Element identifier, as returned by the :meth:`start` method."
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Close open elements, up to (and including) the element identified\nby the given identifier.",
      "docstring": "Close open elements, up to (and including) the element identified\nby the given identifier.\n\nParameters\n----------\nid\n    Element identifier, as returned by the :meth:`start` method.",
      "code": "    def close(self, id):\n        \"\"\"\n        Close open elements, up to (and including) the element identified\n        by the given identifier.\n\n        Parameters\n        ----------\n        id\n            Element identifier, as returned by the :meth:`start` method.\n        \"\"\"\n        while len(self.__tags) > id:\n            self.end()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment",
      "name": "comment",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.comment",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.comment.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment/comment",
          "name": "comment",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.comment.comment",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Comment text."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a comment to the output stream.",
      "docstring": "Add a comment to the output stream.\n\nParameters\n----------\ncomment : str\n    Comment text.",
      "code": "    def comment(self, comment):\n        \"\"\"\n        Add a comment to the output stream.\n\n        Parameters\n        ----------\n        comment : str\n            Comment text.\n        \"\"\"\n        self.__flush()\n        self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"<!-- %s -->\\n\" % _escape_comment(comment))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data",
      "name": "data",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.data",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.data.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.data.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Character data."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add character data to the output stream.",
      "docstring": "Add character data to the output stream.\n\nParameters\n----------\ntext : str\n    Character data.",
      "code": "    def data(self, text):\n        \"\"\"\n        Add character data to the output stream.\n\n        Parameters\n        ----------\n        text : str\n            Character data.\n        \"\"\"\n        self.__data.append(text)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element",
      "name": "element",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/tag",
          "name": "tag",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.tag",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.text",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/attrib",
          "name": "attrib",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.attrib",
          "default_value": "{}",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.extra",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add an entire element.  This is the same as calling :meth:`start`,\n:meth:`data`, and :meth:`end` in sequence. The *text* argument can be\nomitted.",
      "docstring": "Add an entire element.  This is the same as calling :meth:`start`,\n:meth:`data`, and :meth:`end` in sequence. The *text* argument can be\nomitted.",
      "code": "    def element(self, tag, text=None, attrib={}, **extra):\n        \"\"\"\n        Add an entire element.  This is the same as calling :meth:`start`,\n        :meth:`data`, and :meth:`end` in sequence. The *text* argument can be\n        omitted.\n        \"\"\"\n        self.start(tag, attrib, **extra)\n        if text:\n            self.data(text)\n        self.end(indent=False)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end",
      "name": "end",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end/tag",
          "name": "tag",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end.tag",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Element tag.  If given, the tag must match the start tag.  If\nomitted, the current element is closed."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end/indent",
          "name": "indent",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end.indent",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Close the current element (opened by the most recent call to\n:meth:`start`).",
      "docstring": "Close the current element (opened by the most recent call to\n:meth:`start`).\n\nParameters\n----------\ntag\n    Element tag.  If given, the tag must match the start tag.  If\n    omitted, the current element is closed.",
      "code": "    def end(self, tag=None, indent=True):\n        \"\"\"\n        Close the current element (opened by the most recent call to\n        :meth:`start`).\n\n        Parameters\n        ----------\n        tag\n            Element tag.  If given, the tag must match the start tag.  If\n            omitted, the current element is closed.\n        \"\"\"\n        if tag:\n            assert self.__tags, \"unbalanced end(%s)\" % tag\n            assert _escape_cdata(tag) == self.__tags[-1], \\\n                \"expected end(%s), got %s\" % (self.__tags[-1], tag)\n        else:\n            assert self.__tags, \"unbalanced end()\"\n        tag = self.__tags.pop()\n        if self.__data:\n            self.__flush(indent)\n        elif self.__open:\n            self.__open = 0\n            self.__write(\"/>\\n\")\n            return\n        if indent:\n            self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"</%s>\\n\" % tag)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/flush",
      "name": "flush",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.flush",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/flush/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.flush.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Flush the output stream.",
      "docstring": "Flush the output stream.",
      "code": "    def flush(self):\n        \"\"\"Flush the output stream.\"\"\"\n        pass  # replaced by the constructor"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start",
      "name": "start",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/tag",
          "name": "tag",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.tag",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Element tag."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/attrib",
          "name": "attrib",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.attrib",
          "default_value": "{}",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Attribute dictionary.  Alternatively, attributes can be given as\nkeyword arguments."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.extra",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Open a new element.  Attributes can be given as keyword\narguments, or as a string/string dictionary. The method returns\nan opaque identifier that can be passed to the :meth:`close`\nmethod, to close all open elements up to and including this one.",
      "docstring": "Open a new element.  Attributes can be given as keyword\narguments, or as a string/string dictionary. The method returns\nan opaque identifier that can be passed to the :meth:`close`\nmethod, to close all open elements up to and including this one.\n\nParameters\n----------\ntag\n    Element tag.\nattrib\n    Attribute dictionary.  Alternatively, attributes can be given as\n    keyword arguments.\n\nReturns\n-------\nAn element identifier.",
      "code": "    def start(self, tag, attrib={}, **extra):\n        \"\"\"\n        Open a new element.  Attributes can be given as keyword\n        arguments, or as a string/string dictionary. The method returns\n        an opaque identifier that can be passed to the :meth:`close`\n        method, to close all open elements up to and including this one.\n\n        Parameters\n        ----------\n        tag\n            Element tag.\n        attrib\n            Attribute dictionary.  Alternatively, attributes can be given as\n            keyword arguments.\n\n        Returns\n        -------\n        An element identifier.\n        \"\"\"\n        self.__flush()\n        tag = _escape_cdata(tag)\n        self.__data = []\n        self.__tags.append(tag)\n        self.__write(self.__indentation[:len(self.__tags) - 1])\n        self.__write(\"<%s\" % tag)\n        for k, v in {**attrib, **extra}.items():\n            if v:\n                k = _escape_cdata(k)\n                v = _quote_escape_attrib(v)\n                self.__write(' %s=%s' % (k, v))\n        self.__open = 1\n        return len(self.__tags) - 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_attrib",
      "name": "escape_attrib",
      "qname": "lib.matplotlib.backends.backend_svg.escape_attrib",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _escape_attrib')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_attrib/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.escape_attrib.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _escape_attrib\")\ndef escape_attrib(s):\n    return _escape_attrib(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_cdata",
      "name": "escape_cdata",
      "qname": "lib.matplotlib.backends.backend_svg.escape_cdata",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _escape_cdata')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_cdata/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.escape_cdata.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _escape_cdata\")\ndef escape_cdata(s):\n    return _escape_cdata(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_comment",
      "name": "escape_comment",
      "qname": "lib.matplotlib.backends.backend_svg.escape_comment",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _escape_comment')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_comment/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.escape_comment.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _escape_comment\")\ndef escape_comment(s):\n    return _escape_comment.sub(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_css",
      "name": "generate_css",
      "qname": "lib.matplotlib.backends.backend_svg.generate_css",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_css/attrib",
          "name": "attrib",
          "qname": "lib.matplotlib.backends.backend_svg.generate_css.attrib",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef generate_css(attrib=None):\n    return _generate_css(attrib or {})"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_transform",
      "name": "generate_transform",
      "qname": "lib.matplotlib.backends.backend_svg.generate_transform",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_transform/transform_list",
          "name": "transform_list",
          "qname": "lib.matplotlib.backends.backend_svg.generate_transform.transform_list",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\")\ndef generate_transform(transform_list=None):\n    return _generate_transform(transform_list or [])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/short_float_fmt",
      "name": "short_float_fmt",
      "qname": "lib.matplotlib.backends.backend_svg.short_float_fmt",
      "decorators": [
        "_api.deprecated('3.6', alternative='a vendored copy of _short_float_fmt')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/short_float_fmt/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.short_float_fmt.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@_api.deprecated(\"3.6\", alternative=\"a vendored copy of _short_float_fmt\")\ndef short_float_fmt(x):\n    return _short_float_fmt(x)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw the figure using the renderer.\n\nIt is important that this method actually walk the artist tree\neven if not output is produced because this will trigger\ndeferred work (like computing limits auto-limits and tick\nvalues) that users may want access to before saving to disk.",
      "docstring": "Draw the figure using the renderer.\n\nIt is important that this method actually walk the artist tree\neven if not output is produced because this will trigger\ndeferred work (like computing limits auto-limits and tick\nvalues) that users may want access to before saving to disk.",
      "code": "    def draw(self):\n        \"\"\"\n        Draw the figure using the renderer.\n\n        It is important that this method actually walk the artist tree\n        even if not output is produced because this will trigger\n        deferred work (like computing limits auto-limits and tick\n        values) that users may want access to before saving to disk.\n        \"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'foo'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo",
      "name": "print_foo",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo",
      "decorators": [
        "_api.delete_parameter('3.5', 'args')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out format foo.\n\nThis method is normally called via `.Figure.savefig` and\n`.FigureCanvasBase.print_figure`, which take care of setting the figure\nfacecolor, edgecolor, and dpi to the desired output values, and will\nrestore them to the original values.  Therefore, `print_foo` does not\nneed to handle these settings.",
      "docstring": "Write out format foo.\n\nThis method is normally called via `.Figure.savefig` and\n`.FigureCanvasBase.print_figure`, which take care of setting the figure\nfacecolor, edgecolor, and dpi to the desired output values, and will\nrestore them to the original values.  Therefore, `print_foo` does not\nneed to handle these settings.",
      "code": "    @_api.delete_parameter(\"3.5\", \"args\")\n    def print_foo(self, filename, *args, **kwargs):\n        \"\"\"\n        Write out format foo.\n\n        This method is normally called via `.Figure.savefig` and\n        `.FigureCanvasBase.print_figure`, which take care of setting the figure\n        facecolor, edgecolor, and dpi to the desired output values, and will\n        restore them to the original values.  Therefore, `print_foo` does not\n        need to handle these settings.\n        \"\"\"\n        self.draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `.backend_bases.RendererBase` for\ndocumentation of the methods.",
      "docstring": "",
      "code": "    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return 100, 100"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        return 1, 1, 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextTemplate()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # if backend doesn't have dpi, e.g., postscript or svg\n        return points"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_template.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/show/block",
          "name": "block",
          "qname": "lib.matplotlib.backends.backend_template.show.block",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "For image backends - is not required.\nFor GUI backends - show() is usually the last line of a pyplot script and\ntells the backend that it is time to draw.  In interactive mode, this\nshould do nothing.",
      "docstring": "For image backends - is not required.\nFor GUI backends - show() is usually the last line of a pyplot script and\ntells the backend that it is time to draw.  In interactive mode, this\nshould do nothing.",
      "code": "def show(*, block=None):\n    \"\"\"\n    For image backends - is not required.\n    For GUI backends - show() is usually the last line of a pyplot script and\n    tells the backend that it is time to draw.  In interactive mode, this\n    should do nothing.\n    \"\"\"\n    for manager in Gcf.get_all_fig_managers():\n        # do something to display the GUI\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        _backend_tk.blit(self._tkphoto, self.renderer.buffer_rgba(),\n                         (0, 1, 2, 3), bbox=bbox)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        super().draw()\n        self.blit()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        width = int(self.figure.bbox.width)\n        height = int(self.figure.bbox.height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_context(cairo.Context(surface))\n        self._renderer.dpi = self.figure.dpi\n        self.figure.draw(self._renderer)\n        buf = np.reshape(surface.get_data(), (height, width, 4))\n        _backend_tk.blit(\n            self._tkphoto, buf,\n            (2, 1, 0, 3) if sys.byteorder == \"little\" else (1, 2, 3, 0))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread/run",
      "name": "run",
      "qname": "lib.matplotlib.backends.backend_webagg.ServerThread.run",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread/run/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.ServerThread.run.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def run(self):\n        tornado.ioloop.IOLoop.instance().start()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/application",
          "name": "application",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.application",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/request",
          "name": "request",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.request",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.url_prefix",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self):\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"all_figures.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                figures=sorted(Gcf.figs.items()),\n                toolitems=core.NavigationToolbar2WebAgg.toolitems)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get/fignum",
          "name": "fignum",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get.fignum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get/fmt",
          "name": "fmt",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get.fmt",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self, fignum, fmt):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n            self.set_header(\n                'Content-Type', mimetypes.types_map.get(fmt, 'binary'))\n            buff = BytesIO()\n            manager.canvas.figure.savefig(buff, format=fmt)\n            self.write(buff.getvalue())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/FavIcon/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.FavIcon.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/FavIcon/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.FavIcon.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self):\n            self.set_header('Content-Type', 'image/png')\n            self.write(Path(mpl.get_data_path(),\n                            'images/matplotlib.png').read_bytes())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/MplJs/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.MplJs.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/MplJs/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.MplJs.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self):\n            self.set_header('Content-Type', 'application/javascript')\n\n            js_content = core.FigureManagerWebAgg.get_javascript()\n\n            self.write(js_content)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/application",
          "name": "application",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.application",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/request",
          "name": "request",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.request",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.url_prefix",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/get/fignum",
          "name": "fignum",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.get.fignum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self, fignum):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"single_figure.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                fig_id=fignum,\n                toolitems=core.NavigationToolbar2WebAgg.toolitems,\n                canvas=manager.canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_close",
      "name": "on_close",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def on_close(self):\n            self.manager.remove_web_socket(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_message",
      "name": "on_message",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def on_message(self, message):\n            message = json.loads(message)\n            # The 'supports_binary' message is on a client-by-client\n            # basis.  The others affect the (shared) canvas as a\n            # whole.\n            if message['type'] == 'supports_binary':\n                self.supports_binary = message['value']\n            else:\n                manager = Gcf.get_fig_manager(self.fignum)\n                # It is possible for a figure to be closed,\n                # but a stale figure UI is still sending messages\n                # from the browser.\n                if manager is not None:\n                    manager.handle_json(message)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/open",
      "name": "open",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.open",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/open/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.open.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/open/fignum",
          "name": "fignum",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.open.fignum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def open(self, fignum):\n            self.fignum = int(fignum)\n            self.manager = Gcf.get_fig_manager(self.fignum)\n            self.manager.add_web_socket(self)\n            if hasattr(self, 'set_nodelay'):\n                self.set_nodelay(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_binary",
      "name": "send_binary",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_binary",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_binary/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_binary.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_binary/blob",
          "name": "blob",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_binary.blob",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def send_binary(self, blob):\n            if self.supports_binary:\n                self.write_message(blob, binary=True)\n            else:\n                data_uri = \"data:image/png;base64,{0}\".format(\n                    blob.encode('base64').replace('\\n', ''))\n                self.write_message(data_uri)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_json",
      "name": "send_json",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_json",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_json/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_json/content",
          "name": "content",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_json.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def send_json(self, content):\n            self.write_message(json.dumps(content))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.__init__.url_prefix",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, url_prefix=''):\n        if url_prefix:\n            assert url_prefix[0] == '/' and url_prefix[-1] != '/', \\\n                'url_prefix must start with a \"/\" and not end with one.'\n\n        super().__init__(\n            [\n                # Static files for the CSS and JS\n                (url_prefix + r'/_static/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': core.FigureManagerWebAgg.get_static_file_path()}),\n\n                # Static images for the toolbar\n                (url_prefix + r'/_images/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': Path(mpl.get_data_path(), 'images')}),\n\n                # A Matplotlib favicon\n                (url_prefix + r'/favicon.ico', self.FavIcon),\n\n                # The page that contains all of the pieces\n                (url_prefix + r'/([0-9]+)', self.SingleFigurePage,\n                 {'url_prefix': url_prefix}),\n\n                # The page that contains all of the figures\n                (url_prefix + r'/?', self.AllFiguresPage,\n                 {'url_prefix': url_prefix}),\n\n                (url_prefix + r'/js/mpl.js', self.MplJs),\n\n                # Sends images and events to the browser, and receives\n                # events from the browser\n                (url_prefix + r'/([0-9]+)/ws', self.WebSocket),\n\n                # Handles the downloading (i.e., saving) of static images\n                (url_prefix + r'/([0-9]+)/download.([a-z0-9.]+)',\n                 self.Download),\n            ],\n            template_path=core.FigureManagerWebAgg.get_static_file_path())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize",
      "name": "initialize",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.url_prefix",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/port",
          "name": "port",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.port",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/address",
          "name": "address",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.address",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def initialize(cls, url_prefix='', port=None, address=None):\n        if cls.initialized:\n            return\n\n        # Create the class instance\n        app = cls(url_prefix=url_prefix)\n\n        cls.url_prefix = url_prefix\n\n        # This port selection algorithm is borrowed, more or less\n        # verbatim, from IPython.\n        def random_ports(port, n):\n            \"\"\"\n            Generate a list of n random ports near the given port.\n\n            The first 5 ports will be sequential, and the remaining n-5 will be\n            randomly selected in the range [port-2*n, port+2*n].\n            \"\"\"\n            for i in range(min(5, n)):\n                yield port + i\n            for i in range(n - 5):\n                yield port + random.randint(-2 * n, 2 * n)\n\n        if address is None:\n            cls.address = mpl.rcParams['webagg.address']\n        else:\n            cls.address = address\n        cls.port = mpl.rcParams['webagg.port']\n        for port in random_ports(cls.port,\n                                 mpl.rcParams['webagg.port_retries']):\n            try:\n                app.listen(port, cls.address)\n            except socket.error as e:\n                if e.errno != errno.EADDRINUSE:\n                    raise\n            else:\n                cls.port = port\n                break\n        else:\n            raise SystemExit(\n                \"The webagg server could not be started because an available \"\n                \"port could not be found\")\n\n        cls.initialized = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/start",
      "name": "start",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.start",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/start/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.start.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def start(cls):\n        if cls.started:\n            return\n\n        \"\"\"\n        IOLoop.running() was removed as of Tornado 2.4; see for example\n        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY\n        Thus there is no correct way to check if the loop has already been\n        launched. We may end up with two concurrently running loops in that\n        unlucky case with all the expected consequences.\n        \"\"\"\n        ioloop = tornado.ioloop.IOLoop.instance()\n\n        def shutdown():\n            ioloop.stop()\n            print(\"Server is stopped\")\n            sys.stdout.flush()\n            cls.started = False\n\n        @contextmanager\n        def catch_sigint():\n            old_handler = signal.signal(\n                signal.SIGINT,\n                lambda sig, frame: ioloop.add_callback_from_signal(shutdown))\n            try:\n                yield\n            finally:\n                signal.signal(signal.SIGINT, old_handler)\n\n        # Set the flag to True *before* blocking on ioloop.start()\n        cls.started = True\n\n        print(\"Press Ctrl+C to stop WebAgg server\")\n        sys.stdout.flush()\n        with catch_sigint():\n            ioloop.start()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ipython_inline_display",
      "name": "ipython_inline_display",
      "qname": "lib.matplotlib.backends.backend_webagg.ipython_inline_display",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ipython_inline_display/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_webagg.ipython_inline_display.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def ipython_inline_display(figure):\n    import tornado.template\n\n    WebAggApplication.initialize()\n    if not webagg_server_thread.is_alive():\n        webagg_server_thread.start()\n\n    fignum = figure.number\n    tpl = Path(core.FigureManagerWebAgg.get_static_file_path(),\n               \"ipython_inline_figure.html\").read_text()\n    t = tornado.template.Template(tpl)\n    return t.generate(\n        prefix=WebAggApplication.url_prefix,\n        fig_id=fignum,\n        toolitems=core.NavigationToolbar2WebAgg.toolitems,\n        canvas=figure.canvas,\n        port=WebAggApplication.port).decode('utf-8')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Set to True when the renderer contains data that is newer\n        # than the PNG buffer.\n        self._png_is_old = True\n        # Set to True by the `refresh` message so that the next frame\n        # sent to the clients will be a full frame.\n        self._force_full = True\n        # The last buffer, for diff mode.\n        self._last_buff = np.empty((0, 0))\n        # Store the current image mode so that at any point, clients can\n        # request the information. This should be changed by calling\n        # self.set_image_mode(mode) so that the notification can be given\n        # to the connected clients.\n        self._current_image_mode = 'full'\n        # Track mouse events to fill in the x, y position of key events.\n        self._last_mouse_xy = (None, None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        self._png_is_old = True\n        self.manager.refresh_all()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self._png_is_old = True\n        try:\n            super().draw()\n        finally:\n            self.manager.refresh_all()  # Swap the frames."
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        self.send_event(\"draw\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_diff_image",
      "name": "get_diff_image",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.get_diff_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_diff_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.get_diff_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_diff_image(self):\n        if self._png_is_old:\n            renderer = self.get_renderer()\n\n            pixels = np.asarray(renderer.buffer_rgba())\n            # The buffer is created as type uint32 so that entire\n            # pixels can be compared in one numpy call, rather than\n            # needing to compare each plane separately.\n            buff = pixels.view(np.uint32).squeeze(2)\n\n            if (self._force_full\n                    # If the buffer has changed size we need to do a full draw.\n                    or buff.shape != self._last_buff.shape\n                    # If any pixels have transparency, we need to force a full\n                    # draw as we cannot overlay new on top of old.\n                    or (pixels[:, :, 3] != 255).any()):\n                self.set_image_mode('full')\n                output = buff\n            else:\n                self.set_image_mode('diff')\n                diff = buff != self._last_buff\n                output = np.where(diff, buff, 0)\n\n            # Store the current buffer so we can compute the next diff.\n            self._last_buff = buff.copy()\n            self._force_full = False\n            self._png_is_old = False\n\n            data = output.view(dtype=np.uint8).reshape((*output.shape, 4))\n            with BytesIO() as png:\n                Image.fromarray(data).save(png, format=\"png\")\n                return png.getvalue()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack",
      "name": "handle_ack",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_ack",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_ack.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_ack.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_ack(self, event):\n        # Network latency tends to decrease if traffic is flowing\n        # in both directions.  Therefore, the browser sends back\n        # an \"ack\" message after each image frame is received.\n        # This could also be used as a simple sanity check in the\n        # future, but for now the performance increase is enough\n        # to justify it, even if the server does nothing with it.\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw",
      "name": "handle_draw",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_draw.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_draw(self, event):\n        self.draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event",
      "name": "handle_event",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_event(self, event):\n        e_type = event['type']\n        handler = getattr(self, 'handle_{0}'.format(e_type),\n                          self.handle_unknown_event)\n        return handler(event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh",
      "name": "handle_refresh",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_refresh",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_refresh.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_refresh.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_refresh(self, event):\n        figure_label = self.figure.get_label()\n        if not figure_label:\n            figure_label = \"Figure {0}\".format(self.manager.num)\n        self.send_event('figure_label', label=figure_label)\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize",
      "name": "handle_resize",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_resize.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_resize(self, event):\n        x = int(event.get('width', 800)) * self.device_pixel_ratio\n        y = int(event.get('height', 800)) * self.device_pixel_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        ResizeEvent('resize_event', self)._process()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode",
      "name": "handle_send_image_mode",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_send_image_mode",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_send_image_mode.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_send_image_mode.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_send_image_mode(self, event):\n        # The client requests notification of what the current image mode is.\n        self.send_event('image_mode', mode=self._current_image_mode)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_device_pixel_ratio",
      "name": "handle_set_device_pixel_ratio",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_device_pixel_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_device_pixel_ratio/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_device_pixel_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_device_pixel_ratio/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_device_pixel_ratio.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_set_device_pixel_ratio(self, event):\n        self._handle_set_device_pixel_ratio(event.get('device_pixel_ratio', 1))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio",
      "name": "handle_set_dpi_ratio",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_dpi_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_dpi_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_dpi_ratio.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_set_dpi_ratio(self, event):\n        # This handler is for backwards-compatibility with older ipympl.\n        self._handle_set_device_pixel_ratio(event.get('dpi_ratio', 1))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button",
      "name": "handle_toolbar_button",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_toolbar_button",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_toolbar_button.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_toolbar_button.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event",
      "name": "handle_unknown_event",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_unknown_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_unknown_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_unknown_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_unknown_event(self, event):\n        _log.warning('Unhandled message type {0}. {1}'.format(\n                     event['type'], event))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event",
      "name": "send_event",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event/event_type",
          "name": "event_type",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event.event_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def send_event(self, event_type, **kwargs):\n        if self.manager:\n            self.manager._send_event(event_type, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        # docstring inherited\n        cursor = _api.check_getitem({\n            backend_tools.Cursors.HAND: 'pointer',\n            backend_tools.Cursors.POINTER: 'default',\n            backend_tools.Cursors.SELECT_REGION: 'crosshair',\n            backend_tools.Cursors.MOVE: 'move',\n            backend_tools.Cursors.WAIT: 'wait',\n            backend_tools.Cursors.RESIZE_HORIZONTAL: 'ew-resize',\n            backend_tools.Cursors.RESIZE_VERTICAL: 'ns-resize',\n        }, cursor=cursor)\n        self.send_event('cursor', cursor=cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode",
      "name": "set_image_mode",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_image_mode",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_image_mode.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode/mode",
          "name": "mode",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_image_mode.mode",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the image mode for any subsequent images which will be sent\nto the clients. The modes may currently be either 'full' or 'diff'.\n\nNote: diff images may not contain transparency, therefore upon\ndraw this mode may be changed if the resulting image has any\ntransparent component.",
      "docstring": "Set the image mode for any subsequent images which will be sent\nto the clients. The modes may currently be either 'full' or 'diff'.\n\nNote: diff images may not contain transparency, therefore upon\ndraw this mode may be changed if the resulting image has any\ntransparent component.",
      "code": "    def set_image_mode(self, mode):\n        \"\"\"\n        Set the image mode for any subsequent images which will be sent\n        to the clients. The modes may currently be either 'full' or 'diff'.\n\n        Note: diff images may not contain transparency, therefore upon\n        draw this mode may be changed if the resulting image has any\n        transparent component.\n        \"\"\"\n        _api.check_in_list(['full', 'diff'], mode=mode)\n        if self._current_image_mode != mode:\n            self._current_image_mode = mode\n            self.handle_send_image_mode(None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        # show the figure window\n        from matplotlib.pyplot import show\n        show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        self.web_sockets = set()\n        super().__init__(canvas, num)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket",
      "name": "add_web_socket",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.add_web_socket",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.add_web_socket.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket/web_socket",
          "name": "web_socket",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.add_web_socket.web_socket",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_web_socket(self, web_socket):\n        assert hasattr(web_socket, 'send_binary')\n        assert hasattr(web_socket, 'send_json')\n        self.web_sockets.add(web_socket)\n        self.resize(*self.canvas.figure.bbox.size)\n        self._send_event('refresh')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript",
      "name": "get_javascript",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_javascript",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_javascript.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript/stream",
          "name": "stream",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_javascript.stream",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = StringIO()\n        else:\n            output = stream\n\n        output.write((Path(__file__).parent / \"web_backend/js/mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n\n        toolitems = []\n        for name, tooltip, image, method in cls.ToolbarCls.toolitems:\n            if name is None:\n                toolitems.append(['', '', '', ''])\n            else:\n                toolitems.append([name, tooltip, image, method])\n        output.write(\"mpl.toolbar_items = {0};\\n\\n\".format(\n            json.dumps(toolitems)))\n\n        extensions = []\n        for filetype, ext in sorted(FigureCanvasWebAggCore.\n                                    get_supported_filetypes_grouped().\n                                    items()):\n            extensions.append(ext[0])\n        output.write(\"mpl.extensions = {0};\\n\\n\".format(\n            json.dumps(extensions)))\n\n        output.write(\"mpl.default_extension = {0};\".format(\n            json.dumps(FigureCanvasWebAggCore.get_default_filetype())))\n\n        if stream is None:\n            return output.getvalue()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_static_file_path",
      "name": "get_static_file_path",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_static_file_path",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_static_file_path/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_static_file_path.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def get_static_file_path(cls):\n        return os.path.join(os.path.dirname(__file__), 'web_backend')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json",
      "name": "handle_json",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.handle_json",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.handle_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json/content",
          "name": "content",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.handle_json.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_json(self, content):\n        self.canvas.handle_event(content)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/refresh_all",
      "name": "refresh_all",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.refresh_all",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/refresh_all/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.refresh_all.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def refresh_all(self):\n        if self.web_sockets:\n            diff = self.canvas.get_diff_image()\n            if diff is not None:\n                for s in self.web_sockets:\n                    s.send_binary(diff)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket",
      "name": "remove_web_socket",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.remove_web_socket",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.remove_web_socket.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket/web_socket",
          "name": "web_socket",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.remove_web_socket.web_socket",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_web_socket(self, web_socket):\n        self.web_sockets.remove(web_socket)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/w",
          "name": "w",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/h",
          "name": "h",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.h",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/forward",
          "name": "forward",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.forward",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, w, h, forward=True):\n        self._send_event(\n            'resize',\n            size=(w / self.canvas.device_pixel_ratio,\n                  h / self.canvas.device_pixel_ratio),\n            forward=forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        self._send_event('figure_label', label=title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas):\n        self.message = ''\n        self._cursor = None  # Remove with deprecation.\n        super().__init__(canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.send_event(\"rubberband\", x0=x0, y0=y0, x1=x1, y1=y1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self):\n        super().pan()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas.send_event(\"rubberband\", x0=-1, y0=-1, x1=-1, y1=-1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save the current figure",
      "docstring": "Save the current figure",
      "code": "    def save_figure(self, *args):\n        \"\"\"Save the current figure\"\"\"\n        self.canvas.send_event('save')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        self.canvas.send_event('history_buttons',\n                               Back=can_backward, Forward=can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, message):\n        if message != self.message:\n            self.canvas.send_event(\"message\", message=message)\n        self.message = message"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self):\n        super().zoom()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerAsyncio/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerAsyncio.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._task = None\n        super().__init__(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._timer = None\n        super().__init__(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2Wx.configure_subplots(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw/drawDC",
          "name": "drawDC",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.draw.drawDC",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure using RendererWx instance renderer, or using a\npreviously defined renderer if none is specified.",
      "docstring": "Render the figure using RendererWx instance renderer, or using a\npreviously defined renderer if none is specified.",
      "code": "    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using RendererWx instance renderer, or using a\n        previously defined renderer if none is specified.\n        \"\"\"\n        _log.debug(\"%s - draw()\", type(self))\n        self.renderer = RendererWx(self.bitmap, self.figure.dpi)\n        self.figure.draw(self.renderer)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/canvas_class",
          "name": "canvas_class",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.canvas_class",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, num, fig, *, canvas_class=None):\n        # On non-Windows platform, explicitly set the position - fix\n        # positioning bug on some Linux platforms\n        if wx.Platform == '__WXMSW__':\n            pos = wx.DefaultPosition\n        else:\n            pos = wx.Point(20, 20)\n        super().__init__(parent=None, id=-1, pos=pos)\n        # Frame will be sized later by the Fit method\n        _log.debug(\"%s - __init__()\", type(self))\n        _set_frame_icon(self)\n\n        # The parameter will become required after the deprecation elapses.\n        if canvas_class is not None:\n            self.canvas = canvas_class(self, -1, fig)\n        else:\n            _api.warn_deprecated(\n                \"3.6\", message=\"The canvas_class parameter will become \"\n                \"required after the deprecation period starting in Matplotlib \"\n                \"%(since)s elapses.\")\n            self.canvas = self.get_canvas(fig)\n\n        # Auto-attaches itself to self.canvas.manager\n        manager = FigureManagerWx(self.canvas, num, self)\n\n        toolbar = self.canvas.manager.toolbar\n        if toolbar is not None:\n            self.SetToolBar(toolbar)\n\n        # On Windows, canvas sizing must occur after toolbar addition;\n        # otherwise the toolbar further resizes the canvas.\n        w, h = map(math.ceil, fig.bbox.size)\n        self.canvas.SetInitialSize(wx.Size(w, h))\n        self.canvas.SetMinSize((2, 2))\n        self.canvas.SetFocus()\n\n        self.Fit()\n\n        self.Bind(wx.EVT_CLOSE, self._on_close)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_canvas",
      "decorators": [
        "_api.deprecated('3.6', alternative='the canvas_class constructor parameter')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\n        \"3.6\", alternative=\"the canvas_class constructor parameter\")\n    def get_canvas(self, fig):\n        return FigureCanvasWx(self, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_figure_manager",
      "name": "get_figure_manager",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_figure_manager",
      "decorators": [
        "_api.deprecated('3.6', alternative='frame.canvas.manager')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_figure_manager/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_figure_manager.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\", alternative=\"frame.canvas.manager\")\n    def get_figure_manager(self):\n        _log.debug(\"%s - get_figure_manager()\", type(self))\n        return self.canvas.manager"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/frame",
          "name": "frame",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.",
      "docstring": "",
      "code": "    def __init__(self, canvas, num, frame):\n        _log.debug(\"%s - __init__()\", type(self))\n        self.frame = self.window = frame\n        super().__init__(canvas, num)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas",
      "name": "create_with_canvas",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas/canvas_class",
          "name": "canvas_class",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas.canvas_class",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/create_with_canvas/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.create_with_canvas.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def create_with_canvas(cls, canvas_class, figure, num):\n        # docstring inherited\n        wxapp = wx.GetApp() or _create_wxapp()\n        frame = FigureFrameWx(num, figure, canvas_class=canvas_class)\n        manager = figure.canvas.manager\n        if mpl.is_interactive():\n            manager.frame.Show()\n            figure.canvas.draw_idle()\n        return manager"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.destroy.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self, *args):\n        # docstring inherited\n        _log.debug(\"%s - destroy()\", type(self))\n        frame = self.frame\n        if frame:  # Else, may have been already deleted, e.g. when closing.\n            # As this can be called from non-GUI thread from plt.close use\n            # wx.CallAfter to ensure thread safety.\n            wx.CallAfter(frame.Close)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/full_screen_toggle",
      "name": "full_screen_toggle",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.full_screen_toggle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/full_screen_toggle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.full_screen_toggle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def full_screen_toggle(self):\n        # docstring inherited\n        self.frame.ShowFullScreen(not self.frame.IsFullScreen())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/get_window_title",
      "name": "get_window_title",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.get_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/get_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.get_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_window_title(self):\n        # docstring inherited\n        return self.window.GetTitle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, width, height):\n        # docstring inherited\n        # Directly using SetClientSize doesn't handle the toolbar on Windows.\n        self.window.SetSize(self.window.ClientToWindowSize(wx.Size(\n            math.ceil(width), math.ceil(height))))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        # docstring inherited\n        self.window.SetTitle(title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        # docstring inherited\n        self.frame.Show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.frame.Raise()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__/bitmap",
          "name": "bitmap",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__.bitmap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The graphics context provides the color, line styles, etc.\n\nThis class stores a reference to a wxMemoryDC, and a\nwxGraphicsContext that draws to it.  Creating a wxGraphicsContext\nseems to be fairly heavy, so these objects are cached based on the\nbitmap object that is passed in.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\nsince wxPython colour management is rather simple, I have not chosen\nto implement a separate colour manager class.",
      "docstring": "",
      "code": "    def __init__(self, bitmap, renderer):\n        super().__init__()\n        # assert self.Ok(), \"wxMemoryDC not OK to use\"\n        _log.debug(\"%s - __init__(): %s\", type(self), bitmap)\n\n        dc, gfx_ctx = self._cache.get(bitmap, (None, None))\n        if dc is None:\n            dc = wx.MemoryDC(bitmap)\n            gfx_ctx = wx.GraphicsContext.Create(dc)\n            gfx_ctx._lastcliprect = None\n            self._cache[bitmap] = dc, gfx_ctx\n\n        self.bitmap = bitmap\n        self.dc = dc\n        self.gfx_ctx = gfx_ctx\n        self._pen = wx.Pen('BLACK', 1, wx.SOLID)\n        gfx_ctx.SetPen(self._pen)\n        self.renderer = renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour",
      "name": "get_wxcolour",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.get_wxcolour",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.get_wxcolour.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour/color",
          "name": "color",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.get_wxcolour.color",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert a RGB(A) color to a wx.Colour.",
      "docstring": "Convert a RGB(A) color to a wx.Colour.",
      "code": "    def get_wxcolour(self, color):\n        \"\"\"Convert a RGB(A) color to a wx.Colour.\"\"\"\n        _log.debug(\"%s - get_wx_color()\", type(self))\n        return wx.Colour(*[int(255 * x) for x in color])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/select",
      "name": "select",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.select",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/select/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.select.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Select the current bitmap into this wxDC instance.",
      "docstring": "Select the current bitmap into this wxDC instance.",
      "code": "    def select(self):\n        \"\"\"Select the current bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(self.bitmap)\n            self.IsSelected = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle",
      "name": "set_capstyle",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_capstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_capstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle/cs",
          "name": "cs",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_capstyle.cs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_capstyle(self, cs):\n        # docstring inherited\n        _log.debug(\"%s - set_capstyle()\", type(self))\n        self.select()\n        super().set_capstyle(cs)\n        self._pen.SetCap(GraphicsContextWx._capd[self._capstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground",
      "name": "set_foreground",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground/fg",
          "name": "fg",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground.fg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground/isRGBA",
          "name": "isRGBA",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground.isRGBA",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_foreground(self, fg, isRGBA=None):\n        # docstring inherited\n        # Implementation note: wxPython has a separate concept of pen and\n        # brush - the brush fills any outline trace left by the pen.\n        # Here we set both to the same colour - if a figure is not to be\n        # filled, the renderer will set the brush to be transparent\n        # Same goes for text foreground...\n        _log.debug(\"%s - set_foreground()\", type(self))\n        self.select()\n        super().set_foreground(fg, isRGBA)\n\n        self._pen.SetColour(self.get_wxcolour(self.get_rgb()))\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle",
      "name": "set_joinstyle",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_joinstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_joinstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle/js",
          "name": "js",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_joinstyle.js",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_joinstyle(self, js):\n        # docstring inherited\n        _log.debug(\"%s - set_joinstyle()\", type(self))\n        self.select()\n        super().set_joinstyle(js)\n        self._pen.SetJoin(GraphicsContextWx._joind[self._joinstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth",
      "name": "set_linewidth",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_linewidth",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_linewidth.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth/w",
          "name": "w",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_linewidth.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linewidth(self, w):\n        # docstring inherited\n        w = float(w)\n        _log.debug(\"%s - set_linewidth()\", type(self))\n        self.select()\n        if 0 < w < 1:\n            w = 1\n        super().set_linewidth(w)\n        lw = int(self.renderer.points_to_pixels(self._linewidth))\n        if lw == 0:\n            lw = 1\n        self._pen.SetWidth(lw)\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/unselect",
      "name": "unselect",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.unselect",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/unselect/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.unselect.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Select a Null bitmap into this wxDC instance.",
      "docstring": "Select a Null bitmap into this wxDC instance.",
      "code": "    def unselect(self):\n        \"\"\"Select a Null bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(wx.NullBitmap)\n            self.IsSelected = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.HelpWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.HelpWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.HelpWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        _HelpDialog.show(self.figure.canvas.GetTopLevelParent(),\n                         self._get_help_entries())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/coordinates",
          "name": "coordinates",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.coordinates",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.style",
          "default_value": "wx.TB_BOTTOM",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, coordinates=True, *, style=wx.TB_BOTTOM):\n        wx.ToolBar.__init__(self, canvas.GetParent(), -1, style=style)\n\n        if 'wxMac' in wx.PlatformInfo:\n            self.SetToolBitmapSize((24, 24))\n        self.wx_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.AddSeparator()\n                continue\n            self.wx_ids[text] = (\n                self.AddTool(\n                    -1,\n                    bitmap=self._icon(f\"{image_file}.png\"),\n                    bmpDisabled=wx.NullBitmap,\n                    label=text, shortHelp=tooltip_text,\n                    kind=(wx.ITEM_CHECK if text in [\"Pan\", \"Zoom\"]\n                          else wx.ITEM_NORMAL))\n                .Id)\n            self.Bind(wx.EVT_TOOL, getattr(self, callback),\n                      id=self.wx_ids[text])\n\n        self._coordinates = coordinates\n        if self._coordinates:\n            self.AddStretchableSpace()\n            self._label_text = wx.StaticText(self, style=wx.ALIGN_RIGHT)\n            self.AddControl(self._label_text)\n\n        self.Realize()\n\n        NavigationToolbar2.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        self.canvas._rubberband_rect = (x0, height - y0, x1, height - y1)\n        self.canvas.Refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.pan.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas._rubberband_rect = None\n        self.canvas.Refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        # Fetch the required filename and file type.\n        filetypes, exts, filter_index = self.canvas._get_imagesave_wildcards()\n        default_file = self.canvas.get_default_filename()\n        dialog = wx.FileDialog(\n            self.canvas.GetParent(), \"Save to file\",\n            mpl.rcParams[\"savefig.directory\"], default_file, filetypes,\n            wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)\n        dialog.SetFilterIndex(filter_index)\n        if dialog.ShowModal() == wx.ID_OK:\n            path = pathlib.Path(dialog.GetPath())\n            _log.debug('%s - Save file path: %s', type(self), path)\n            fmt = exts[dialog.GetFilterIndex()]\n            ext = path.suffix[1:]\n            if ext in self.canvas.get_supported_filetypes() and fmt != ext:\n                # looks like they forgot to set the image type drop\n                # down, going with the extension.\n                _log.warning('extension %s did not match the selected '\n                             'image type %s; going with %s',\n                             ext, fmt, ext)\n                fmt = ext\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams[\"savefig.directory\"]:\n                mpl.rcParams[\"savefig.directory\"] = str(path.parent)\n            try:\n                self.canvas.figure.savefig(str(path), format=fmt)\n            except Exception as e:\n                dialog = wx.MessageDialog(\n                    parent=self.canvas.GetParent(), message=str(e),\n                    caption='Matplotlib error')\n                dialog.ShowModal()\n                dialog.Destroy()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'Back' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Back'], can_backward)\n        if 'Forward' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Forward'], can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        if self._coordinates:\n            self._label_text.SetLabel(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.zoom.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__/bitmap",
          "name": "bitmap",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__.bitmap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles. It acts as the\n'renderer' instance used by many classes in the hierarchy.",
      "docstring": "Initialise a wxWindows renderer instance.",
      "code": "    def __init__(self, bitmap, dpi):\n        \"\"\"Initialise a wxWindows renderer instance.\"\"\"\n        super().__init__()\n        _log.debug(\"%s - __init__()\", type(self))\n        self.width = bitmap.GetWidth()\n        self.height = bitmap.GetHeight()\n        self.bitmap = bitmap\n        self.fontd = {}\n        self.dpi = dpi\n        self.gc = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path",
      "name": "convert_path",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path/gfx_ctx",
          "name": "gfx_ctx",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path.gfx_ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def convert_path(gfx_ctx, path, transform):\n        wxpath = gfx_ctx.CreatePath()\n        for points, code in path.iter_segments(transform):\n            if code == Path.MOVETO:\n                wxpath.MoveToPoint(*points)\n            elif code == Path.LINETO:\n                wxpath.AddLineToPoint(*points)\n            elif code == Path.CURVE3:\n                wxpath.AddQuadCurveToPoint(*points)\n            elif code == Path.CURVE4:\n                wxpath.AddCurveToPoint(*points)\n            elif code == Path.CLOSEPOLY:\n                wxpath.CloseSubpath()\n        return wxpath"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im):\n        bbox = gc.get_clip_rectangle()\n        if bbox is not None:\n            l, b, w, h = bbox.bounds\n        else:\n            l = 0\n            b = 0\n            w = self.width\n            h = self.height\n        rows, cols = im.shape[:2]\n        bitmap = wx.Bitmap.FromBufferRGBA(cols, rows, im.tobytes())\n        gc.select()\n        gc.gfx_ctx.DrawBitmap(bitmap, int(l), int(self.height - b),\n                              int(w), int(-h))\n        gc.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n        transform = transform + \\\n            Affine2D().scale(1.0, -1.0).translate(0.0, self.height)\n        wxpath = self.convert_path(gfx_ctx, path, transform)\n        if rgbFace is not None:\n            gfx_ctx.SetBrush(wx.Brush(gc.get_wxcolour(rgbFace)))\n            gfx_ctx.DrawPath(wxpath)\n        else:\n            gfx_ctx.StrokePath(wxpath)\n        gc.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n        _log.debug(\"%s - draw_text()\", type(self))\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n\n        font = self.get_wx_font(s, prop)\n        color = gc.get_wxcolour(gc.get_rgb())\n        gfx_ctx.SetFont(font, color)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath)\n        x = int(x)\n        y = int(y - h)\n\n        if angle == 0.0:\n            gfx_ctx.DrawText(s, x, y)\n        else:\n            rads = math.radians(angle)\n            xo = h * math.sin(rads)\n            yo = h * math.cos(rads)\n            gfx_ctx.DrawRotatedText(s, x - xo, y - yo, rads)\n\n        gc.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n\n        if self.gc is None:\n            gc = self.new_gc()\n        else:\n            gc = self.gc\n        gfx_ctx = gc.gfx_ctx\n        font = self.get_wx_font(s, prop)\n        gfx_ctx.SetFont(font, wx.BLACK)\n        w, h, descent, leading = gfx_ctx.GetFullTextExtent(s)\n\n        return w, h, descent"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font",
      "name": "get_wx_font",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a wx font.  Cache font instances for efficiency.",
      "docstring": "Return a wx font.  Cache font instances for efficiency.",
      "code": "    def get_wx_font(self, s, prop):\n        \"\"\"Return a wx font.  Cache font instances for efficiency.\"\"\"\n        _log.debug(\"%s - get_wx_font()\", type(self))\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is not None:\n            return font\n        size = self.points_to_pixels(prop.get_size_in_points())\n        # Font colour is determined by the active wx.Pen\n        # TODO: It may be wise to cache font information\n        self.fontd[key] = font = wx.Font(  # Cache the font and gc.\n            pointSize=int(size + 0.5),\n            family=self.fontnames.get(prop.get_name(), wx.ROMAN),\n            style=self.fontangles[prop.get_style()],\n            weight=self.fontweights[prop.get_weight()])\n        return font"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle",
      "name": "handle_clip_rectangle",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.handle_clip_rectangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.handle_clip_rectangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.handle_clip_rectangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_clip_rectangle(self, gc):\n        new_bounds = gc.get_clip_rectangle()\n        if new_bounds is not None:\n            new_bounds = new_bounds.bounds\n        gfx_ctx = gc.gfx_ctx\n        if gfx_ctx._lastcliprect != new_bounds:\n            gfx_ctx._lastcliprect = new_bounds\n            if new_bounds is None:\n                gfx_ctx.ResetClip()\n            else:\n                gfx_ctx.Clip(new_bounds[0],\n                             self.height - new_bounds[1] - new_bounds[3],\n                             new_bounds[2], new_bounds[3])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        _log.debug(\"%s - new_gc()\", type(self))\n        self.gc = GraphicsContextWx(self.bitmap, self)\n        self.gc.select()\n        self.gc.unselect()\n        return self.gc"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/offset_text_height",
      "name": "offset_text_height",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.offset_text_height",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/offset_text_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.offset_text_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_api.deprecated(\"3.6\")\n    def offset_text_height(self):\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2Wx.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        NavigationToolbar2Wx.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2Wx.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        NavigationToolbar2Wx.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using wx.Timer events.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._timer = wx.Timer()\n        self._timer.Notify = self._on_timer\n        super().__init__(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        if not self.canvas._isDrawn:\n            self.canvas.draw()\n        if not self.canvas.bitmap.IsOk() or not wx.TheClipboard.Open():\n            return\n        try:\n            wx.TheClipboard.SetData(wx.BitmapDataObject(self.canvas.bitmap))\n        finally:\n            wx.TheClipboard.Close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.style",
          "default_value": "wx.TB_BOTTOM",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager, parent=None, style=wx.TB_BOTTOM):\n        if parent is None:\n            parent = toolmanager.canvas.GetParent()\n        ToolContainerBase.__init__(self, toolmanager)\n        wx.ToolBar.__init__(self, parent, -1, style=style)\n        self._space = self.AddStretchableSpace()\n        self._label_text = wx.StaticText(self, style=wx.ALIGN_RIGHT)\n        self.AddControl(self._label_text)\n        self._toolitems = {}\n        self._groups = {}  # Mapping of groups to the separator after them."
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        # Find or create the separator that follows this group.\n        if group not in self._groups:\n            self._groups[group] = self.InsertSeparator(\n                self._get_tool_pos(self._space))\n        sep = self._groups[group]\n        # List all separators.\n        seps = [t for t in map(self.GetToolByPos, range(self.ToolsCount))\n                if t.IsSeparator() and not t.IsStretchableSpace()]\n        # Find where to insert the tool.\n        if position >= 0:\n            # Find the start of the group by looking for the separator\n            # preceding this one; then move forward from it.\n            start = (0 if sep == seps[0]\n                     else self._get_tool_pos(seps[seps.index(sep) - 1]) + 1)\n        else:\n            # Move backwards from this separator.\n            start = self._get_tool_pos(sep) + 1\n        idx = start + position\n        if image_file:\n            bmp = NavigationToolbar2Wx._icon(image_file)\n            kind = wx.ITEM_NORMAL if not toggle else wx.ITEM_CHECK\n            tool = self.InsertTool(idx, -1, name, bmp, wx.NullBitmap, kind,\n                                   description or \"\")\n        else:\n            size = (self.GetTextExtent(name)[0] + 10, -1)\n            if toggle:\n                control = wx.ToggleButton(self, -1, name, size=size)\n            else:\n                control = wx.Button(self, -1, name, size=size)\n            tool = self.InsertControl(idx, control, label=name)\n        self.Realize()\n\n        def handler(event):\n            self.trigger_tool(name)\n\n        if image_file:\n            self.Bind(wx.EVT_TOOL, handler, tool)\n        else:\n            control.Bind(wx.EVT_LEFT_DOWN, handler)\n\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tool, handler))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        for tool, handler in self._toolitems[name]:\n            self.DeleteTool(tool.Id)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self._label_text.SetLabel(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for tool, handler in self._toolitems[name]:\n            if not tool.IsControl():\n                self.ToggleTool(tool.Id, toggled)\n            else:\n                tool.GetControl().SetValue(toggled)\n        self.Refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/error_msg_wx",
      "name": "error_msg_wx",
      "qname": "lib.matplotlib.backends.backend_wx.error_msg_wx",
      "decorators": [
        "_api.deprecated('3.6')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/error_msg_wx/msg",
          "name": "msg",
          "qname": "lib.matplotlib.backends.backend_wx.error_msg_wx.msg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/error_msg_wx/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_wx.error_msg_wx.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Signal an error condition with a popup error dialog.",
      "docstring": "Signal an error condition with a popup error dialog.",
      "code": "@_api.deprecated(\"3.6\")\ndef error_msg_wx(msg, parent=None):\n    \"\"\"Signal an error condition with a popup error dialog.\"\"\"\n    dialog = wx.MessageDialog(parent=parent,\n                              message=msg,\n                              caption='Matplotlib backend_wx error',\n                              style=wx.OK | wx.CENTRE)\n    dialog.ShowModal()\n    dialog.Destroy()\n    return None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # docstring inherited\n        bitmap = _rgba_to_wx_bitmap(self.get_renderer().buffer_rgba())\n        if bbox is None:\n            self.bitmap = bitmap\n        else:\n            srcDC = wx.MemoryDC(bitmap)\n            destDC = wx.MemoryDC(self.bitmap)\n            x = int(bbox.x0)\n            y = int(self.bitmap.GetHeight() - bbox.y1)\n            destDC.Blit(x, y, int(bbox.width), int(bbox.height), srcDC, x, y)\n            destDC.SelectObject(wx.NullBitmap)\n            srcDC.SelectObject(wx.NullBitmap)\n        self.gui_repaint()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw/drawDC",
          "name": "drawDC",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.draw.drawDC",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure using agg.",
      "docstring": "Render the figure using agg.",
      "code": "    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using agg.\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n        self.bitmap = _rgba_to_wx_bitmap(self.get_renderer().buffer_rgba())\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg.get_canvas",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas(self, fig):\n        return FigureCanvasWxAgg(self, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw/drawDC",
          "name": "drawDC",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.draw.drawDC",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self, drawDC=None):\n        size = self.figure.bbox.size.astype(int)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, *size)\n        self._renderer.set_context(cairo.Context(surface))\n        self._renderer.dpi = self.figure.dpi\n        self.figure.draw(self._renderer)\n        self.bitmap = wxcairo.BitmapFromImageSurface(surface)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo.get_canvas",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas(self, fig):\n        return FigureCanvasWxCairo(self, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.qt_editor.figureoptions/figure_edit",
      "name": "figure_edit",
      "qname": "lib.matplotlib.backends.qt_editor.figureoptions.figure_edit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.qt_editor.figureoptions/figure_edit/axes",
          "name": "axes",
          "qname": "lib.matplotlib.backends.qt_editor.figureoptions.figure_edit.axes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.qt_editor.figureoptions/figure_edit/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.qt_editor.figureoptions.figure_edit.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Edit matplotlib figure options",
      "docstring": "Edit matplotlib figure options",
      "code": "def figure_edit(axes, parent=None):\n    \"\"\"Edit matplotlib figure options\"\"\"\n    sep = (None, None)  # separator\n\n    # Get / General\n    def convert_limits(lim, converter):\n        \"\"\"Convert axis limits for correct input editors.\"\"\"\n        if isinstance(converter, DateConverter):\n            return map(num2date, lim)\n        # Cast to builtin floats as they have nicer reprs.\n        return map(float, lim)\n\n    xconverter = axes.xaxis.converter\n    xmin, xmax = convert_limits(axes.get_xlim(), xconverter)\n    yconverter = axes.yaxis.converter\n    ymin, ymax = convert_limits(axes.get_ylim(), yconverter)\n    general = [('Title', axes.get_title()),\n               sep,\n               (None, \"<b>X-Axis</b>\"),\n               ('Left', xmin), ('Right', xmax),\n               ('Label', axes.get_xlabel()),\n               ('Scale', [axes.get_xscale(),\n                          'linear', 'log', 'symlog', 'logit']),\n               sep,\n               (None, \"<b>Y-Axis</b>\"),\n               ('Bottom', ymin), ('Top', ymax),\n               ('Label', axes.get_ylabel()),\n               ('Scale', [axes.get_yscale(),\n                          'linear', 'log', 'symlog', 'logit']),\n               sep,\n               ('(Re-)Generate automatic legend', False),\n               ]\n\n    # Save the unit data\n    xunits = axes.xaxis.get_units()\n    yunits = axes.yaxis.get_units()\n\n    # Get / Curves\n    labeled_lines = []\n    for line in axes.get_lines():\n        label = line.get_label()\n        if label == '_nolegend_':\n            continue\n        labeled_lines.append((label, line))\n    curves = []\n\n    def prepare_data(d, init):\n        \"\"\"\n        Prepare entry for FormLayout.\n\n        *d* is a mapping of shorthands to style names (a single style may\n        have multiple shorthands, in particular the shorthands `None`,\n        `\"None\"`, `\"none\"` and `\"\"` are synonyms); *init* is one shorthand\n        of the initial style.\n\n        This function returns an list suitable for initializing a\n        FormLayout combobox, namely `[initial_name, (shorthand,\n        style_name), (shorthand, style_name), ...]`.\n        \"\"\"\n        if init not in d:\n            d = {**d, init: str(init)}\n        # Drop duplicate shorthands from dict (by overwriting them during\n        # the dict comprehension).\n        name2short = {name: short for short, name in d.items()}\n        # Convert back to {shorthand: name}.\n        short2name = {short: name for name, short in name2short.items()}\n        # Find the kept shorthand for the style specified by init.\n        canonical_init = name2short[d[init]]\n        # Sort by representation and prepend the initial value.\n        return ([canonical_init] +\n                sorted(short2name.items(),\n                       key=lambda short_and_name: short_and_name[1]))\n\n    for label, line in labeled_lines:\n        color = mcolors.to_hex(\n            mcolors.to_rgba(line.get_color(), line.get_alpha()),\n            keep_alpha=True)\n        ec = mcolors.to_hex(\n            mcolors.to_rgba(line.get_markeredgecolor(), line.get_alpha()),\n            keep_alpha=True)\n        fc = mcolors.to_hex(\n            mcolors.to_rgba(line.get_markerfacecolor(), line.get_alpha()),\n            keep_alpha=True)\n        curvedata = [\n            ('Label', label),\n            sep,\n            (None, '<b>Line</b>'),\n            ('Line style', prepare_data(LINESTYLES, line.get_linestyle())),\n            ('Draw style', prepare_data(DRAWSTYLES, line.get_drawstyle())),\n            ('Width', line.get_linewidth()),\n            ('Color (RGBA)', color),\n            sep,\n            (None, '<b>Marker</b>'),\n            ('Style', prepare_data(MARKERS, line.get_marker())),\n            ('Size', line.get_markersize()),\n            ('Face color (RGBA)', fc),\n            ('Edge color (RGBA)', ec)]\n        curves.append([curvedata, label, \"\"])\n    # Is there a curve displayed?\n    has_curve = bool(curves)\n\n    # Get ScalarMappables.\n    labeled_mappables = []\n    for mappable in [*axes.images, *axes.collections]:\n        label = mappable.get_label()\n        if label == '_nolegend_' or mappable.get_array() is None:\n            continue\n        labeled_mappables.append((label, mappable))\n    mappables = []\n    cmaps = [(cmap, name) for name, cmap in sorted(cm._colormaps.items())]\n    for label, mappable in labeled_mappables:\n        cmap = mappable.get_cmap()\n        if cmap not in cm._colormaps.values():\n            cmaps = [(cmap, cmap.name), *cmaps]\n        low, high = mappable.get_clim()\n        mappabledata = [\n            ('Label', label),\n            ('Colormap', [cmap.name] + cmaps),\n            ('Min. value', low),\n            ('Max. value', high),\n        ]\n        if hasattr(mappable, \"get_interpolation\"):  # Images.\n            interpolations = [\n                (name, name) for name in sorted(mimage.interpolations_names)]\n            mappabledata.append((\n                'Interpolation',\n                [mappable.get_interpolation(), *interpolations]))\n        mappables.append([mappabledata, label, \"\"])\n    # Is there a scalarmappable displayed?\n    has_sm = bool(mappables)\n\n    datalist = [(general, \"Axes\", \"\")]\n    if curves:\n        datalist.append((curves, \"Curves\", \"\"))\n    if mappables:\n        datalist.append((mappables, \"Images, etc.\", \"\"))\n\n    def apply_callback(data):\n        \"\"\"A callback to apply changes.\"\"\"\n        orig_xlim = axes.get_xlim()\n        orig_ylim = axes.get_ylim()\n\n        general = data.pop(0)\n        curves = data.pop(0) if has_curve else []\n        mappables = data.pop(0) if has_sm else []\n        if data:\n            raise ValueError(\"Unexpected field\")\n\n        # Set / General\n        (title, xmin, xmax, xlabel, xscale, ymin, ymax, ylabel, yscale,\n         generate_legend) = general\n\n        if axes.get_xscale() != xscale:\n            axes.set_xscale(xscale)\n        if axes.get_yscale() != yscale:\n            axes.set_yscale(yscale)\n\n        axes.set_title(title)\n        axes.set_xlim(xmin, xmax)\n        axes.set_xlabel(xlabel)\n        axes.set_ylim(ymin, ymax)\n        axes.set_ylabel(ylabel)\n\n        # Restore the unit data\n        axes.xaxis.converter = xconverter\n        axes.yaxis.converter = yconverter\n        axes.xaxis.set_units(xunits)\n        axes.yaxis.set_units(yunits)\n        axes.xaxis._update_axisinfo()\n        axes.yaxis._update_axisinfo()\n\n        # Set / Curves\n        for index, curve in enumerate(curves):\n            line = labeled_lines[index][1]\n            (label, linestyle, drawstyle, linewidth, color, marker, markersize,\n             markerfacecolor, markeredgecolor) = curve\n            line.set_label(label)\n            line.set_linestyle(linestyle)\n            line.set_drawstyle(drawstyle)\n            line.set_linewidth(linewidth)\n            rgba = mcolors.to_rgba(color)\n            line.set_alpha(None)\n            line.set_color(rgba)\n            if marker != 'none':\n                line.set_marker(marker)\n                line.set_markersize(markersize)\n                line.set_markerfacecolor(markerfacecolor)\n                line.set_markeredgecolor(markeredgecolor)\n\n        # Set ScalarMappables.\n        for index, mappable_settings in enumerate(mappables):\n            mappable = labeled_mappables[index][1]\n            if len(mappable_settings) == 5:\n                label, cmap, low, high, interpolation = mappable_settings\n                mappable.set_interpolation(interpolation)\n            elif len(mappable_settings) == 4:\n                label, cmap, low, high = mappable_settings\n            mappable.set_label(label)\n            mappable.set_cmap(cm.get_cmap(cmap))\n            mappable.set_clim(*sorted([low, high]))\n\n        # re-generate legend, if checkbox is checked\n        if generate_legend:\n            draggable = None\n            ncols = 1\n            if axes.legend_ is not None:\n                old_legend = axes.get_legend()\n                draggable = old_legend._draggable is not None\n                ncols = old_legend._ncols\n            new_legend = axes.legend(ncols=ncols)\n            if new_legend:\n                new_legend.set_draggable(draggable)\n\n        # Redraw\n        figure = axes.get_figure()\n        figure.canvas.draw()\n        if not (axes.get_xlim() == orig_xlim and axes.get_ylim() == orig_ylim):\n            figure.canvas.toolbar.push_current()\n\n    _formlayout.fedit(\n        datalist, title=\"Figure options\", parent=parent,\n        icon=QtGui.QIcon(\n            str(cbook._get_data_path('images', 'qt4_editor_options.svg'))),\n        apply=apply_callback)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__getstate__",
      "name": "__getstate__",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.__getstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__getstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__getstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getstate__(self):\n        return {\n            **vars(self),\n            # In general, callbacks may not be pickled, so we just drop them,\n            # unless directed otherwise by self._pickled_cids.\n            \"callbacks\": {s: {cid: proxy() for cid, proxy in d.items()\n                              if cid in self._pickled_cids}\n                          for s, d in self.callbacks.items()},\n            # It is simpler to reconstruct this from callbacks in __setstate__.\n            \"_func_cid_map\": None,\n        }"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__/exception_handler",
          "name": "exception_handler",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__.exception_handler",
          "default_value": "_exception_printer",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "If not None, *exception_handler* must be a function that takes an\n`Exception` as single parameter.  It gets called with any `Exception`\nraised by the callbacks during `CallbackRegistry.process`, and may\neither re-raise the exception or handle it in another manner.\n\nThe default handler prints the exception (with `traceback.print_exc`) if\nan interactive event loop is running; it re-raises the exception if no\ninteractive event loop is running."
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__/signals",
          "name": "signals",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__.signals",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "list",
            "default_value": "",
            "description": "If not None, *signals* is a list of signals that this registry handles:\nattempting to `process` or to `connect` to a signal not in the list\nthrows a `ValueError`.  The default, None, does not restrict the\nhandled signals."
          },
          "type": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Handle registering, processing, blocking, and disconnecting\nfor a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...    print('eat', x)\n    >>> def ondrink(x):\n    ...    print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456)   # nothing will be called\n\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)        # nothing will be called\n\n    >>> with callbacks.blocked(signal='drink'):\n    ...     callbacks.process('drink', 123)  # nothing will be called\n    >>> callbacks.process('drink', 123)\n    drink 123\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.",
      "docstring": "",
      "code": "    def __init__(self, exception_handler=_exception_printer, *, signals=None):\n        self._signals = None if signals is None else list(signals)  # Copy it.\n        self.exception_handler = exception_handler\n        self.callbacks = {}\n        self._cid_gen = itertools.count()\n        self._func_cid_map = {}\n        # A hidden variable that marks cids that need to be pickled.\n        self._pickled_cids = set()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__setstate__",
      "name": "__setstate__",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.__setstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__setstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__setstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__setstate__/state",
          "name": "state",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__setstate__.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __setstate__(self, state):\n        vars(self).update(state)\n        self.callbacks = {\n            s: {cid: _weak_or_strong_ref(func, self._remove_proxy)\n                for cid, func in d.items()}\n            for s, d in self.callbacks.items()}\n        self._func_cid_map = {\n            s: {proxy: cid for cid, proxy in d.items()}\n            for s, d in self.callbacks.items()}"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/blocked",
      "name": "blocked",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.blocked",
      "decorators": [
        "contextlib.contextmanager"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/blocked/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.blocked.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/blocked/signal",
          "name": "signal",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.blocked.signal",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The callback signal to block. The default is to block all signals."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Block callback signals from being processed.\n\nA context manager to temporarily block/disable callback signals\nfrom being processed by the registered listeners.",
      "docstring": "Block callback signals from being processed.\n\nA context manager to temporarily block/disable callback signals\nfrom being processed by the registered listeners.\n\nParameters\n----------\nsignal : str, optional\n    The callback signal to block. The default is to block all signals.",
      "code": "    @contextlib.contextmanager\n    def blocked(self, *, signal=None):\n        \"\"\"\n        Block callback signals from being processed.\n\n        A context manager to temporarily block/disable callback signals\n        from being processed by the registered listeners.\n\n        Parameters\n        ----------\n        signal : str, optional\n            The callback signal to block. The default is to block all signals.\n        \"\"\"\n        orig = self.callbacks\n        try:\n            if signal is None:\n                # Empty out the callbacks\n                self.callbacks = {}\n            else:\n                # Only remove the specific signal\n                self.callbacks = {k: orig[k] for k in orig if k != signal}\n            yield\n        finally:\n            self.callbacks = orig"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect",
      "name": "connect",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.connect",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.connect.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect/signal",
          "name": "signal",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.connect.signal",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect/func",
          "name": "func",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.connect.func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Register *func* to be called when signal *signal* is generated.",
      "docstring": "Register *func* to be called when signal *signal* is generated.",
      "code": "    def connect(self, signal, func):\n        \"\"\"Register *func* to be called when signal *signal* is generated.\"\"\"\n        if signal == \"units finalize\":\n            _api.warn_deprecated(\n                \"3.5\", name=signal, obj_type=\"signal\", alternative=\"units\")\n        if self._signals is not None:\n            _api.check_in_list(self._signals, signal=signal)\n        self._func_cid_map.setdefault(signal, {})\n        proxy = _weak_or_strong_ref(func, self._remove_proxy)\n        if proxy in self._func_cid_map[signal]:\n            return self._func_cid_map[signal][proxy]\n        cid = next(self._cid_gen)\n        self._func_cid_map[signal][proxy] = cid\n        self.callbacks.setdefault(signal, {})\n        self.callbacks[signal][cid] = proxy\n        return cid"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect",
      "name": "disconnect",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.disconnect",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.disconnect.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect/cid",
          "name": "cid",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.disconnect.cid",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Disconnect the callback registered with callback id *cid*.\n\nNo error is raised if such a callback does not exist.",
      "docstring": "Disconnect the callback registered with callback id *cid*.\n\nNo error is raised if such a callback does not exist.",
      "code": "    def disconnect(self, cid):\n        \"\"\"\n        Disconnect the callback registered with callback id *cid*.\n\n        No error is raised if such a callback does not exist.\n        \"\"\"\n        self._pickled_cids.discard(cid)\n        # Clean up callbacks\n        for signal, cid_to_proxy in list(self.callbacks.items()):\n            proxy = cid_to_proxy.pop(cid, None)\n            if proxy is not None:\n                break\n        else:\n            # Not found\n            return\n\n        proxy_to_cid = self._func_cid_map[signal]\n        for current_proxy, current_cid in list(proxy_to_cid.items()):\n            if current_cid == cid:\n                assert proxy is current_proxy\n                del proxy_to_cid[current_proxy]\n        # Clean up empty dicts\n        if len(self.callbacks[signal]) == 0:\n            del self.callbacks[signal]\n            del self._func_cid_map[signal]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process",
      "name": "process",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.process",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Process signal *s*.\n\nAll of the functions registered to receive callbacks on *s* will be\ncalled with ``*args`` and ``**kwargs``.",
      "docstring": "Process signal *s*.\n\nAll of the functions registered to receive callbacks on *s* will be\ncalled with ``*args`` and ``**kwargs``.",
      "code": "    def process(self, s, *args, **kwargs):\n        \"\"\"\n        Process signal *s*.\n\n        All of the functions registered to receive callbacks on *s* will be\n        called with ``*args`` and ``**kwargs``.\n        \"\"\"\n        if self._signals is not None:\n            _api.check_in_list(self._signals, signal=s)\n        for cid, ref in list(self.callbacks.get(s, {}).items()):\n            func = ref()\n            if func is not None:\n                try:\n                    func(*args, **kwargs)\n                # this does not capture KeyboardInterrupt, SystemExit,\n                # and GeneratorExit\n                except Exception as exc:\n                    if self.exception_handler is not None:\n                        self.exception_handler(exc)\n                    else:\n                        raise"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/__contains__",
      "name": "__contains__",
      "qname": "lib.matplotlib.cbook.Grouper.__contains__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__contains__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.__contains__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__contains__/item",
          "name": "item",
          "qname": "lib.matplotlib.cbook.Grouper.__contains__.item",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.Grouper.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__init__/init",
          "name": "init",
          "qname": "lib.matplotlib.cbook.Grouper.__init__.init",
          "default_value": "()",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.",
      "docstring": "",
      "code": "    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/__iter__",
      "name": "__iter__",
      "qname": "lib.matplotlib.cbook.Grouper.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__iter__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Iterate over each of the disjoint sets as a list.\n\nThe iterator is invalid if interleaved with calls to join().",
      "docstring": "Iterate over each of the disjoint sets as a list.\n\nThe iterator is invalid if interleaved with calls to join().",
      "code": "    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/clean",
      "name": "clean",
      "qname": "lib.matplotlib.cbook.Grouper.clean",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/clean/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.clean.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Clean dead weak references from the dictionary.",
      "docstring": "Clean dead weak references from the dictionary.",
      "code": "    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings",
      "name": "get_siblings",
      "qname": "lib.matplotlib.cbook.Grouper.get_siblings",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.get_siblings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.get_siblings.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return all of the items joined with *a*, including itself.",
      "docstring": "Return all of the items joined with *a*, including itself.",
      "code": "    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/join",
      "name": "join",
      "qname": "lib.matplotlib.cbook.Grouper.join",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/join/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.join.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/join/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.join.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/join/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.Grouper.join.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Join given arguments into the same set.  Accepts one or more arguments.",
      "docstring": "Join given arguments into the same set.  Accepts one or more arguments.",
      "code": "    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined",
      "name": "joined",
      "qname": "lib.matplotlib.cbook.Grouper.joined",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.joined.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.joined.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined/b",
          "name": "b",
          "qname": "lib.matplotlib.cbook.Grouper.joined.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether *a* and *b* are members of the same set.",
      "docstring": "Return whether *a* and *b* are members of the same set.",
      "code": "    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/remove",
      "name": "remove",
      "qname": "lib.matplotlib.cbook.Grouper.remove",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/remove/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.remove.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/remove/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.remove.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/GrouperView/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.GrouperView.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/GrouperView/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.GrouperView.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/GrouperView/__init__/grouper",
          "name": "grouper",
          "qname": "lib.matplotlib.cbook.GrouperView.__init__.grouper",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Immutable view over a `.Grouper`.",
      "docstring": "",
      "code": "    def __init__(self, grouper):\n        self._grouper = grouper"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.cbook.Stack.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the current element, or None.",
      "docstring": "Return the current element, or None.",
      "code": "    def __call__(self):\n        \"\"\"Return the current element, or None.\"\"\"\n        if not self._elements:\n            return self._default\n        else:\n            return self._elements[self._pos]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__getitem__",
      "name": "__getitem__",
      "qname": "lib.matplotlib.cbook.Stack.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__getitem__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__getitem__/ind",
          "name": "ind",
          "qname": "lib.matplotlib.cbook.Stack.__getitem__.ind",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getitem__(self, ind):\n        return self._elements[ind]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.Stack.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__init__/default",
          "name": "default",
          "qname": "lib.matplotlib.cbook.Stack.__init__.default",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "docstring": "",
      "code": "    def __init__(self, default=None):\n        self.clear()\n        self._default = default"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__len__",
      "name": "__len__",
      "qname": "lib.matplotlib.cbook.Stack.__len__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__len__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__len__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __len__(self):\n        return len(self._elements)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/back",
      "name": "back",
      "qname": "lib.matplotlib.cbook.Stack.back",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/back/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.back.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move the position back and return the current element.",
      "docstring": "Move the position back and return the current element.",
      "code": "    def back(self):\n        \"\"\"Move the position back and return the current element.\"\"\"\n        if self._pos > 0:\n            self._pos -= 1\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/bubble",
      "name": "bubble",
      "qname": "lib.matplotlib.cbook.Stack.bubble",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/bubble/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.bubble.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/bubble/o",
          "name": "o",
          "qname": "lib.matplotlib.cbook.Stack.bubble.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Raise all references of *o* to the top of the stack, and return it.",
      "docstring": "Raise all references of *o* to the top of the stack, and return it.\n\nRaises\n------\nValueError\n    If *o* is not in the stack.",
      "code": "    def bubble(self, o):\n        \"\"\"\n        Raise all references of *o* to the top of the stack, and return it.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        top_elements = []\n        for elem in old_elements:\n            if elem == o:\n                top_elements.append(elem)\n            else:\n                self.push(elem)\n        for _ in top_elements:\n            self.push(o)\n        return o"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/clear",
      "name": "clear",
      "qname": "lib.matplotlib.cbook.Stack.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Empty the stack.",
      "docstring": "Empty the stack.",
      "code": "    def clear(self):\n        \"\"\"Empty the stack.\"\"\"\n        self._pos = -1\n        self._elements = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/empty",
      "name": "empty",
      "qname": "lib.matplotlib.cbook.Stack.empty",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/empty/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.empty.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the stack is empty.",
      "docstring": "Return whether the stack is empty.",
      "code": "    def empty(self):\n        \"\"\"Return whether the stack is empty.\"\"\"\n        return len(self._elements) == 0"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/forward",
      "name": "forward",
      "qname": "lib.matplotlib.cbook.Stack.forward",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/forward/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.forward.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move the position forward and return the current element.",
      "docstring": "Move the position forward and return the current element.",
      "code": "    def forward(self):\n        \"\"\"Move the position forward and return the current element.\"\"\"\n        self._pos = min(self._pos + 1, len(self._elements) - 1)\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/home",
      "name": "home",
      "qname": "lib.matplotlib.cbook.Stack.home",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/home/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.home.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Push the first element onto the top of the stack.\n\nThe first element is returned.",
      "docstring": "Push the first element onto the top of the stack.\n\nThe first element is returned.",
      "code": "    def home(self):\n        \"\"\"\n        Push the first element onto the top of the stack.\n\n        The first element is returned.\n        \"\"\"\n        if not self._elements:\n            return\n        self.push(self._elements[0])\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/push",
      "name": "push",
      "qname": "lib.matplotlib.cbook.Stack.push",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/push/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.push.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/push/o",
          "name": "o",
          "qname": "lib.matplotlib.cbook.Stack.push.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Push *o* to the stack at current position.  Discard all later elements.\n\n*o* is returned.",
      "docstring": "Push *o* to the stack at current position.  Discard all later elements.\n\n*o* is returned.",
      "code": "    def push(self, o):\n        \"\"\"\n        Push *o* to the stack at current position.  Discard all later elements.\n\n        *o* is returned.\n        \"\"\"\n        self._elements = self._elements[:self._pos + 1] + [o]\n        self._pos = len(self._elements) - 1\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/remove",
      "name": "remove",
      "qname": "lib.matplotlib.cbook.Stack.remove",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/remove/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.remove.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/remove/o",
          "name": "o",
          "qname": "lib.matplotlib.cbook.Stack.remove.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Remove *o* from the stack.",
      "docstring": "Remove *o* from the stack.\n\nRaises\n------\nValueError\n    If *o* is not in the stack.",
      "code": "    def remove(self, o):\n        \"\"\"\n        Remove *o* from the stack.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        for elem in old_elements:\n            if elem != o:\n                self.push(elem)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats",
      "name": "boxplot_stats",
      "qname": "lib.matplotlib.cbook.boxplot_stats",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/X",
          "name": "X",
          "qname": "lib.matplotlib.cbook.boxplot_stats.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Data that will be represented in the boxplots. Should have 2 or\nfewer dimensions."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/whis",
          "name": "whis",
          "qname": "lib.matplotlib.cbook.boxplot_stats.whis",
          "default_value": "1.5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float or (float, float)",
            "default_value": "1.5",
            "description": "The position of the whiskers.\n\nIf a float, the lower whisker is at the lowest datum above\n``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\nquartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\noriginal definition of boxplots.\n\nIf a pair of floats, they indicate the percentiles at which to draw the\nwhiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\nresults in whiskers covering the whole range of the data.\n\nIn the edge case where ``Q1 == Q3``, *whis* is automatically set to\n(0, 100) (cover the whole range of the data) if *autorange* is True.\n\nBeyond the whiskers, data are considered outliers and are plotted as\nindividual points."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "(float, float)"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/bootstrap",
          "name": "bootstrap",
          "qname": "lib.matplotlib.cbook.boxplot_stats.bootstrap",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Number of times the confidence intervals around the median\nshould be bootstrapped (percentile method)."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/labels",
          "name": "labels",
          "qname": "lib.matplotlib.cbook.boxplot_stats.labels",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Labels for each dataset. Length must be compatible with\ndimensions of *X*."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/autorange",
          "name": "autorange",
          "qname": "lib.matplotlib.cbook.boxplot_stats.autorange",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "(False)",
            "description": "When `True` and the data are distributed such that the 25th and 75th\npercentiles are equal, ``whis`` is set to (0, 100) such that the\nwhisker ends are at the minimum and maximum of the data."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of dictionaries of statistics used to draw a series of box\nand whisker plots using `~.Axes.bxp`.",
      "docstring": "Return a list of dictionaries of statistics used to draw a series of box\nand whisker plots using `~.Axes.bxp`.\n\nParameters\n----------\nX : array-like\n    Data that will be represented in the boxplots. Should have 2 or\n    fewer dimensions.\n\nwhis : float or (float, float), default: 1.5\n    The position of the whiskers.\n\n    If a float, the lower whisker is at the lowest datum above\n    ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n    ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\n    quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\n    original definition of boxplots.\n\n    If a pair of floats, they indicate the percentiles at which to draw the\n    whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\n    results in whiskers covering the whole range of the data.\n\n    In the edge case where ``Q1 == Q3``, *whis* is automatically set to\n    (0, 100) (cover the whole range of the data) if *autorange* is True.\n\n    Beyond the whiskers, data are considered outliers and are plotted as\n    individual points.\n\nbootstrap : int, optional\n    Number of times the confidence intervals around the median\n    should be bootstrapped (percentile method).\n\nlabels : array-like, optional\n    Labels for each dataset. Length must be compatible with\n    dimensions of *X*.\n\nautorange : bool, optional (False)\n    When `True` and the data are distributed such that the 25th and 75th\n    percentiles are equal, ``whis`` is set to (0, 100) such that the\n    whisker ends are at the minimum and maximum of the data.\n\nReturns\n-------\nlist of dict\n    A list of dictionaries containing the results for each column\n    of data. Keys of each dictionary are the following:\n\n    ========   ===================================\n    Key        Value Description\n    ========   ===================================\n    label      tick label for the boxplot\n    mean       arithmetic mean value\n    med        50th percentile\n    q1         first quartile (25th percentile)\n    q3         third quartile (75th percentile)\n    iqr        interquartile range\n    cilo       lower notch around the median\n    cihi       upper notch around the median\n    whislo     end of the lower whisker\n    whishi     end of the upper whisker\n    fliers     outliers\n    ========   ===================================\n\nNotes\n-----\nNon-bootstrapping approach to confidence interval uses Gaussian-based\nasymptotic approximation:\n\n.. math::\n\n    \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}\n\nGeneral approach from:\nMcGill, R., Tukey, J.W., and Larsen, W.A. (1978) \"Variations of\nBoxplots\", The American Statistician, 32:12-16.",
      "code": "def boxplot_stats(X, whis=1.5, bootstrap=None, labels=None,\n                  autorange=False):\n    r\"\"\"\n    Return a list of dictionaries of statistics used to draw a series of box\n    and whisker plots using `~.Axes.bxp`.\n\n    Parameters\n    ----------\n    X : array-like\n        Data that will be represented in the boxplots. Should have 2 or\n        fewer dimensions.\n\n    whis : float or (float, float), default: 1.5\n        The position of the whiskers.\n\n        If a float, the lower whisker is at the lowest datum above\n        ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n        ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\n        quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\n        original definition of boxplots.\n\n        If a pair of floats, they indicate the percentiles at which to draw the\n        whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\n        results in whiskers covering the whole range of the data.\n\n        In the edge case where ``Q1 == Q3``, *whis* is automatically set to\n        (0, 100) (cover the whole range of the data) if *autorange* is True.\n\n        Beyond the whiskers, data are considered outliers and are plotted as\n        individual points.\n\n    bootstrap : int, optional\n        Number of times the confidence intervals around the median\n        should be bootstrapped (percentile method).\n\n    labels : array-like, optional\n        Labels for each dataset. Length must be compatible with\n        dimensions of *X*.\n\n    autorange : bool, optional (False)\n        When `True` and the data are distributed such that the 25th and 75th\n        percentiles are equal, ``whis`` is set to (0, 100) such that the\n        whisker ends are at the minimum and maximum of the data.\n\n    Returns\n    -------\n    list of dict\n        A list of dictionaries containing the results for each column\n        of data. Keys of each dictionary are the following:\n\n        ========   ===================================\n        Key        Value Description\n        ========   ===================================\n        label      tick label for the boxplot\n        mean       arithmetic mean value\n        med        50th percentile\n        q1         first quartile (25th percentile)\n        q3         third quartile (75th percentile)\n        iqr        interquartile range\n        cilo       lower notch around the median\n        cihi       upper notch around the median\n        whislo     end of the lower whisker\n        whishi     end of the upper whisker\n        fliers     outliers\n        ========   ===================================\n\n    Notes\n    -----\n    Non-bootstrapping approach to confidence interval uses Gaussian-based\n    asymptotic approximation:\n\n    .. math::\n\n        \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}\n\n    General approach from:\n    McGill, R., Tukey, J.W., and Larsen, W.A. (1978) \"Variations of\n    Boxplots\", The American Statistician, 32:12-16.\n    \"\"\"\n\n    def _bootstrap_median(data, N=5000):\n        # determine 95% confidence intervals of the median\n        M = len(data)\n        percentiles = [2.5, 97.5]\n\n        bs_index = np.random.randint(M, size=(N, M))\n        bsData = data[bs_index]\n        estimate = np.median(bsData, axis=1, overwrite_input=True)\n\n        CI = np.percentile(estimate, percentiles)\n        return CI\n\n    def _compute_conf_interval(data, med, iqr, bootstrap):\n        if bootstrap is not None:\n            # Do a bootstrap estimate of notch locations.\n            # get conf. intervals around median\n            CI = _bootstrap_median(data, N=bootstrap)\n            notch_min = CI[0]\n            notch_max = CI[1]\n        else:\n\n            N = len(data)\n            notch_min = med - 1.57 * iqr / np.sqrt(N)\n            notch_max = med + 1.57 * iqr / np.sqrt(N)\n\n        return notch_min, notch_max\n\n    # output is a list of dicts\n    bxpstats = []\n\n    # convert X to a list of lists\n    X = _reshape_2D(X, \"X\")\n\n    ncols = len(X)\n    if labels is None:\n        labels = itertools.repeat(None)\n    elif len(labels) != ncols:\n        raise ValueError(\"Dimensions of labels and X must be compatible\")\n\n    input_whis = whis\n    for ii, (x, label) in enumerate(zip(X, labels)):\n\n        # empty dict\n        stats = {}\n        if label is not None:\n            stats['label'] = label\n\n        # restore whis to the input values in case it got changed in the loop\n        whis = input_whis\n\n        # note tricksiness, append up here and then mutate below\n        bxpstats.append(stats)\n\n        # if empty, bail\n        if len(x) == 0:\n            stats['fliers'] = np.array([])\n            stats['mean'] = np.nan\n            stats['med'] = np.nan\n            stats['q1'] = np.nan\n            stats['q3'] = np.nan\n            stats['iqr'] = np.nan\n            stats['cilo'] = np.nan\n            stats['cihi'] = np.nan\n            stats['whislo'] = np.nan\n            stats['whishi'] = np.nan\n            continue\n\n        # up-convert to an array, just to be safe\n        x = np.asarray(x)\n\n        # arithmetic mean\n        stats['mean'] = np.mean(x)\n\n        # medians and quartiles\n        q1, med, q3 = np.percentile(x, [25, 50, 75])\n\n        # interquartile range\n        stats['iqr'] = q3 - q1\n        if stats['iqr'] == 0 and autorange:\n            whis = (0, 100)\n\n        # conf. interval around median\n        stats['cilo'], stats['cihi'] = _compute_conf_interval(\n            x, med, stats['iqr'], bootstrap\n        )\n\n        # lowest/highest non-outliers\n        if np.iterable(whis) and not isinstance(whis, str):\n            loval, hival = np.percentile(x, whis)\n        elif np.isreal(whis):\n            loval = q1 - whis * stats['iqr']\n            hival = q3 + whis * stats['iqr']\n        else:\n            raise ValueError('whis must be a float or list of percentiles')\n\n        # get high extreme\n        wiskhi = x[x <= hival]\n        if len(wiskhi) == 0 or np.max(wiskhi) < q3:\n            stats['whishi'] = q3\n        else:\n            stats['whishi'] = np.max(wiskhi)\n\n        # get low extreme\n        wisklo = x[x >= loval]\n        if len(wisklo) == 0 or np.min(wisklo) > q1:\n            stats['whislo'] = q1\n        else:\n            stats['whislo'] = np.min(wisklo)\n\n        # compute a single array of outliers\n        stats['fliers'] = np.concatenate([\n            x[x < stats['whislo']],\n            x[x > stats['whishi']],\n        ])\n\n        # add in the remaining stats\n        stats['q1'], stats['med'], stats['q3'] = q1, med, q3\n\n    return bxpstats"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/contiguous_regions",
      "name": "contiguous_regions",
      "qname": "lib.matplotlib.cbook.contiguous_regions",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/contiguous_regions/mask",
          "name": "mask",
          "qname": "lib.matplotlib.cbook.contiguous_regions.mask",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\nTrue and we cover all such regions.",
      "docstring": "Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\nTrue and we cover all such regions.",
      "code": "def contiguous_regions(mask):\n    \"\"\"\n    Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\n    True and we cover all such regions.\n    \"\"\"\n    mask = np.asarray(mask, dtype=bool)\n\n    if not mask.size:\n        return []\n\n    # Find the indices of region changes, and correct offset\n    idx, = np.nonzero(mask[:-1] != mask[1:])\n    idx += 1\n\n    # List operations are faster for moderately sized arrays\n    idx = idx.tolist()\n\n    # Add first and/or last index if needed\n    if mask[0]:\n        idx = [0] + idx\n    if mask[-1]:\n        idx.append(len(mask))\n\n    return list(zip(idx[::2], idx[1::2]))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/delete_masked_points",
      "name": "delete_masked_points",
      "qname": "lib.matplotlib.cbook.delete_masked_points",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/delete_masked_points/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.delete_masked_points.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Find all masked and/or non-finite points in a set of arguments,\nand return the arguments with only the unmasked points remaining.\n\nArguments can be in any of 5 categories:\n\n1) 1-D masked arrays\n2) 1-D ndarrays\n3) ndarrays with more than one dimension\n4) other non-string iterables\n5) anything else\n\nThe first argument must be in one of the first four categories;\nany argument with a length differing from that of the first\nargument (and hence anything in category 5) then will be\npassed through unchanged.\n\nMasks are obtained from all arguments of the correct length\nin categories 1, 2, and 4; a point is bad if masked in a masked\narray or if it is a nan or inf.  No attempt is made to\nextract a mask from categories 2, 3, and 4 if `numpy.isfinite`\ndoes not yield a Boolean array.\n\nAll input arguments that are not passed unchanged are returned\nas ndarrays after removing the points or rows corresponding to\nmasks in any of the arguments.\n\nA vastly simpler version of this function was originally\nwritten as a helper for Axes.scatter().",
      "docstring": "Find all masked and/or non-finite points in a set of arguments,\nand return the arguments with only the unmasked points remaining.\n\nArguments can be in any of 5 categories:\n\n1) 1-D masked arrays\n2) 1-D ndarrays\n3) ndarrays with more than one dimension\n4) other non-string iterables\n5) anything else\n\nThe first argument must be in one of the first four categories;\nany argument with a length differing from that of the first\nargument (and hence anything in category 5) then will be\npassed through unchanged.\n\nMasks are obtained from all arguments of the correct length\nin categories 1, 2, and 4; a point is bad if masked in a masked\narray or if it is a nan or inf.  No attempt is made to\nextract a mask from categories 2, 3, and 4 if `numpy.isfinite`\ndoes not yield a Boolean array.\n\nAll input arguments that are not passed unchanged are returned\nas ndarrays after removing the points or rows corresponding to\nmasks in any of the arguments.\n\nA vastly simpler version of this function was originally\nwritten as a helper for Axes.scatter().",
      "code": "def delete_masked_points(*args):\n    \"\"\"\n    Find all masked and/or non-finite points in a set of arguments,\n    and return the arguments with only the unmasked points remaining.\n\n    Arguments can be in any of 5 categories:\n\n    1) 1-D masked arrays\n    2) 1-D ndarrays\n    3) ndarrays with more than one dimension\n    4) other non-string iterables\n    5) anything else\n\n    The first argument must be in one of the first four categories;\n    any argument with a length differing from that of the first\n    argument (and hence anything in category 5) then will be\n    passed through unchanged.\n\n    Masks are obtained from all arguments of the correct length\n    in categories 1, 2, and 4; a point is bad if masked in a masked\n    array or if it is a nan or inf.  No attempt is made to\n    extract a mask from categories 2, 3, and 4 if `numpy.isfinite`\n    does not yield a Boolean array.\n\n    All input arguments that are not passed unchanged are returned\n    as ndarrays after removing the points or rows corresponding to\n    masks in any of the arguments.\n\n    A vastly simpler version of this function was originally\n    written as a helper for Axes.scatter().\n\n    \"\"\"\n    if not len(args):\n        return ()\n    if is_scalar_or_string(args[0]):\n        raise ValueError(\"First argument must be a sequence\")\n    nrecs = len(args[0])\n    margs = []\n    seqlist = [False] * len(args)\n    for i, x in enumerate(args):\n        if not isinstance(x, str) and np.iterable(x) and len(x) == nrecs:\n            seqlist[i] = True\n            if isinstance(x, np.ma.MaskedArray):\n                if x.ndim > 1:\n                    raise ValueError(\"Masked arrays must be 1-D\")\n            else:\n                x = np.asarray(x)\n        margs.append(x)\n    masks = []  # List of masks that are True where good.\n    for i, x in enumerate(margs):\n        if seqlist[i]:\n            if x.ndim > 1:\n                continue  # Don't try to get nan locations unless 1-D.\n            if isinstance(x, np.ma.MaskedArray):\n                masks.append(~np.ma.getmaskarray(x))  # invert the mask\n                xd = x.data\n            else:\n                xd = x\n            try:\n                mask = np.isfinite(xd)\n                if isinstance(mask, np.ndarray):\n                    masks.append(mask)\n            except Exception:  # Fixme: put in tuple of possible exceptions?\n                pass\n    if len(masks):\n        mask = np.logical_and.reduce(masks)\n        igood = mask.nonzero()[0]\n        if len(igood) < nrecs:\n            for i, x in enumerate(margs):\n                if seqlist[i]:\n                    margs[i] = x[igood]\n    for i, x in enumerate(margs):\n        if seqlist[i] and isinstance(x, np.ma.MaskedArray):\n            margs[i] = x.filled()\n    return margs"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/file_requires_unicode",
      "name": "file_requires_unicode",
      "qname": "lib.matplotlib.cbook.file_requires_unicode",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/file_requires_unicode/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.file_requires_unicode.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the given writable file-like object requires Unicode to be\nwritten to it.",
      "docstring": "Return whether the given writable file-like object requires Unicode to be\nwritten to it.",
      "code": "def file_requires_unicode(x):\n    \"\"\"\n    Return whether the given writable file-like object requires Unicode to be\n    written to it.\n    \"\"\"\n    try:\n        x.write(b'')\n    except TypeError:\n        return True\n    else:\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/flatten",
      "name": "flatten",
      "qname": "lib.matplotlib.cbook.flatten",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/flatten/seq",
          "name": "seq",
          "qname": "lib.matplotlib.cbook.flatten.seq",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/flatten/scalarp",
          "name": "scalarp",
          "qname": "lib.matplotlib.cbook.flatten.scalarp",
          "default_value": "is_scalar_or_string",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a generator of flattened nested containers.\n\nFor example:\n\n    >>> from matplotlib.cbook import flatten\n    >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n    >>> print(list(flatten(l)))\n    ['John', 'Hunter', 1, 23, 42, 5, 23]\n\nBy: Composite of Holger Krekel and Luther Blissett\nFrom: https://code.activestate.com/recipes/121294/\nand Recipe 1.12 in cookbook",
      "docstring": "Return a generator of flattened nested containers.\n\nFor example:\n\n    >>> from matplotlib.cbook import flatten\n    >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n    >>> print(list(flatten(l)))\n    ['John', 'Hunter', 1, 23, 42, 5, 23]\n\nBy: Composite of Holger Krekel and Luther Blissett\nFrom: https://code.activestate.com/recipes/121294/\nand Recipe 1.12 in cookbook",
      "code": "def flatten(seq, scalarp=is_scalar_or_string):\n    \"\"\"\n    Return a generator of flattened nested containers.\n\n    For example:\n\n        >>> from matplotlib.cbook import flatten\n        >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n        >>> print(list(flatten(l)))\n        ['John', 'Hunter', 1, 23, 42, 5, 23]\n\n    By: Composite of Holger Krekel and Luther Blissett\n    From: https://code.activestate.com/recipes/121294/\n    and Recipe 1.12 in cookbook\n    \"\"\"\n    for item in seq:\n        if scalarp(item) or item is None:\n            yield item\n        else:\n            yield from flatten(item, scalarp)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/get_sample_data",
      "name": "get_sample_data",
      "qname": "lib.matplotlib.cbook.get_sample_data",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_sample_data/fname",
          "name": "fname",
          "qname": "lib.matplotlib.cbook.get_sample_data.fname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_sample_data/asfileobj",
          "name": "asfileobj",
          "qname": "lib.matplotlib.cbook.get_sample_data.asfileobj",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_sample_data/np_load",
          "name": "np_load",
          "qname": "lib.matplotlib.cbook.get_sample_data.np_load",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a sample data file.  *fname* is a path relative to the\n:file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\nreturn a file object, otherwise just a file path.\n\nSample data files are stored in the 'mpl-data/sample_data' directory within\nthe Matplotlib package.\n\nIf the filename ends in .gz, the file is implicitly ungzipped.  If the\nfilename ends with .npy or .npz, *asfileobj* is True, and *np_load* is\nTrue, the file is loaded with `numpy.load`.  *np_load* currently defaults\nto False but will default to True in a future release.",
      "docstring": "Return a sample data file.  *fname* is a path relative to the\n:file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\nreturn a file object, otherwise just a file path.\n\nSample data files are stored in the 'mpl-data/sample_data' directory within\nthe Matplotlib package.\n\nIf the filename ends in .gz, the file is implicitly ungzipped.  If the\nfilename ends with .npy or .npz, *asfileobj* is True, and *np_load* is\nTrue, the file is loaded with `numpy.load`.  *np_load* currently defaults\nto False but will default to True in a future release.",
      "code": "def get_sample_data(fname, asfileobj=True, *, np_load=False):\n    \"\"\"\n    Return a sample data file.  *fname* is a path relative to the\n    :file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\n    return a file object, otherwise just a file path.\n\n    Sample data files are stored in the 'mpl-data/sample_data' directory within\n    the Matplotlib package.\n\n    If the filename ends in .gz, the file is implicitly ungzipped.  If the\n    filename ends with .npy or .npz, *asfileobj* is True, and *np_load* is\n    True, the file is loaded with `numpy.load`.  *np_load* currently defaults\n    to False but will default to True in a future release.\n    \"\"\"\n    path = _get_data_path('sample_data', fname)\n    if asfileobj:\n        suffix = path.suffix.lower()\n        if suffix == '.gz':\n            return gzip.open(path)\n        elif suffix in ['.npy', '.npz']:\n            if np_load:\n                return np.load(path)\n            else:\n                _api.warn_deprecated(\n                    \"3.3\", message=\"In a future release, get_sample_data \"\n                    \"will automatically load numpy arrays.  Set np_load to \"\n                    \"True to get the array and suppress this warning.  Set \"\n                    \"asfileobj to False to get the path to the data file and \"\n                    \"suppress this warning.\")\n                return path.open('rb')\n        elif suffix in ['.csv', '.xrc', '.txt']:\n            return path.open('r')\n        else:\n            return path.open('rb')\n    else:\n        return str(path)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/index_of",
      "name": "index_of",
      "qname": "lib.matplotlib.cbook.index_of",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/index_of/y",
          "name": "y",
          "qname": "lib.matplotlib.cbook.index_of.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float or array-like",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "array-like"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper function to create reasonable x values for the given *y*.\n\nThis is used for plotting (x, y) if x values are not explicitly given.\n\nFirst try ``y.index`` (assuming *y* is a `pandas.Series`), if that\nfails, use ``range(len(y))``.\n\nThis will be extended in the future to deal with more types of\nlabeled data.",
      "docstring": "A helper function to create reasonable x values for the given *y*.\n\nThis is used for plotting (x, y) if x values are not explicitly given.\n\nFirst try ``y.index`` (assuming *y* is a `pandas.Series`), if that\nfails, use ``range(len(y))``.\n\nThis will be extended in the future to deal with more types of\nlabeled data.\n\nParameters\n----------\ny : float or array-like\n\nReturns\n-------\nx, y : ndarray\n   The x and y values to plot.",
      "code": "def index_of(y):\n    \"\"\"\n    A helper function to create reasonable x values for the given *y*.\n\n    This is used for plotting (x, y) if x values are not explicitly given.\n\n    First try ``y.index`` (assuming *y* is a `pandas.Series`), if that\n    fails, use ``range(len(y))``.\n\n    This will be extended in the future to deal with more types of\n    labeled data.\n\n    Parameters\n    ----------\n    y : float or array-like\n\n    Returns\n    -------\n    x, y : ndarray\n       The x and y values to plot.\n    \"\"\"\n    try:\n        return y.index.to_numpy(), y.to_numpy()\n    except AttributeError:\n        pass\n    try:\n        y = _check_1d(y)\n    except (np.VisibleDeprecationWarning, ValueError):\n        # NumPy 1.19 will warn on ragged input, and we can't actually use it.\n        pass\n    else:\n        return np.arange(y.shape[0], dtype=float), y\n    raise ValueError('Input could not be cast to an at-least-1D NumPy array')"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/is_math_text",
      "name": "is_math_text",
      "qname": "lib.matplotlib.cbook.is_math_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/is_math_text/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.is_math_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the string *s* contains math expressions.\n\nThis is done by checking whether *s* contains an even number of\nnon-escaped dollar signs.",
      "docstring": "Return whether the string *s* contains math expressions.\n\nThis is done by checking whether *s* contains an even number of\nnon-escaped dollar signs.",
      "code": "def is_math_text(s):\n    \"\"\"\n    Return whether the string *s* contains math expressions.\n\n    This is done by checking whether *s* contains an even number of\n    non-escaped dollar signs.\n    \"\"\"\n    s = str(s)\n    dollar_count = s.count(r'$') - s.count(r'\\$')\n    even_dollars = (dollar_count > 0 and dollar_count % 2 == 0)\n    return even_dollars"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/is_scalar_or_string",
      "name": "is_scalar_or_string",
      "qname": "lib.matplotlib.cbook.is_scalar_or_string",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/is_scalar_or_string/val",
          "name": "val",
          "qname": "lib.matplotlib.cbook.is_scalar_or_string.val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the given object is a scalar or string like.",
      "docstring": "Return whether the given object is a scalar or string like.",
      "code": "def is_scalar_or_string(val):\n    \"\"\"Return whether the given object is a scalar or string like.\"\"\"\n    return isinstance(val, str) or not np.iterable(val)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/is_writable_file_like",
      "name": "is_writable_file_like",
      "qname": "lib.matplotlib.cbook.is_writable_file_like",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/is_writable_file_like/obj",
          "name": "obj",
          "qname": "lib.matplotlib.cbook.is_writable_file_like.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether *obj* looks like a file object with a *write* method.",
      "docstring": "Return whether *obj* looks like a file object with a *write* method.",
      "code": "def is_writable_file_like(obj):\n    \"\"\"Return whether *obj* looks like a file object with a *write* method.\"\"\"\n    return callable(getattr(obj, 'write', None))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/maxdict/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.maxdict.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.maxdict.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__init__/maxsize",
          "name": "maxsize",
          "qname": "lib.matplotlib.cbook.maxdict.__init__.maxsize",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A dictionary with a maximum size.",
      "docstring": "",
      "code": "    def __init__(self, maxsize):\n        super().__init__()\n        self.maxsize = maxsize"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__",
      "name": "__setitem__",
      "qname": "lib.matplotlib.cbook.maxdict.__setitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.maxdict.__setitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__/k",
          "name": "k",
          "qname": "lib.matplotlib.cbook.maxdict.__setitem__.k",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__/v",
          "name": "v",
          "qname": "lib.matplotlib.cbook.maxdict.__setitem__.v",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __setitem__(self, k, v):\n        super().__setitem__(k, v)\n        while len(self) >= self.maxsize:\n            del self[next(iter(self))]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs",
      "name": "normalize_kwargs",
      "qname": "lib.matplotlib.cbook.normalize_kwargs",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs/kw",
          "name": "kw",
          "qname": "lib.matplotlib.cbook.normalize_kwargs.kw",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict or None",
            "default_value": "",
            "description": "A dict of keyword arguments.  None is explicitly supported and treated\nas an empty dict, to support functions with an optional parameter of\nthe form ``props=None``."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs/alias_mapping",
          "name": "alias_mapping",
          "qname": "lib.matplotlib.cbook.normalize_kwargs.alias_mapping",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict or Artist subclass or Artist instance",
            "default_value": "",
            "description": "A mapping between a canonical name to a list of aliases, in order of\nprecedence from lowest to highest.\n\nIf the canonical value is not in the list it is assumed to have the\nhighest priority.\n\nIf an Artist subclass or instance is passed, use its properties alias\nmapping."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "Artist subclass"
              },
              {
                "kind": "NamedType",
                "name": "Artist instance"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Helper function to normalize kwarg inputs.",
      "docstring": "Helper function to normalize kwarg inputs.\n\nParameters\n----------\nkw : dict or None\n    A dict of keyword arguments.  None is explicitly supported and treated\n    as an empty dict, to support functions with an optional parameter of\n    the form ``props=None``.\n\nalias_mapping : dict or Artist subclass or Artist instance, optional\n    A mapping between a canonical name to a list of aliases, in order of\n    precedence from lowest to highest.\n\n    If the canonical value is not in the list it is assumed to have the\n    highest priority.\n\n    If an Artist subclass or instance is passed, use its properties alias\n    mapping.\n\nRaises\n------\nTypeError\n    To match what Python raises if invalid arguments/keyword arguments are\n    passed to a callable.",
      "code": "def normalize_kwargs(kw, alias_mapping=None):\n    \"\"\"\n    Helper function to normalize kwarg inputs.\n\n    Parameters\n    ----------\n    kw : dict or None\n        A dict of keyword arguments.  None is explicitly supported and treated\n        as an empty dict, to support functions with an optional parameter of\n        the form ``props=None``.\n\n    alias_mapping : dict or Artist subclass or Artist instance, optional\n        A mapping between a canonical name to a list of aliases, in order of\n        precedence from lowest to highest.\n\n        If the canonical value is not in the list it is assumed to have the\n        highest priority.\n\n        If an Artist subclass or instance is passed, use its properties alias\n        mapping.\n\n    Raises\n    ------\n    TypeError\n        To match what Python raises if invalid arguments/keyword arguments are\n        passed to a callable.\n    \"\"\"\n    from matplotlib.artist import Artist\n\n    if kw is None:\n        return {}\n\n    # deal with default value of alias_mapping\n    if alias_mapping is None:\n        alias_mapping = dict()\n    elif (isinstance(alias_mapping, type) and issubclass(alias_mapping, Artist)\n          or isinstance(alias_mapping, Artist)):\n        alias_mapping = getattr(alias_mapping, \"_alias_map\", {})\n\n    to_canonical = {alias: canonical\n                    for canonical, alias_list in alias_mapping.items()\n                    for alias in alias_list}\n    canonical_to_seen = {}\n    ret = {}  # output dictionary\n\n    for k, v in kw.items():\n        canonical = to_canonical.get(k, k)\n        if canonical in canonical_to_seen:\n            raise TypeError(f\"Got both {canonical_to_seen[canonical]!r} and \"\n                            f\"{k!r}, which are aliases of one another\")\n        canonical_to_seen[canonical] = k\n        ret[canonical] = v\n\n    return ret"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/open_file_cm",
      "name": "open_file_cm",
      "qname": "lib.matplotlib.cbook.open_file_cm",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/open_file_cm/path_or_file",
          "name": "path_or_file",
          "qname": "lib.matplotlib.cbook.open_file_cm.path_or_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/open_file_cm/mode",
          "name": "mode",
          "qname": "lib.matplotlib.cbook.open_file_cm.mode",
          "default_value": "'r'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/open_file_cm/encoding",
          "name": "encoding",
          "qname": "lib.matplotlib.cbook.open_file_cm.encoding",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Pass through file objects and context-manage path-likes.",
      "docstring": "Pass through file objects and context-manage path-likes.",
      "code": "def open_file_cm(path_or_file, mode=\"r\", encoding=None):\n    r\"\"\"Pass through file objects and context-manage path-likes.\"\"\"\n    fh, opened = to_filehandle(path_or_file, mode, True, encoding)\n    return fh if opened else contextlib.nullcontext(fh)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/print_cycles",
      "name": "print_cycles",
      "qname": "lib.matplotlib.cbook.print_cycles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/print_cycles/objects",
          "name": "objects",
          "qname": "lib.matplotlib.cbook.print_cycles.objects",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "A list of objects to find cycles in."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/print_cycles/outstream",
          "name": "outstream",
          "qname": "lib.matplotlib.cbook.print_cycles.outstream",
          "default_value": "sys.stdout",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "The stream for output."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/print_cycles/show_progress",
          "name": "show_progress",
          "qname": "lib.matplotlib.cbook.print_cycles.show_progress",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "If True, print the number of objects reached as they are found."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Print loops of cyclic references in the given *objects*.\n\nIt is often useful to pass in ``gc.garbage`` to find the cycles that are\npreventing some objects from being garbage collected.",
      "docstring": "Print loops of cyclic references in the given *objects*.\n\nIt is often useful to pass in ``gc.garbage`` to find the cycles that are\npreventing some objects from being garbage collected.\n\nParameters\n----------\nobjects\n    A list of objects to find cycles in.\noutstream\n    The stream for output.\nshow_progress : bool\n    If True, print the number of objects reached as they are found.",
      "code": "def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n    \"\"\"\n    Print loops of cyclic references in the given *objects*.\n\n    It is often useful to pass in ``gc.garbage`` to find the cycles that are\n    preventing some objects from being garbage collected.\n\n    Parameters\n    ----------\n    objects\n        A list of objects to find cycles in.\n    outstream\n        The stream for output.\n    show_progress : bool\n        If True, print the number of objects reached as they are found.\n    \"\"\"\n    import gc\n\n    def print_path(path):\n        for i, step in enumerate(path):\n            # next \"wraps around\"\n            next = path[(i + 1) % len(path)]\n\n            outstream.write(\"   %s -- \" % type(step))\n            if isinstance(step, dict):\n                for key, val in step.items():\n                    if val is next:\n                        outstream.write(\"[{!r}]\".format(key))\n                        break\n                    if key is next:\n                        outstream.write(\"[key] = {!r}\".format(val))\n                        break\n            elif isinstance(step, list):\n                outstream.write(\"[%d]\" % step.index(next))\n            elif isinstance(step, tuple):\n                outstream.write(\"( tuple )\")\n            else:\n                outstream.write(repr(step))\n            outstream.write(\" ->\\n\")\n        outstream.write(\"\\n\")\n\n    def recurse(obj, start, all, current_path):\n        if show_progress:\n            outstream.write(\"%d\\r\" % len(all))\n\n        all[id(obj)] = None\n\n        referents = gc.get_referents(obj)\n        for referent in referents:\n            # If we've found our way back to the start, this is\n            # a cycle, so print it out\n            if referent is start:\n                print_path(current_path)\n\n            # Don't go back through the original list of objects, or\n            # through temporary references to the object, since those\n            # are just an artifact of the cycle detector itself.\n            elif referent is objects or isinstance(referent, types.FrameType):\n                continue\n\n            # We haven't seen this object before, so recurse\n            elif id(referent) not in all:\n                recurse(referent, start, all, current_path + [obj])\n\n    for obj in objects:\n        outstream.write(f\"Examining: {obj!r}\\n\")\n        recurse(obj, obj, {}, [])"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/pts_to_midstep",
      "name": "pts_to_midstep",
      "qname": "lib.matplotlib.cbook.pts_to_midstep",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_midstep/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.pts_to_midstep.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array",
            "default_value": "",
            "description": "The x location of the steps. May be empty."
          },
          "type": {
            "kind": "NamedType",
            "name": "array"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_midstep/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.pts_to_midstep.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert continuous line to mid-steps.\n\nGiven a set of ``N`` points convert to ``2N`` points which when connected\nlinearly give a step function which changes values at the middle of the\nintervals.",
      "docstring": "Convert continuous line to mid-steps.\n\nGiven a set of ``N`` points convert to ``2N`` points which when connected\nlinearly give a step function which changes values at the middle of the\nintervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as\n    ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N``.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)",
      "code": "def pts_to_midstep(x, *args):\n    \"\"\"\n    Convert continuous line to mid-steps.\n\n    Given a set of ``N`` points convert to ``2N`` points which when connected\n    linearly give a step function which changes values at the middle of the\n    intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as\n        ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N``.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), 2 * len(x)))\n    x = np.asanyarray(x)\n    steps[0, 1:-1:2] = steps[0, 2::2] = (x[:-1] + x[1:]) / 2\n    steps[0, :1] = x[:1]  # Also works for zero-sized input.\n    steps[0, -1:] = x[-1:]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0::2]\n    return steps"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/pts_to_poststep",
      "name": "pts_to_poststep",
      "qname": "lib.matplotlib.cbook.pts_to_poststep",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_poststep/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.pts_to_poststep.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array",
            "default_value": "",
            "description": "The x location of the steps. May be empty."
          },
          "type": {
            "kind": "NamedType",
            "name": "array"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_poststep/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.pts_to_poststep.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert continuous line to post-steps.\n\nGiven a set of ``N`` points convert to ``2N + 1`` points, which when\nconnected linearly give a step function which changes values at the end of\nthe intervals.",
      "docstring": "Convert continuous line to post-steps.\n\nGiven a set of ``N`` points convert to ``2N + 1`` points, which when\nconnected linearly give a step function which changes values at the end of\nthe intervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N + 1``. For\n    ``N=0``, the length will be 0.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)",
      "code": "def pts_to_poststep(x, *args):\n    \"\"\"\n    Convert continuous line to post-steps.\n\n    Given a set of ``N`` points convert to ``2N + 1`` points, which when\n    connected linearly give a step function which changes values at the end of\n    the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 2::2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0:-2:2]\n    return steps"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/pts_to_prestep",
      "name": "pts_to_prestep",
      "qname": "lib.matplotlib.cbook.pts_to_prestep",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_prestep/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.pts_to_prestep.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array",
            "default_value": "",
            "description": "The x location of the steps. May be empty."
          },
          "type": {
            "kind": "NamedType",
            "name": "array"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_prestep/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.pts_to_prestep.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert continuous line to pre-steps.\n\nGiven a set of ``N`` points, convert to ``2N - 1`` points, which when\nconnected linearly give a step function which changes values at the\nbeginning of the intervals.",
      "docstring": "Convert continuous line to pre-steps.\n\nGiven a set of ``N`` points, convert to ``2N - 1`` points, which when\nconnected linearly give a step function which changes values at the\nbeginning of the intervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N + 1``. For\n    ``N=0``, the length will be 0.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)",
      "code": "def pts_to_prestep(x, *args):\n    \"\"\"\n    Convert continuous line to pre-steps.\n\n    Given a set of ``N`` points, convert to ``2N - 1`` points, which when\n    connected linearly give a step function which changes values at the\n    beginning of the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    # In all `pts_to_*step` functions, only assign once using *x* and *args*,\n    # as converting to an array may be expensive.\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 0:-2:2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 2::2]\n    return steps"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/report_memory",
      "name": "report_memory",
      "qname": "lib.matplotlib.cbook.report_memory",
      "decorators": [
        "_api.deprecated('3.5', alternative='psutil.virtual_memory')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/report_memory/i",
          "name": "i",
          "qname": "lib.matplotlib.cbook.report_memory.i",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the memory consumed by the process.",
      "docstring": "Return the memory consumed by the process.",
      "code": "@_api.deprecated(\"3.5\", alternative=\"psutil.virtual_memory\")\ndef report_memory(i=0):  # argument may go away\n    \"\"\"Return the memory consumed by the process.\"\"\"\n    def call(command, os_name):\n        try:\n            return subprocess.check_output(command)\n        except subprocess.CalledProcessError as err:\n            raise NotImplementedError(\n                \"report_memory works on %s only if \"\n                \"the '%s' program is found\" % (os_name, command[0])\n            ) from err\n\n    pid = os.getpid()\n    if sys.platform == 'sunos5':\n        lines = call(['ps', '-p', '%d' % pid, '-o', 'osz'], 'Sun OS')\n        mem = int(lines[-1].strip())\n    elif sys.platform == 'linux':\n        lines = call(['ps', '-p', '%d' % pid, '-o', 'rss,sz'], 'Linux')\n        mem = int(lines[1].split()[1])\n    elif sys.platform == 'darwin':\n        lines = call(['ps', '-p', '%d' % pid, '-o', 'rss,vsz'], 'Mac OS')\n        mem = int(lines[1].split()[0])\n    elif sys.platform == 'win32':\n        lines = call([\"tasklist\", \"/nh\", \"/fi\", \"pid eq %d\" % pid], 'Windows')\n        mem = int(lines.strip().split()[-2].replace(',', ''))\n    else:\n        raise NotImplementedError(\n            \"We don't have a memory monitor for %s\" % sys.platform)\n    return mem"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/safe_first_element",
      "name": "safe_first_element",
      "qname": "lib.matplotlib.cbook.safe_first_element",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/safe_first_element/obj",
          "name": "obj",
          "qname": "lib.matplotlib.cbook.safe_first_element.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the first element in *obj*.\n\nThis is an type-independent way of obtaining the first element,\nsupporting both index access and the iterator protocol.",
      "docstring": "Return the first element in *obj*.\n\nThis is an type-independent way of obtaining the first element,\nsupporting both index access and the iterator protocol.",
      "code": "def safe_first_element(obj):\n    \"\"\"\n    Return the first element in *obj*.\n\n    This is an type-independent way of obtaining the first element,\n    supporting both index access and the iterator protocol.\n    \"\"\"\n    return _safe_first_non_none(obj, skip_none=False)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/safe_masked_invalid",
      "name": "safe_masked_invalid",
      "qname": "lib.matplotlib.cbook.safe_masked_invalid",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/safe_masked_invalid/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.safe_masked_invalid.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/safe_masked_invalid/copy",
          "name": "copy",
          "qname": "lib.matplotlib.cbook.safe_masked_invalid.copy",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def safe_masked_invalid(x, copy=False):\n    x = np.array(x, subok=True, copy=copy)\n    if not x.dtype.isnative:\n        # If we have already made a copy, do the byteswap in place, else make a\n        # copy with the byte order swapped.\n        x = x.byteswap(inplace=copy).newbyteorder('N')  # Swap to native order.\n    try:\n        xm = np.ma.masked_invalid(x, copy=False)\n        xm.shrink_mask()\n    except TypeError:\n        return x\n    return xm"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/sanitize_sequence",
      "name": "sanitize_sequence",
      "qname": "lib.matplotlib.cbook.sanitize_sequence",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/sanitize_sequence/data",
          "name": "data",
          "qname": "lib.matplotlib.cbook.sanitize_sequence.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert dictview objects to list. Other inputs are returned unchanged.",
      "docstring": "Convert dictview objects to list. Other inputs are returned unchanged.",
      "code": "def sanitize_sequence(data):\n    \"\"\"\n    Convert dictview objects to list. Other inputs are returned unchanged.\n    \"\"\"\n    return (list(data) if isinstance(data, collections.abc.MappingView)\n            else data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.silent_list.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.silent_list.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__/type",
          "name": "type",
          "qname": "lib.matplotlib.cbook.silent_list.__init__.type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__/seq",
          "name": "seq",
          "qname": "lib.matplotlib.cbook.silent_list.__init__.seq",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>\n\nIf ``self.type`` is None, the type name is obtained from the first item in\nthe list (if any).",
      "docstring": "",
      "code": "    def __init__(self, type, seq=None):\n        self.type = type\n        if seq is not None:\n            self.extend(seq)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/silent_list/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.cbook.silent_list.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.silent_list.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        if self.type is not None or len(self) != 0:\n            tp = self.type if self.type is not None else type(self[0]).__name__\n            return f\"<a list of {len(self)} {tp} objects>\"\n        else:\n            return \"<an empty list>\""
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/simple_linear_interpolation",
      "name": "simple_linear_interpolation",
      "qname": "lib.matplotlib.cbook.simple_linear_interpolation",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/simple_linear_interpolation/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.simple_linear_interpolation.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array, shape (n, ...)",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array"
              },
              {
                "kind": "NamedType",
                "name": "shape (n, ...)"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/simple_linear_interpolation/steps",
          "name": "steps",
          "qname": "lib.matplotlib.cbook.simple_linear_interpolation.steps",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Resample an array with ``steps - 1`` points between original point pairs.\n\nAlong each column of *a*, ``(steps - 1)`` points are introduced between\neach original values; the values are linearly interpolated.",
      "docstring": "Resample an array with ``steps - 1`` points between original point pairs.\n\nAlong each column of *a*, ``(steps - 1)`` points are introduced between\neach original values; the values are linearly interpolated.\n\nParameters\n----------\na : array, shape (n, ...)\nsteps : int\n\nReturns\n-------\narray\n    shape ``((n - 1) * steps + 1, ...)``",
      "code": "def simple_linear_interpolation(a, steps):\n    \"\"\"\n    Resample an array with ``steps - 1`` points between original point pairs.\n\n    Along each column of *a*, ``(steps - 1)`` points are introduced between\n    each original values; the values are linearly interpolated.\n\n    Parameters\n    ----------\n    a : array, shape (n, ...)\n    steps : int\n\n    Returns\n    -------\n    array\n        shape ``((n - 1) * steps + 1, ...)``\n    \"\"\"\n    fps = a.reshape((len(a), -1))\n    xp = np.arange(len(a)) * steps\n    x = np.arange((len(a) - 1) * steps + 1)\n    return (np.column_stack([np.interp(x, xp, fp) for fp in fps.T])\n            .reshape((len(x),) + a.shape[1:]))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/strip_math",
      "name": "strip_math",
      "qname": "lib.matplotlib.cbook.strip_math",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/strip_math/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.strip_math.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Remove latex formatting from mathtext.\n\nOnly handles fully math and fully non-math strings.",
      "docstring": "Remove latex formatting from mathtext.\n\nOnly handles fully math and fully non-math strings.",
      "code": "def strip_math(s):\n    \"\"\"\n    Remove latex formatting from mathtext.\n\n    Only handles fully math and fully non-math strings.\n    \"\"\"\n    if len(s) >= 2 and s[0] == s[-1] == \"$\":\n        s = s[1:-1]\n        for tex, plain in [\n                (r\"\\times\", \"x\"),  # Specifically for Formatter support.\n                (r\"\\mathdefault\", \"\"),\n                (r\"\\rm\", \"\"),\n                (r\"\\cal\", \"\"),\n                (r\"\\tt\", \"\"),\n                (r\"\\it\", \"\"),\n                (\"\\\\\", \"\"),\n                (\"{\", \"\"),\n                (\"}\", \"\"),\n        ]:\n            s = s.replace(tex, plain)\n    return s"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/to_filehandle",
      "name": "to_filehandle",
      "qname": "lib.matplotlib.cbook.to_filehandle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/fname",
          "name": "fname",
          "qname": "lib.matplotlib.cbook.to_filehandle.fname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "If `str` or `os.PathLike`, the file is opened using the flags specified\nby *flag* and *encoding*.  If a file-like object, it is passed through."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/flag",
          "name": "flag",
          "qname": "lib.matplotlib.cbook.to_filehandle.flag",
          "default_value": "'r'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'r'",
            "description": "Passed as the *mode* argument to `open` when *fname* is `str` or\n`os.PathLike`; ignored if *fname* is file-like."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/return_opened",
          "name": "return_opened",
          "qname": "lib.matplotlib.cbook.to_filehandle.return_opened",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, return both the file object and a boolean indicating whether\nthis was a new file (that the caller needs to close).  If False, return\nonly the new file."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/encoding",
          "name": "encoding",
          "qname": "lib.matplotlib.cbook.to_filehandle.encoding",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or None",
            "default_value": "None",
            "description": "Passed as the *mode* argument to `open` when *fname* is `str` or\n`os.PathLike`; ignored if *fname* is file-like."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert a path to an open file handle or pass-through a file-like object.\n\nConsider using `open_file_cm` instead, as it allows one to properly close\nnewly created file objects more easily.",
      "docstring": "Convert a path to an open file handle or pass-through a file-like object.\n\nConsider using `open_file_cm` instead, as it allows one to properly close\nnewly created file objects more easily.\n\nParameters\n----------\nfname : str or path-like or file-like\n    If `str` or `os.PathLike`, the file is opened using the flags specified\n    by *flag* and *encoding*.  If a file-like object, it is passed through.\nflag : str, default: 'r'\n    Passed as the *mode* argument to `open` when *fname* is `str` or\n    `os.PathLike`; ignored if *fname* is file-like.\nreturn_opened : bool, default: False\n    If True, return both the file object and a boolean indicating whether\n    this was a new file (that the caller needs to close).  If False, return\n    only the new file.\nencoding : str or None, default: None\n    Passed as the *mode* argument to `open` when *fname* is `str` or\n    `os.PathLike`; ignored if *fname* is file-like.\n\nReturns\n-------\nfh : file-like\nopened : bool\n    *opened* is only returned if *return_opened* is True.",
      "code": "def to_filehandle(fname, flag='r', return_opened=False, encoding=None):\n    \"\"\"\n    Convert a path to an open file handle or pass-through a file-like object.\n\n    Consider using `open_file_cm` instead, as it allows one to properly close\n    newly created file objects more easily.\n\n    Parameters\n    ----------\n    fname : str or path-like or file-like\n        If `str` or `os.PathLike`, the file is opened using the flags specified\n        by *flag* and *encoding*.  If a file-like object, it is passed through.\n    flag : str, default: 'r'\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n    return_opened : bool, default: False\n        If True, return both the file object and a boolean indicating whether\n        this was a new file (that the caller needs to close).  If False, return\n        only the new file.\n    encoding : str or None, default: None\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n\n    Returns\n    -------\n    fh : file-like\n    opened : bool\n        *opened* is only returned if *return_opened* is True.\n    \"\"\"\n    if isinstance(fname, os.PathLike):\n        fname = os.fspath(fname)\n    if isinstance(fname, str):\n        if fname.endswith('.gz'):\n            fh = gzip.open(fname, flag)\n        elif fname.endswith('.bz2'):\n            # python may not be compiled with bz2 support,\n            # bury import until we need it\n            import bz2\n            fh = bz2.BZ2File(fname, flag)\n        else:\n            fh = open(fname, flag, encoding=encoding)\n        opened = True\n    elif hasattr(fname, 'seek'):\n        fh = fname\n        opened = False\n    else:\n        raise ValueError('fname must be a PathLike or file handle')\n    if return_opened:\n        return fh, opened\n    return fh"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/violin_stats",
      "name": "violin_stats",
      "qname": "lib.matplotlib.cbook.violin_stats",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/X",
          "name": "X",
          "qname": "lib.matplotlib.cbook.violin_stats.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Sample data that will be used to produce the gaussian kernel density\nestimates. Must have 2 or fewer dimensions."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/method",
          "name": "method",
          "qname": "lib.matplotlib.cbook.violin_stats.method",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "The method used to calculate the kernel density estimate for each\ncolumn of data. When called via ``method(v, coords)``, it should\nreturn a vector of the values of the KDE evaluated at the values\nspecified in coords."
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/points",
          "name": "points",
          "qname": "lib.matplotlib.cbook.violin_stats.points",
          "default_value": "100",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "100",
            "description": "Defines the number of points to evaluate each of the gaussian kernel\ndensity estimates at."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/quantiles",
          "name": "quantiles",
          "qname": "lib.matplotlib.cbook.violin_stats.quantiles",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "Defines (if not None) a list of floats in interval [0, 1] for each\ncolumn of data, which represents the quantiles that will be rendered\nfor that column of data. Must have 2 or fewer dimensions. 1D array will\nbe treated as a singleton list containing them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": true,
                "max_inclusive": true
              },
              {
                "kind": "NamedType",
                "name": "array-like"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of dictionaries of data which can be used to draw a series\nof violin plots.\n\nSee the ``Returns`` section below to view the required keys of the\ndictionary.\n\nUsers can skip this function and pass a user-defined set of dictionaries\nwith the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\nto do the calculations. See the *Returns* section below for the keys\nthat must be present in the dictionaries.",
      "docstring": "Return a list of dictionaries of data which can be used to draw a series\nof violin plots.\n\nSee the ``Returns`` section below to view the required keys of the\ndictionary.\n\nUsers can skip this function and pass a user-defined set of dictionaries\nwith the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\nto do the calculations. See the *Returns* section below for the keys\nthat must be present in the dictionaries.\n\nParameters\n----------\nX : array-like\n    Sample data that will be used to produce the gaussian kernel density\n    estimates. Must have 2 or fewer dimensions.\n\nmethod : callable\n    The method used to calculate the kernel density estimate for each\n    column of data. When called via ``method(v, coords)``, it should\n    return a vector of the values of the KDE evaluated at the values\n    specified in coords.\n\npoints : int, default: 100\n    Defines the number of points to evaluate each of the gaussian kernel\n    density estimates at.\n\nquantiles : array-like, default: None\n    Defines (if not None) a list of floats in interval [0, 1] for each\n    column of data, which represents the quantiles that will be rendered\n    for that column of data. Must have 2 or fewer dimensions. 1D array will\n    be treated as a singleton list containing them.\n\nReturns\n-------\nlist of dict\n    A list of dictionaries containing the results for each column of data.\n    The dictionaries contain at least the following:\n\n    - coords: A list of scalars containing the coordinates this particular\n      kernel density estimate was evaluated at.\n    - vals: A list of scalars containing the values of the kernel density\n      estimate at each of the coordinates given in *coords*.\n    - mean: The mean value for this column of data.\n    - median: The median value for this column of data.\n    - min: The minimum value for this column of data.\n    - max: The maximum value for this column of data.\n    - quantiles: The quantile values for this column of data.",
      "code": "def violin_stats(X, method, points=100, quantiles=None):\n    \"\"\"\n    Return a list of dictionaries of data which can be used to draw a series\n    of violin plots.\n\n    See the ``Returns`` section below to view the required keys of the\n    dictionary.\n\n    Users can skip this function and pass a user-defined set of dictionaries\n    with the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\n    to do the calculations. See the *Returns* section below for the keys\n    that must be present in the dictionaries.\n\n    Parameters\n    ----------\n    X : array-like\n        Sample data that will be used to produce the gaussian kernel density\n        estimates. Must have 2 or fewer dimensions.\n\n    method : callable\n        The method used to calculate the kernel density estimate for each\n        column of data. When called via ``method(v, coords)``, it should\n        return a vector of the values of the KDE evaluated at the values\n        specified in coords.\n\n    points : int, default: 100\n        Defines the number of points to evaluate each of the gaussian kernel\n        density estimates at.\n\n    quantiles : array-like, default: None\n        Defines (if not None) a list of floats in interval [0, 1] for each\n        column of data, which represents the quantiles that will be rendered\n        for that column of data. Must have 2 or fewer dimensions. 1D array will\n        be treated as a singleton list containing them.\n\n    Returns\n    -------\n    list of dict\n        A list of dictionaries containing the results for each column of data.\n        The dictionaries contain at least the following:\n\n        - coords: A list of scalars containing the coordinates this particular\n          kernel density estimate was evaluated at.\n        - vals: A list of scalars containing the values of the kernel density\n          estimate at each of the coordinates given in *coords*.\n        - mean: The mean value for this column of data.\n        - median: The median value for this column of data.\n        - min: The minimum value for this column of data.\n        - max: The maximum value for this column of data.\n        - quantiles: The quantile values for this column of data.\n    \"\"\"\n\n    # List of dictionaries describing each of the violins.\n    vpstats = []\n\n    # Want X to be a list of data sequences\n    X = _reshape_2D(X, \"X\")\n\n    # Want quantiles to be as the same shape as data sequences\n    if quantiles is not None and len(quantiles) != 0:\n        quantiles = _reshape_2D(quantiles, \"quantiles\")\n    # Else, mock quantiles if it's none or empty\n    else:\n        quantiles = [[]] * len(X)\n\n    # quantiles should has the same size as dataset\n    if len(X) != len(quantiles):\n        raise ValueError(\"List of violinplot statistics and quantiles values\"\n                         \" must have the same length\")\n\n    # Zip x and quantiles\n    for (x, q) in zip(X, quantiles):\n        # Dictionary of results for this distribution\n        stats = {}\n\n        # Calculate basic stats for the distribution\n        min_val = np.min(x)\n        max_val = np.max(x)\n        quantile_val = np.percentile(x, 100 * q)\n\n        # Evaluate the kernel density estimate\n        coords = np.linspace(min_val, max_val, points)\n        stats['vals'] = method(x, coords)\n        stats['coords'] = coords\n\n        # Store additional statistics for this distribution\n        stats['mean'] = np.mean(x)\n        stats['median'] = np.median(x)\n        stats['min'] = min_val\n        stats['max'] = max_val\n        stats['quantiles'] = np.atleast_1d(quantile_val)\n\n        # Append to output\n        vpstats.append(stats)\n\n    return vpstats"
    }
  ]
}